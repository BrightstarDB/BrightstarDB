namespace BrightstarDB.CodeGeneration
{
    using System;
    using System.Collections.Generic;
    using System.Collections.Immutable;
    using System.Globalization;
    using System.Linq;
    using System.Text;
    using System.Text.RegularExpressions;
    using System.Threading.Tasks;
    using BrightstarDB.Client;
    using BrightstarDB.EntityFramework;
    using BrightstarDB.Rdf;
    using Humanizer;
    using Microsoft.CodeAnalysis;
    using Microsoft.CodeAnalysis.CSharp;
    using Microsoft.CodeAnalysis.CSharp.Syntax;
    using Microsoft.CodeAnalysis.Editing;
    using Microsoft.CodeAnalysis.Formatting;
    using Microsoft.CodeAnalysis.MSBuild;
    using VB = Microsoft.CodeAnalysis.VisualBasic;
    using VBSyntax = Microsoft.CodeAnalysis.VisualBasic.Syntax;

    public static class Generator
    {
        private static readonly Regex interfaceNameTransformationExpression = new Regex("I(?<name>[A-Z].*)", RegexOptions.Compiled);
        private const string headerComment =
@"-----------------------------------------------------------------------
<autogenerated>
   This code was generated from a template.

   Changes to this file may cause incorrect behaviour and will be lost
   if the code is regenerated.
</autogenerated>
------------------------------------------------------------------------";

        // synchronous version of GenerateAsync, really only for making the T4 generation logic simpler - use the asynchronous overloads wherever possible
        public static string Generate(
            string language,
            string solutionPath,
            string contextNamespace,
            string contextName = "EntityContext",
            Func<INamedTypeSymbol, string> entityNamespaceSelector = null,
            Func<INamedTypeSymbol, string> entityNameSelector = null,
            Func<INamedTypeSymbol, bool> interfacePredicate = null)
        {
            var castLanguage = (Language)Enum.Parse(typeof(Language), language);

            var nodes = GenerateAsync(
                castLanguage,
                solutionPath,
                contextNamespace,
                contextName,
                entityNamespaceSelector,
                entityNameSelector,
                interfacePredicate).Result;

            return nodes
                .Aggregate(
                    new StringBuilder(),
                    (sb, next) => sb.AppendLine(next.ToFullString()),
                    x => x.ToString());
        }

        /// <summary>
        /// Generates code for an entity context and for each entity housed within that context.
        /// </summary>
        /// <param name="language">
        /// The language in which code should be generated.
        /// </param>
        /// <param name="solutionPath">
        /// The path to the solution file containing the entities for whom code will be generated.
        /// </param>
        /// <param name="contextNamespace">
        /// The namespace in which to place the generated entity context.
        /// </param>
        /// <param name="contextName">
        /// The name for the generated entity context.
        /// </param>
        /// <param name="entityNamespaceSelector">
        /// A callback used to determine the namespace for each generated entity. If left as <see langword="null"/>, generated entities are placed in the same namespace
        /// as their associated interface.
        /// </param>
        /// <param name="entityNameSelector">
        /// A callback used to determine the name for each generated entity. If left as <see langword="null"/>, generated entities are named the same as their interface
        /// except with the leading "I" removed. If there is no leading "I", an "Impl" suffix is instead added to the interface's name.
        /// </param>
        /// <param name="interfacePredicate">
        /// A callback used to determine which interfaces should result in generated entities. If left as <see langword="null"/>, all interfaces marked with
        /// <see cref="EntityAttribute"/> are included.
        /// </param>
        /// <returns>
        /// A <see cref="SyntaxNode"/> for each generated class, with the entity context first in the list.
        /// </returns>
        public async static Task<IImmutableList<SyntaxNode>> GenerateAsync(
            Language language,
            string solutionPath,
            string contextNamespace,
            string contextName = "EntityContext",
            Func<INamedTypeSymbol, string> entityNamespaceSelector = null,
            Func<INamedTypeSymbol, string> entityNameSelector = null,
            Func<INamedTypeSymbol, bool> interfacePredicate = null)
        {
            var workspace = MSBuildWorkspace.Create();
            var solution = await workspace.OpenSolutionAsync(solutionPath);

            return await GenerateAsync(
                language,
                solution,
                contextNamespace,
                contextName,
                entityNamespaceSelector,
                entityNameSelector,
                interfacePredicate);
        }

        /// <summary>
        /// Generates code for an entity context and for each entity housed within that context.
        /// </summary>
        /// <param name="language">
        /// The language in which code should be generated.
        /// </param>
        /// <param name="solution">
        /// The solution containing the entities for whom code will be generated.
        /// </param>
        /// <param name="contextNamespace">
        /// The namespace in which to place the generated entity context.
        /// </param>
        /// <param name="contextName">
        /// The name for the generated entity context.
        /// </param>
        /// <param name="entityNamespaceSelector">
        /// A callback used to determine the namespace for each generated entity. If left as <see langword="null"/>, generated entities are placed in the same namespace
        /// as their associated interface.
        /// </param>
        /// <param name="entityNameSelector">
        /// A callback used to determine the name for each generated entity. If left as <see langword="null"/>, generated entities are named the same as their interface
        /// except with the leading "I" removed. If there is no leading "I", an "Impl" suffix is instead added to the interface's name.
        /// </param>
        /// <param name="interfacePredicate">
        /// A callback used to determine which interfaces should result in generated entities. If left as <see langword="null"/>, all interfaces marked with
        /// <see cref="EntityAttribute"/> are included.
        /// </param>
        /// <returns>
        /// A <see cref="SyntaxNode"/> for each generated class, with the entity context first in the list.
        /// </returns>
        public async static Task<IImmutableList<SyntaxNode>> GenerateAsync(
            Language language,
            Solution solution,
            string contextNamespace,
            string contextName = "EntityContext",
            Func<INamedTypeSymbol, string> entityNamespaceSelector = null,
            Func<INamedTypeSymbol, string> entityNameSelector = null,
            Func<INamedTypeSymbol, bool> interfacePredicate = null)
        {
            entityNamespaceSelector = entityNamespaceSelector ?? (x => x.ContainingNamespace.ToDisplayString());
            interfacePredicate = interfacePredicate ?? (x => x.GetAttributes().Any(y => y.AttributeClass.ToString() == typeof(EntityAttribute).FullName));
            entityNameSelector = entityNameSelector ??
                (x =>
                {
                    var name = x.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);

                    if (interfaceNameTransformationExpression.IsMatch(name))
                    {
                        return interfaceNameTransformationExpression.Replace(name, "${name}");
                    }
                    else
                    {
                        return name + "Impl";
                    }
                });

            var compilations = await Task.WhenAll(
                solution
                    .Projects
                    .Select(async x =>
                    {
                        var compilation = await x.GetCompilationAsync();
                        return new { Project = x, Compilation = compilation };
                    }));

            var entityMetadata = compilations
                .SelectMany(x =>
                    x
                        .Compilation
                        .SyntaxTrees
                        .Select(y =>
                            new
                            {
                                Project = x.Project,
                                Compilation = x.Compilation,
                                SyntaxTree = y,
                                SemanticModel = x.Compilation.GetSemanticModel(y)
                            }))
                .SelectMany(
                    x => x
                        .SyntaxTree
                        .GetRoot()
                        .DescendantNodes()
                        .Where(y => y is InterfaceDeclarationSyntax || y is VBSyntax.InterfaceBlockSyntax)
                        .Select(y =>
                            new
                            {
                                Project = x.Project,
                                Compilation = x.Compilation,
                                SyntaxTree = x.SyntaxTree,
                                SemanticModel = x.SemanticModel,
                                InterfaceSymbol = (INamedTypeSymbol)x.SemanticModel.GetDeclaredSymbol(y)
                            }))
                .Where(x => interfacePredicate(x.InterfaceSymbol))
                .Distinct()
                .ToList();

            var interfaceSymbols = entityMetadata
                .Select(x => x.InterfaceSymbol)
                .ToImmutableList();

            var entities = entityMetadata
                .Select(x =>
                    GenerateEntity(
                        language,
                        solution,
                        x.Compilation,
                        interfaceSymbols,
                        entityNamespaceSelector,
                        entityNameSelector,
                        x.InterfaceSymbol))
                .ToList();

            var context = GenerateContext(
                language,
                solution,
                contextNamespace,
                contextName,
                interfaceSymbols,
                entityNamespaceSelector,
                entityNameSelector);

            return new[] { context }
                .Concat(entities)
                .Select(x => Formatter.Format(x, solution.Workspace))
                .ToImmutableList();
        }

        private static SyntaxNode GenerateContext(
            Language language,
            Solution solution,
            string @namespace,
            string name,
            IImmutableList<INamedTypeSymbol> interfaceSymbols,
            Func<INamedTypeSymbol, string> entityNamespaceSelector,
            Func<INamedTypeSymbol, string> entityNameSelector)
        {
            Compilation compilation;
            var references = new[]
            {
                MetadataReference.CreateFromAssembly(typeof(object).Assembly),
                MetadataReference.CreateFromAssembly(typeof(BrightstarException).Assembly)
            };

            // we create our own compilation with which to generate the entity context
            switch (language)
            {
                case Language.CSharp:
                    compilation = CSharpCompilation.Create("Ignore", references: references);
                    break;
                case Language.VisualBasic:
                    compilation = VB.VisualBasicCompilation.Create("Ignore", references: references);
                    break;
                default:
                    throw new NotSupportedException();
            }

            var syntaxGenerator = SyntaxGenerator.GetGenerator(solution.Workspace, language.ToSyntaxGeneratorLanguageName());
            var generator = new EntityContextGenerator(
                language,
                syntaxGenerator,
                solution,
                compilation,
                @namespace,
                name,
                interfaceSymbols,
                entityNamespaceSelector,
                entityNameSelector);

            var context = generator
                .Generate();

            context = syntaxGenerator.WithLeadingComments(context, headerComment, language);

            return context
                .NormalizeWhitespace();
        }

        private static SyntaxNode GenerateEntity(
            Language language,
            Solution solution,
            Compilation compilation,
            IImmutableList<INamedTypeSymbol> interfaceSymbols,
            Func<INamedTypeSymbol, string> entityNamespaceSelector,
            Func<INamedTypeSymbol, string> entityNameSelector,
            INamedTypeSymbol interfaceSymbol)
        {
            var syntaxGenerator = SyntaxGenerator.GetGenerator(solution.Workspace, language.ToSyntaxGeneratorLanguageName());
            var generator = new EntityGenerator(
                language,
                syntaxGenerator,
                solution,
                compilation,
                interfaceSymbols,
                entityNamespaceSelector,
                entityNameSelector,
                interfaceSymbol);

            return generator
                .Generate()
                .NormalizeWhitespace();
        }

        private abstract class GeneratorBase
        {
            protected readonly SyntaxGenerator syntaxGenerator;
            protected readonly Solution solution;
            protected readonly Compilation compilation;
            protected readonly Language language;
            protected readonly string @namespace;
            protected readonly IImmutableList<INamedTypeSymbol> interfaceSymbols;
            protected readonly Func<INamedTypeSymbol, string> entityNamespaceSelector;
            protected readonly Func<INamedTypeSymbol, string> entityNameSelector;

            protected GeneratorBase(
                Language language,
                SyntaxGenerator syntaxGenerator,
                Solution solution,
                Compilation compilation,
                string @namespace,
                IImmutableList<INamedTypeSymbol> interfaceSymbols,
                Func<INamedTypeSymbol, string> entityNamespaceSelector,
                Func<INamedTypeSymbol, string> entityNameSelector)
            {
                this.language = language;
                this.syntaxGenerator = syntaxGenerator;
                this.solution = solution;
                this.compilation = compilation;
                this.@namespace = @namespace;
                this.interfaceSymbols = interfaceSymbols;
                this.entityNamespaceSelector = entityNamespaceSelector;
                this.entityNameSelector = entityNameSelector;
            }

            public abstract SyntaxNode Generate();

            protected SyntaxNode GetNamespaceDeclaration()
            {
                return syntaxGenerator.NamespaceDeclaration(@namespace);
            }

            protected IEnumerable<SyntaxNode> GetClassAttributes()
            {
                // GENERATED CODE:
                //
                //     [System.CodeDom.Compiler.GeneratedCode("BrightstarDB", "[version]")]
                //     [System.Runtime.CompilerServices.CompilerGenerated)]
                yield return syntaxGenerator
                    .Attribute(
                        "System.CodeDom.Compiler.GeneratedCode",
                        syntaxGenerator.LiteralExpression("BrightstarDB"),
                        syntaxGenerator.LiteralExpression(typeof(BrightstarException).Assembly.GetName().Version.ToString()));
                yield return syntaxGenerator
                    .Attribute(
                        "System.Runtime.CompilerServices.CompilerGenerated");
            }

            protected static IEnumerable<ISymbol> GetMembersRecursive(INamedTypeSymbol interfaceSymbol)
            {
                foreach (var member in interfaceSymbol.GetMembers())
                {
                    yield return member;
                }

                foreach (var implementedInterface in interfaceSymbol.Interfaces)
                {
                    foreach (var member in GetMembersRecursive(implementedInterface))
                    {
                        yield return member;
                    }
                }
            }

            protected string GetEntityClassNameForInterfaceSymbol(INamedTypeSymbol interfaceSymbol)
            {
                return entityNameSelector(interfaceSymbol);
            }

            protected SyntaxNode GetEntityClassForInterfaceSymbol(INamedTypeSymbol interfaceSymbol)
            {
                return syntaxGenerator
                    .QualifiedName(
                        syntaxGenerator.IdentifierName(entityNamespaceSelector(interfaceSymbol)),
                        syntaxGenerator.IdentifierName(entityNameSelector(interfaceSymbol)));
            }
        }

        private sealed class EntityContextGenerator : GeneratorBase
        {
            private readonly string name;

            public EntityContextGenerator(
                    Language language,
                    SyntaxGenerator syntaxGenerator,
                    Solution solution,
                    Compilation compilation,
                    string @namespace,
                    string name,
                    IImmutableList<INamedTypeSymbol> interfaceSymbols,
                    Func<INamedTypeSymbol, string> entityNamespaceSelector,
                    Func<INamedTypeSymbol, string> entityNameSelector)
                : base(language, syntaxGenerator, solution, compilation, @namespace, interfaceSymbols, entityNamespaceSelector, entityNameSelector)
            {
                this.name = name;
            }

            public override SyntaxNode Generate()
            {
                var namespaceDeclaration = GetNamespaceDeclaration();
                var classDeclaration = GetClassDeclaration();

                classDeclaration = syntaxGenerator
                    .AddAttributes(classDeclaration, GetClassAttributes());
                classDeclaration = syntaxGenerator
                    .AddMembers(classDeclaration, GetMembers());
                namespaceDeclaration = syntaxGenerator
                    .AddMembers(namespaceDeclaration, classDeclaration);

                return namespaceDeclaration;
            }

            private SyntaxNode GetClassDeclaration()
            {
                var baseType = compilation
                    .GetTypeByMetadataName(typeof(BrightstarEntityContext).FullName);
                
                if (baseType == null)
                {
                    throw new InvalidOperationException(
                        string.Format(
                            CultureInfo.InvariantCulture,
                            "Failed to find type in BrightstarDB assembly. Are you sure assembly {0} has a reference to BrightstarDB?",
                            compilation.AssemblyName));
                }

                return syntaxGenerator
                    .ClassDeclaration(
                        name,
                        accessibility: Accessibility.Public,
                        modifiers: DeclarationModifiers.Partial,
                        baseType: syntaxGenerator.TypeExpression(baseType));
            }

            private IEnumerable<SyntaxNode> GetMembers()
            {
                return
                    GetConstructors()
                    .Concat(
                        new SyntaxNode[]
                        {
                            GetInitializeContextMethod(),
                            GetEntitySetMethod()
                        })
                    .Concat(GetEntityProperties());
            }

            private IEnumerable<SyntaxNode> GetConstructors()
            {
                var reflectionMappingProviderType = compilation.GetTypeByMetadataName(typeof(ReflectionMappingProvider).FullName);
                var entityMappingStoreType = compilation.GetTypeByMetadataName(typeof(EntityMappingStore).FullName);
                var iDataObjectStoreType = compilation.GetTypeByMetadataName(typeof(IDataObjectStore).FullName);
                var iEnumerableTType = compilation.GetTypeByMetadataName(typeof(IEnumerable<>).FullName);
                var nullableTType = compilation.GetTypeByMetadataName(typeof(Nullable<>).FullName);
                var stringType = compilation.GetTypeByMetadataName(typeof(string).FullName);
                var boolType = compilation.GetTypeByMetadataName(typeof(bool).FullName);

                // GENERATED CODE:
                //
                //     static [Name]
                //     {
                //         var provider = new ReflectionMappingProvider();
                //
                //         [foreach entity type]
                //             provider.AddMappingsForType(EntityMappingStore.Instance, typeof([EntityContractType]));
                //             EntityMappingStore.Instance.SetImplMapping<[EntityContractType], [EntityType]>();
                //     }
                yield return syntaxGenerator
                    .ConstructorDeclaration(
                        modifiers: DeclarationModifiers.Static,
                        statements:
                            new[]
                            {
                                syntaxGenerator.LocalDeclarationStatement(
                                    "provider",
                                    syntaxGenerator.ObjectCreationExpression(reflectionMappingProviderType))
                            }
                            .Concat(
                                interfaceSymbols
                                    .SelectMany(x =>
                                        new[]
                                        {
                                            syntaxGenerator
                                                .InvocationExpression(
                                                    syntaxGenerator.MemberAccessExpression(
                                                        syntaxGenerator.IdentifierName("provider"),
                                                        "AddMappingsForType"),
                                                    syntaxGenerator.MemberAccessExpression(
                                                        syntaxGenerator.TypeExpression(entityMappingStoreType),
                                                        "Instance"),
                                                    syntaxGenerator.TypeOf(syntaxGenerator.TypeExpression(x), language)),
                                            syntaxGenerator
                                                .InvocationExpression(
                                                    syntaxGenerator.MemberAccessExpression(
                                                        syntaxGenerator.MemberAccessExpression(
                                                            syntaxGenerator.TypeExpression(entityMappingStoreType),
                                                            "Instance"),
                                                        syntaxGenerator.GenericName(
                                                            "SetImplMapping",
                                                            typeArguments: new[]
                                                            {
                                                                syntaxGenerator.TypeExpression(x),
                                                                GetEntityClassForInterfaceSymbol(x)
                                                            })))
                                        })));

                

                var initializeContextInvocation = syntaxGenerator
                    .InvocationExpression(
                        syntaxGenerator.MemberAccessExpression(
                            syntaxGenerator.ThisExpression(),
                            "InitializeContext"));

                // GENERATED CODE:
                //
                //     public [Name]()
                //         : base()
                //     {
                //         this.InitializeContext();
                //     }
                yield return syntaxGenerator
                    .ConstructorDeclaration(
                        accessibility: Accessibility.Public,
                        statements: new[]
                        {
                            initializeContextInvocation
                        });

                // GENERATED CODE:
                //
                //     public [Name](IDataObjectStore dataObjectStore)
                //         : base(dataObjectStore)
                //     {
                //         this.InitializeContext();
                //     }
                yield return syntaxGenerator
                    .ConstructorDeclaration(
                        accessibility: Accessibility.Public,
                        parameters: new[]
                        {
                            syntaxGenerator.ParameterDeclaration("dataObjectStore", syntaxGenerator.TypeExpression(iDataObjectStoreType))
                        },
                        baseConstructorArguments: new[]
                        {
                            syntaxGenerator.IdentifierName("dataObjectStore")
                        },
                        statements: new[]
                        {
                            initializeContextInvocation
                        });

                // GENERATED CODE:
                //
                //     public [Name](string updateGraphUri, IEnumerable<string> datasetGraphUris, string versionGraphUri)
                //         : base(updateGraphUri, datasetGraphUris, versionGraphUri)
                //     {
                //         this.InitializeContext();
                //     }
                yield return syntaxGenerator
                    .ConstructorDeclaration(
                        accessibility: Accessibility.Public,
                        parameters: new[]
                        {
                            syntaxGenerator.ParameterDeclaration("updateGraphUri", syntaxGenerator.TypeExpression(SpecialType.System_String)),
                            syntaxGenerator.ParameterDeclaration(
                                "datasetGraphUris",
                                syntaxGenerator.TypeExpression(iEnumerableTType.Construct(stringType))),
                            syntaxGenerator.ParameterDeclaration("versionGraphUri", syntaxGenerator.TypeExpression(SpecialType.System_String))
                        },
                        baseConstructorArguments: new[]
                        {
                            syntaxGenerator.IdentifierName("updateGraphUri"),
                            syntaxGenerator.IdentifierName("datasetGraphUris"),
                            syntaxGenerator.IdentifierName("versionGraphUri")
                        },
                        statements: new[]
                        {
                            initializeContextInvocation
                        });

                // GENERATED CODE:
                //
                //     public [Name](string connectionString, bool? enableOptimisticLocking = null, string updateGraphUri = null, IEnumerable< string > datasetGraphUris = null, string versionGraphUri = null)
                //         : base(connectionString, enableOptimisticLocking, updateGraphUri, datasetGraphUris, versionGraphUri)
                //     {
                //         this.InitializeContext();
                //     }
                yield return syntaxGenerator
                    .ConstructorDeclaration(
                        accessibility: Accessibility.Public,
                        parameters: new[]
                        {
                            syntaxGenerator.ParameterDeclaration(
                                "connectionString",
                                syntaxGenerator.TypeExpression(SpecialType.System_String)),
                            syntaxGenerator.ParameterDeclaration(
                                "enableOptimisticLocking",
                                syntaxGenerator.TypeExpression(nullableTType.Construct(boolType)),
                                initializer: syntaxGenerator.NullLiteralExpression()),
                            syntaxGenerator.ParameterDeclaration(
                                "updateGraphUri",
                                syntaxGenerator.TypeExpression(SpecialType.System_String),
                                initializer: syntaxGenerator.NullLiteralExpression()),
                            syntaxGenerator.ParameterDeclaration(
                                "datasetGraphUris",
                                syntaxGenerator.TypeExpression(iEnumerableTType.Construct(stringType)),
                                initializer: syntaxGenerator.NullLiteralExpression()),
                            syntaxGenerator.ParameterDeclaration(
                                "versionGraphUri",
                                syntaxGenerator.TypeExpression(SpecialType.System_String),
                                initializer: syntaxGenerator.NullLiteralExpression())
                        },
                        baseConstructorArguments: new[]
                        {
                            syntaxGenerator.IdentifierName("connectionString"),
                            syntaxGenerator.IdentifierName("enableOptimisticLocking"),
                            syntaxGenerator.IdentifierName("updateGraphUri"),
                            syntaxGenerator.IdentifierName("datasetGraphUris"),
                            syntaxGenerator.IdentifierName("versionGraphUri")
                        },
                        statements: new[]
                        {
                            initializeContextInvocation
                        });
            }

            private SyntaxNode GetInitializeContextMethod()
            {
                var brightstarEntitySetType = compilation.GetTypeByMetadataName(typeof(BrightstarEntitySet<>).FullName);

                // GENERATED CODE:
                //
                //     private void InitializeContext()
                //     {
                //         [foreach entity type]
                //             this.[EntitySetFieldName] = new BrightstarEntitySet<[EntityContractType]>(this);
                //     }
                return syntaxGenerator.MethodDeclaration(
                    "InitializeContext",
                    accessibility: Accessibility.Private,
                    statements: interfaceSymbols
                        .Select(x => syntaxGenerator
                            .AssignmentStatement(
                                syntaxGenerator.MemberAccessExpression(
                                    syntaxGenerator.ThisExpression(),
                                    "_" + GetEntityClassNameForInterfaceSymbol(x).Pluralize()),
                                syntaxGenerator.ObjectCreationExpression(
                                    brightstarEntitySetType.Construct(x),
                                    syntaxGenerator.ThisExpression()))));
            }

            private IEnumerable<SyntaxNode> GetEntityProperties()
            {
                var iEntitySetType = compilation.GetTypeByMetadataName(typeof(IEntitySet<>).FullName);
                
                // GENERATED CODE:
                //
                //     [foreach entity type]
                //         private IEntitySet<[EntityContractType]> _[EntitySetPropertyName];
                //         public IEntitySet<[EntityContractType]> [EntitySetPropertyName]
                //         {
                //             get { return this._[EntitySetPropertyName]; }
                //         }
                return interfaceSymbols
                    .SelectMany(x =>
                    {
                        var propertyName = GetEntityClassNameForInterfaceSymbol(x).Pluralize();
                        var fieldName = "_" + propertyName;
                        var propertyType = iEntitySetType.Construct(x);

                        return new[]
                        {
                            syntaxGenerator.FieldDeclaration(
                                fieldName,
                                syntaxGenerator.TypeExpression(propertyType),
                                accessibility: Accessibility.Private),
                            syntaxGenerator.PropertyDeclaration(
                                propertyName,
                                syntaxGenerator.TypeExpression(propertyType),
                                accessibility: Accessibility.Public,
                                modifiers: DeclarationModifiers.ReadOnly,
                                getAccessorStatements: new[]
                                {
                                    syntaxGenerator.ReturnStatement(
                                        syntaxGenerator.MemberAccessExpression(
                                            syntaxGenerator.ThisExpression(),
                                            fieldName))
                                })
                        };
                    });
            }

            private SyntaxNode GetEntitySetMethod()
            {
                var typeType = compilation.GetTypeByMetadataName(typeof(Type).FullName);
                var iEntitySetType = compilation.GetTypeByMetadataName(typeof(IEntitySet<>).FullName);
                var invalidOperationExceptionType = compilation.GetTypeByMetadataName(typeof(InvalidOperationException).FullName);

                // GENERATED CODE:
                //
                //     public IEntitySet<T> EntitySet<T>() where T : class
                //     {
                //         var type = typeof(T);
                //         [foreach entity type]
                //             if (type.Equals(typeof([EntityContractType])))
                //             {
                //                 return (IEntitySet<T>)this.[EntitySetPropertyName];
                //             }
                //         throw new InvalidOperationException(typeo(T).FullName + " is not a recognized entity interface type.");
                //     }
                return syntaxGenerator.WithTypeConstraint(
                    syntaxGenerator.MethodDeclaration(
                        "EntitySet",
                        accessibility: Accessibility.Public,
                        typeParameters: new[] { "T" },
                        returnType: syntaxGenerator.TypeExpression(iEntitySetType),
                        statements:
                            new[]
                            {
                                syntaxGenerator.LocalDeclarationStatement(
                                    typeType,
                                    "type",
                                    syntaxGenerator.TypeOf(syntaxGenerator.IdentifierName("T"), language))
                            }
                            .Concat(
                                interfaceSymbols
                                    .Select(x => syntaxGenerator.IfStatement(
                                        syntaxGenerator.InvocationExpression(
                                            syntaxGenerator.MemberAccessExpression(
                                                syntaxGenerator.IdentifierName("type"),
                                                "Equals"),
                                            syntaxGenerator.TypeOf(syntaxGenerator.TypeExpression(x), language)),
                                        new[]
                                        {
                                            syntaxGenerator.ReturnStatement(
                                                syntaxGenerator.CastExpression(
                                                    iEntitySetType,
                                                    syntaxGenerator.MemberAccessExpression(
                                                        syntaxGenerator.ThisExpression(),
                                                        syntaxGenerator.IdentifierName(
                                                            GetEntityClassNameForInterfaceSymbol(x).Pluralize()))))
                                        })))
                            .Concat(new[]
                            {
                                syntaxGenerator.ThrowStatement(
                                    syntaxGenerator.ObjectCreationExpression(
                                        invalidOperationExceptionType,
                                        syntaxGenerator.AddExpression(
                                            syntaxGenerator.MemberAccessExpression(
                                                syntaxGenerator.TypeOf(syntaxGenerator.IdentifierName("T"), language),
                                                "FullName"),
                                            syntaxGenerator.LiteralExpression(" is not a recognized entity interface type."))))
                            })),
                    "T",
                    SpecialTypeConstraintKind.ReferenceType);
            }
        }

        private sealed class EntityGenerator : GeneratorBase
        {
            private readonly INamedTypeSymbol interfaceSymbol;
            private readonly string name;
            private readonly ISet<ITypeSymbol> basicTypes;

            public EntityGenerator(
                    Language language,
                    SyntaxGenerator syntaxGenerator,
                    Solution solution,
                    Compilation compilation,
                    IImmutableList<INamedTypeSymbol> interfaceSymbols,
                    Func<INamedTypeSymbol, string> entityNamespaceSelector,
                    Func<INamedTypeSymbol, string> entityNameSelector,
                    INamedTypeSymbol interfaceSymbol)
                : base(language, syntaxGenerator, solution, compilation, entityNamespaceSelector(interfaceSymbol), interfaceSymbols, entityNamespaceSelector, entityNameSelector)
            {
                this.interfaceSymbol = interfaceSymbol;
                this.name = entityNameSelector(interfaceSymbol);

                var basicTypes = new[]
                {
                    typeof(bool),
                    typeof(short),
                    typeof(int),
                    typeof(long),
                    typeof(ushort),
                    typeof(uint),
                    typeof(ulong),
                    typeof(string),
                    typeof(decimal),
                    typeof(double),
                    typeof(float),
                    typeof(byte),
                    typeof(char),
                    typeof(sbyte),
                    typeof(DateTime),
                    typeof(Guid),
                    typeof(Uri),
                    typeof(PlainLiteral)

                    // TODO: nullables?
                };

                this.basicTypes = new HashSet<ITypeSymbol>(basicTypes.Select(x => compilation.GetTypeByMetadataName(x.FullName)));
            }

            public override SyntaxNode Generate()
            {
                var namespaceDeclaration = GetNamespaceDeclaration();
                var classDeclaration = GetClassDeclaration();

                classDeclaration = syntaxGenerator
                    .AddAttributes(classDeclaration, GetClassAttributes());
                classDeclaration = syntaxGenerator
                    .AddMembers(classDeclaration, GetMembers());
                namespaceDeclaration = syntaxGenerator
                    .AddMembers(namespaceDeclaration, classDeclaration);

                return namespaceDeclaration;
            }

            private SyntaxNode GetClassDeclaration()
            {
                var baseType = compilation
                    .GetTypeByMetadataName(typeof(BrightstarEntityObject).FullName);

                if (baseType == null)
                {
                    throw new InvalidOperationException(
                        string.Format(
                            CultureInfo.InvariantCulture,
                            "Failed to find type in BrightstarDB assembly. Are you sure assembly {0} has a reference to BrightstarDB?",
                            compilation.AssemblyName));
                }

                return syntaxGenerator
                    .ClassDeclaration(
                        this.name,
                        accessibility: Accessibility.Public,
                        modifiers: DeclarationModifiers.Partial,
                        baseType: syntaxGenerator.TypeExpression(baseType),
                        interfaceTypes: new[] { syntaxGenerator.TypeExpression(this.interfaceSymbol) });
            }

            private IEnumerable<SyntaxNode> GetMembers()
            {
                var idProperty = GetIdProperty();

                return
                    GetConstructors()
                    .Concat(idProperty == null ? Enumerable.Empty<SyntaxNode>() : new[] { idProperty })
                    .Concat(GetNonIdentifierProperties(FindIdentityProperty()));
            }

            private IEnumerable<SyntaxNode> GetConstructors()
            {
                var brightstarEntityContextType = compilation.GetTypeByMetadataName(typeof(BrightstarEntityContext).FullName);
                var iDataObjectType = compilation.GetTypeByMetadataName(typeof(IDataObject).FullName);

                // GENERATED CODE:
                //
                //     public [Name]()
                //         : base()
                //     {
                //     }
                yield return syntaxGenerator
                    .ConstructorDeclaration(
                        accessibility: Accessibility.Public);

                // GENERATED CODE:
                //
                //     public [Name](BrightstarEntityContext context)
                //         : base(context, typeof([EntityType]))
                //     {
                //     }
                yield return syntaxGenerator
                    .ConstructorDeclaration(
                        accessibility: Accessibility.Public,
                        parameters: new[]
                        {
                            syntaxGenerator.ParameterDeclaration("context", syntaxGenerator.TypeExpression(brightstarEntityContextType))
                        },
                        baseConstructorArguments: new[]
                        {
                            syntaxGenerator.IdentifierName("context"),
                            syntaxGenerator.TypeOf(syntaxGenerator.IdentifierName(this.name), language)
                        });

                // GENERATED CODE:
                //
                //     public [Name](BrightstarEntityContext context, IDataObject dataObject)
                //         : base(context, dataObject)
                //     {
                //     }
                yield return syntaxGenerator
                    .ConstructorDeclaration(
                        accessibility: Accessibility.Public,
                        parameters: new[]
                        {
                            syntaxGenerator.ParameterDeclaration("context", syntaxGenerator.TypeExpression(brightstarEntityContextType)),
                            syntaxGenerator.ParameterDeclaration("dataObject", syntaxGenerator.TypeExpression(iDataObjectType))
                        },
                        baseConstructorArguments: new[]
                        {
                            syntaxGenerator.IdentifierName("context"),
                            syntaxGenerator.IdentifierName("dataObject")
                        });
            }

            private SyntaxNode GetIdProperty()
            {
                var identityProperty = FindIdentityProperty();

                if (identityProperty == null)
                {
                    return null;
                }

                ValidateIdentityProperty(identityProperty);

                // GENERATED CODE:
                //
                //     public string [IdentifierPropertyName]
                //     {
                //         get { return base.GetKey(); }
                //         set { base.SetKey(value); }
                //     }
                var propertyDeclaration = syntaxGenerator.PropertyDeclaration(
                    identityProperty.Name,
                    syntaxGenerator.TypeExpression(identityProperty.Type),
                    accessibility: Accessibility.Public,
                    getAccessorStatements: new[]
                    {
                        syntaxGenerator.ReturnStatement(
                            syntaxGenerator.InvocationExpression(
                                syntaxGenerator.MemberAccessExpression(
                                    syntaxGenerator.BaseExpression(),
                                    "GetKey")))
                    },
                    setAccessorStatements: new[]
                    {
                        syntaxGenerator.InvocationExpression(
                            syntaxGenerator.MemberAccessExpression(
                                syntaxGenerator.BaseExpression(),
                                "SetKey"),
                            syntaxGenerator.IdentifierName("value"))
                    });

                propertyDeclaration = syntaxGenerator.AddAttributes(
                    propertyDeclaration,
                    identityProperty
                        .GetAttributes()
                        .Where(x => !IsEntityFrameworkAttribute(x))
                        .Select(x => syntaxGenerator.Attribute(x)));

                return propertyDeclaration;
            }

            private IEnumerable<SyntaxNode> GetNonIdentifierProperties(IPropertySymbol identifierProperty)
            {
                var properties = GetMembersRecursive(this.interfaceSymbol)
                    .OfType<IPropertySymbol>()
                    .Where(x => x != identifierProperty)
                    .Where(x => !IsIgnoredProperty(x))
                    .ToList();

                foreach (var property in properties)
                {
                    bool isCollection;
                    ITypeSymbol scalarType;

                    ValidateProperty(property, out isCollection, out scalarType);
                    SyntaxNode propertyDeclaration = null;

                    if (isCollection)
                    {
                        // GENERATED CODE:
                        //
                        //     public ICollection<[RelatedEntityType]> [PropertyName]
                        //     {
                        //         get { return base.GetRelatedObjects<[RelatedEntityType]>("[PropertyName]"); }
                        //         set
                        //         {
                        //             if (value == null) throw new ArgumentNullException("value");
                        //             base.SetRelatedObjects<[RelatedEntityType]>("[PropertyName]", value);
                        //         }
                        //     }
                        propertyDeclaration = syntaxGenerator.PropertyDeclaration(
                            property.Name,
                            syntaxGenerator.TypeExpression(property.Type),
                            accessibility: Accessibility.Public,
                            getAccessorStatements: new[]
                            {
                                syntaxGenerator.ReturnStatement(
                                    syntaxGenerator.InvocationExpression(
                                        syntaxGenerator.WithTypeArguments(
                                            syntaxGenerator.MemberAccessExpression(
                                                syntaxGenerator.BaseExpression(),
                                                "GetRelatedObjects"),
                                            syntaxGenerator.TypeExpression(scalarType)),
                                        syntaxGenerator.LiteralExpression(property.Name)))
                            },
                            setAccessorStatements: new[]
                            {
                                syntaxGenerator.IfStatement(
                                    syntaxGenerator.ValueEqualsExpression(
                                        syntaxGenerator.IdentifierName("value"),
                                        syntaxGenerator.NullLiteralExpression()),
                                    new[]
                                    {
                                        syntaxGenerator.ThrowStatement(
                                            syntaxGenerator.ObjectCreationExpression(
                                                compilation.GetTypeByMetadataName(typeof(ArgumentNullException).FullName),
                                                syntaxGenerator.LiteralExpression("value")))
                                    }),
                                    syntaxGenerator.InvocationExpression(
                                        syntaxGenerator.WithTypeArguments(
                                            syntaxGenerator.MemberAccessExpression(
                                                syntaxGenerator.BaseExpression(),
                                                "SetRelatedObjects"),
                                            syntaxGenerator.TypeExpression(scalarType)),
                                        syntaxGenerator.LiteralExpression(property.Name),
                                        syntaxGenerator.IdentifierName("value"))
                            });
                    }
                    else
                    {
                        var isEntity = this.interfaceSymbols.Any(x => x == scalarType);

                        if (isEntity)
                        {
                            // GENERATED CODE:
                            //
                            //     public [RelatedEntityType] [PropertyName]
                            propertyDeclaration = syntaxGenerator.PropertyDeclaration(
                                property.Name,
                                syntaxGenerator.TypeExpression(property.Type),
                                accessibility: Accessibility.Public,
                                getAccessorStatements: new[]
                                {
                                    syntaxGenerator.ReturnStatement(
                                        syntaxGenerator.InvocationExpression(
                                            syntaxGenerator.WithTypeArguments(
                                                syntaxGenerator.MemberAccessExpression(
                                                    syntaxGenerator.BaseExpression(),
                                                    "GetRelatedObject"),
                                                syntaxGenerator.TypeExpression(scalarType)),
                                            syntaxGenerator.LiteralExpression(property.Name)))
                                },
                                setAccessorStatements: new[]
                                {
                                    syntaxGenerator.InvocationExpression(
                                        syntaxGenerator.WithTypeArguments(
                                            syntaxGenerator.MemberAccessExpression(
                                                syntaxGenerator.BaseExpression(),
                                                "SetRelatedObject"),
                                            syntaxGenerator.TypeExpression(scalarType)),
                                        syntaxGenerator.LiteralExpression(property.Name),
                                        syntaxGenerator.IdentifierName("value"))
                                });

                            if (property.GetMethod != null)
                            {
                                // GENERATED CODE:
                                //
                                //     get { return base.GetRelatedObject<[RelatedEntityType]>("[PropertyName]"); }
                                propertyDeclaration = syntaxGenerator.WithGetAccessorStatements(
                                    propertyDeclaration,
                                    new[]
                                    {
                                        syntaxGenerator.ReturnStatement(
                                            syntaxGenerator.InvocationExpression(
                                                syntaxGenerator.WithTypeArguments(
                                                    syntaxGenerator.MemberAccessExpression(
                                                        syntaxGenerator.BaseExpression(),
                                                        "GetRelatedObject"),
                                                    syntaxGenerator.TypeExpression(scalarType)),
                                                syntaxGenerator.LiteralExpression(property.Name)))
                                    });
                            }

                            if (property.SetMethod != null)
                            {
                                // GENERATED CODE:
                                //
                                //     set { base.SetRelatedObject<[RelatedEntityType]>("[PropertyName]", value); }
                                propertyDeclaration = syntaxGenerator.WithSetAccessorStatements(
                                    propertyDeclaration,
                                    new[]
                                    {
                                        syntaxGenerator.InvocationExpression(
                                            syntaxGenerator.WithTypeArguments(
                                                syntaxGenerator.MemberAccessExpression(
                                                    syntaxGenerator.BaseExpression(),
                                                    "SetRelatedObject"),
                                                syntaxGenerator.TypeExpression(scalarType)),
                                            syntaxGenerator.LiteralExpression(property.Name),
                                            syntaxGenerator.IdentifierName("value"))
                                    });
                            }
                        }
                        else
                        {
                            // GENERATED CODE:
                            //
                            //     public [PropertyType] [PropertyName]
                            //     {
                            //         get { return base.GetRelatedProperty<[PropertyType]>("[PropertyName]"); }
                            //         set { base.SetRelatedProperty("[PropertyName]", value); }
                            //     }
                            propertyDeclaration = syntaxGenerator.PropertyDeclaration(
                                property.Name,
                                syntaxGenerator.TypeExpression(property.Type),
                                accessibility: Accessibility.Public,
                                getAccessorStatements: new[]
                                {
                                    syntaxGenerator.ReturnStatement(
                                        syntaxGenerator.InvocationExpression(
                                            syntaxGenerator.WithTypeArguments(
                                                syntaxGenerator.MemberAccessExpression(
                                                    syntaxGenerator.BaseExpression(),
                                                    "GetRelatedProperty"),
                                                syntaxGenerator.TypeExpression(scalarType)),
                                            syntaxGenerator.LiteralExpression(property.Name)))
                                },
                                setAccessorStatements: new[]
                                {
                                    syntaxGenerator.InvocationExpression(
                                        syntaxGenerator.MemberAccessExpression(
                                            syntaxGenerator.BaseExpression(),
                                            "SetRelatedProperty"),
                                        syntaxGenerator.LiteralExpression(property.Name),
                                        syntaxGenerator.IdentifierName("value"))
                                });
                        }
                    }

                    propertyDeclaration = syntaxGenerator.AsPublicInterfaceImplementation(propertyDeclaration, syntaxGenerator.TypeExpression(this.interfaceSymbol));

                    propertyDeclaration = syntaxGenerator.AddAttributes(
                        propertyDeclaration,
                        property
                            .GetAttributes()
                            .Where(x => !IsEntityFrameworkAttribute(x))
                            .Select(x => syntaxGenerator.Attribute(x)));

                    yield return propertyDeclaration;
                }
            }

            private static bool IsEntityFrameworkAttribute(AttributeData attribute)
            {
                return attribute.AttributeClass.ContainingNamespace.ToDisplayString() == "BrightstarDB.EntityFramework";
            }

            private IPropertySymbol FindIdentityProperty()
            {
                var identifierAttributeType = compilation.GetTypeByMetadataName(typeof(IdentifierAttribute).FullName);
                var potentialIdentifierProperties =
                    from property in GetMembersRecursive(this.interfaceSymbol).OfType<IPropertySymbol>()
                    let isDefinedInOriginalInterface = property.ContainingSymbol == this.interfaceSymbol
                    let hasIdentifierAttribute = property.GetAttributes().Any(y => y.AttributeClass == identifierAttributeType)
                    let isClassWithIdSuffix = property.Name == this.name + "Id" || property.Name == this.name + "ID"
                    let isId = property.Name == "Id" || property.Name == "ID"
                    let rank =
                        (hasIdentifierAttribute
                            ? 5
                            : (isClassWithIdSuffix
                                ? 4
                                : (isId
                                    ? 3
                                    : 0)))
                    where rank > 0
                    let scaledRank = rank * (isDefinedInOriginalInterface ? 2 : 1)
                    orderby scaledRank descending
                    select property;

                return potentialIdentifierProperties
                    .FirstOrDefault();
            }

            private void ValidateIdentityProperty(IPropertySymbol identityProperty)
            {
                var stringType = compilation.GetTypeByMetadataName(typeof(string).FullName);
                var identifierAttributeType = compilation.GetTypeByMetadataName(typeof(IdentifierAttribute).FullName);

                if (identityProperty.Type != stringType)
                {
                    throw new InvalidOperationException(
                        string.Format(
                            CultureInfo.InvariantCulture,
                            "The property '{0}' must be of type {1} to be used as the identity property for an entity. If this property is intended to be the identity property for the entity please change its type to {1}. If it is not intended to be the identity property, either rename this property or create an identity property and decorate it with the [{2}] attribute.",
                            identityProperty.ToDisplayString(),
                            stringType.ToDisplayString(),
                            identifierAttributeType.ToDisplayString()));
                }

                if (identityProperty.SetMethod != null)
                {
                    throw new InvalidOperationException(
                        string.Format(
                            CultureInfo.InvariantCulture,
                            "The property '{0}' must not have a setter to be used as the identity property for an entity. If this property is intended to be the identity property for the entity please remove the setter. If it is not intended to be the identity property, either rename this property or create an identity propertyn and decorate it with the [{1}] attribute.",
                            identityProperty.ToDisplayString(),
                            identifierAttributeType.ToDisplayString()));
                }
            }

            private bool IsIgnoredProperty(IPropertySymbol property)
            {
                var ignoreAttributeType = compilation.GetTypeByMetadataName(typeof(IgnoreAttribute).FullName);
                return property
                    .GetAttributes()
                    .Any(x => x.AttributeClass == ignoreAttributeType);
            }

            private void ValidateProperty(IPropertySymbol property, out bool isCollection, out ITypeSymbol scalarType)
            {
                if (!IsSupportedPropertyType(property.Type, out isCollection, out scalarType))
                {
                    throw new InvalidOperationException(
                        string.Format(
                            CultureInfo.InvariantCulture,
                            "Invalid property: {0} - the property type {1} is not supported by Entity Framework.",
                            property.ToDisplayString(),
                            property.Type.ToDisplayString()));
                }

                var inversePropertyAttributeType = compilation.GetTypeByMetadataName(typeof(InversePropertyAttribute).FullName);
                var inversePropertyAttribute = property.GetAttributes().SingleOrDefault(x => x.AttributeClass == inversePropertyAttributeType);

                if (inversePropertyAttribute != null)
                {
                    var scalarTypeCopy = scalarType;
                    var targetType = this.interfaceSymbols.SingleOrDefault(x => x == scalarTypeCopy);

                    if (targetType == null)
                    {
                        throw new InvalidOperationException(
                            string.Format(
                                CultureInfo.InvariantCulture,
                                "Invalid {0} attribute on property {1}. The property type {2} must be marked as an Entity.",
                                inversePropertyAttributeType.ToDisplayString(),
                                property.ToDisplayString(),
                                scalarType.ToDisplayString()));
                    }

                    var inversePropertyName = (string)inversePropertyAttribute.ConstructorArguments[0].Value;

                    var targetProperty = targetType
                        .GetMembers()
                        .OfType<IPropertySymbol>()
                        .Where(x => x.Name == inversePropertyName)
                        .FirstOrDefault();

                    if (targetProperty == null)
                    {
                        throw new InvalidOperationException(
                            string.Format(
                                CultureInfo.InvariantCulture,
                                "Invalid {0} attribute on property {1}. A property named '{2}' cannot be found on the target interface type {3}.",
                                inversePropertyAttributeType.ToDisplayString(),
                                property.ToDisplayString(),
                                inversePropertyName,
                                targetType.ToDisplayString()));
                    }
                }
            }

            private bool IsSupportedPropertyType(ITypeSymbol propertyType, out bool isCollection, out ITypeSymbol scalarType)
            {
                isCollection = IsCollectionType(propertyType);
                scalarType = propertyType;

                if (isCollection)
                {
                    scalarType = ((INamedTypeSymbol)propertyType).TypeArguments[0];
                }

                return IsSupportedScalarPropertyType(scalarType);
            }

            private bool IsSupportedScalarPropertyType(ITypeSymbol propertyType)
            {
                if (basicTypes.Contains(propertyType))
                {
                    return true;
                }

                if (IsNullable(propertyType, o => basicTypes.Contains(o) || IsEnum(o)))
                {
                    return true;
                }

                if (IsEnum(propertyType))
                {
                    return true;
                }

                var byteType = compilation.GetTypeByMetadataName(typeof(byte).FullName);

                if (IsArray(propertyType, e => e == byteType))
                {
                    return true;
                }

                if (IsEntityType(propertyType))
                {
                    return true;
                }

                return false;
            }

            private bool IsEnum(ITypeSymbol type)
            {
                var enumType = compilation.GetTypeByMetadataName(typeof(Enum).FullName);
                return type.BaseType == enumType;
            }

            private bool IsArray(ITypeSymbol type, Func<ITypeSymbol, bool> elementTypePredicate = null)
            {
                var arrayType = type as IArrayTypeSymbol;

                if (arrayType == null)
                {
                    return false;
                }

                return elementTypePredicate == null || elementTypePredicate(arrayType.ElementType);
            }

            private bool IsNullable(ITypeSymbol type, Func<ITypeSymbol, bool> underlyingTypePredicate = null)
            {
                var nullableTType = compilation.GetTypeByMetadataName(typeof(Nullable<>).FullName);

                if (type.OriginalDefinition != nullableTType)
                {
                    return false;
                }

                var namedType = (INamedTypeSymbol)type;

                return underlyingTypePredicate == null || underlyingTypePredicate(namedType.TypeArguments[0]);
            }

            private bool IsEntityType(ITypeSymbol type)
            {
                return this.interfaceSymbols.Any(x => x == type);
            }

            private bool IsCollectionType(ITypeSymbol type)
            {
                var iCollectionTType = compilation.GetTypeByMetadataName(typeof(ICollection<>).FullName);

                // TODO: existing template allows ISet<T> in one place, and then not in a subsequent place
                //var iSetTType = compilation.GetTypeByMetadataName(typeof(ISet<>).FullName);

                return type.OriginalDefinition == iCollectionTType;// || type.OriginalDefinition == iSetTType;
            }
        }
    }
}
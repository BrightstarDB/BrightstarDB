using System.IO;
using System.Reflection;
using Buildalyzer;
using Buildalyzer.Workspaces;
using Microsoft.Extensions.Logging;

namespace BrightstarDB.CodeGeneration
{
    using System;
    using System.Collections.Generic;
    using System.Collections.Immutable;
    using System.Globalization;
    using System.Linq;
    using System.Text;
    using System.Text.RegularExpressions;
    using System.Threading.Tasks;
    using Microsoft.CodeAnalysis;
    using Microsoft.CodeAnalysis.CSharp;
    using Microsoft.CodeAnalysis.CSharp.Syntax;
    using Microsoft.CodeAnalysis.Editing;
    using Microsoft.CodeAnalysis.Formatting;
    using VB = Microsoft.CodeAnalysis.VisualBasic;
    using VBSyntax = Microsoft.CodeAnalysis.VisualBasic.Syntax;

    public static class Generator
    {
        private static readonly Regex interfaceNameTransformationExpression = new Regex("I(?<name>[A-Z].*)", RegexOptions.Compiled);
        private const string headerComment =
@"-----------------------------------------------------------------------
<autogenerated>
   This code was generated from a template.

   Changes to this file may cause incorrect behaviour and will be lost
   if the code is regenerated.
</autogenerated>
------------------------------------------------------------------------";

        // synchronous version of GenerateAsync, really only for making the T4 generation logic simpler - use the asynchronous overloads wherever possible
        public static string Generate(
            string language,
            string solutionPath,
            string contextNamespace,
            string contextName = "EntityContext",
            Func<INamedTypeSymbol, string> entityNamespaceSelector = null,
            Func<INamedTypeSymbol, string> entityNameSelector = null,
            Func<INamedTypeSymbol, bool> interfacePredicate = null)
        {
            return _Generate(language, solutionPath, contextNamespace, contextName, entityNamespaceSelector, entityNameSelector, null, interfacePredicate);
        }

        // Updated version of the T4 entry point for the generation logic. Removes the unused selector functions and adds a boolean flag for controlling 
        // whether entity classes default to internal accessibility. The old entry point is kept for backwards compatibility with existing project's T4 templates
        public static string Generate2(
            string language,
            string solutionPath,
            string contextNamespace,
            string contextName = "EntityContext",
            bool internalEntityClasses = false
            )
        {
            return _Generate(language, solutionPath, contextNamespace, contextName,
                entityAccessibiltySelector:
                    internalEntityClasses
                        ? (Func<INamedTypeSymbol, Accessibility>)Generator.InteralyEntityAccessibilitySelector
                        : Generator.DefaultEntityAccessibilitySelector);
        }

        private static string _Generate(string language,
            string solutionPath,
            string contextNamespace,
            string contextName = "EntityContext",
            Func<INamedTypeSymbol, string> entityNamespaceSelector = null,
            Func<INamedTypeSymbol, string> entityNameSelector = null,
            Func<INamedTypeSymbol, Accessibility> entityAccessibiltySelector = null,
            Func<INamedTypeSymbol, bool> interfacePredicate = null)
        {
            var castLanguage = (Language)Enum.Parse(typeof(Language), language);

            var nodes = GenerateAsync(
                castLanguage,
                solutionPath,
                contextNamespace,
                contextName,
                entityNamespaceSelector,
                entityNameSelector,
                entityAccessibiltySelector,
                interfacePredicate).Result;

            return nodes
                .Aggregate(
                    new StringBuilder(),
                    (sb, next) => sb.AppendLine(next.ToFullString()),
                    x => x.ToString());
        }

        public static async Task<IImmutableList<SyntaxNode>> GenerateFromProjectAsync(
            Language language,
            string projectPath,
            string contextNamespace,
            string contextName,
            Func<INamedTypeSymbol, string> entityNamespaceSelector = null,
            Func<INamedTypeSymbol, string> entityNameSelector = null,
            Func<INamedTypeSymbol, Accessibility> entityAccessibilitySelector = null,
            Func<INamedTypeSymbol, bool> interfacePredicate = null,
            ILoggerFactory loggerFactory = null)
        {
            var amOptions = new AnalyzerManagerOptions();
            TextWriter logTextWriter = null;
            if (loggerFactory != null)
            {
                amOptions.LoggerFactory = loggerFactory;
            }
            else
            {
                amOptions.LogWriter = logTextWriter = new StringWriter();
            }
            var manager = new AnalyzerManager(amOptions);
            var workspace = new AdhocWorkspace();
            var project = manager.GetProject(projectPath);
            var results = project.Build().First();
            if (!results.Succeeded)
            {
                var exceptionMessage = "Analysis build failed for project " + results.ProjectFilePath;
                if (logTextWriter != null)
                {
                    exceptionMessage += "\n" + logTextWriter;
                }
                throw new Exception(exceptionMessage);
            }
            var brightstarAssemblyPath = results.References.FirstOrDefault(r =>
                r.EndsWith("BrightstarDB.dll", true, CultureInfo.InvariantCulture));
            if (brightstarAssemblyPath == null)
            {
                throw new Exception(
                    "Could not locate a BrightstarDB.dll reference amongst any of the solution projects");
            }

            project.AddToWorkspace(workspace);

            return await GenerateAsync(
                language,
                workspace.CurrentSolution,
                contextNamespace,
                contextName,
                entityNamespaceSelector,
                entityNameSelector,
                entityAccessibilitySelector,
                interfacePredicate,
                brightstarAssemblyPath);
        }

        /// <summary>
        /// Generates code for an entity context and for each entity housed within that context.
        /// </summary>
        /// <param name="language">
        /// The language in which code should be generated.
        /// </param>
        /// <param name="solutionPath">
        /// The path to the solution file containing the entities for whom code will be generated.
        /// </param>
        /// <param name="contextNamespace">
        /// The namespace in which to place the generated entity context.
        /// </param>
        /// <param name="contextName">
        /// The name for the generated entity context.
        /// </param>
        /// <param name="entityNamespaceSelector">
        /// A callback used to determine the namespace for each generated entity. If left as <see langword="null"/>, generated entities are placed in the same namespace
        /// as their associated interface.
        /// </param>
        /// <param name="entityNameSelector">
        /// A callback used to determine the name for each generated entity. If left as <see langword="null"/>, generated entities are named the same as their interface
        /// except with the leading "I" removed. If there is no leading "I", an "Impl" suffix is instead added to the interface's name.
        /// </param>
        /// <param name="entityAccessibilitySelector">
        /// A callback used to determine the declared accessibility for each generated entity. If left as <see langword="null"/>, generated entity classes have the same
        /// declared accessibility as the entity interface that they implement.
        /// </param>
        /// <param name="interfacePredicate">
        /// A callback used to determine which interfaces should result in generated entities. If left as <see langword="null"/>, all interfaces marked with
        /// <see cref="EntityAttribute"/> are included.
        /// </param>
        /// <param name="brightstarAssemblyPath">The path to the BrightstarDB assembly to be referenced by the generated code. If this parameter is null, the path to the assembly will be loaded from the solution.</param>
        /// <returns>
        /// A <see cref="SyntaxNode"/> for each generated class, with the entity context first in the list.
        /// </returns>
        public static async Task<IImmutableList<SyntaxNode>> GenerateAsync(
            Language language,
            string solutionPath,
            string contextNamespace,
            string contextName = "EntityContext",
            Func<INamedTypeSymbol, string> entityNamespaceSelector = null,
            Func<INamedTypeSymbol, string> entityNameSelector = null,
            Func<INamedTypeSymbol, Accessibility> entityAccessibilitySelector = null,
            Func<INamedTypeSymbol, bool> interfacePredicate = null,
            string brightstarAssemblyPath = null)
        {
            var log = new StringWriter();
            var managerOptions = new AnalyzerManagerOptions { LogWriter = log };
            var manager = new AnalyzerManager(solutionPath, managerOptions);
            var workspace = new AdhocWorkspace();
            //brightstarAssemblyPath = GetBrightstarAssemblyLocation();
            foreach (var project in manager.Projects.Values)
            {
                Console.WriteLine("Loading project " + project.ProjectFile.Path);
                var results = project.Build().First();
                Console.WriteLine("Project Build " + (results.Succeeded?"Succeeded" : "FAILED"));
                if (!results.Succeeded)
                {
                    throw new Exception("Analysis build failed for project: " + results.ProjectFilePath + "\n" + log);
                }
                Console.WriteLine(string.Join("\n", results.References));
                if (brightstarAssemblyPath == null)
                {
                    brightstarAssemblyPath = results.References.FirstOrDefault(r =>
                        r.EndsWith("BrightstarDB.dll", true, CultureInfo.InvariantCulture));
                }
                project.AddToWorkspace(workspace);
            }

            if (brightstarAssemblyPath == null)
            {
                throw new Exception(
                    "Could not locate a BrightstarDB.dll reference amongst any of the solution projects");
            }

            return await GenerateAsync(
                language,
                workspace.CurrentSolution,
                contextNamespace,
                contextName,
                entityNamespaceSelector,
                entityNameSelector,
                entityAccessibilitySelector,
                interfacePredicate,
                brightstarAssemblyPath);
        }

        /// <summary>
        /// Generates code for an entity context and for each entity housed within that context.
        /// </summary>
        /// <param name="language">
        /// The language in which code should be generated.
        /// </param>
        /// <param name="solution">
        /// The solution containing the entities for whom code will be generated.
        /// </param>
        /// <param name="contextNamespace">
        /// The namespace in which to place the generated entity context.
        /// </param>
        /// <param name="contextName">
        /// The name for the generated entity context.
        /// </param>
        /// <param name="entityNamespaceSelector">
        /// A callback used to determine the namespace for each generated entity. If left as <see langword="null"/>, generated entities are placed in the same namespace
        /// as their associated interface.
        /// </param>
        /// <param name="entityNameSelector">
        /// A callback used to determine the name for each generated entity. If left as <see langword="null"/>, generated entities are named the same as their interface
        /// except with the leading "I" removed. If there is no leading "I", an "Impl" suffix is instead added to the interface's name.
        /// </param>
        /// <param name="entityAccessibilitySelector">
        /// A callback used to determine the declared accessibility for each generated entity. If left as <see langword="null"/>, generated entity classes have the same
        /// declared accessibility as the entity interface that they implement.
        /// </param>
        /// <param name="interfacePredicate">
        /// A callback used to determine which interfaces should result in generated entities. If left as <see langword="null"/>, all interfaces marked with
        /// <see cref="EntityAttribute"/> are included.
        /// </param>
        /// <param name="brightstarAssemblyPath">The path to the BrightstarDB assembly to be referenced by the generated code. If this parameter is null, the path to the assembly will be loaded from the solution.</param>
        /// <returns>
        /// A <see cref="SyntaxNode"/> for each generated class, with the entity context first in the list.
        /// </returns>
        public static async Task<IImmutableList<SyntaxNode>> GenerateAsync(
            Language language,
            Solution solution,
            string contextNamespace,
            string contextName = "EntityContext",
            Func<INamedTypeSymbol, string> entityNamespaceSelector = null,
            Func<INamedTypeSymbol, string> entityNameSelector = null,
            Func<INamedTypeSymbol, Accessibility> entityAccessibilitySelector = null,
            Func<INamedTypeSymbol, bool> interfacePredicate = null, 
            string brightstarAssemblyPath = null)
        {
            if (brightstarAssemblyPath == null)
            {
                brightstarAssemblyPath = GetBrightstarAssemblyLocation();
            }

            entityNamespaceSelector = entityNamespaceSelector ?? (x => x.ContainingNamespace.ToDisplayString());
            interfacePredicate = interfacePredicate ?? (x => x.GetAttributes().Any(y => y.AttributeClass.ToString() == Constants.EntityAttribute));
            entityNameSelector = entityNameSelector ??
                (x =>
                {
                    var name = x.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);

                    if (interfaceNameTransformationExpression.IsMatch(name))
                    {
                        return interfaceNameTransformationExpression.Replace(name, "${name}");
                    }
                    else
                    {
                        return name + "Impl";
                    }
                });
            entityAccessibilitySelector = entityAccessibilitySelector ?? DefaultEntityAccessibilitySelector;

            var compilations = await Task.WhenAll(
                solution
                    .Projects
                    .Select(async x =>
                    {
                        var compilation = await x.GetCompilationAsync();
                        return new { Project = x, Compilation = compilation };
                    }));

            var entityMetadata = compilations
                .SelectMany(x =>
                    x
                        .Compilation
                        .SyntaxTrees
                        .Select(y =>
                            new
                            {
                                Project = x.Project,
                                Compilation = x.Compilation,
                                SyntaxTree = y,
                                SemanticModel = x.Compilation.GetSemanticModel(y)
                            }))
                .SelectMany(
                    x => x
                        .SyntaxTree
                        .GetRoot()
                        .DescendantNodes()
                        .Where(y => y is InterfaceDeclarationSyntax || y is VBSyntax.InterfaceBlockSyntax)
                        .Select(y =>
                            new
                            {
                                Project = x.Project,
                                Compilation = x.Compilation,
                                SyntaxTree = x.SyntaxTree,
                                SemanticModel = x.SemanticModel,
                                InterfaceSymbol = (INamedTypeSymbol)x.SemanticModel.GetDeclaredSymbol(y)
                            }))
                .Where(x => interfacePredicate(x.InterfaceSymbol))
                .Distinct()
                .ToList();

            var interfaceSymbols = entityMetadata
                .Select(x => x.InterfaceSymbol)
                .ToImmutableList();

            var entities = entityMetadata
                .Select(x =>
                    GenerateEntity(
                        language,
                        solution,
                        x.Compilation,
                        interfaceSymbols,
                        entityNamespaceSelector,
                        entityNameSelector,
                        entityAccessibilitySelector,
                        x.InterfaceSymbol))
                .ToList();

            var context = GenerateContext(
                language,
                solution,
                contextNamespace,
                contextName,
                interfaceSymbols,
                entityNamespaceSelector,
                entityNameSelector,
                brightstarAssemblyPath);

            return new[] { context }
                .Concat(entities)
                .Select(x => Formatter.Format(x, solution.Workspace))
                .ToImmutableList();
        }

        /// <summary>
        /// A utility function providing the default BrightstarDB entity class accessibility logic
        /// </summary>
        /// <param name="interfaceSymbol">The entity interface that the class is generated from</param>
        /// <returns>The accessibility to apply to the generated entity class.</returns>
        /// <remarks>
        /// This default selector returns the declared accessibility of the interface symbol, so
        /// that the generated entity class has the same access level as the interface it is generated from.
        /// </remarks>
        public static Accessibility DefaultEntityAccessibilitySelector(INamedTypeSymbol interfaceSymbol)
        {
            return interfaceSymbol.DeclaredAccessibility;
        }

        /// <summary>
        /// A utility function providing the "internal entity classes" entity class accessibility logic
        /// </summary>
        /// <param name="interfaceSymbol">The entity interface that the class is generated from</param>
        /// <returns>The accessibility to apply to the generated entity class.</returns>
        /// <remarks>
        /// If the declared accessibility of the interface is <see cref="Accessibility.Public"/>, then 
        /// this function returns <see cref="Accessibility.Internal"/>; so that public interfaces are
        /// implemented by internal entity classes. For all other entity interface 
        /// accessibility levels, the generated class will have the same accessibility as the interface.
        /// </remarks>
        public static Accessibility InteralyEntityAccessibilitySelector(INamedTypeSymbol interfaceSymbol)
        {
            return interfaceSymbol.DeclaredAccessibility == Accessibility.Public ? Accessibility.Internal : interfaceSymbol.DeclaredAccessibility;
        }

        private static string GetBrightstarAssemblyLocation()
        {
            var codeGenAssemblyLocation = Assembly.GetExecutingAssembly().Location;
            var bsLocation = Path.Combine(Path.GetDirectoryName(codeGenAssemblyLocation), "brightstar.dll");
            return bsLocation;
        }

        private static string GetBrightstarAssemblyLocation(Solution solution)
        {
            var brightstarRef = solution.Projects.SelectMany(x => x.MetadataReferences)
                .FirstOrDefault(
                    x =>
                        x.Properties.Kind == MetadataImageKind.Assembly &&
                        x.Display.EndsWith("BrightstarDB.dll", StringComparison.InvariantCultureIgnoreCase));
            return brightstarRef?.Display;
        }

        private static SyntaxNode GenerateContext(
            Language language,
            Solution solution,
            string @namespace,
            string name,
            IImmutableList<INamedTypeSymbol> interfaceSymbols,
            Func<INamedTypeSymbol, string> entityNamespaceSelector,
            Func<INamedTypeSymbol, string> entityNameSelector,
            string brightstarAssemblyPath)
        {
            Compilation compilation;
            
            var references = new[]
            {
                MetadataReference.CreateFromFile(typeof(object).Assembly.Location),
                MetadataReference.CreateFromFile(brightstarAssemblyPath)
            };

            // we create our own compilation with which to generate the entity context
            switch (language)
            {
                case Language.CSharp:
                    compilation = CSharpCompilation.Create("Ignore", references: references);
                    break;
                case Language.VisualBasic:
                    compilation = VB.VisualBasicCompilation.Create("Ignore", references: references);
                    break;
                default:
                    throw new NotSupportedException();
            }

            var syntaxGenerator = SyntaxGenerator.GetGenerator(solution.Workspace, language.ToSyntaxGeneratorLanguageName());
            var generator = new EntityContextGenerator(
                language,
                syntaxGenerator,
                solution,
                compilation,
                @namespace,
                name,
                interfaceSymbols,
                entityNamespaceSelector,
                entityNameSelector);

            var context = generator
                .Generate();

            context = syntaxGenerator.WithLeadingComments(context, headerComment, language);

            return context
                .NormalizeWhitespace();
        }

        private static SyntaxNode GenerateEntity(
            Language language,
            Solution solution,
            Compilation compilation,
            IImmutableList<INamedTypeSymbol> interfaceSymbols,
            Func<INamedTypeSymbol, string> entityNamespaceSelector,
            Func<INamedTypeSymbol, string> entityNameSelector,
            Func<INamedTypeSymbol, Accessibility> entityAccessibilitySelector,
            INamedTypeSymbol interfaceSymbol)
        {
            var syntaxGenerator = SyntaxGenerator.GetGenerator(solution.Workspace, language.ToSyntaxGeneratorLanguageName());
            var generator = new EntityGenerator(
                language,
                syntaxGenerator,
                solution,
                compilation,
                interfaceSymbols,
                entityNamespaceSelector,
                entityNameSelector,
                entityAccessibilitySelector,
                interfaceSymbol);

            return generator
                .Generate()
                .NormalizeWhitespace();
        }

        private abstract class GeneratorBase
        {
            protected readonly SyntaxGenerator syntaxGenerator;
            protected readonly Solution solution;
            protected readonly Compilation compilation;
            protected readonly Language language;
            protected readonly string @namespace;
            protected readonly IImmutableList<INamedTypeSymbol> interfaceSymbols;
            protected readonly Func<INamedTypeSymbol, string> entityNamespaceSelector;
            protected readonly Func<INamedTypeSymbol, string> entityNameSelector;

            protected GeneratorBase(
                Language language,
                SyntaxGenerator syntaxGenerator,
                Solution solution,
                Compilation compilation,
                string @namespace,
                IImmutableList<INamedTypeSymbol> interfaceSymbols,
                Func<INamedTypeSymbol, string> entityNamespaceSelector,
                Func<INamedTypeSymbol, string> entityNameSelector)
            {
                this.language = language;
                this.syntaxGenerator = syntaxGenerator;
                this.solution = solution;
                this.compilation = compilation;
                this.@namespace = @namespace;
                this.interfaceSymbols = interfaceSymbols;
                this.entityNamespaceSelector = entityNamespaceSelector;
                this.entityNameSelector = entityNameSelector;
            }

            protected SymbolDisplayFormat ErrorMessageDisplayFormat
            {
                get { return language == Language.CSharp ? SymbolDisplayFormat.CSharpErrorMessageFormat : SymbolDisplayFormat.VisualBasicErrorMessageFormat; }
            }

            public abstract SyntaxNode Generate();

            protected SyntaxNode GetNamespaceDeclaration()
            {
                return syntaxGenerator.NamespaceDeclaration(@namespace);
            }

            protected IEnumerable<SyntaxNode> GetClassAttributes()
            {
                // GENERATED CODE:
                //
                //     [System.CodeDom.Compiler.GeneratedCode("BrightstarDB.CodeGeneration", "[version]")]
                //     [System.Runtime.CompilerServices.CompilerGenerated)]
                yield return syntaxGenerator
                    .Attribute(
                        "System.CodeDom.Compiler.GeneratedCode",
                        syntaxGenerator.LiteralExpression("BrightstarDB.CodeGeneration"),
                        syntaxGenerator.LiteralExpression(Assembly.GetAssembly(typeof(Generator)).GetName().Version.ToString()));
                yield return syntaxGenerator
                    .Attribute(
                        "System.Runtime.CompilerServices.CompilerGenerated");
            }

            protected static IEnumerable<ISymbol> GetMembersRecursive(INamedTypeSymbol interfaceSymbol)
            {
                foreach (var member in interfaceSymbol.GetMembers())
                {
                    yield return member;
                }

                foreach (var implementedInterface in interfaceSymbol.Interfaces)
                {
                    foreach (var member in GetMembersRecursive(implementedInterface))
                    {
                        yield return member;
                    }
                }
            }

            protected string GetEntityClassNameForInterfaceSymbol(INamedTypeSymbol interfaceSymbol)
            {
                return entityNameSelector(interfaceSymbol);
            }

            protected SyntaxNode GetEntityClassForInterfaceSymbol(INamedTypeSymbol interfaceSymbol)
            {
                return syntaxGenerator
                    .QualifiedName(
                        syntaxGenerator.IdentifierName(entityNamespaceSelector(interfaceSymbol)),
                        syntaxGenerator.IdentifierName(entityNameSelector(interfaceSymbol)));
            }
        }

        private sealed class EntityContextGenerator : GeneratorBase
        {
            private readonly string name;

            public EntityContextGenerator(
                    Language language,
                    SyntaxGenerator syntaxGenerator,
                    Solution solution,
                    Compilation compilation,
                    string @namespace,
                    string name,
                    IImmutableList<INamedTypeSymbol> interfaceSymbols,
                    Func<INamedTypeSymbol, string> entityNamespaceSelector,
                    Func<INamedTypeSymbol, string> entityNameSelector)
                : base(language, syntaxGenerator, solution, compilation, @namespace, interfaceSymbols, entityNamespaceSelector, entityNameSelector)
            {
                this.name = name;
            }

            public override SyntaxNode Generate()
            {
                var namespaceDeclaration = GetNamespaceDeclaration();
                var classDeclaration = GetClassDeclaration();

                classDeclaration = syntaxGenerator
                    .AddAttributes(classDeclaration, GetClassAttributes());
                classDeclaration = syntaxGenerator
                    .AddMembers(classDeclaration, GetMembers());
                namespaceDeclaration = syntaxGenerator
                    .AddMembers(namespaceDeclaration, classDeclaration);

                return namespaceDeclaration;
            }

            private SyntaxNode GetClassDeclaration()
            {
                var baseType = compilation
                    .GetTypeByMetadataName(Constants.BrightstarEntityContext);
                
                if (baseType == null)
                {
                    throw new InvalidOperationException(
                        string.Format(
                            CultureInfo.InvariantCulture,
                            "Failed to find type in BrightstarDB assembly. Are you sure assembly {0} has a reference to BrightstarDB?",
                            compilation.AssemblyName));
                }

                return syntaxGenerator
                    .ClassDeclaration(
                        name,
                        accessibility: Accessibility.Public,
                        modifiers: DeclarationModifiers.Partial,
                        baseType: syntaxGenerator.TypeExpression(baseType));
            }

            private IEnumerable<SyntaxNode> GetMembers()
            {
                return
                    GetConstructors()
                    .Concat(
                        new SyntaxNode[]
                        {
                            GetInitializeContextMethod(),
                            GetEntitySetMethod()
                        })
                    .Concat(GetEntityProperties());
            }

            private IEnumerable<SyntaxNode> GetConstructors()
            {
                var reflectionMappingProviderType = compilation.GetTypeByMetadataName(Constants.ReflectionMappingProvider);
                var entityMappingStoreType = compilation.GetTypeByMetadataName(Constants.EntityMappingStore);
                var iDataObjectStoreType = compilation.GetTypeByMetadataName(Constants.IDataObjectStore);
                var iEnumerableTType = compilation.GetTypeByMetadataName(typeof(IEnumerable<>).FullName);
                var nullableTType = compilation.GetTypeByMetadataName(typeof(Nullable<>).FullName);
                var stringType = compilation.GetTypeByMetadataName(typeof(string).FullName);
                var boolType = compilation.GetTypeByMetadataName(typeof(bool).FullName);

                // GENERATED CODE:
                //
                //     static [Name]
                //     {
                //         var provider = new ReflectionMappingProvider();
                //
                //         [foreach entity type]
                //             provider.AddMappingsForType(EntityMappingStore.Instance, typeof([EntityContractType]));
                //             EntityMappingStore.Instance.SetImplMapping<[EntityContractType], [EntityType]>();
                //     }
                yield return syntaxGenerator
                    .ConstructorDeclaration(
                        modifiers: DeclarationModifiers.Static,
                        statements:
                            new[]
                            {
                                syntaxGenerator.LocalDeclarationStatement(
                                    "provider",
                                    syntaxGenerator.ObjectCreationExpression(reflectionMappingProviderType))
                            }
                            .Concat(
                                interfaceSymbols
                                    .SelectMany(x =>
                                        new[]
                                        {
                                            syntaxGenerator
                                                .InvocationExpression(
                                                    syntaxGenerator.MemberAccessExpression(
                                                        syntaxGenerator.IdentifierName("provider"),
                                                        "AddMappingsForType"),
                                                    syntaxGenerator.MemberAccessExpression(
                                                        syntaxGenerator.TypeExpression(entityMappingStoreType),
                                                        "Instance"),
                                                    syntaxGenerator.TypeOf(syntaxGenerator.TypeExpression(x), language)),
                                            syntaxGenerator
                                                .InvocationExpression(
                                                    syntaxGenerator.MemberAccessExpression(
                                                        syntaxGenerator.MemberAccessExpression(
                                                            syntaxGenerator.TypeExpression(entityMappingStoreType),
                                                            "Instance"),
                                                        syntaxGenerator.GenericName(
                                                            "SetImplMapping",
                                                            typeArguments: new[]
                                                            {
                                                                syntaxGenerator.TypeExpression(x),
                                                                GetEntityClassForInterfaceSymbol(x)
                                                            })))
                                        })));

                

                var initializeContextInvocation = syntaxGenerator
                    .InvocationExpression(
                        syntaxGenerator.MemberAccessExpression(
                            syntaxGenerator.ThisExpression(),
                            "InitializeContext"));

                // GENERATED CODE:
                //
                //     public [Name]()
                //         : base()
                //     {
                //         this.InitializeContext();
                //     }
                yield return syntaxGenerator
                    .ConstructorDeclaration(
                        accessibility: Accessibility.Public,
                        statements: new[]
                        {
                            initializeContextInvocation
                        });

                // GENERATED CODE:
                //
                //     public [Name](IDataObjectStore dataObjectStore)
                //         : base(dataObjectStore)
                //     {
                //         this.InitializeContext();
                //     }
                yield return syntaxGenerator
                    .ConstructorDeclaration(
                        accessibility: Accessibility.Public,
                        parameters: new[]
                        {
                            syntaxGenerator.ParameterDeclaration("dataObjectStore", syntaxGenerator.TypeExpression(iDataObjectStoreType))
                        },
                        baseConstructorArguments: new[]
                        {
                            syntaxGenerator.IdentifierName("dataObjectStore")
                        },
                        statements: new[]
                        {
                            initializeContextInvocation
                        });

                // GENERATED CODE:
                //
                //     public [Name](string updateGraphUri, IEnumerable<string> datasetGraphUris, string versionGraphUri)
                //         : base(updateGraphUri, datasetGraphUris, versionGraphUri)
                //     {
                //         this.InitializeContext();
                //     }
                yield return syntaxGenerator
                    .ConstructorDeclaration(
                        accessibility: Accessibility.Public,
                        parameters: new[]
                        {
                            syntaxGenerator.ParameterDeclaration("updateGraphUri", syntaxGenerator.TypeExpression(SpecialType.System_String)),
                            syntaxGenerator.ParameterDeclaration(
                                "datasetGraphUris",
                                syntaxGenerator.TypeExpression(iEnumerableTType.Construct(stringType))),
                            syntaxGenerator.ParameterDeclaration("versionGraphUri", syntaxGenerator.TypeExpression(SpecialType.System_String))
                        },
                        baseConstructorArguments: new[]
                        {
                            syntaxGenerator.IdentifierName("updateGraphUri"),
                            syntaxGenerator.IdentifierName("datasetGraphUris"),
                            syntaxGenerator.IdentifierName("versionGraphUri")
                        },
                        statements: new[]
                        {
                            initializeContextInvocation
                        });

                // GENERATED CODE:
                //
                //     public [Name](string connectionString, bool? enableOptimisticLocking = null, string updateGraphUri = null, IEnumerable< string > datasetGraphUris = null, string versionGraphUri = null)
                //         : base(connectionString, enableOptimisticLocking, updateGraphUri, datasetGraphUris, versionGraphUri)
                //     {
                //         this.InitializeContext();
                //     }
                yield return syntaxGenerator
                    .ConstructorDeclaration(
                        accessibility: Accessibility.Public,
                        parameters: new[]
                        {
                            syntaxGenerator.ParameterDeclaration(
                                "connectionString",
                                syntaxGenerator.TypeExpression(SpecialType.System_String)),
                            syntaxGenerator.ParameterDeclaration(
                                "enableOptimisticLocking",
                                syntaxGenerator.TypeExpression(nullableTType.Construct(boolType)),
                                initializer: syntaxGenerator.NullLiteralExpression()),
                            syntaxGenerator.ParameterDeclaration(
                                "updateGraphUri",
                                syntaxGenerator.TypeExpression(SpecialType.System_String),
                                initializer: syntaxGenerator.NullLiteralExpression()),
                            syntaxGenerator.ParameterDeclaration(
                                "datasetGraphUris",
                                syntaxGenerator.TypeExpression(iEnumerableTType.Construct(stringType)),
                                initializer: syntaxGenerator.NullLiteralExpression()),
                            syntaxGenerator.ParameterDeclaration(
                                "versionGraphUri",
                                syntaxGenerator.TypeExpression(SpecialType.System_String),
                                initializer: syntaxGenerator.NullLiteralExpression())
                        },
                        baseConstructorArguments: new[]
                        {
                            syntaxGenerator.IdentifierName("connectionString"),
                            syntaxGenerator.IdentifierName("enableOptimisticLocking"),
                            syntaxGenerator.IdentifierName("updateGraphUri"),
                            syntaxGenerator.IdentifierName("datasetGraphUris"),
                            syntaxGenerator.IdentifierName("versionGraphUri")
                        },
                        statements: new[]
                        {
                            initializeContextInvocation
                        });
            }

            private SyntaxNode GetInitializeContextMethod()
            {
                var brightstarEntitySetType = compilation.GetTypeByMetadataName(Constants.BrightstarEntitySet);

                // GENERATED CODE:
                //
                //     private void InitializeContext()
                //     {
                //         [foreach entity type]
                //             this.[EntitySetFieldName] = new BrightstarEntitySet<[EntityContractType]>(this);
                //     }
                return syntaxGenerator.MethodDeclaration(
                    "InitializeContext",
                    accessibility: Accessibility.Private,
                    statements: interfaceSymbols
                        .Select(x => syntaxGenerator
                            .AssignmentStatement(
                                syntaxGenerator.MemberAccessExpression(
                                    syntaxGenerator.ThisExpression(),
                                    "_" + GetEntityClassNameForInterfaceSymbol(x).Pluralize()),
                                syntaxGenerator.ObjectCreationExpression(
                                    brightstarEntitySetType.Construct(x),
                                    syntaxGenerator.ThisExpression()))));
            }

            private IEnumerable<SyntaxNode> GetEntityProperties()
            {
                var iEntitySetType = compilation.GetTypeByMetadataName(Constants.IEntitySet);
                
                // GENERATED CODE:
                //
                //     [foreach entity type]
                //         private IEntitySet<[EntityContractType]> _[EntitySetPropertyName];
                //         public IEntitySet<[EntityContractType]> [EntitySetPropertyName]
                //         {
                //             get { return this._[EntitySetPropertyName]; }
                //         }
                return interfaceSymbols
                    .SelectMany(x =>
                    {
                        var propertyName = GetEntityClassNameForInterfaceSymbol(x).Pluralize();
                        var fieldName = "_" + propertyName;
                        var propertyType = iEntitySetType.Construct(x);

                        return new[]
                        {
                            syntaxGenerator.FieldDeclaration(
                                fieldName,
                                syntaxGenerator.TypeExpression(propertyType),
                                accessibility: Accessibility.Private),
                            syntaxGenerator.PropertyDeclaration(
                                propertyName,
                                syntaxGenerator.TypeExpression(propertyType),
                                accessibility: x.DeclaredAccessibility,
                                modifiers: DeclarationModifiers.ReadOnly,
                                getAccessorStatements: new[]
                                {
                                    syntaxGenerator.ReturnStatement(
                                        syntaxGenerator.MemberAccessExpression(
                                            syntaxGenerator.ThisExpression(),
                                            fieldName))
                                })
                        };
                    });
            }

            private SyntaxNode GetEntitySetMethod()
            {
                var typeType = compilation.GetTypeByMetadataName(typeof(Type).FullName);
                var iEntitySetType = compilation.GetTypeByMetadataName(Constants.IEntitySet);
                var invalidOperationExceptionType = compilation.GetTypeByMetadataName(typeof(InvalidOperationException).FullName);

                // GENERATED CODE:
                //
                //     public IEntitySet<T> EntitySet<T>() where T : class
                //     {
                //         var type = typeof(T);
                //         [foreach entity type]
                //             if (type.Equals(typeof([EntityContractType])))
                //             {
                //                 return (IEntitySet<T>)this.[EntitySetPropertyName];
                //             }
                //         throw new InvalidOperationException(typeo(T).FullName + " is not a recognized entity interface type.");
                //     }
                return syntaxGenerator.WithTypeConstraint(
                    syntaxGenerator.MethodDeclaration(
                        "EntitySet",
                        accessibility: Accessibility.Public,
                        typeParameters: new[] { "T" },
                        returnType: syntaxGenerator.TypeExpression(iEntitySetType),
                        statements:
                            new[]
                            {
                                syntaxGenerator.LocalDeclarationStatement(
                                    typeType,
                                    "type",
                                    syntaxGenerator.TypeOf(syntaxGenerator.IdentifierName("T"), language))
                            }
                            .Concat(
                                interfaceSymbols
                                    .Select(x => syntaxGenerator.IfStatement(
                                        syntaxGenerator.InvocationExpression(
                                            syntaxGenerator.MemberAccessExpression(
                                                syntaxGenerator.IdentifierName("type"),
                                                "Equals"),
                                            syntaxGenerator.TypeOf(syntaxGenerator.TypeExpression(x), language)),
                                        new[]
                                        {
                                            syntaxGenerator.ReturnStatement(
                                                syntaxGenerator.CastExpression(
                                                    iEntitySetType,
                                                    syntaxGenerator.MemberAccessExpression(
                                                        syntaxGenerator.ThisExpression(),
                                                        syntaxGenerator.IdentifierName(
                                                            GetEntityClassNameForInterfaceSymbol(x).Pluralize()))))
                                        })))
                            .Concat(new[]
                            {
                                syntaxGenerator.ThrowStatement(
                                    syntaxGenerator.ObjectCreationExpression(
                                        invalidOperationExceptionType,
                                        syntaxGenerator.AddExpression(
                                            syntaxGenerator.MemberAccessExpression(
                                                syntaxGenerator.TypeOf(syntaxGenerator.IdentifierName("T"), language),
                                                "FullName"),
                                            syntaxGenerator.LiteralExpression(" is not a recognized entity interface type."))))
                            })),
                    "T",
                    SpecialTypeConstraintKind.ReferenceType);
            }
        }

        private sealed class EntityGenerator : GeneratorBase
        {
            private readonly INamedTypeSymbol interfaceSymbol;
            private readonly string name;
            private readonly Accessibility accessibility;
            private readonly ISet<ITypeSymbol> basicTypes;

            public EntityGenerator(
                    Language language,
                    SyntaxGenerator syntaxGenerator,
                    Solution solution,
                    Compilation compilation,
                    IImmutableList<INamedTypeSymbol> interfaceSymbols,
                    Func<INamedTypeSymbol, string> entityNamespaceSelector,
                    Func<INamedTypeSymbol, string> entityNameSelector,
                    Func<INamedTypeSymbol, Accessibility> entityAccessibilitySelector,
                    INamedTypeSymbol interfaceSymbol)
                : base(language, syntaxGenerator, solution, compilation, entityNamespaceSelector(interfaceSymbol), interfaceSymbols, entityNamespaceSelector, entityNameSelector)
            {
                this.interfaceSymbol = interfaceSymbol;
                this.name = entityNameSelector(interfaceSymbol);
                this.accessibility = entityAccessibilitySelector(interfaceSymbol);

                var basicTypes = new[]
                {
                    typeof(bool).FullName,
                    typeof(short).FullName,
                    typeof(int).FullName,
                    typeof(long).FullName,
                    typeof(ushort).FullName,
                    typeof(uint).FullName,
                    typeof(ulong).FullName,
                    typeof(string).FullName,
                    typeof(decimal).FullName,
                    typeof(double).FullName,
                    typeof(float).FullName,
                    typeof(byte).FullName,
                    typeof(char).FullName,
                    typeof(sbyte).FullName,
                    typeof(DateTime).FullName,
                    typeof(Guid).FullName,
                    typeof(Uri).FullName,
                    Constants.PlainLiteral,
                };

                this.basicTypes = new HashSet<ITypeSymbol>(basicTypes.Select(x => compilation.GetTypeByMetadataName(x)));
            }

            public override SyntaxNode Generate()
            {
                var namespaceDeclaration = GetNamespaceDeclaration();
                var classDeclaration = GetClassDeclaration();

                classDeclaration = syntaxGenerator
                    .AddAttributes(classDeclaration, GetClassAttributes());
                classDeclaration = syntaxGenerator
                    .AddMembers(classDeclaration, GetMembers());
                namespaceDeclaration = syntaxGenerator
                    .AddMembers(namespaceDeclaration, classDeclaration);

                return namespaceDeclaration;
            }

            private SyntaxNode GetClassDeclaration()
            {
                var baseType = compilation
                    .GetTypeByMetadataName(Constants.BrightstarEntityObject);

                if (baseType == null)
                {
                    throw new InvalidOperationException(
                        string.Format(
                            CultureInfo.InvariantCulture,
                            "Failed to find type in BrightstarDB assembly. Are you sure assembly {0} has a reference to BrightstarDB?",
                            compilation.AssemblyName));
                }

                return syntaxGenerator
                    .ClassDeclaration(
                        this.name,
                        accessibility: this.accessibility,
                        modifiers: DeclarationModifiers.Partial,
                        baseType: syntaxGenerator.TypeExpression(baseType),
                        interfaceTypes: new[] { syntaxGenerator.TypeExpression(this.interfaceSymbol) });
            }

            private IEnumerable<SyntaxNode> GetMembers()
            {
                var idProperty = GetIdProperty();

                return
                    GetConstructors()
                    .Concat(idProperty == null ? Enumerable.Empty<SyntaxNode>() : new[] { idProperty })
                    .Concat(GetNonIdentifierProperties(FindIdentityProperty()));
            }

            private IEnumerable<SyntaxNode> GetConstructors()
            {
                var brightstarEntityContextType = compilation.GetTypeByMetadataName(Constants.BrightstarEntityContext);
                var iDataObjectType = compilation.GetTypeByMetadataName(Constants.IDataObject);

                // GENERATED CODE:
                //
                //     public [Name]()
                //         : base()
                //     {
                //     }
                yield return syntaxGenerator
                    .ConstructorDeclaration(
                        accessibility: Accessibility.Public);

                // GENERATED CODE:
                //
                //     public [Name](BrightstarEntityContext context)
                //         : base(context, typeof([EntityType]))
                //     {
                //     }
                yield return syntaxGenerator
                    .ConstructorDeclaration(
                        accessibility: Accessibility.Public,
                        parameters: new[]
                        {
                            syntaxGenerator.ParameterDeclaration("context", syntaxGenerator.TypeExpression(brightstarEntityContextType))
                        },
                        baseConstructorArguments: new[]
                        {
                            syntaxGenerator.IdentifierName("context"),
                            syntaxGenerator.TypeOf(syntaxGenerator.IdentifierName(this.name), language)
                        });

                // GENERATED CODE:
                //
                //     public [Name](BrightstarEntityContext context, IDataObject dataObject)
                //         : base(context, dataObject)
                //     {
                //     }
                yield return syntaxGenerator
                    .ConstructorDeclaration(
                        accessibility: Accessibility.Public,
                        parameters: new[]
                        {
                            syntaxGenerator.ParameterDeclaration("context", syntaxGenerator.TypeExpression(brightstarEntityContextType)),
                            syntaxGenerator.ParameterDeclaration("dataObject", syntaxGenerator.TypeExpression(iDataObjectType))
                        },
                        baseConstructorArguments: new[]
                        {
                            syntaxGenerator.IdentifierName("context"),
                            syntaxGenerator.IdentifierName("dataObject")
                        });
            }

            private SyntaxNode GetIdProperty()
            {
                var identityProperty = FindIdentityProperty();

                if (identityProperty == null)
                {
                    return null;
                }

                ValidateIdentityProperty(identityProperty);

                // GENERATED CODE:
                //
                //     public string [IdentifierPropertyName]
                //     {
                //         get { return base.GetKey(); }
                //         set { base.SetKey(value); }
                //     }
                var propertyDeclaration = syntaxGenerator.PropertyDeclaration(
                    identityProperty.Name,
                    syntaxGenerator.TypeExpression(identityProperty.Type),
                    accessibility: Accessibility.Public,
                    getAccessorStatements: new[]
                    {
                        syntaxGenerator.ReturnStatement(
                            syntaxGenerator.InvocationExpression(
                                syntaxGenerator.MemberAccessExpression(
                                    syntaxGenerator.BaseExpression(),
                                    "GetKey")))
                    },
                    setAccessorStatements: new[]
                    {
                        syntaxGenerator.InvocationExpression(
                            syntaxGenerator.MemberAccessExpression(
                                syntaxGenerator.BaseExpression(),
                                "SetKey"),
                            syntaxGenerator.IdentifierName("value"))
                    });

                propertyDeclaration = syntaxGenerator.AddAttributes(
                    propertyDeclaration,
                    identityProperty
                        .GetAttributes()
                        .Where(x => !IsEntityFrameworkAttribute(x))
                        .Select(x => syntaxGenerator.Attribute(x)));

                propertyDeclaration = syntaxGenerator.AsPublicInterfaceImplementation(propertyDeclaration, syntaxGenerator.TypeExpression(identityProperty.ContainingType));

                return propertyDeclaration;
            }

            private IEnumerable<SyntaxNode> GetNonIdentifierProperties(IPropertySymbol identifierProperty)
            {
                var properties = GetMembersRecursive(this.interfaceSymbol)
                    .OfType<IPropertySymbol>()
                    .Where(x => x != identifierProperty)
                    .Where(x => !IsIgnoredProperty(x))
                    .ToList();

                foreach (var property in properties)
                {
                    bool isCollection;
                    ITypeSymbol scalarType;

                    ValidateProperty(property, out isCollection, out scalarType);
                    SyntaxNode propertyDeclaration = null;

                    if (isCollection)
                    {
                        // GENERATED CODE:
                        //
                        //     public ICollection<[RelatedEntityType]> [PropertyName]
                        //     {
                        //         get { return base.GetRelatedObjects<[RelatedEntityType]>("[PropertyName]"); }
                        //         set
                        //         {
                        //             if (value == null) throw new ArgumentNullException("value");
                        //             base.SetRelatedObjects<[RelatedEntityType]>("[PropertyName]", value);
                        //         }
                        //     }
                        propertyDeclaration = syntaxGenerator.PropertyDeclaration(
                            property.Name,
                            syntaxGenerator.TypeExpression(property.Type),
                            accessibility: Accessibility.Public,
                            getAccessorStatements: new[]
                            {
                                syntaxGenerator.ReturnStatement(
                                    syntaxGenerator.InvocationExpression(
                                        syntaxGenerator.WithTypeArguments(
                                            syntaxGenerator.MemberAccessExpression(
                                                syntaxGenerator.BaseExpression(),
                                                "GetRelatedObjects"),
                                            syntaxGenerator.TypeExpression(scalarType)),
                                        syntaxGenerator.LiteralExpression(property.Name)))
                            },
                            setAccessorStatements: new[]
                            {
                                syntaxGenerator.IfStatement(
                                    syntaxGenerator.ValueEqualsExpression(
                                        syntaxGenerator.IdentifierName("value"),
                                        syntaxGenerator.NullLiteralExpression()),
                                    new[]
                                    {
                                        syntaxGenerator.ThrowStatement(
                                            syntaxGenerator.ObjectCreationExpression(
                                                compilation.GetTypeByMetadataName(typeof(ArgumentNullException).FullName),
                                                syntaxGenerator.LiteralExpression("value")))
                                    }),
                                    syntaxGenerator.InvocationExpression(
                                        syntaxGenerator.WithTypeArguments(
                                            syntaxGenerator.MemberAccessExpression(
                                                syntaxGenerator.BaseExpression(),
                                                "SetRelatedObjects"),
                                            syntaxGenerator.TypeExpression(scalarType)),
                                        syntaxGenerator.LiteralExpression(property.Name),
                                        syntaxGenerator.IdentifierName("value"))
                            });
                    }
                    else
                    {
                        var isEntity = this.interfaceSymbols.Any(x => x == scalarType);

                        if (isEntity)
                        {
                            // GENERATED CODE:
                            //
                            //     public [RelatedEntityType] [PropertyName]
                            propertyDeclaration = syntaxGenerator.PropertyDeclaration(
                                property.Name,
                                syntaxGenerator.TypeExpression(property.Type),
                                accessibility: Accessibility.Public,
                                getAccessorStatements: new[]
                                {
                                    syntaxGenerator.ReturnStatement(
                                        syntaxGenerator.InvocationExpression(
                                            syntaxGenerator.WithTypeArguments(
                                                syntaxGenerator.MemberAccessExpression(
                                                    syntaxGenerator.BaseExpression(),
                                                    "GetRelatedObject"),
                                                syntaxGenerator.TypeExpression(scalarType)),
                                            syntaxGenerator.LiteralExpression(property.Name)))
                                },
                                setAccessorStatements: new[]
                                {
                                    syntaxGenerator.InvocationExpression(
                                        syntaxGenerator.WithTypeArguments(
                                            syntaxGenerator.MemberAccessExpression(
                                                syntaxGenerator.BaseExpression(),
                                                "SetRelatedObject"),
                                            syntaxGenerator.TypeExpression(scalarType)),
                                        syntaxGenerator.LiteralExpression(property.Name),
                                        syntaxGenerator.IdentifierName("value"))
                                });

                            if (property.GetMethod != null)
                            {
                                // GENERATED CODE:
                                //
                                //     get { return base.GetRelatedObject<[RelatedEntityType]>("[PropertyName]"); }
                                propertyDeclaration = syntaxGenerator.WithGetAccessorStatements(
                                    propertyDeclaration,
                                    new[]
                                    {
                                        syntaxGenerator.ReturnStatement(
                                            syntaxGenerator.InvocationExpression(
                                                syntaxGenerator.WithTypeArguments(
                                                    syntaxGenerator.MemberAccessExpression(
                                                        syntaxGenerator.BaseExpression(),
                                                        "GetRelatedObject"),
                                                    syntaxGenerator.TypeExpression(scalarType)),
                                                syntaxGenerator.LiteralExpression(property.Name)))
                                    });
                            }

                            if (property.SetMethod != null)
                            {
                                // GENERATED CODE:
                                //
                                //     set { base.SetRelatedObject<[RelatedEntityType]>("[PropertyName]", value); }
                                propertyDeclaration = syntaxGenerator.WithSetAccessorStatements(
                                    propertyDeclaration,
                                    new[]
                                    {
                                        syntaxGenerator.InvocationExpression(
                                            syntaxGenerator.WithTypeArguments(
                                                syntaxGenerator.MemberAccessExpression(
                                                    syntaxGenerator.BaseExpression(),
                                                    "SetRelatedObject"),
                                                syntaxGenerator.TypeExpression(scalarType)),
                                            syntaxGenerator.LiteralExpression(property.Name),
                                            syntaxGenerator.IdentifierName("value"))
                                    });
                            }
                        }
                        else
                        {
                            // GENERATED CODE:
                            //
                            //     public [PropertyType] [PropertyName]
                            //     {
                            //         get { return base.GetRelatedProperty<[PropertyType]>("[PropertyName]"); }
                            //         set { base.SetRelatedProperty("[PropertyName]", value); }
                            //     }
                            propertyDeclaration = syntaxGenerator.PropertyDeclaration(
                                property.Name,
                                syntaxGenerator.TypeExpression(property.Type),
                                accessibility: Accessibility.Public,
                                getAccessorStatements: new[]
                                {
                                    syntaxGenerator.ReturnStatement(
                                        syntaxGenerator.InvocationExpression(
                                            syntaxGenerator.WithTypeArguments(
                                                syntaxGenerator.MemberAccessExpression(
                                                    syntaxGenerator.BaseExpression(),
                                                    "GetRelatedProperty"),
                                                syntaxGenerator.TypeExpression(scalarType)),
                                            syntaxGenerator.LiteralExpression(property.Name)))
                                },
                                setAccessorStatements: new[]
                                {
                                    syntaxGenerator.InvocationExpression(
                                        syntaxGenerator.MemberAccessExpression(
                                            syntaxGenerator.BaseExpression(),
                                            "SetRelatedProperty"),
                                        syntaxGenerator.LiteralExpression(property.Name),
                                        syntaxGenerator.IdentifierName("value"))
                                });
                        }
                    }

                    propertyDeclaration = syntaxGenerator.AsPublicInterfaceImplementation(propertyDeclaration, syntaxGenerator.TypeExpression(property.ContainingType));

                    propertyDeclaration = syntaxGenerator.AddAttributes(
                        propertyDeclaration,
                        property
                            .GetAttributes()
                            .Where(x => !IsEntityFrameworkAttribute(x))
                            .Select(x => syntaxGenerator.Attribute(x)));

                    yield return propertyDeclaration;
                }
            }

            private static bool IsEntityFrameworkAttribute(AttributeData attribute)
            {
                return attribute.AttributeClass.ContainingNamespace.ToDisplayString() == "BrightstarDB.EntityFramework";
            }

            private IPropertySymbol FindIdentityProperty()
            {
                var identifierAttributeType = compilation.GetTypeByMetadataName(Constants.IdentifierAttribute);
                var potentialIdentifierProperties =
                    from property in GetMembersRecursive(this.interfaceSymbol).OfType<IPropertySymbol>()
                    let isDefinedInOriginalInterface = property.ContainingSymbol == this.interfaceSymbol
                    let hasIdentifierAttribute = property.GetAttributes().Any(y => y.AttributeClass == identifierAttributeType)
                    let isClassWithIdSuffix = property.Name == this.name + "Id" || property.Name == this.name + "ID"
                    let isId = property.Name == "Id" || property.Name == "ID"
                    let rank =
                        (hasIdentifierAttribute
                            ? 5
                            : (isClassWithIdSuffix
                                ? 4
                                : (isId
                                    ? 3
                                    : 0)))
                    where rank > 0
                    let scaledRank = rank * (isDefinedInOriginalInterface ? 2 : 1)
                    orderby scaledRank descending
                    select property;

                return potentialIdentifierProperties
                    .FirstOrDefault();
            }

            private void ValidateIdentityProperty(IPropertySymbol identityProperty)
            {
                var stringType = compilation.GetTypeByMetadataName(typeof(string).FullName);
                var identifierAttributeType = compilation.GetTypeByMetadataName(Constants.IdentifierAttribute);

                if (identityProperty.Type != stringType)
                {
                    throw new InvalidOperationException(
                        string.Format(
                            CultureInfo.InvariantCulture,
                            "The property '{0}' must be of type {1} to be used as the identity property for an entity. If this property is intended to be the identity property for the entity please change its type to {1}. If it is not intended to be the identity property, either rename this property or create an identity property and decorate it with the [{2}] attribute.",
                            identityProperty.ToDisplayString(this.ErrorMessageDisplayFormat),
                            stringType.ToDisplayString(this.ErrorMessageDisplayFormat),
                            identifierAttributeType.ToDisplayString(this.ErrorMessageDisplayFormat)));
                }

                if (identityProperty.SetMethod != null)
                {
                    throw new InvalidOperationException(
                        string.Format(
                            CultureInfo.InvariantCulture,
                            "The property '{0}' must not have a setter to be used as the identity property for an entity. If this property is intended to be the identity property for the entity please remove the setter. If it is not intended to be the identity property, either rename this property or create an identity propertyn and decorate it with the [{1}] attribute.",
                            identityProperty.ToDisplayString(this.ErrorMessageDisplayFormat),
                            identifierAttributeType.ToDisplayString(this.ErrorMessageDisplayFormat)));
                }
            }

            private bool IsIgnoredProperty(IPropertySymbol property)
            {
                var ignoreAttributeType = compilation.GetTypeByMetadataName(Constants.IgnoreAttribute);
                return property
                    .GetAttributes()
                    .Any(x => x.AttributeClass == ignoreAttributeType);
            }

            private void ValidateProperty(IPropertySymbol property, out bool isCollection, out ITypeSymbol scalarType)
            {
                if (!IsSupportedPropertyType(property.Type, out isCollection, out scalarType))
                {
                    throw new InvalidOperationException(
                        string.Format(
                            CultureInfo.InvariantCulture,
                            "Invalid property: {0} - the property type {1} is not supported by Entity Framework.",
                            property.ToDisplayString(this.ErrorMessageDisplayFormat),
                            property.Type.ToDisplayString(this.ErrorMessageDisplayFormat)));
                }

                var inversePropertyAttributeType = compilation.GetTypeByMetadataName(Constants.InversePropertyAttribute);
                var inversePropertyAttribute = property.GetAttributes().SingleOrDefault(x => x.AttributeClass == inversePropertyAttributeType);

                if (inversePropertyAttribute != null)
                {
                    var scalarTypeCopy = scalarType;
                    var targetType = this.interfaceSymbols.SingleOrDefault(x => x == scalarTypeCopy);

                    if (targetType == null)
                    {
                        throw new InvalidOperationException(
                            string.Format(
                                CultureInfo.InvariantCulture,
                                "Invalid {0} attribute on property {1}. The property type {2} must be marked as an Entity.",
                                inversePropertyAttributeType.ToDisplayString(this.ErrorMessageDisplayFormat),
                                property.ToDisplayString(this.ErrorMessageDisplayFormat),
                                scalarType.ToDisplayString(this.ErrorMessageDisplayFormat)));
                    }

                    var inversePropertyName = (string)inversePropertyAttribute.ConstructorArguments[0].Value;

                    var targetProperty = targetType
                        .GetMembers()
                        .OfType<IPropertySymbol>()
                        .Where(x => x.Name == inversePropertyName)
                        .FirstOrDefault();

                    if (targetProperty == null)
                    {
                        throw new InvalidOperationException(
                            string.Format(
                                CultureInfo.InvariantCulture,
                                "Invalid {0} attribute on property {1}. A property named '{2}' cannot be found on the target interface type {3}.",
                                inversePropertyAttributeType.ToDisplayString(this.ErrorMessageDisplayFormat),
                                property.ToDisplayString(this.ErrorMessageDisplayFormat),
                                inversePropertyName,
                                targetType.ToDisplayString(this.ErrorMessageDisplayFormat)));
                    }
                }
            }

            private bool IsSupportedPropertyType(ITypeSymbol propertyType, out bool isCollection, out ITypeSymbol scalarType)
            {
                isCollection = IsCollectionType(propertyType);
                scalarType = propertyType;

                if (isCollection)
                {
                    scalarType = ((INamedTypeSymbol)propertyType).TypeArguments[0];
                }

                return IsSupportedScalarPropertyType(scalarType);
            }

            private bool IsSupportedScalarPropertyType(ITypeSymbol propertyType)
            {
                if (basicTypes.Contains(propertyType))
                {
                    return true;
                }

                if (IsNullable(propertyType, o => basicTypes.Contains(o) || IsEnum(o)))
                {
                    return true;
                }

                if (IsEnum(propertyType))
                {
                    return true;
                }

                var byteType = compilation.GetTypeByMetadataName(typeof(byte).FullName);

                if (IsArray(propertyType, e => e == byteType))
                {
                    return true;
                }

                if (IsEntityType(propertyType))
                {
                    return true;
                }

                return false;
            }

            private bool IsEnum(ITypeSymbol type)
            {
                var enumType = compilation.GetTypeByMetadataName(typeof(Enum).FullName);
                return type.BaseType == enumType;
            }

            private bool IsArray(ITypeSymbol type, Func<ITypeSymbol, bool> elementTypePredicate = null)
            {
                var arrayType = type as IArrayTypeSymbol;

                if (arrayType == null)
                {
                    return false;
                }

                return elementTypePredicate == null || elementTypePredicate(arrayType.ElementType);
            }

            private bool IsNullable(ITypeSymbol type, Func<ITypeSymbol, bool> underlyingTypePredicate = null)
            {
                var nullableTType = compilation.GetTypeByMetadataName(typeof(Nullable<>).FullName);

                if (type.OriginalDefinition != nullableTType)
                {
                    return false;
                }

                var namedType = (INamedTypeSymbol)type;

                return underlyingTypePredicate == null || underlyingTypePredicate(namedType.TypeArguments[0]);
            }

            private bool IsEntityType(ITypeSymbol type)
            {
                return this.interfaceSymbols.Any(x => x == type);
            }

            private bool IsCollectionType(ITypeSymbol type)
            {
                var iCollectionTType = compilation.GetTypeByMetadataName(typeof(ICollection<>).FullName);

                // TODO: existing template allows ISet<T> in one place, and then not in a subsequent place
                //var iSetTType = compilation.GetTypeByMetadataName(typeof(ISet<>).FullName);

                return type.OriginalDefinition == iCollectionTType;// || type.OriginalDefinition == iSetTType;
            }
        }
    }
}
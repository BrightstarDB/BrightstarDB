<?xml version="1.0"?>
<doc>
    <assembly>
        <name>dotNetRDF</name>
    </assembly>
    <members>
        <member name="M:VDS.RDF.PortableClassLibraryExtensions.Close(System.IO.TextWriter)">
            <summary>
            Provides a default no-op implementation of TextWriter.Close() for Portable Class Library
            </summary>
            <param name="theWriter"></param>
        </member>
        <member name="M:VDS.RDF.PortableClassLibraryExtensions.Close(System.Xml.XmlWriter)">
            <summary>
            Provides a default no-op implementation of XmlWriter.Close() for the Portable Class Library
            </summary>
            <param name="writer"></param>
        </member>
        <member name="M:VDS.RDF.PortableClassLibraryExtensions.Copy(System.String)">
            <summary>
            Replacement for the static String.Copy(string) method
            that is not present in the Portable Class Library
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Console">
            <summary>
            Provides a replacement for System.Console in portable class libraries
            that writes to the debug output stream rather than to the console.
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.StreamLoader">
            <summary>
            Static helper class for loading data from a stream into Graphs / Triple Stores
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.StreamLoader.RaiseWarning(System.String)">
            <summary>
            Raises warning messages
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="M:VDS.RDF.Parsing.StreamLoader.RaiseStoreWarning(System.String)">
            <summary>
            Raises Store Warning messages
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="E:VDS.RDF.Parsing.StreamLoader.Warning">
            <summary>
            Event which is raised when the parser invoked by the FileLoader detects a non-fatal issue with the RDF syntax
            </summary>
        </member>
        <member name="E:VDS.RDF.Parsing.StreamLoader.StoreWarning">
            <summary>
            Event which is raised when the Store parser invoked by the FileLoader detects a non-fatal issue with the RDF syntax
            </summary>
        </member>
        <member name="T:VDS.RDF.HashSet`1">
            <summary>
            Emulates the HashSet class for Windows Phone since Windows Phone doesn't have the HashSet class in its Silverlight based profile
            </summary>
            <remarks>
            Does not handle null items
            </remarks>
        </member>
        <member name="T:VDS.RDF.Writing.HtmlTextWriter">
            <summary>
            Custom implementation of <see cref="!:System.Web.UI.HtmlTextWriter">System.Web.UI.HtmlTextWriter</see> to replace it in builds where System.Web is not available
            </summary>
            <remarks>
            <para>
            Note that this is not a full implementation of HtmlTextWriter as per the original class, it simply emulates all the functionality that dotNetRDF requires for it's HTML outputting
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.#ctor(System.IO.TextWriter)">
            <summary>
            Creates a new HTML Text Writer
            </summary>
            <param name="writer">Text Writer</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.AddAttribute(System.String,System.String)">
            <summary>
            Adds an attribute to the next element to be written
            </summary>
            <param name="name">Attribute Name</param>
            <param name="value">Value</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.AddAttribute(System.String,System.String,System.Boolean)">
            <summary>
            Adds an attribute to the next element to be written
            </summary>
            <param name="name">Attribute Name</param>
            <param name="value">Value</param>
            <param name="fEncode">Whether to encode the attribute value</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.AddAttribute(VDS.RDF.Writing.HtmlTextWriterAttribute,System.String)">
            <summary>
            Adds an attribute to the next element to be written
            </summary>
            <param name="key">Attribute</param>
            <param name="value">Value</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.AddAttribute(VDS.RDF.Writing.HtmlTextWriterAttribute,System.String,System.Boolean)">
            <summary>
            Adds an attribute to the next element to be written
            </summary>
            <param name="key">Attribute</param>
            <param name="value">Value</param>
            <param name="fEncode">Whether to encode the attribute value</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.AddStyleAttribute(System.String,System.String)">
            <summary>
            Adds a CSS style that will be used in the style attribute of the next element to be written
            </summary>
            <param name="name">CSS Attribute Name</param>
            <param name="value">Value</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.AddStyleAttribute(VDS.RDF.Writing.HtmlTextWriterStyle,System.String)">
            <summary>
            Adds a CSS style that will be used in the style attribute of the next element to be written
            </summary>
            <param name="key">CSS Attribute</param>
            <param name="value">Value</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.Close">
            <summary>
            Close the writer
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.Flush">
            <summary>
            Flush the writer
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.RenderBeginTag(System.String)">
            <summary>
            Writes the begin tag for an element
            </summary>
            <param name="tagName">Tag Name</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.RenderBeginTag(VDS.RDF.Writing.HtmlTextWriterTag)">
            <summary>
            Writes the begin tag for an element
            </summary>
            <param name="tagKey">Tag</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.RenderEndTag">
            <summary>
            Writes the end tag for an element
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.Write(System.Char)">
            <summary>
            Writes a character
            </summary>
            <param name="value">Character</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.Write(System.Boolean)">
            <summary>
            Writes a boolean
            </summary>
            <param name="value">Boolean</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.Write(System.Char[])">
            <summary>
            Writes some characters
            </summary>
            <param name="buffer">Characters</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.Write(System.Char[],System.Int32,System.Int32)">
            <summary>
            Writes some portion of the given characters
            </summary>
            <param name="buffer">Characters</param>
            <param name="index">Index to start at</param>
            <param name="count">Number of characters to write</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.Write(System.Decimal)">
            <summary>
            Writes a decimal
            </summary>
            <param name="value">Decimal</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.Write(System.Double)">
            <summary>
            Writes a double
            </summary>
            <param name="value">Double</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.Write(System.Single)">
            <summary>
            Writes a float
            </summary>
            <param name="value">Float</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.Write(System.Int32)">
            <summary>
            Writes an integer
            </summary>
            <param name="value">Integer</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.Write(System.Int64)">
            <summary>
            Writes a long integer
            </summary>
            <param name="value">Long Integer</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.Write(System.Object)">
            <summary>
            Writes an object
            </summary>
            <param name="value">Object</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.Write(System.String,System.Object[])">
            <summary>
            Writes a formatted string
            </summary>
            <param name="format">String with format</param>
            <param name="arg">Arguments to insert into string</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.Write(System.String)">
            <summary>
            Writes a string
            </summary>
            <param name="value">String</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.Write(System.UInt32)">
            <summary>
            Writes an unsigned integer
            </summary>
            <param name="value">Unsigned Integer</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.Write(System.UInt64)">
            <summary>
            Writes an unsigned long integer
            </summary>
            <param name="value">Unsigned Long Integer</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.WriteAttribute(System.String,System.String)">
            <summary>
            Writes an attribute
            </summary>
            <param name="name">Attribute Name</param>
            <param name="value">Value</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.WriteAttribute(System.String,System.String,System.Boolean)">
            <summary>
            Writes an attribute
            </summary>
            <param name="name">Attribute Name</param>
            <param name="value">Value</param>
            <param name="fEncode">Whether to encode the value</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.WriteBeginTag(System.String)">
            <summary>
            Writes a begin tag but does not terminate it so that methods like <see cref="M:VDS.RDF.Writing.HtmlTextWriter.WriteAttribute(System.String,System.String)"/> may be used
            </summary>
            <param name="tagName">Tag Name</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.WriteBreak">
            <summary>
            Writes a line break
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.WriteEncodedText(System.String)">
            <summary>
            Writes encoded text
            </summary>
            <param name="text">Text</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.WriteEncodedUrl(System.String)">
            <summary>
            Writes an encoded URL
            </summary>
            <param name="url">URL</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.WriteEncodedUrlParameter(System.String)">
            <summary>
            Writes an encoded URL parameter
            </summary>
            <param name="urlText">URL parameter</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.WriteEndTag(System.String)">
            <summary>
            Writes an end tag
            </summary>
            <param name="tagName">Tag Name</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.WriteFullBeginTag(System.String)">
            <summary>
            Writes a begin tag with the terminating &lt;, use <see cref="M:VDS.RDF.Writing.HtmlTextWriter.WriteBeginTag(System.String)"/> instead if you need to add attributes afterwards
            </summary>
            <param name="tagName">Tag Name</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.WriteLine">
            <summary>
            Writes a new line
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.WriteLine(System.Boolean)">
            <summary>
            Writes a boolean followed by a new line
            </summary>
            <param name="value">Boolean</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.WriteLine(System.Char)">
            <summary>
            Writes a character followed by a new line
            </summary>
            <param name="value">Character</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.WriteLine(System.Char[])">
            <summary>
            Writes some characters followed by a new line
            </summary>
            <param name="buffer">Characters</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.WriteLine(System.Char[],System.Int32,System.Int32)">
            <summary>
            Writes some portion of the characters followed by a new line
            </summary>
            <param name="buffer">Characters</param>
            <param name="index">Index to start at</param>
            <param name="count">Number of characters to write</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.WriteLine(System.Decimal)">
            <summary>
            Writes a decimal followed by a new line
            </summary>
            <param name="value">Decimal</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.WriteLine(System.Double)">
            <summary>
            Writes a double followed by a new line
            </summary>
            <param name="value">Double</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.WriteLine(System.Single)">
            <summary>
            Writes a float followed by a new line
            </summary>
            <param name="value">Float</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.WriteLine(System.Int32)">
            <summary>
            Writes an integer followed by a new line
            </summary>
            <param name="value">Integer</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.WriteLine(System.Int64)">
            <summary>
            Writes a long integer followed by a new line
            </summary>
            <param name="value">Long Integer</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.WriteLine(System.Object)">
            <summary>
            Writes an object followed by a new line
            </summary>
            <param name="value">Object</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.WriteLine(System.String)">
            <summary>
            Writes a string followed by a new line
            </summary>
            <param name="value">String</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.WriteLine(System.String,System.Object[])">
            <summary>
            Writes a formatted string followed by a new line
            </summary>
            <param name="format">String</param>
            <param name="arg">Arguments to insert into string</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.WriteLine(System.UInt32)">
            <summary>
            Writes an unsigned integer followed by a new line
            </summary>
            <param name="value">Unsigned Integer</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.WriteLine(System.UInt64)">
            <summary>
            Writes an unsigned long integer followed by a new line
            </summary>
            <param name="value">Unsigned Long Integer</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.WriteLineNoTabs(System.String)">
            <summary>
            Writes a string on a line with no tabs
            </summary>
            <param name="s">String</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.WriteStyleAttribute(System.String,System.String)">
            <summary>
            Writes a style attribute
            </summary>
            <param name="name">Attribute Name</param>
            <param name="value">Value</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlTextWriter.WriteStyleAttribute(System.String,System.String,System.Boolean)">
            <summary>
            Writes a style attribute
            </summary>
            <param name="name">Attribute Name</param>
            <param name="value">Value</param>
            <param name="fEncode">Whether to encode the value</param>
        </member>
        <member name="P:VDS.RDF.Writing.HtmlTextWriter.Encoding">
            <summary>
            Gets the encoding of the Inner Writer
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.HtmlTextWriter.Indent">
            <summary>
            Gets/Sets the current Indent
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.HtmlTextWriter.InnerWriter">
            <summary>
            Gets the Inner Writer
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.HtmlTextWriterAttribute">
            <summary>
            HTML Attributes
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.Accesskey">
            <summary>
            Access Key
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.Align">
            <summary>
            Align
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.Alt">
            <summary>
            Alternative Text
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.Background">
            <summary>
            Background Image
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.Bgcolor">
            <summary>
            Background Colour
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.Border">
            <summary>
            Border
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.Bordercolor">
            <summary>
            Border Colour
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.Cellpadding">
            <summary>
            Cell Padding
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.Cellspacing">
            <summary>
            Cell Spacing
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.Checked">
            <summary>
            Checked
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.Class">
            <summary>
            CSS Class
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.Cols">
            <summary>
            Columns
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.Colspan">
            <summary>
            Column Span
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.Disabled">
            <summary>
            Disabled
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.For">
            <summary>
            For
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.Height">
            <summary>
            Height
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.Href">
            <summary>
            Hyper Reference
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.Id">
            <summary>
            ID
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.Maxlength">
            <summary>
            Maximum Length
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.Multiple">
            <summary>
            Multiple Values permitted
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.Name">
            <summary>
            Name
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.Nowrap">
            <summary>
            No Wrapping
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.Onchange">
            <summary>
            On Change
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.Onclick">
            <summary>
            On Click
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.ReadOnly">
            <summary>
            Read Only
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.Rows">
            <summary>
            Rows
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.Rowspan">
            <summary>
            Row Span
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.Rules">
            <summary>
            Rules
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.Selected">
            <summary>
            Selected
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.Size">
            <summary>
            Size
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.Src">
            <summary>
            Source
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.Style">
            <summary>
            CSS Styles
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.Tabindex">
            <summary>
            Tab Index
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.Target">
            <summary>
            Target
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.Title">
            <summary>
            Title
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.Type">
            <summary>
            Type
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.Valign">
            <summary>
            Vertical Align
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.Value">
            <summary>
            Value
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.Width">
            <summary>
            Width
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.Wrap">
            <summary>
            Wrapping
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.Abbr">
            <summary>
            Abbreviation
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.AutoComplete">
            <summary>
            Auto-Complete
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.Axis">
            <summary>
            Axis
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.Content">
            <summary>
            Content
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.Coords">
            <summary>
            Coordinates
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.DesignerRegion">
            <summary>
            Designer Region
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.Dir">
            <summary>
            Direction
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.Headers">
            <summary>
            Headers
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.Longdesc">
            <summary>
            Long Description
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.Rel">
            <summary>
            Relationship
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.Scope">
            <summary>
            Scope
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.Shape">
            <summary>
            Shape
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.Usemap">
            <summary>
            Use Map
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterAttribute.VCardName">
            <summary>
            VCard Name
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.HtmlTextWriterStyle">
            <summary>
            CSS Styles
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterStyle.BackgroundColor">
            <summary>
            Background Colour
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterStyle.BackgroundImage">
            <summary>
            Background Image
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterStyle.BorderCollapse">
            <summary>
            Border Collapse
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterStyle.BorderColor">
            <summary>
            Border Colour
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterStyle.BorderStyle">
            <summary>
            Border Style
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterStyle.BorderWidth">
            <summary>
            Border Width
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterStyle.Color">
            <summary>
            Colour
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterStyle.FontFamily">
            <summary>
            Font Family
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterStyle.FontSize">
            <summary>
            Font Size
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterStyle.FontStyle">
            <summary>
            Font Style
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterStyle.FontWeight">
            <summary>
            Font Weight
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterStyle.Height">
            <summary>
            Height
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterStyle.TextDecoration">
            <summary>
            Text Decoration
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterStyle.Width">
            <summary>
            Width
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterStyle.ListStyleImage">
            <summary>
            List Style Image
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterStyle.ListStyleType">
            <summary>
            List Style Type
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterStyle.Cursor">
            <summary>
            Cursor
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterStyle.Direction">
            <summary>
            Direction
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterStyle.Display">
            <summary>
            Display
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterStyle.Filter">
            <summary>
            Filter
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterStyle.FontVariant">
            <summary>
            Font Variant
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterStyle.Left">
            <summary>
            Left Position
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterStyle.Margin">
            <summary>
            Margin
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterStyle.MarginBottom">
            <summary>
            Bottom Margin
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterStyle.MarginLeft">
            <summary>
            Left Margin
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterStyle.MarginRight">
            <summary>
            Right Margin
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterStyle.MarginTop">
            <summary>
            Top Margin
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterStyle.Overflow">
            <summary>
            Overflow
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterStyle.OverflowX">
            <summary>
            X Overflow
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterStyle.OverflowY">
            <summary>
            Y Overflow
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterStyle.Padding">
            <summary>
            Padding
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterStyle.PaddingBottom">
            <summary>
            Bottom Padding
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterStyle.PaddingLeft">
            <summary>
            Left Padding
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterStyle.PaddingRight">
            <summary>
            Right Padding
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterStyle.PaddingTop">
            <summary>
            Top Padding
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterStyle.Position">
            <summary>
            Position
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterStyle.TextAlign">
            <summary>
            Text Alignment
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterStyle.VerticalAlign">
            <summary>
            Vertical Alignment
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterStyle.TextOverflow">
            <summary>
            Text Overflow
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterStyle.Top">
            <summary>
            Top Position
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterStyle.Visibility">
            <summary>
            Visibility
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterStyle.WhiteSpace">
            <summary>
            Whitespace
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterStyle.ZIndex">
            <summary>
            Z Index
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.HtmlTextWriterTag">
            <summary>
            HTML Tags
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Unknown">
            <summary>
            Unknown
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.A">
            <summary>
            Link
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Acronym">
            <summary>
            Acronym
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Address">
            <summary>
            Address
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Area">
            <summary>
            Area
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.B">
            <summary>
            Bold
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Base">
            <summary>
            Base URI
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Basefont">
            <summary>
            Base Font
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Bdo">
            <summary>
            Bidirectional
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Bgsound">
            <summary>
            Background Sound
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Big">
            <summary>
            Big
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Blockquote">
            <summary>
            Block Quotes
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Body">
            <summary>
            Body
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Br">
            <summary>
            Line Break
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Button">
            <summary>
            Button
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Caption">
            <summary>
            Caption
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Center">
            <summary>
            Centering
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Cite">
            <summary>
            Citation
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Code">
            <summary>
            Code
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Col">
            <summary>
            Column
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Colgroup">
            <summary>
            Column Group
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Dd">
            <summary>
            Data Definition
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Del">
            <summary>
            Deleted
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Dfn">
            <summary>
            Definition
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Dir">
            <summary>
            Direction
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Div">
            <summary>
            Div
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Dl">
            <summary>
            Dl
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Dt">
            <summary>
            Dt
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Em">
            <summary>
            Emphasis
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Embed">
            <summary>
            Embed
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Fieldset">
            <summary>
            Field Set
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Font">
            <summary>
            Font
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Form">
            <summary>
            Form
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Frame">
            <summary>
            Frame
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Frameset">
            <summary>
            Frame Set
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.H1">
            <summary>
            Heading 1
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.H2">
            <summary>
            Heading 2
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.H3">
            <summary>
            Heading 3
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.H4">
            <summary>
            Heading 4
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.H5">
            <summary>
            Heading 5
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.H6">
            <summary>
            Heading 6
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Head">
            <summary>
            Head
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Hr">
            <summary>
            Horizontal Rule
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Html">
            <summary>
            HTML
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.I">
            <summary>
            Italics
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Iframe">
            <summary>
            Inline Frame
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Img">
            <summary>
            Image
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Input">
            <summary>
            Form Input
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Ins">
            <summary>
            Inserted
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Isindex">
            <summary>
            Is Index
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Kbd">
            <summary>
            Keyboard
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Label">
            <summary>
            Label
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Legend">
            <summary>
            Legend
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Li">
            <summary>
            List Item
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Link">
            <summary>
            Link
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Map">
            <summary>
            Map
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Marquee">
            <summary>
            Marquee
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Menu">
            <summary>
            Menu
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Meta">
            <summary>
            Metadata
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Nobr">
            <summary>
            Nobr
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Noframes">
            <summary>
            No Frames
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Noscript">
            <summary>
            No Script
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Object">
            <summary>
            Object
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Ol">
            <summary>
            Ordered List
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Option">
            <summary>
            Option
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.P">
            <summary>
            Paragraph
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Param">
            <summary>
            Param
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Pre">
            <summary>
            Pre-formatted
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Q">
            <summary>
            Q
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Rt">
            <summary>
            Rt
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Ruby">
            <summary>
            Ruby
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.S">
            <summary>
            Strike-through
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Samp">
            <summary>
            Sample
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Script">
            <summary>
            Script
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Select">
            <summary>
            Select
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Small">
            <summary>
            Small
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Span">
            <summary>
            Span
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Strike">
            <summary>
            Strike
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Strong">
            <summary>
            Strong
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Style">
            <summary>
            CSS Styles
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Sub">
            <summary>
            Subscript
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Sup">
            <summary>
            Superscript
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Table">
            <summary>
            Table
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Tbody">
            <summary>
            Table Body
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Td">
            <summary>
            Table Column
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Textarea">
            <summary>
            Text Area
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Tfoot">
            <summary>
            Table Footer
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Th">
            <summary>
            Table Column Header
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Thead">
            <summary>
            Table Head
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Title">
            <summary>
            Title
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Tr">
            <summary>
            Table Row
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Tt">
            <summary>
            Teletype
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.U">
            <summary>
            Underline
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Ul">
            <summary>
            Unordered List
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Var">
            <summary>
            Var
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Wbr">
            <summary>
            Wbr
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.HtmlTextWriterTag.Xml">
            <summary>
            XML
            </summary>
        </member>
        <member name="T:VDS.RDF.HttpUtility">
            <summary>
            An implementation of HttpUtility for use with Silverlight builds which require it
            </summary>
            <remarks>
            <para>
            The URL Encoding algorithm is partially based on an algorithm presented in this <a href="http://www.codeguru.com/cpp/cpp/cpp_mfc/article.php/c4029">CodeGuru</a> article
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.HttpUtility.HtmlDecode(System.String)">
            <summary>
            HTML Decodes a String so any character entities used are converted to their actual characters
            </summary>
            <param name="value">Value to decode</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.HttpUtility.HtmlEncode(System.String)">
            <summary>
            HTML Encodes a String so any that requires entitzing are converted to character entities
            </summary>
            <param name="value">Value to encode</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.HttpUtility.UrlEncode(System.String)">
            <summary>
            Encodes a URL string so any characters that require percent encoding are encoded
            </summary>
            <param name="value">Value to encode</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.HttpUtility.UrlDecode(System.String)">
            <summary>
            Decodes a URL string so any characters that are percent encoded are converted to actual characters
            </summary>
            <param name="value">Value to decode</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.SilverlightExtensions">
            <summary>
            Extension Methods for the Silverlight build to avoid having to do lots of #if SILVERLIGHT blocks
            </summary>
        </member>
        <member name="M:VDS.RDF.SilverlightExtensions.Split(System.String,System.Char[],System.Int32)">
            <summary>
            Splits a String
            </summary>
            <param name="value">String to split</param>
            <param name="chars">Separator</param>
            <param name="count">Maximum number of results</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.SilverlightExtensions.ToCharArray(System.String,System.Int32,System.Int32)">
            <summary>
            Copies the characters in a specified substring to a character array
            </summary>
            <param name="value">String</param>
            <param name="startIndex">Start Index</param>
            <param name="count">Number of characters to copy</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.SilverlightExtensions.IsFile(System.Uri)">
            <summary>
            Gets whether a URI is a file:/// URI
            </summary>
            <param name="u">URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.SilverlightExtensions.Segments(System.Uri)">
            <summary>
            Gets the Segments of the URI
            </summary>
            <param name="u">URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.SilverlightExtensions.PathAndQuery(System.Uri)">
            <summary>
            Gets the Path and Query of the URI
            </summary>
            <param name="u">URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.SilverlightExtensions.RemoveAll``1(System.Collections.Generic.List{``0},System.Func{``0,System.Boolean})">
            <summary>
            Removes all items from a List which return true for the given function
            </summary>
            <typeparam name="T">Type</typeparam>
            <param name="l">List</param>
            <param name="func">Function</param>
        </member>
        <member name="T:VDS.RDF.Configuration.CollectionFactory">
            <summary>
            Object Factory for loading triple and graph collections
            </summary>
        </member>
        <member name="T:VDS.RDF.Configuration.IObjectFactory">
            <summary>
            Interface for Object Factories which are factory classes that can create Objects based on configuration information in a Graph
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.IObjectFactory.TryLoadObject(VDS.RDF.IGraph,VDS.RDF.INode,System.Type,System.Object@)">
            <summary>
            Attempts to load an Object of the given type identified by the given Node and returned as the Type that this loader generates
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="targetType">Target Type</param>
            <param name="obj">Created Object</param>
            <returns>True if the loader succeeded in creating an Object</returns>
            <remarks>
            <para>
            The Factory should not throw an error if some required configuration is missing as another factory further down the processing chain may still be able to create the object.  If the factory encounters errors and all the required configuration information is present then that error should be thrown i.e. class instantiation throws an error or a call to load an object that this object requires fails.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Configuration.IObjectFactory.CanLoadObject(System.Type)">
            <summary>
            Returns whether this Factory is capable of creating objects of the given type
            </summary>
            <param name="t">Target Type</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.CollectionFactory.TryLoadObject(VDS.RDF.IGraph,VDS.RDF.INode,System.Type,System.Object@)">
            <summary>
            Tries to load a triple/graph collection which is specified in the given configuration graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="targetType">Target type</param>
            <param name="obj">Returned Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.CollectionFactory.CanLoadObject(System.Type)">
            <summary>
            Gets whether this factory can load objects of the given type
            </summary>
            <param name="t">Type</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Configuration.PropertyFunctionFactoryFactory">
            <summary>
            Factory class for producing Custom SPARQL Expression Factories from Configuration Graphs
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.PropertyFunctionFactoryFactory.TryLoadObject(VDS.RDF.IGraph,VDS.RDF.INode,System.Type,System.Object@)">
            <summary>
            Tries to load a SPARQL Property Function Factory based on information from the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="targetType">Target Type</param>
            <param name="obj">Output Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.PropertyFunctionFactoryFactory.CanLoadObject(System.Type)">
            <summary>
            Gets whether this Factory can load objects of the given Type
            </summary>
            <param name="t">Type</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Configuration.OperatorFactory">
            <summary>
            SPARQL Operator factory which is capable of loading any implementation of ISparqlOperator which has a public unparameterized constructor
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.OperatorFactory.TryLoadObject(VDS.RDF.IGraph,VDS.RDF.INode,System.Type,System.Object@)">
            <summary>
            Tries to load an object of the given type
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="targetType">Target Type</param>
            <param name="obj">Returned Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.OperatorFactory.CanLoadObject(System.Type)">
            <summary>
            Gets whether this factory can load objects of the given type
            </summary>
            <param name="t">Type</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.BaseDemandGraphCollection">
            <summary>
            A decorator for graph collections that allows for graphs to be loaded on demand if they don't exist in the underlying graph collection
            </summary>
        </member>
        <member name="T:VDS.RDF.WrapperGraphCollection">
            <summary>
            Abstract decorator for Graph Collections to make it easier to add new functionality to existing implementations
            </summary>
        </member>
        <member name="T:VDS.RDF.BaseGraphCollection">
            <summary>
            Abstract Base Class for Graph Collections
            </summary>
            <remarks>Designed to allow the underlying storage of a Graph Collection to be changed at a later date without affecting classes that use it</remarks>
        </member>
        <member name="M:VDS.RDF.BaseGraphCollection.Contains(System.Uri)">
            <summary>
            Checks whether the Graph with the given Uri exists in this Graph Collection
            </summary>
            <param name="graphUri">Graph Uri to test</param>
            <returns></returns>
            <remarks>
            The null URI is used to reference the Default Graph
            </remarks>
        </member>
        <member name="M:VDS.RDF.BaseGraphCollection.Add(VDS.RDF.IGraph,System.Boolean)">
            <summary>
            Adds a Graph to the Collection
            </summary>
            <param name="g">Graph to add</param>
            <param name="mergeIfExists">Sets whether the Graph should be merged with an existing Graph of the same Uri if present</param>
        </member>
        <member name="M:VDS.RDF.BaseGraphCollection.Remove(System.Uri)">
            <summary>
            Removes a Graph from the Collection
            </summary>
            <param name="graphUri">Uri of the Graph to remove</param>
            <remarks>
            The null URI is used to reference the Default Graph
            </remarks>
        </member>
        <member name="M:VDS.RDF.BaseGraphCollection.Dispose">
            <summary>
            Disposes of the Graph Collection
            </summary>
            <remarks>Invokes the <see cref="!:IGraph.Dispose()">Dispose()</see> method of all Graphs contained in the Collection</remarks>
        </member>
        <member name="M:VDS.RDF.BaseGraphCollection.GetEnumerator">
            <summary>
            Gets the Enumerator for the Collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraphCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets the Enumerator for this Collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraphCollection.RaiseGraphAdded(VDS.RDF.IGraph)">
            <summary>
            Helper method which raises the <see cref="E:VDS.RDF.BaseGraphCollection.GraphAdded">Graph Added</see> event manually
            </summary>
            <param name="g">Graph</param>
        </member>
        <member name="M:VDS.RDF.BaseGraphCollection.RaiseGraphRemoved(VDS.RDF.IGraph)">
            <summary>
            Helper method which raises the <see cref="E:VDS.RDF.BaseGraphCollection.GraphRemoved">Graph Removed</see> event manually
            </summary>
            <param name="g">Graph</param>
        </member>
        <member name="P:VDS.RDF.BaseGraphCollection.Count">
            <summary>
            Gets the number of Graphs in the Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.BaseGraphCollection.GraphUris">
            <summary>
            Provides access to the Graph URIs of Graphs in the Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.BaseGraphCollection.Item(System.Uri)">
            <summary>
            Gets a Graph from the Collection
            </summary>
            <param name="graphUri">Graph Uri</param>
            <returns></returns>
            <remarks>
            The null URI is used to reference the Default Graph
            </remarks>
        </member>
        <member name="E:VDS.RDF.BaseGraphCollection.GraphAdded">
            <summary>
            Event which is raised when a Graph is added to the Collection
            </summary>
        </member>
        <member name="E:VDS.RDF.BaseGraphCollection.GraphRemoved">
            <summary>
            Event which is raised when a Graph is removed from the Collection
            </summary>
        </member>
        <member name="F:VDS.RDF.WrapperGraphCollection._graphs">
            <summary>
            Underlying Graph Collection
            </summary>
        </member>
        <member name="M:VDS.RDF.WrapperGraphCollection.#ctor">
            <summary>
            Creates a decorator around a default <see cref="T:VDS.RDF.GraphCollection"/> instance
            </summary>
        </member>
        <member name="M:VDS.RDF.WrapperGraphCollection.#ctor(VDS.RDF.BaseGraphCollection)">
            <summary>
            Creates a decorator around the given graph collection
            </summary>
            <param name="graphCollection">Graph Collection</param>
        </member>
        <member name="M:VDS.RDF.WrapperGraphCollection.Add(VDS.RDF.IGraph,System.Boolean)">
            <summary>
            Adds a Graph to the collection
            </summary>
            <param name="g">Graph</param>
            <param name="mergeIfExists">Whether to merge into an existing Graph with the same URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.WrapperGraphCollection.Contains(System.Uri)">
            <summary>
            Gets whether the collection contains the given Graph
            </summary>
            <param name="graphUri"></param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.WrapperGraphCollection.Dispose">
            <summary>
            Disposes of the collection
            </summary>
        </member>
        <member name="M:VDS.RDF.WrapperGraphCollection.GetEnumerator">
            <summary>
            Gets the enumerator for the collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.WrapperGraphCollection.Remove(System.Uri)">
            <summary>
            Removes a Graph from the collection
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.WrapperGraphCollection.Count">
            <summary>
            Gets the number of Graphs in the collection
            </summary>
        </member>
        <member name="P:VDS.RDF.WrapperGraphCollection.GraphUris">
            <summary>
            Gets the URIs of the Graphs in the collection
            </summary>
        </member>
        <member name="P:VDS.RDF.WrapperGraphCollection.Item(System.Uri)">
            <summary>
            Gets a Graph from the collection
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseDemandGraphCollection.#ctor">
            <summary>
            Creates a new decorator
            </summary>
        </member>
        <member name="M:VDS.RDF.BaseDemandGraphCollection.#ctor(VDS.RDF.BaseGraphCollection)">
            <summary>
            Creates a new decorator over the given graph collection
            </summary>
            <param name="collection">Graph Collection</param>
        </member>
        <member name="M:VDS.RDF.BaseDemandGraphCollection.Contains(System.Uri)">
            <summary>
            Checks whether the collection contains a Graph invoking an on-demand load if not present in the underlying collection
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseDemandGraphCollection.LoadOnDemand(System.Uri)">
            <summary>
            Loads a Graph on demand
            </summary>
            <param name="graphUri">URI of the Graph to load</param>
            <returns>A Graph if it could be loaded and throws an error otherwise</returns>
        </member>
        <member name="T:VDS.RDF.BaseGraph">
            <summary>
            Abstract Base Implementation of the <see cref="T:VDS.RDF.IGraph">IGraph</see> interface
            </summary>
        </member>
        <member name="T:VDS.RDF.IGraph">
            <summary>
            Interface for RDF Graphs
            </summary>
            <remarks>
            <para>
            Most implementations will probably want to inherit from the abstract class <see cref="T:VDS.RDF.BaseGraph">BaseGraph</see> since it contains reference implementations of various algorithms (Graph Equality/Graph Difference/Sub-Graph testing etc) which will save considerable work in implementation and ensure consistent behaviour of some methods across implementations.
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.INodeFactory">
            <summary>
            Interface for classes which can create Nodes
            </summary>
        </member>
        <member name="M:VDS.RDF.INodeFactory.CreateBlankNode">
            <summary>
            Creates a Blank Node with a new automatically generated ID
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.INodeFactory.CreateBlankNode(System.String)">
            <summary>
            Creates a Blank Node with the given Node ID
            </summary>
            <param name="nodeId">Node ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.INodeFactory.CreateGraphLiteralNode">
            <summary>
            Creates a Graph Literal Node which represents the empty Subgraph
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.INodeFactory.CreateGraphLiteralNode(VDS.RDF.IGraph)">
            <summary>
            Creates a Graph Literal Node which represents the given Subgraph
            </summary>
            <param name="subgraph">Subgraph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.INodeFactory.CreateLiteralNode(System.String,System.Uri)">
            <summary>
            Creates a Literal Node with the given Value and Data Type
            </summary>
            <param name="literal">Value of the Literal</param>
            <param name="datatype">Data Type URI of the Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.INodeFactory.CreateLiteralNode(System.String)">
            <summary>
            Creates a Literal Node with the given Value
            </summary>
            <param name="literal">Value of the Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.INodeFactory.CreateLiteralNode(System.String,System.String)">
            <summary>
            Creates a Literal Node with the given Value and Language
            </summary>
            <param name="literal">Value of the Literal</param>
            <param name="langspec">Language Specifier for the Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.INodeFactory.CreateUriNode(System.Uri)">
            <summary>
            Creates a URI Node for the given URI
            </summary>
            <param name="uri">URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.INodeFactory.CreateVariableNode(System.String)">
            <summary>
            Creates a Variable Node for the given Variable Name
            </summary>
            <param name="varname"></param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.INodeFactory.GetNextBlankNodeID">
            <summary>
            Creates a new unused Blank Node ID and returns it
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.Assert(VDS.RDF.Triple)">
            <summary>
            Asserts a Triple in the Graph
            </summary>
            <param name="t">A Triple</param>
        </member>
        <member name="M:VDS.RDF.IGraph.Assert(System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Asserts an Enumerable of Triples in the Graph
            </summary>
            <param name="ts">An Enumerable of Triples</param>
        </member>
        <member name="M:VDS.RDF.IGraph.Retract(VDS.RDF.Triple)">
            <summary>
            Retracts a Triple from the Graph
            </summary>
            <param name="t">A Triple</param>
        </member>
        <member name="M:VDS.RDF.IGraph.Retract(System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Retracts an Enumerable of Triples from the Graph
            </summary>
            <param name="ts">Enumerable of Triples</param>
        </member>
        <member name="M:VDS.RDF.IGraph.Clear">
            <summary>
            Retracts all Triples from the Graph
            </summary>
            <remarks>
            <para>
            The Graph should raise the <see cref="E:VDS.RDF.IGraph.ClearRequested">ClearRequested</see> event at the start of the Clear operation and abort the operation if the operation is cancelled by an event handler.  On completing the Clear the <see cref="E:VDS.RDF.IGraph.Cleared">Cleared</see> event should be raised.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.IGraph.CreateUriNode">
            <summary>
            Creates a URI Node that corresponds to the Base URI of the Graph
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.CreateUriNode(System.String)">
            <summary>
            Creates a URI Node for the given QName using the Graphs NamespaceMap to resolve the QName
            </summary>
            <param name="qname">QName</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.GetBlankNode(System.String)">
            <summary>
            Selects the Blank Node with the given ID if it exists in the Graph, returns null otherwise
            </summary>
            <param name="nodeId">Node ID</param>
            <returns>The Node if it exists in the Graph or null</returns>
        </member>
        <member name="M:VDS.RDF.IGraph.GetLiteralNode(System.String,System.String)">
            <summary>
            Selects the Literal Node with the given Value and Language if it exists in the Graph, returns null otherwise
            </summary>
            <param name="literal">Value of the Literal</param>
            <param name="langspec">Language Specifier of the Literal</param>
            <returns>The Node if it exists in the Graph or null</returns>
        </member>
        <member name="M:VDS.RDF.IGraph.GetLiteralNode(System.String)">
            <summary>
            Selects the Literal Node with the given Value if it exists in the Graph, returns null otherwise
            </summary>
            <param name="literal">Value of the Literal</param>
            <returns>The Node if it exists in the Graph or null</returns>
        </member>
        <member name="M:VDS.RDF.IGraph.GetLiteralNode(System.String,System.Uri)">
            <summary>
            Selects the Literal Node with the given Value and DataType if it exists in the Graph, returns otherwise
            </summary>
            <param name="literal">Value of the Literal</param>
            <param name="datatype">Data Type of the Literal</param>
            <returns>The Node if it exists in the Graph or null</returns>
        </member>
        <member name="M:VDS.RDF.IGraph.GetTriples(System.Uri)">
            <summary>
            Selects all Triples which have a Uri Node with the given Uri
            </summary>
            <param name="uri">Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.GetTriples(VDS.RDF.INode)">
            <summary>
            Selects all Triples which contain the given Node
            </summary>
            <param name="n">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.GetTriplesWithObject(System.Uri)">
            <summary>
            Selects all Triples where the Object is a Uri Node with the given Uri
            </summary>
            <param name="u">Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.GetTriplesWithObject(VDS.RDF.INode)">
            <summary>
            Selects all Triples where the Object is a given Node
            </summary>
            <param name="n">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.GetTriplesWithPredicate(VDS.RDF.INode)">
            <summary>
            Selects all Triples where the Predicate is a given Node
            </summary>
            <param name="n">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.GetTriplesWithPredicate(System.Uri)">
            <summary>
            Selects all Triples where the Predicate is a Uri Node with the given Uri
            </summary>
            <param name="u">Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.GetTriplesWithSubject(VDS.RDF.INode)">
            <summary>
            Selects all Triples where the Subject is a given Node
            </summary>
            <param name="n">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.GetTriplesWithSubject(System.Uri)">
            <summary>
            Selects all Triples where the Subject is a Uri Node with the given Uri
            </summary>
            <param name="u">Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.GetTriplesWithSubjectPredicate(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Selects all Triples with the given Subject and Predicate
            </summary>
            <param name="subj">Subject</param>
            <param name="pred">Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.GetTriplesWithSubjectObject(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Selects all Triples with the given Subject and Object
            </summary>
            <param name="subj">Subject</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.GetTriplesWithPredicateObject(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Selects all Triples with the given Predicate and Object
            </summary>
            <param name="pred">Predicate</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.GetUriNode(System.String)">
            <summary>
            Selects the Uri Node with the given QName if it exists in the Graph, returns null otherwise
            </summary>
            <param name="qname">QName</param>
            <returns>The Node if it exists in the Graph or null</returns>
        </member>
        <member name="M:VDS.RDF.IGraph.GetUriNode(System.Uri)">
            <summary>
            Selects the Uri Node with the given Uri if it exists in the Graph, returns null otherwise
            </summary>
            <param name="uri">Uri</param>
            <returns>The Node if it exists in the Graph or null</returns>
        </member>
        <member name="M:VDS.RDF.IGraph.ContainsTriple(VDS.RDF.Triple)">
            <summary>
            Gets whether a given Triple is in this Graph
            </summary>
            <param name="t">Triple to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.Merge(VDS.RDF.IGraph)">
            <summary>
            Merges the given Graph into this Graph
            </summary>
            <param name="g">Graph to merge</param>
            <remarks>
            <para>
            The Graph should raise the <see cref="E:VDS.RDF.IGraph.MergeRequested">MergeRequested</see> event at the start of the Merge operation and abort the operation if the operation is cancelled by an event handler.  On completing the Merge the <see cref="E:VDS.RDF.IGraph.Merged">Merged</see> event should be raised.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.IGraph.Merge(VDS.RDF.IGraph,System.Boolean)">
            <summary>
            Merges the given Graph into this Graph
            </summary>
            <param name="g">Graph to merge</param>
            <param name="keepOriginalGraphUri">Indicates that the Merge should preserve the Graph URIs of Nodes</param>
            <remarks>
            <para>
            The Graph should raise the <see cref="E:VDS.RDF.IGraph.MergeRequested">MergeRequested</see> event at the start of the Merge operation and abort the operation if the operation is cancelled by an event handler.  On completing the Merge the <see cref="E:VDS.RDF.IGraph.Merged">Merged</see> event should be raised.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.IGraph.Equals(VDS.RDF.IGraph,System.Collections.Generic.Dictionary{VDS.RDF.INode,VDS.RDF.INode}@)">
            <summary>
            Checks whether a Graph is equal to another Graph and if so returns the mapping of Blank Nodes
            </summary>
            <param name="g">Graph to compare with</param>
            <param name="mapping">Mapping of Blank Nodes</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.IsSubGraphOf(VDS.RDF.IGraph)">
            <summary>
            Checks whether this Graph is a sub-graph of the given Graph
            </summary>
            <param name="g">Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.IsSubGraphOf(VDS.RDF.IGraph,System.Collections.Generic.Dictionary{VDS.RDF.INode,VDS.RDF.INode}@)">
            <summary>
            Checks whether this Graph is a sub-graph of the given Graph
            </summary>
            <param name="g">Graph</param>
            <param name="mapping">Mapping of Blank Nodes</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.HasSubGraph(VDS.RDF.IGraph)">
            <summary>
            Checks whether this Graph has the given Graph as a sub-graph
            </summary>
            <param name="g">Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.HasSubGraph(VDS.RDF.IGraph,System.Collections.Generic.Dictionary{VDS.RDF.INode,VDS.RDF.INode}@)">
            <summary>
            Checks whether this Graph has the given Graph as a sub-graph
            </summary>
            <param name="g">Graph</param>
            <param name="mapping">Mapping of Blank Nodes</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IGraph.Difference(VDS.RDF.IGraph)">
            <summary>
            Calculates the difference between this Graph and the given Graph
            </summary>
            <param name="g">Graph</param>
            <returns></returns>
            <remarks>
            <para>
            Produces a report which shows the changes that must be made to this Graph to produce the given Graph
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.IGraph.ResolveQName(System.String)">
            <summary>
            Resolves a QName into a URI using the Namespace Map and Base URI of this Graph
            </summary>
            <param name="qname">QName</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.IGraph.BaseUri">
            <summary>
            Gets/Sets the Base Uri for the Graph
            </summary>
        </member>
        <member name="P:VDS.RDF.IGraph.IsEmpty">
            <summary>
            Gets whether a Graph is Empty
            </summary>
        </member>
        <member name="P:VDS.RDF.IGraph.NamespaceMap">
            <summary>
            Gets the Namespace Map for the Graph
            </summary>
        </member>
        <member name="P:VDS.RDF.IGraph.Nodes">
            <summary>
            Gets the Nodes of the Graph
            </summary>
        </member>
        <member name="P:VDS.RDF.IGraph.Triples">
            <summary>
            Gets the Triple Collection for the Graph
            </summary>
        </member>
        <member name="E:VDS.RDF.IGraph.TripleAsserted">
            <summary>
            Event which is raised when a Triple is asserted in the Graph
            </summary>
            <remarks>
            Whenever this event is raised the <see cref="E:VDS.RDF.IGraph.Changed">Changed</see> event should also be raised
            </remarks>
        </member>
        <member name="E:VDS.RDF.IGraph.TripleRetracted">
            <summary>
            Event which is raised when a Triple is retracted from the Graph
            </summary>
            <remarks>
            Whenever this event is raised the <see cref="E:VDS.RDF.IGraph.Changed">Changed</see> event should also be raised
            </remarks>
        </member>
        <member name="E:VDS.RDF.IGraph.Changed">
            <summary>
            Event which is raised when the Graph contents change
            </summary>
        </member>
        <member name="E:VDS.RDF.IGraph.ClearRequested">
            <summary>
            Event which is raised just before the Graph is cleared of its contents
            </summary>
        </member>
        <member name="E:VDS.RDF.IGraph.Cleared">
            <summary>
            Event which is raised after the Graph is cleared of its contents
            </summary>
        </member>
        <member name="E:VDS.RDF.IGraph.MergeRequested">
            <summary>
            Event which is raised just before a Merge operation begins on the Graph
            </summary>
        </member>
        <member name="E:VDS.RDF.IGraph.Merged">
            <summary>
            Event which is raised when a Merge operation is completed on the Graph
            </summary>
        </member>
        <member name="F:VDS.RDF.BaseGraph._triples">
            <summary>
            Collection of Triples in the Graph
            </summary>
        </member>
        <member name="F:VDS.RDF.BaseGraph._nsmapper">
            <summary>
            Namespace Mapper
            </summary>
        </member>
        <member name="F:VDS.RDF.BaseGraph._baseuri">
            <summary>
            Base Uri of the Graph
            </summary>
        </member>
        <member name="F:VDS.RDF.BaseGraph._bnodemapper">
            <summary>
            Blank Node ID Mapper
            </summary>
        </member>
        <member name="M:VDS.RDF.BaseGraph.#ctor(VDS.RDF.BaseTripleCollection)">
            <summary>
            Creates a new Base Graph using the given Triple Collection
            </summary>
            <param name="tripleCollection">Triple Collection to use</param>
        </member>
        <member name="M:VDS.RDF.BaseGraph.#ctor">
            <summary>
            Creates a new Base Graph which uses the default <see cref="T:VDS.RDF.TreeIndexedTripleCollection"/> as the Triple Collection
            </summary>
        </member>
        <member name="M:VDS.RDF.BaseGraph.Assert(VDS.RDF.Triple)">
            <summary>
            Asserts a Triple in the Graph
            </summary>
            <param name="t">The Triple to add to the Graph</param>
        </member>
        <member name="M:VDS.RDF.BaseGraph.Assert(System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Asserts a List of Triples in the graph
            </summary>
            <param name="ts">List of Triples in the form of an IEnumerable</param>
        </member>
        <member name="M:VDS.RDF.BaseGraph.Retract(VDS.RDF.Triple)">
            <summary>
            Retracts a Triple from the Graph
            </summary>
            <param name="t">Triple to Retract</param>
            <remarks>Current implementation may have some defunct Nodes left in the Graph as only the Triple is retracted</remarks>
        </member>
        <member name="M:VDS.RDF.BaseGraph.Retract(System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Retracts a enumeration of Triples from the graph
            </summary>
            <param name="ts">Enumeration of Triples to retract</param>
        </member>
        <member name="M:VDS.RDF.BaseGraph.Clear">
            <summary>
            Clears all Triples from the Graph
            </summary>
            <remarks>
            <para>
            The Graph will raise the <see cref="E:VDS.RDF.BaseGraph.ClearRequested">ClearRequested</see> event at the start of the Clear operation which allows for aborting the operation if the operation is cancelled by an event handler.  On completing the Clear the <see cref="E:VDS.RDF.BaseGraph.Cleared">Cleared</see> event will be raised.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.BaseGraph.CreateBlankNode">
            <summary>
            Creates a New Blank Node with an auto-generated Blank Node ID
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.CreateBlankNode(System.String)">
            <summary>
            Creates a New Blank Node with a user-defined Blank Node ID
            </summary>
            <param name="nodeId">Node ID to use</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.CreateLiteralNode(System.String)">
            <summary>
            Creates a New Literal Node with the given Value
            </summary>
            <param name="literal">String value of the Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.CreateLiteralNode(System.String,System.String)">
            <summary>
            Creates a New Literal Node with the given Value and Language Specifier
            </summary>
            <param name="literal">String value of the Literal</param>
            <param name="langspec">Language Specifier of the Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.CreateLiteralNode(System.String,System.Uri)">
            <summary>
            Creates a new Literal Node with the given Value and Data Type
            </summary>
            <param name="literal">String value of the Literal</param>
            <param name="datatype">URI of the Data Type</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.CreateUriNode">
            <summary>
            Creates a new URI Node that refers to the Base Uri of the Graph
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.CreateUriNode(System.Uri)">
            <summary>
            Creates a new URI Node with the given URI
            </summary>
            <param name="uri">URI for the Node</param>
            <returns></returns>
            <remarks>
            Generally we expect to be passed an absolute URI, while relative URIs are permitted the behaviour is less well defined.  If there is a Base URI defined for the Graph then relative URIs will be automatically resolved against that Base, if the Base URI is not defined then relative URIs will be left as is.  In this case issues may occur when trying to serialize the data or when accurate round tripping is required.
            </remarks>
        </member>
        <member name="M:VDS.RDF.BaseGraph.CreateUriNode(System.String)">
            <summary>
            Creates a new URI Node with the given QName
            </summary>
            <param name="qname">QName for the Node</param>
            <returns></returns>
            <remarks>Internally the Graph will resolve the QName to a full URI, throws an RDF Exception when this is not possible</remarks>
        </member>
        <member name="M:VDS.RDF.BaseGraph.CreateVariableNode(System.String)">
            <summary>
            Creates a new Variable Node
            </summary>
            <param name="varname">Variable Name</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.CreateGraphLiteralNode">
            <summary>
            Creates a new Graph Literal Node with its value being an Empty Subgraph
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.CreateGraphLiteralNode(VDS.RDF.IGraph)">
            <summary>
            Creates a new Graph Literal Node with its value being the given Subgraph
            </summary>
            <param name="subgraph">Subgraph this Node represents</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.GetBlankNode(System.String)">
            <summary>
            Returns the Blank Node with the given Identifier
            </summary>
            <param name="nodeId">The Identifier of the Blank Node to select</param>
            <returns>Either the Blank Node or null if no Node with the given Identifier exists</returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.GetLiteralNode(System.String,System.String)">
            <summary>
            Returns the LiteralNode with the given Value in the given Language if it exists
            </summary>
            <param name="literal">The literal value of the Node to select</param>
            <param name="langspec">The Language Specifier for the Node to select</param>
            <returns>Either the LiteralNode Or null if no Node with the given Value and Language Specifier exists</returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.GetLiteralNode(System.String)">
            <summary>
            Returns the LiteralNode with the given Value if it exists
            </summary>
            <param name="literal">The literal value of the Node to select</param>
            <returns>Either the LiteralNode Or null if no Node with the given Value exists</returns>
            <remarks>The LiteralNode in the Graph must have no Language or DataType set</remarks>
        </member>
        <member name="M:VDS.RDF.BaseGraph.GetLiteralNode(System.String,System.Uri)">
            <summary>
            Returns the LiteralNode with the given Value and given Data Type if it exists
            </summary>
            <param name="literal">The literal value of the Node to select</param>
            <param name="datatype">The Uri for the Data Type of the Literal to select</param>
            <returns>Either the LiteralNode Or null if no Node with the given Value and Data Type exists</returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.GetUriNode(System.String)">
            <summary>
            Returns the UriNode with the given QName if it exists
            </summary>
            <param name="qname">The QName of the Node to select</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.GetUriNode(System.Uri)">
            <summary>
            Returns the UriNode with the given Uri if it exists
            </summary>
            <param name="uri">The Uri of the Node to select</param>
            <returns>Either the UriNode Or null if no Node with the given Uri exists</returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.GetTriples(System.Uri)">
            <summary>
            Gets all the Triples involving the given Uri
            </summary>
            <param name="uri">The Uri to find Triples involving</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.GetTriples(VDS.RDF.INode)">
            <summary>
            Gets all the Triples involving the given Node
            </summary>
            <param name="n">The Node to find Triples involving</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.GetTriplesWithObject(System.Uri)">
            <summary>
            Gets all the Triples with the given Uri as the Object
            </summary>
            <param name="u">The Uri to find Triples with it as the Object</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.GetTriplesWithObject(VDS.RDF.INode)">
            <summary>
            Gets all the Triples with the given Node as the Object
            </summary>
            <param name="n">The Node to find Triples with it as the Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.GetTriplesWithPredicate(VDS.RDF.INode)">
            <summary>
            Gets all the Triples with the given Node as the Predicate
            </summary>
            <param name="n">The Node to find Triples with it as the Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.GetTriplesWithPredicate(System.Uri)">
            <summary>
            Gets all the Triples with the given Uri as the Predicate
            </summary>
            <param name="u">The Uri to find Triples with it as the Predicate</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.GetTriplesWithSubject(VDS.RDF.INode)">
            <summary>
            Gets all the Triples with the given Node as the Subject
            </summary>
            <param name="n">The Node to find Triples with it as the Subject</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.GetTriplesWithSubject(System.Uri)">
            <summary>
            Gets all the Triples with the given Uri as the Subject
            </summary>
            <param name="u">The Uri to find Triples with it as the Subject</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.GetTriplesWithSubjectPredicate(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Selects all Triples with the given Subject and Predicate
            </summary>
            <param name="subj">Subject</param>
            <param name="pred">Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.GetTriplesWithSubjectObject(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Selects all Triples with the given Subject and Object
            </summary>
            <param name="subj">Subject</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.GetTriplesWithPredicateObject(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Selects all Triples with the given Predicate and Object
            </summary>
            <param name="pred">Predicate</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.ContainsTriple(VDS.RDF.Triple)">
            <summary>
            Gets whether a given Triple exists in this Graph
            </summary>
            <param name="t">Triple to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.Merge(VDS.RDF.IGraph)">
            <summary>
            Merges another Graph into the current Graph
            </summary>
            <param name="g">Graph to Merge into this Graph</param>
            <remarks>The Graph on which you invoke this method will preserve its Blank Node IDs while the Blank Nodes from the Graph being merged in will be given new IDs as required in the scope of this Graph.</remarks>
        </member>
        <member name="M:VDS.RDF.BaseGraph.Merge(VDS.RDF.IGraph,System.Boolean)">
            <summary>
            Merges another Graph into the current Graph
            </summary>
            <param name="g">Graph to Merge into this Graph</param>
            <param name="keepOriginalGraphUri">Indicates that the Merge should preserve the Graph URIs of Nodes so they refer to the Graph they originated in</param>
            <remarks>
            <para>
            The Graph on which you invoke this method will preserve its Blank Node IDs while the Blank Nodes from the Graph being merged in will be given new IDs as required in the scope of this Graph.
            </para>
            <para>
            The Graph will raise the <see cref="E:VDS.RDF.BaseGraph.MergeRequested">MergeRequested</see> event before the Merge operation which gives any event handlers the oppurtunity to cancel this event.  When the Merge operation is completed the <see cref="E:VDS.RDF.BaseGraph.Merged">Merged</see> event is raised
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.BaseGraph.Equals(System.Object)">
            <summary>
            Determines whether a Graph is equal to another Object
            </summary>
            <param name="obj">Object to test</param>
            <returns></returns>
            <remarks>
            <para>
            A Graph can only be equal to another Object which is an <see cref="T:VDS.RDF.IGraph">IGraph</see>
            </para>
            <para>
            Graph Equality is determined by a somewhat complex algorithm which is explained in the remarks of the other overload for Equals
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.BaseGraph.Equals(VDS.RDF.IGraph,System.Collections.Generic.Dictionary{VDS.RDF.INode,VDS.RDF.INode}@)">
            <summary>
            Determines whether this Graph is equal to the given Graph
            </summary>
            <param name="g">Graph to test for equality</param>
            <param name="mapping">Mapping of Blank Nodes iff the Graphs are equal and contain some Blank Nodes</param>
            <returns></returns>
            <remarks>
            See <see cref="T:VDS.RDF.GraphMatcher"/> for documentation of the equality algorithm used.
            </remarks>
        </member>
        <member name="M:VDS.RDF.BaseGraph.IsSubGraphOf(VDS.RDF.IGraph)">
            <summary>
            Checks whether this Graph is a sub-graph of the given Graph
            </summary>
            <param name="g">Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.IsSubGraphOf(VDS.RDF.IGraph,System.Collections.Generic.Dictionary{VDS.RDF.INode,VDS.RDF.INode}@)">
            <summary>
            Checks whether this Graph is a sub-graph of the given Graph
            </summary>
            <param name="g">Graph</param>
            <param name="mapping">Mapping of Blank Nodes</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.HasSubGraph(VDS.RDF.IGraph)">
            <summary>
            Checks whether this Graph has the given Graph as a sub-graph
            </summary>
            <param name="g">Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.HasSubGraph(VDS.RDF.IGraph,System.Collections.Generic.Dictionary{VDS.RDF.INode,VDS.RDF.INode}@)">
            <summary>
            Checks whether this Graph has the given Graph as a sub-graph
            </summary>
            <param name="g">Graph</param>
            <param name="mapping">Mapping of Blank Nodes</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.Difference(VDS.RDF.IGraph)">
            <summary>
            Computes the Difference between this Graph the given Graph
            </summary>
            <param name="g">Graph</param>
            <returns></returns>
            <remarks>
            <para>
            Produces a report which shows the changes that must be made to this Graph to produce the given Graph
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.BaseGraph.ResolveQName(System.String)">
            <summary>
            Helper function for Resolving QNames to URIs
            </summary>
            <param name="qname">QName to resolve to a Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.GetNextBlankNodeID">
            <summary>
            Creates a new unused Blank Node ID and returns it
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.OnTripleAsserted(System.Object,VDS.RDF.TripleEventArgs)">
            <summary>
            Event Handler which handles the <see cref="E:VDS.RDF.BaseTripleCollection.TripleAdded">Triple Added</see> event from the underlying Triple Collection by raising the Graph's <see cref="E:VDS.RDF.BaseGraph.TripleAsserted">TripleAsserted</see> event
            </summary>
            <param name="sender">Sender</param>
            <param name="args">Triple Event Arguments</param>
        </member>
        <member name="M:VDS.RDF.BaseGraph.RaiseTripleAsserted(VDS.RDF.TripleEventArgs)">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.BaseGraph.TripleAsserted">Triple Asserted</see> event manually
            </summary>
            <param name="args">Triple Event Arguments</param>
        </member>
        <member name="M:VDS.RDF.BaseGraph.RaiseTripleAsserted(VDS.RDF.Triple)">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.BaseGraph.TripleAsserted">Triple Asserted</see> event manually
            </summary>
            <param name="t">Triple</param>
        </member>
        <member name="M:VDS.RDF.BaseGraph.OnTripleRetracted(System.Object,VDS.RDF.TripleEventArgs)">
            <summary>
            Event Handler which handles the <see cref="E:VDS.RDF.BaseTripleCollection.TripleRemoved">Triple Removed</see> event from the underlying Triple Collection by raising the Graph's <see cref="E:VDS.RDF.BaseGraph.TripleRetracted">Triple Retracted</see> event
            </summary>
            <param name="sender">Sender</param>
            <param name="args">Triple Event Arguments</param>
        </member>
        <member name="M:VDS.RDF.BaseGraph.RaiseTripleRetracted(VDS.RDF.TripleEventArgs)">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.BaseGraph.TripleRetracted">Triple Retracted</see> event manually
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:VDS.RDF.BaseGraph.RaiseTripleRetracted(VDS.RDF.Triple)">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.BaseGraph.TripleRetracted">Triple Retracted</see> event manually
            </summary>
            <param name="t">Triple</param>
        </member>
        <member name="M:VDS.RDF.BaseGraph.RaiseGraphChanged(VDS.RDF.TripleEventArgs)">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.BaseGraph.Changed">Changed</see> event
            </summary>
            <param name="args">Triple Event Arguments</param>
        </member>
        <member name="M:VDS.RDF.BaseGraph.RaiseGraphChanged">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.BaseGraph.Changed">Changed</see> event
            </summary>
        </member>
        <member name="M:VDS.RDF.BaseGraph.RaiseClearRequested">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.BaseGraph.ClearRequested">Clear Requested</see> event and returning whether any of the Event Handlers cancelled the operation
            </summary>
            <returns>True if the operation can continue, false if it should be aborted</returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.RaiseCleared">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.BaseGraph.Cleared">Cleared</see> event
            </summary>
        </member>
        <member name="M:VDS.RDF.BaseGraph.RaiseMergeRequested">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.BaseGraph.MergeRequested">Merge Requested</see> event and returning whether any of the Event Handlers cancelled the operation
            </summary>
            <returns>True if the operation can continue, false if it should be aborted</returns>
        </member>
        <member name="M:VDS.RDF.BaseGraph.RaiseMerged">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.BaseGraph.Merged">Merged</see> event
            </summary>
        </member>
        <member name="M:VDS.RDF.BaseGraph.AttachEventHandlers(VDS.RDF.BaseTripleCollection)">
            <summary>
            Helper method for attaching the necessary event Handlers to a Triple Collection
            </summary>
            <param name="tripleCollection">Triple Collection</param>
            <remarks>
            May be useful if you replace the Triple Collection after instantiation e.g. as done in <see cref="T:VDS.RDF.Query.SparqlView">SparqlView</see>'s
            </remarks>
        </member>
        <member name="M:VDS.RDF.BaseGraph.DetachEventHandlers(VDS.RDF.BaseTripleCollection)">
            <summary>
            Helper method for detaching the necessary event Handlers from a Triple Collection
            </summary>
            <param name="tripleCollection">Triple Collection</param>
            <remarks>
            May be useful if you replace the Triple Collection after instantiation e.g. as done in <see cref="T:VDS.RDF.Query.SparqlView">SparqlView</see>'s
            </remarks>
        </member>
        <member name="M:VDS.RDF.BaseGraph.Dispose">
            <summary>
            Disposes of a Graph
            </summary>
        </member>
        <member name="P:VDS.RDF.BaseGraph.Triples">
            <summary>
            Gets the set of Triples described in this Graph
            </summary>
        </member>
        <member name="P:VDS.RDF.BaseGraph.Nodes">
            <summary>
            Gets the set of Nodes which make up this Graph
            </summary>
        </member>
        <member name="P:VDS.RDF.BaseGraph.NamespaceMap">
            <summary>
            Gets the Namespace Mapper for this Graph which contains all in use Namespace Prefixes and their URIs
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.BaseGraph.BaseUri">
            <summary>
            Gets the current Base Uri for the Graph
            </summary>
            <remarks>
            This value may be changed during Graph population depending on whether the Concrete syntax allows the Base Uri to be changed and how the Parser handles this
            </remarks>
        </member>
        <member name="P:VDS.RDF.BaseGraph.IsEmpty">
            <summary>
            Gets whether a Graph is Empty ie. Contains No Triples or Nodes
            </summary>
        </member>
        <member name="E:VDS.RDF.BaseGraph.TripleAsserted">
            <summary>
            Event which is raised when a Triple is asserted in the Graph
            </summary>
        </member>
        <member name="E:VDS.RDF.BaseGraph.TripleRetracted">
            <summary>
            Event which is raised when a Triple is retracted from the Graph
            </summary>
        </member>
        <member name="E:VDS.RDF.BaseGraph.Changed">
            <summary>
            Event which is raised when the Graph contents change
            </summary>
        </member>
        <member name="E:VDS.RDF.BaseGraph.ClearRequested">
            <summary>
            Event which is raised just before the Graph is cleared of its contents
            </summary>
        </member>
        <member name="E:VDS.RDF.BaseGraph.Cleared">
            <summary>
            Event which is raised after the Graph is cleared of its contents
            </summary>
        </member>
        <member name="E:VDS.RDF.BaseGraph.MergeRequested">
            <summary>
            Event which is raised when a Merge operation is requested on the Graph
            </summary>
        </member>
        <member name="E:VDS.RDF.BaseGraph.Merged">
            <summary>
            Event which is raised when a Merge operation is completed on the Graph
            </summary>
        </member>
        <member name="T:VDS.RDF.BaseTripleStore">
            <summary>
            Abstract Base Class for a Triple Store
            </summary>
        </member>
        <member name="T:VDS.RDF.ITripleStore">
            <summary>
            Interface for Triple Stores
            </summary>
            <remarks>A Triple Store may be a representation of some storage backed actual store or just a temporary collection of Graphs created for working with.  Note that an implementation is not required to provide a definitive view of a Triple Store and may only provide a limited/partial snapshot of the underlying store.  Check the documentation for the various implementations to see what type of view of a Triple Store they actually provide.</remarks>
        </member>
        <member name="M:VDS.RDF.ITripleStore.Add(VDS.RDF.IGraph)">
            <summary>
            Adds a Graph into the Triple Store
            </summary>
            <param name="g">Graph to add</param>
        </member>
        <member name="M:VDS.RDF.ITripleStore.Add(VDS.RDF.IGraph,System.Boolean)">
            <summary>
            Adds a Graph into the Triple Store
            </summary>
            <param name="g">Graph to add</param>
            <param name="mergeIfExists">Controls whether the Graph should be merged with an existing Graph of the same Uri if it already exists in the Triple Store</param>
        </member>
        <member name="M:VDS.RDF.ITripleStore.AddFromUri(System.Uri)">
            <summary>
            Adds a Graph into the Triple Store by dereferencing the Graph Uri to get the RDF and then load the resulting Graph into the Triple Store
            </summary>
            <param name="graphUri">Uri of the Graph to be added</param>
        </member>
        <member name="M:VDS.RDF.ITripleStore.AddFromUri(System.Uri,System.Boolean)">
            <summary>
            Adds a Graph into the Triple Store by dereferencing the Graph Uri to get the RDF and then load the resulting Graph into the Triple Store
            </summary>
            <param name="graphUri">Uri of the Graph to be added</param>
            <param name="mergeIfExists">Controls whether the Graph should be merged with an existing Graph of the same Uri if it already exists in the Triple Store</param>
        </member>
        <member name="M:VDS.RDF.ITripleStore.Remove(System.Uri)">
            <summary>
            Removes a Graph from the Triple Store
            </summary>
            <param name="graphUri">Graph Uri of the Graph to remove</param>
        </member>
        <member name="M:VDS.RDF.ITripleStore.HasGraph(System.Uri)">
            <summary>
            Checks whether the Graph with the given Uri is in this Triple Store
            </summary>
            <param name="graphUri">Graph Uri</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.ITripleStore.IsEmpty">
            <summary>
            Gets whether a TripleStore is Empty
            </summary>
        </member>
        <member name="P:VDS.RDF.ITripleStore.Graphs">
            <summary>
            Gets the Graph Collection of Graphs in this Triple Store
            </summary>
        </member>
        <member name="P:VDS.RDF.ITripleStore.Triples">
            <summary>
            Gets all the Triples in the Triple Store which are currently loaded in memory (see remarks)
            </summary>
            <remarks>Since a Triple Store object may represent only a snapshot of the underlying Store evaluating this enumerator may only return some of the Triples in the Store and may depending on specific Triple Store return nothing.</remarks>
        </member>
        <member name="P:VDS.RDF.ITripleStore.Item(System.Uri)">
            <summary>
            Gets a Graph from the Triple Store;
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
        </member>
        <member name="E:VDS.RDF.ITripleStore.GraphAdded">
            <summary>
            Event which is raised when a Graph is added
            </summary>
        </member>
        <member name="E:VDS.RDF.ITripleStore.GraphRemoved">
            <summary>
            Event which is raised when a Graph is removed
            </summary>
        </member>
        <member name="E:VDS.RDF.ITripleStore.GraphChanged">
            <summary>
            Event which is raised when a Graphs contents changes
            </summary>
        </member>
        <member name="E:VDS.RDF.ITripleStore.GraphCleared">
            <summary>
            Event which is raised when a Graph is cleared
            </summary>
        </member>
        <member name="E:VDS.RDF.ITripleStore.GraphMerged">
            <summary>
            Event which is raised when a Graph has a merge operation performed on it
            </summary>
        </member>
        <member name="F:VDS.RDF.BaseTripleStore._graphs">
            <summary>
            Collection of Graphs that comprise the Triple Store
            </summary>
        </member>
        <member name="F:VDS.RDF.BaseTripleStore.GraphAddedHandler">
            <summary>
            Event Handler definitions
            </summary>
        </member>
        <member name="F:VDS.RDF.BaseTripleStore.GraphRemovedHandler">
            <summary>
            Event Handler definitions
            </summary>
        </member>
        <member name="F:VDS.RDF.BaseTripleStore.GraphChangedHandler">
            <summary>
            Event Handler definitions
            </summary>
        </member>
        <member name="F:VDS.RDF.BaseTripleStore.GraphMergedHandler">
            <summary>
            Event Handler definitions
            </summary>
        </member>
        <member name="F:VDS.RDF.BaseTripleStore.GraphClearedHandler">
            <summary>
            Event Handler definitions
            </summary>
        </member>
        <member name="M:VDS.RDF.BaseTripleStore.#ctor(VDS.RDF.BaseGraphCollection)">
            <summary>
            Creates a new Base Triple Store
            </summary>
            <param name="graphCollection">Graph Collection to use</param>
        </member>
        <member name="M:VDS.RDF.BaseTripleStore.Add(VDS.RDF.IGraph)">
            <summary>
            Adds a Graph into the Triple Store
            </summary>
            <param name="g">Graph to add</param>
        </member>
        <member name="M:VDS.RDF.BaseTripleStore.Add(VDS.RDF.IGraph,System.Boolean)">
            <summary>
            Adds a Graph into the Triple Store using the chosen Merging Behaviour
            </summary>
            <param name="g">Graph to add</param>
            <param name="mergeIfExists">Whether the Graph should be merged with an existing Graph with the same Base Uri</param>
        </member>
        <member name="M:VDS.RDF.BaseTripleStore.AddFromUri(System.Uri)">
            <summary>
            Adds a Graph into the Triple Store which is retrieved from the given Uri
            </summary>
            <param name="graphUri">Uri of the Graph to load</param>
        </member>
        <member name="M:VDS.RDF.BaseTripleStore.AddFromUri(System.Uri,System.Boolean)">
            <summary>
            Adds a Graph into the Triple Store which is retrieved from the given Uri using the chosen Merging Behaviour
            </summary>
            <param name="graphUri">Graph to add</param>
            <param name="mergeIfExists">Whether the Graph should be merged with an existing Graph with the same Base Uri</param>
            <remarks>
            <strong>Important:</strong> Under Silverlight/Windows Phone 7 this will happen asynchronously so the Graph may not be immediatedly available in the store
            </remarks>
        </member>
        <member name="M:VDS.RDF.BaseTripleStore.Remove(System.Uri)">
            <summary>
            Removes a Graph from the Triple Store
            </summary>
            <param name="graphUri">Uri of the Graph to Remove</param>
        </member>
        <member name="M:VDS.RDF.BaseTripleStore.HasGraph(System.Uri)">
            <summary>
            Checks whether a Graph with the given Base Uri exists in the Triple Store
            </summary>
            <param name="graphUri">Graph Uri</param>
            <returns>True if the Graph exists in the Triple Store</returns>
        </member>
        <member name="M:VDS.RDF.BaseTripleStore.RaiseGraphAdded(VDS.RDF.IGraph)">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.BaseTripleStore.GraphAdded">Graph Added</see> event manually
            </summary>
            <param name="g">Graph</param>
        </member>
        <member name="M:VDS.RDF.BaseTripleStore.RaiseGraphAdded(VDS.RDF.GraphEventArgs)">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.BaseTripleStore.GraphAdded">Graph Added</see> event manually
            </summary>
            <param name="args">Graph Event Arguments</param>
        </member>
        <member name="M:VDS.RDF.BaseTripleStore.OnGraphAdded(System.Object,VDS.RDF.GraphEventArgs)">
            <summary>
            Event Handler which handles the <see cref="E:VDS.RDF.BaseGraphCollection.GraphAdded">Graph Added</see> event from the underlying Graph Collection and raises the Triple Store's <see cref="E:VDS.RDF.BaseTripleStore.GraphAdded">Graph Added</see> event
            </summary>
            <param name="sender">Sender</param>
            <param name="args">Graph Event Arguments</param>
            <remarks>Override this method if your Triple Store implementation wishes to take additional actions when a Graph is added to the Store</remarks>
        </member>
        <member name="M:VDS.RDF.BaseTripleStore.RaiseGraphRemoved(VDS.RDF.IGraph)">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.BaseTripleStore.GraphRemoved">Graph Removed</see> event manually
            </summary>
            <param name="g">Graph</param>
        </member>
        <member name="M:VDS.RDF.BaseTripleStore.RaiseGraphRemoved(VDS.RDF.GraphEventArgs)">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.BaseTripleStore.GraphRemoved">Graph Removed</see> event manually
            </summary>
            <param name="args">Graph Event Arguments</param>
        </member>
        <member name="M:VDS.RDF.BaseTripleStore.OnGraphRemoved(System.Object,VDS.RDF.GraphEventArgs)">
            <summary>
            Event Handler which handles the <see cref="E:VDS.RDF.BaseGraphCollection.GraphRemoved">Graph Removed</see> event from the underlying Graph Collection and raises the Triple Stores's <see cref="E:VDS.RDF.BaseTripleStore.GraphRemoved">Graph Removed</see> event
            </summary>
            <param name="sender">Sender</param>
            <param name="args">Graph Event Arguments</param>
        </member>
        <member name="M:VDS.RDF.BaseTripleStore.RaiseGraphChanged(VDS.RDF.GraphEventArgs)">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.BaseTripleStore.GraphChanged">Graph Changed</see> event manually
            </summary>
            <param name="args">Graph Event Arguments</param>
        </member>
        <member name="M:VDS.RDF.BaseTripleStore.OnGraphChanged(System.Object,VDS.RDF.GraphEventArgs)">
            <summary>
            Event Handler which handles the <see cref="E:VDS.RDF.IGraph.Changed">Changed</see> event of the contained Graphs by raising the Triple Store's <see cref="E:VDS.RDF.BaseTripleStore.GraphChanged">Graph Changed</see> event
            </summary>
            <param name="sender">Sender</param>
            <param name="args">Graph Event Arguments</param>
        </member>
        <member name="M:VDS.RDF.BaseTripleStore.RaiseGraphChanged(VDS.RDF.IGraph)">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.BaseTripleStore.GraphChanged">Graph Changed</see> event manually
            </summary>
            <param name="g">Graph</param>
        </member>
        <member name="M:VDS.RDF.BaseTripleStore.RaiseGraphCleared(VDS.RDF.GraphEventArgs)">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.BaseTripleStore.GraphCleared">Graph Cleared</see> event manually
            </summary>
            <param name="args">Graph Event Arguments</param>
        </member>
        <member name="M:VDS.RDF.BaseTripleStore.OnGraphCleared(System.Object,VDS.RDF.GraphEventArgs)">
            <summary>
            Event Handler which handles the <see cref="E:VDS.RDF.IGraph.Cleared">Cleared</see> event of the contained Graphs by raising the Triple Stores's <see cref="E:VDS.RDF.BaseTripleStore.GraphCleared">Graph Cleared</see> event
            </summary>
            <param name="sender">Sender</param>
            <param name="args">Graph Event Arguments</param>
        </member>
        <member name="M:VDS.RDF.BaseTripleStore.RaiseGraphMerged(VDS.RDF.GraphEventArgs)">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.BaseTripleStore.GraphMerged">Graph Merged</see> event manually
            </summary>
            <param name="args">Graph Event Arguments</param>
        </member>
        <member name="M:VDS.RDF.BaseTripleStore.OnGraphMerged(System.Object,VDS.RDF.GraphEventArgs)">
            <summary>
            Event Handler which handles the <see cref="E:VDS.RDF.IGraph.Merged">Merged</see> event of the contained Graphs by raising the Triple Store's <see cref="E:VDS.RDF.BaseTripleStore.GraphMerged">Graph Merged</see> event
            </summary>
            <param name="sender">Sender</param>
            <param name="args">Graph Event Arguments</param>
        </member>
        <member name="M:VDS.RDF.BaseTripleStore.AttachEventHandlers(VDS.RDF.IGraph)">
            <summary>
            Helper method which attaches the Triple Store's Event Handlers to the relevant events of a Graph
            </summary>
            <param name="g">Graph</param>
        </member>
        <member name="M:VDS.RDF.BaseTripleStore.DetachEventHandlers(VDS.RDF.IGraph)">
            <summary>
            Helper method which detaches the Triple Store's Event Handlers from the relevant events of a Graph
            </summary>
            <param name="g"></param>
        </member>
        <member name="M:VDS.RDF.BaseTripleStore.Dispose">
            <summary>
            Disposes of the Triple Store
            </summary>
            <remarks>Derived classes must override this to implement required disposal actions</remarks>
        </member>
        <member name="P:VDS.RDF.BaseTripleStore.IsEmpty">
            <summary>
            Gets whether the Triple Store is empty
            </summary>
        </member>
        <member name="P:VDS.RDF.BaseTripleStore.Graphs">
            <summary>
            Gets the Collection of Graphs that comprise this Triple Store
            </summary>
        </member>
        <member name="P:VDS.RDF.BaseTripleStore.Triples">
            <summary>
            Gets all the Triples in the Triple Store
            </summary>
        </member>
        <member name="P:VDS.RDF.BaseTripleStore.Item(System.Uri)">
            <summary>
            Gets the Graph with the given URI
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
        </member>
        <member name="E:VDS.RDF.BaseTripleStore.GraphAdded">
            <summary>
            Event which is raised when a Graph is added
            </summary>
        </member>
        <member name="E:VDS.RDF.BaseTripleStore.GraphRemoved">
            <summary>
            Event which is raised when a Graph is removed
            </summary>
        </member>
        <member name="E:VDS.RDF.BaseTripleStore.GraphChanged">
            <summary>
            Event which is raised when a Graphs contents changes
            </summary>
        </member>
        <member name="E:VDS.RDF.BaseTripleStore.GraphCleared">
            <summary>
            Event which is raised when a Graph is cleared
            </summary>
        </member>
        <member name="E:VDS.RDF.BaseTripleStore.GraphMerged">
            <summary>
            Event which is raised when a Graph has a merge operation performed on it
            </summary>
        </member>
        <member name="T:VDS.RDF.SubTreeIndexedTripleCollection">
            <summary>
            An indexed triple collection that uses our <see cref="T:VDS.Common.Collections.MultiDictionary`2"/> and <see cref="T:VDS.Common.Trees.BinaryTree`3"/> implementations under the hood for the index structures
            </summary>
            <remarks>
            <para>
            A variation on <see cref="T:VDS.RDF.TreeIndexedTripleCollection"/> which structures the indexes slightly differently, this may give differing performance and reduced memory usage in some scenarios.
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.BaseTripleCollection">
            <summary>
            Abstract Base Class for Triple Collections
            </summary>
            <remarks>
            Designed to allow the underlying storage of a Triple Collection to be changed at a later date without affecting classes that use it.
            </remarks>
        </member>
        <member name="M:VDS.RDF.BaseTripleCollection.Add(VDS.RDF.Triple)">
            <summary>
            Adds a Triple to the Collection
            </summary>
            <param name="t">Triple to add</param>
            <remarks>Adding a Triple that already exists should be permitted though it is not necessary to persist the duplicate to underlying storage</remarks>
        </member>
        <member name="M:VDS.RDF.BaseTripleCollection.Contains(VDS.RDF.Triple)">
            <summary>
            Determines whether a given Triple is in the Triple Collection
            </summary>
            <param name="t">The Triple to test</param>
            <returns>True if the Triple already exists in the Triple Collection</returns>
        </member>
        <member name="M:VDS.RDF.BaseTripleCollection.Delete(VDS.RDF.Triple)">
            <summary>
            Deletes a Triple from the Collection
            </summary>
            <param name="t">Triple to remove</param>
            <remarks>Deleting something that doesn't exist should have no effect and give no error</remarks>
        </member>
        <member name="M:VDS.RDF.BaseTripleCollection.WithSubject(VDS.RDF.INode)">
            <summary>
            Gets all the Triples with the given Subject
            </summary>
            <param name="subj">ubject to lookup</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseTripleCollection.WithPredicate(VDS.RDF.INode)">
            <summary>
            Gets all the Triples with the given Predicate
            </summary>
            <param name="pred">Predicate to lookup</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseTripleCollection.WithObject(VDS.RDF.INode)">
            <summary>
            Gets all the Triples with the given Object
            </summary>
            <param name="obj">Object to lookup</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseTripleCollection.WithSubjectPredicate(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets all the Triples with the given Subject Predicate pair
            </summary>
            <param name="subj">Subject to lookup</param>
            <param name="pred">Predicate to lookup</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseTripleCollection.WithPredicateObject(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets all the Triples with the given Predicate Object pair
            </summary>
            <param name="pred">Predicate to lookup</param>
            <param name="obj">Object to lookup</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseTripleCollection.WithSubjectObject(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets all the Triples with the given Subject Object pair
            </summary>
            <param name="subj">Subject to lookup</param>
            <param name="obj">Object to lookup</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseTripleCollection.Dispose">
            <summary>
            Diposes of a Triple Collection
            </summary>
        </member>
        <member name="M:VDS.RDF.BaseTripleCollection.GetEnumerator">
            <summary>
            Gets the typed Enumerator for the Triple Collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseTripleCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets the non-generic Enumerator for the Triple Collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseTripleCollection.RaiseTripleAdded(VDS.RDF.Triple)">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.BaseTripleCollection.TripleAdded">Triple Added</see> event
            </summary>
            <param name="t">Triple</param>
        </member>
        <member name="M:VDS.RDF.BaseTripleCollection.RaiseTripleRemoved(VDS.RDF.Triple)">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.BaseTripleCollection.TripleRemoved">Triple Removed</see> event
            </summary>
            <param name="t">Triple</param>
        </member>
        <member name="P:VDS.RDF.BaseTripleCollection.Count">
            <summary>
            Gets the Number of Triples in the Triple Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.BaseTripleCollection.Item(VDS.RDF.Triple)">
            <summary>
            Gets the given Triple
            </summary>
            <param name="t">Triple to retrieve</param>
            <returns></returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if the given Triple doesn't exist</exception>
        </member>
        <member name="P:VDS.RDF.BaseTripleCollection.ObjectNodes">
            <summary>
            Gets all the Nodes which are Objects of Triples in the Triple Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.BaseTripleCollection.PredicateNodes">
            <summary>
            Gets all the Nodes which are Predicates of Triples in the Triple Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.BaseTripleCollection.SubjectNodes">
            <summary>
            Gets all the Nodes which are Subjects of Triples in the Triple Collection
            </summary>
        </member>
        <member name="E:VDS.RDF.BaseTripleCollection.TripleAdded">
            <summary>
            Event which occurs when a Triple is added to the Collection
            </summary>
        </member>
        <member name="E:VDS.RDF.BaseTripleCollection.TripleRemoved">
            <summary>
            Event which occurs when a Triple is removed from the Collection
            </summary>
        </member>
        <member name="M:VDS.RDF.SubTreeIndexedTripleCollection.#ctor">
            <summary>
            Creates a new Tree Indexed triple collection
            </summary>
        </member>
        <member name="M:VDS.RDF.SubTreeIndexedTripleCollection.Index(VDS.RDF.Triple)">
            <summary>
            Indexes a Triple
            </summary>
            <param name="t">Triple</param>
        </member>
        <member name="M:VDS.RDF.SubTreeIndexedTripleCollection.Index(VDS.RDF.INode,VDS.RDF.Triple,VDS.Common.Collections.MultiDictionary{VDS.RDF.INode,VDS.Common.Collections.MultiDictionary{VDS.RDF.Triple,System.Collections.Generic.List{VDS.RDF.Triple}}},System.Func{VDS.RDF.Triple,System.Int32},System.Collections.Generic.IComparer{VDS.RDF.Triple})">
            <summary>
            Helper for indexing triples
            </summary>
            <param name="n">Node to index by</param>
            <param name="t">Triple</param>
            <param name="index">Index to insert into</param>
            <param name="comparer">Comparer for the Index</param>
            <param name="hashFunc">Hash Function for the Index</param>
        </member>
        <member name="M:VDS.RDF.SubTreeIndexedTripleCollection.Unindex(VDS.RDF.Triple)">
            <summary>
            Unindexes a triple
            </summary>
            <param name="t">Triple</param>
        </member>
        <member name="M:VDS.RDF.SubTreeIndexedTripleCollection.Unindex(VDS.RDF.INode,VDS.RDF.Triple,VDS.Common.Collections.MultiDictionary{VDS.RDF.INode,VDS.Common.Collections.MultiDictionary{VDS.RDF.Triple,System.Collections.Generic.List{VDS.RDF.Triple}}})">
            <summary>
            Helper for unindexing triples
            </summary>
            <param name="n">Node to index by</param>
            <param name="t">Triple</param>
            <param name="index">Index to remove from</param>
        </member>
        <member name="M:VDS.RDF.SubTreeIndexedTripleCollection.Add(VDS.RDF.Triple)">
            <summary>
            Adds a Triple to the collection
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.SubTreeIndexedTripleCollection.Contains(VDS.RDF.Triple)">
            <summary>
            Checks whether the collection contains a given Triple
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.SubTreeIndexedTripleCollection.Delete(VDS.RDF.Triple)">
            <summary>
            Deletes a triple from the collection
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.SubTreeIndexedTripleCollection.WithObject(VDS.RDF.INode)">
            <summary>
            Gets all the triples with a given object
            </summary>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.SubTreeIndexedTripleCollection.WithPredicate(VDS.RDF.INode)">
            <summary>
            Gets all the triples with a given predicate
            </summary>
            <param name="pred">Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.SubTreeIndexedTripleCollection.WithSubject(VDS.RDF.INode)">
            <summary>
            Gets all the triples with a given subject
            </summary>
            <param name="subj">Subject</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.SubTreeIndexedTripleCollection.WithPredicateObject(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets all the triples with a given predicate and object
            </summary>
            <param name="pred">Predicate</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.SubTreeIndexedTripleCollection.WithSubjectObject(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets all the triples with a given subject and object
            </summary>
            <param name="subj">Subject</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.SubTreeIndexedTripleCollection.WithSubjectPredicate(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets all the triples with a given subject and predicate
            </summary>
            <param name="subj">Subject</param>
            <param name="pred">Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.SubTreeIndexedTripleCollection.Dispose">
            <summary>
            Disposes of the collection
            </summary>
        </member>
        <member name="M:VDS.RDF.SubTreeIndexedTripleCollection.GetEnumerator">
            <summary>
            Gets the enumerator for the collection
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.SubTreeIndexedTripleCollection.Count">
            <summary>
            Gets the count of triples in the collection
            </summary>
        </member>
        <member name="P:VDS.RDF.SubTreeIndexedTripleCollection.Item(VDS.RDF.Triple)">
            <summary>
            Gets the specific instance of a Triple in the collection
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.SubTreeIndexedTripleCollection.ObjectNodes">
            <summary>
            Gets the Object Nodes
            </summary>
        </member>
        <member name="P:VDS.RDF.SubTreeIndexedTripleCollection.PredicateNodes">
            <summary>
            Gets the Predicate Nodes
            </summary>
        </member>
        <member name="P:VDS.RDF.SubTreeIndexedTripleCollection.SubjectNodes">
            <summary>
            Gets the Subject Nodes
            </summary>
        </member>
        <member name="T:VDS.RDF.WrapperGraph">
            <summary>
            Abstract decorator for Graphs to make it easier to layer functionality on top of existing implementations
            </summary>
        </member>
        <member name="F:VDS.RDF.WrapperGraph._g">
            <summary>
            Underlying Graph this is a wrapper around
            </summary>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.#ctor">
            <summary>
            Creates a wrapper around the default Graph implementation, primarily required only for deserialization and requires that the caller call <see cref="M:VDS.RDF.WrapperGraph.AttachEventHandlers"/> to properly wire up event handling
            </summary>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.#ctor(VDS.RDF.IGraph)">
            <summary>
            Creates a new wrapper around the given Graph
            </summary>
            <param name="g">Graph</param>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.Assert(VDS.RDF.Triple)">
            <summary>
            Asserts a Triple in the Graph
            </summary>
            <param name="t">Triple</param>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.Assert(System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Asserts Triples in the Graph
            </summary>
            <param name="ts">Triples</param>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.Retract(VDS.RDF.Triple)">
            <summary>
            Retracts a Triple from the Graph
            </summary>
            <param name="t">Triple</param>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.Retract(System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Retracts Triples from the Graph
            </summary>
            <param name="ts">Triples</param>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.Clear">
            <summary>
            Clears the Graph
            </summary>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.CreateBlankNode(System.String)">
            <summary>
            Creates a new Blank Node with the given Node ID
            </summary>
            <param name="nodeId">Node ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.CreateBlankNode">
            <summary>
            Creates a new Blank Node
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.GetNextBlankNodeID">
            <summary>
            Gets the next available Blank Node ID
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.CreateGraphLiteralNode(VDS.RDF.IGraph)">
            <summary>
            Creates a new Graph Literal Node with the given sub-graph
            </summary>
            <param name="subgraph">Sub-graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.CreateGraphLiteralNode">
            <summary>
            Creates a new Graph Literal Node
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.CreateLiteralNode(System.String)">
            <summary>
            Creates a new Literal Node
            </summary>
            <param name="literal">Value</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.CreateLiteralNode(System.String,System.Uri)">
            <summary>
            Creates a new Literal Node with the given Datatype
            </summary>
            <param name="literal">Value</param>
            <param name="datatype">Datatype URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.CreateLiteralNode(System.String,System.String)">
            <summary>
            Creates a new Literal Node with the given Language
            </summary>
            <param name="literal">Value</param>
            <param name="langspec">Language</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.CreateUriNode">
            <summary>
            Creates a new URI Node that references the Graphs Base URI
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.CreateUriNode(System.String)">
            <summary>
            Creates a new URI Node from a QName
            </summary>
            <param name="qname">QName</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.CreateUriNode(System.Uri)">
            <summary>
            Creates a new URI Node
            </summary>
            <param name="uri">URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.CreateVariableNode(System.String)">
            <summary>
            Creates a new Variable Node
            </summary>
            <param name="varname">Variable Name</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.GetBlankNode(System.String)">
            <summary>
            Attempts to get the Blank Node with the given ID
            </summary>
            <param name="nodeId">Node ID</param>
            <returns>The Node if it exists or null</returns>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.GetLiteralNode(System.String,System.String)">
            <summary>
            Attempts to get the Literal Node with the given Value and Language
            </summary>
            <param name="literal">Value</param>
            <param name="langspec">Language</param>
            <returns>The Node if it exists or null</returns>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.GetLiteralNode(System.String)">
            <summary>
            Attempts to get the Literal Node with the given Value
            </summary>
            <param name="literal">Value</param>
            <returns>The Node if it exists or null</returns>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.GetLiteralNode(System.String,System.Uri)">
            <summary>
            Attempts to get the Literal Node with the given Value and Datatype
            </summary>
            <param name="literal">Value</param>
            <param name="datatype">Datatype URI</param>
            <returns>The Node if it exists or null otherwise</returns>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.GetTriples(System.Uri)">
            <summary>
            Gets all the Triples involving the given URI
            </summary>
            <param name="uri">The URI to find Triples involving</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.GetTriples(VDS.RDF.INode)">
            <summary>
            Gets all the Triples involving the given Node
            </summary>
            <param name="n">The Node to find Triples involving</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.GetTriplesWithObject(System.Uri)">
            <summary>
            Gets all the Triples with the given URI as the Object
            </summary>
            <param name="u">The URI to find Triples with it as the Object</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.GetTriplesWithObject(VDS.RDF.INode)">
            <summary>
            Gets all the Triples with the given Node as the Object
            </summary>
            <param name="n">The Node to find Triples with it as the Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.GetTriplesWithPredicate(VDS.RDF.INode)">
            <summary>
            Gets all the Triples with the given Node as the Predicate
            </summary>
            <param name="n">The Node to find Triples with it as the Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.GetTriplesWithPredicate(System.Uri)">
            <summary>
            Gets all the Triples with the given Uri as the Predicate
            </summary>
            <param name="u">The Uri to find Triples with it as the Predicate</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.GetTriplesWithSubject(VDS.RDF.INode)">
            <summary>
            Gets all the Triples with the given Node as the Subject
            </summary>
            <param name="n">The Node to find Triples with it as the Subject</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.GetTriplesWithSubject(System.Uri)">
            <summary>
            Gets all the Triples with the given Uri as the Subject
            </summary>
            <param name="u">The Uri to find Triples with it as the Subject</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.GetTriplesWithSubjectPredicate(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Selects all Triples with the given Subject and Predicate
            </summary>
            <param name="subj">Subject</param>
            <param name="pred">Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.GetTriplesWithSubjectObject(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Selects all Triples with the given Subject and Object
            </summary>
            <param name="subj">Subject</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.GetTriplesWithPredicateObject(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Selects all Triples with the given Predicate and Object
            </summary>
            <param name="pred">Predicate</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.GetUriNode(System.String)">
            <summary>
            Returns the UriNode with the given QName if it exists
            </summary>
            <param name="qname">The QName of the Node to select</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.GetUriNode(System.Uri)">
            <summary>
            Returns the UriNode with the given Uri if it exists
            </summary>
            <param name="uri">The Uri of the Node to select</param>
            <returns>Either the UriNode Or null if no Node with the given Uri exists</returns>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.ContainsTriple(VDS.RDF.Triple)">
            <summary>
            Gets whether a given Triple exists in this Graph
            </summary>
            <param name="t">Triple to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.Merge(VDS.RDF.IGraph)">
            <summary>
            Merges another Graph into the current Graph
            </summary>
            <param name="g">Graph to Merge into this Graph</param>
            <remarks>The Graph on which you invoke this method will preserve its Blank Node IDs while the Blank Nodes from the Graph being merged in will be given new IDs as required in the scope of this Graph.</remarks>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.Merge(VDS.RDF.IGraph,System.Boolean)">
            <summary>
            Merges another Graph into the current Graph
            </summary>
            <param name="g">Graph to Merge into this Graph</param>
            <param name="keepOriginalGraphUri">Indicates that the Merge should preserve the Graph URIs of Nodes so they refer to the Graph they originated in</param>
            <remarks>
            <para>
            The Graph on which you invoke this method will preserve its Blank Node IDs while the Blank Nodes from the Graph being merged in will be given new IDs as required in the scope of this Graph.
            </para>
            <para>
            The Graph will raise the <see cref="E:VDS.RDF.WrapperGraph.MergeRequested">MergeRequested</see> event before the Merge operation which gives any event handlers the oppurtunity to cancel this event.  When the Merge operation is completed the <see cref="E:VDS.RDF.WrapperGraph.Merged">Merged</see> event is raised
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.Equals(System.Object)">
            <summary>
            Determines whether a Graph is equal to another Object
            </summary>
            <param name="obj">Object to test</param>
            <returns></returns>
            <remarks>
            <para>
            A Graph can only be equal to another Object which is an <see cref="T:VDS.RDF.IGraph">IGraph</see>
            </para>
            <para>
            Graph Equality is determined by a somewhat complex algorithm which is explained in the remarks of the other overload for Equals
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.Equals(VDS.RDF.IGraph,System.Collections.Generic.Dictionary{VDS.RDF.INode,VDS.RDF.INode}@)">
            <summary>
            Determines whether this Graph is equal to the given Graph
            </summary>
            <param name="g">Graph to test for equality</param>
            <param name="mapping">Mapping of Blank Nodes iff the Graphs are equal and contain some Blank Nodes</param>
            <returns></returns>
            <remarks>
            <para>
            The algorithm used to determine Graph equality is based in part on a Iterative Vertex Classification Algorithm described in a Technical Report from HP by Jeremy J Carroll - <a href="http://www.hpl.hp.com/techreports/2001/HPL-2001-293.html">Matching RDF Graphs</a>
            </para>
            <para>
            Graph Equality is determined according to the following algorithm:
            </para>
            <ol>
            <li>If the given Graph is null Graphs are not equal</li>
            <li>If the given Graph is this Graph (as determined by Reference Equality) then Graphs are equal</li>
            <li>If the Graphs have a different number of Triples they are not equal</li>
            <li>Declare a list of Triples which are the Triples of the given Graph called <em>OtherTriples</em></li>
            <li>Declare two dictionaries of Nodes to Integers which are called <em>LocalClassification</em> and <em>OtherClassification</em></li>
            <li>For Each Triple in this Graph
                <ol>
                <li>If it is a Ground Triple and cannot be found and removed from <em>OtherTriples</em> then Graphs are not equal since the Triple does not exist in both Graphs</li>
                <li>If it contains Blank Nodes track the number of usages of this Blank Node in <em>LocalClassification</em></li>
                </ol>
            </li> 
            <li>If there are any Triples remaining in <em>OtherTriples</em> which are Ground Triples then Graphs are not equal since this Graph does not contain them</li>
            <li>If all the Triples from both Graphs were Ground Triples and there were no Blank Nodes then the Graphs are equal</li>
            <li>Iterate over the remaining Triples in <em>OtherTriples</em> and populate the <em>OtherClassification</em></li>
            <li>If the count of the two classifications is different the Graphs are not equal since there are differing numbers of Blank Nodes in the Graph</li>
            <li>Now build two additional dictionaries of Integers to Integers which are called <em>LocalDegreeClassification</em> and <em>OtherDegreeClassification</em>.  Iterate over <em>LocalClassification</em> and <em>OtherClassification</em> such that the corresponding degree classifications contain a mapping of the number of Blank Nodes with a given degree</li>
            <li>If the count of the two degree classifications is different the Graphs are not equal since there are not the same range of Blank Node degrees in both Graphs</li>
            <li>For All classifications in <em>LocalDegreeClassification</em> there must be a matching classification in <em>OtherDegreeClassification</em> else the Graphs are not equal</li>
            <li>Then build a possible mapping using the following rules:
                <ol>
                <li>Any Blank Node used only once should be mapped to an equivalent Blank Node in the other Graph.  If this is not possible then the Graphs are not equal</li>
                <li>Any Blank Node with a unique degree should be mapped to an equivalent Blank Node in the other Graph.  If this is not possible then the Graphs are not equal</li>
                <li>Keep a copy of the mapping up to this point as a Base Mapping for use as a fallback in later steps</li>
                <li>Build up lists of dependent pairs of Blank Nodes for both Graphs</li>
                <li>Use these lists to determine if there are any independent nodes not yet mapped.  These should be mapped to equivalent Blank Nodes in the other Graph, if this is not possible the Graphs are not equal</li>
                <li>Use the Dependencies and existing mappings to generate a possible mapping</li>
                <li>If a Complete Possible Mapping (there is a Mapping for each Blank Node from this Graph to the Other Graph) then test this mapping.  If it succeeds then the Graphs are equal</li>
                <li>Otherwise we now fallback to the Base Mapping and use it as a basis for Brute Forcing the possible solution space and testing every possibility until either a mapping works or we find the Graphs to be non-equal</li>
                </ol>
            </li>
            </ol>
            </remarks>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.IsSubGraphOf(VDS.RDF.IGraph)">
            <summary>
            Checks whether this Graph is a sub-graph of the given Graph
            </summary>
            <param name="g">Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.IsSubGraphOf(VDS.RDF.IGraph,System.Collections.Generic.Dictionary{VDS.RDF.INode,VDS.RDF.INode}@)">
            <summary>
            Checks whether this Graph is a sub-graph of the given Graph
            </summary>
            <param name="g">Graph</param>
            <param name="mapping">Mapping of Blank Nodes</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.HasSubGraph(VDS.RDF.IGraph)">
            <summary>
            Checks whether this Graph has the given Graph as a sub-graph
            </summary>
            <param name="g">Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.HasSubGraph(VDS.RDF.IGraph,System.Collections.Generic.Dictionary{VDS.RDF.INode,VDS.RDF.INode}@)">
            <summary>
            Checks whether this Graph has the given Graph as a sub-graph
            </summary>
            <param name="g">Graph</param>
            <param name="mapping">Mapping of Blank Nodes</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.Difference(VDS.RDF.IGraph)">
            <summary>
            Computes the Difference between this Graph the given Graph
            </summary>
            <param name="g">Graph</param>
            <returns></returns>
            <remarks>
            <para>
            Produces a report which shows the changes that must be made to this Graph to produce the given Graph
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.ResolveQName(System.String)">
            <summary>
            Helper function for Resolving QNames to URIs
            </summary>
            <param name="qname">QName to resolve to a Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.OnTripleAsserted(System.Object,VDS.RDF.TripleEventArgs)">
            <summary>
            Event Handler which handles the <see cref="E:VDS.RDF.BaseTripleCollection.TripleAdded">Triple Added</see> event from the underlying Triple Collection by raising the Graph's <see cref="E:VDS.RDF.WrapperGraph.TripleAsserted">TripleAsserted</see> event
            </summary>
            <param name="sender">Sender</param>
            <param name="args">Triple Event Arguments</param>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.RaiseTripleAsserted(VDS.RDF.TripleEventArgs)">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.WrapperGraph.TripleAsserted">Triple Asserted</see> event manually
            </summary>
            <param name="args">Triple Event Arguments</param>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.RaiseTripleAsserted(VDS.RDF.Triple)">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.WrapperGraph.TripleAsserted">Triple Asserted</see> event manually
            </summary>
            <param name="t">Triple</param>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.OnTripleRetracted(System.Object,VDS.RDF.TripleEventArgs)">
            <summary>
            Event Handler which handles the <see cref="E:VDS.RDF.BaseTripleCollection.TripleRemoved">Triple Removed</see> event from the underlying Triple Collection by raising the Graph's <see cref="E:VDS.RDF.WrapperGraph.TripleRetracted">Triple Retracted</see> event
            </summary>
            <param name="sender">Sender</param>
            <param name="args">Triple Event Arguments</param>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.RaiseTripleRetracted(VDS.RDF.TripleEventArgs)">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.WrapperGraph.TripleRetracted">Triple Retracted</see> event manually
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.RaiseTripleRetracted(VDS.RDF.Triple)">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.WrapperGraph.TripleRetracted">Triple Retracted</see> event manually
            </summary>
            <param name="t">Triple</param>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.OnChanged(System.Object,VDS.RDF.GraphEventArgs)">
            <summary>
            Event handler to help propogate Graph events from the underlying graph
            </summary>
            <param name="sender">Sender</param>
            <param name="args">Arguments</param>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.RaiseGraphChanged(VDS.RDF.TripleEventArgs)">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.WrapperGraph.Changed">Changed</see> event
            </summary>
            <param name="args">Triple Event Arguments</param>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.RaiseGraphChanged">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.WrapperGraph.Changed">Changed</see> event
            </summary>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.OnClearRequested(System.Object,VDS.RDF.CancellableGraphEventArgs)">
            <summary>
            Event handler to help propogate Graph events from the underlying graph
            </summary>
            <param name="sender">Sender</param>
            <param name="args">Arguments</param>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.RaiseClearRequested(VDS.RDF.CancellableGraphEventArgs)">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.WrapperGraph.ClearRequested">Clear Requested</see> event and returning whether any of the Event Handlers cancelled the operation
            </summary>
            <returns>True if the operation can continue, false if it should be aborted</returns>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.OnCleared(System.Object,VDS.RDF.GraphEventArgs)">
            <summary>
            Event handler to help propogate Graph events from the underlying graph
            </summary>
            <param name="sender">Sender</param>
            <param name="args">Arguments</param>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.RaiseCleared">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.WrapperGraph.Cleared">Cleared</see> event
            </summary>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.OnMergeRequested(System.Object,VDS.RDF.CancellableGraphEventArgs)">
            <summary>
            Event handler to help propogate Graph events from the underlying graph
            </summary>
            <param name="sender">Sender</param>
            <param name="args">Arguments</param>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.RaiseMergeRequested(VDS.RDF.CancellableGraphEventArgs)">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.WrapperGraph.MergeRequested">Merge Requested</see> event and returning whether any of the Event Handlers cancelled the operation
            </summary>
            <returns>True if the operation can continue, false if it should be aborted</returns>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.OnMerged(System.Object,VDS.RDF.GraphEventArgs)">
            <summary>
            Event handler to help propogate Graph events from the underlying graph
            </summary>
            <param name="sender">Sender</param>
            <param name="args">Arguments</param>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.RaiseMerged">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.WrapperGraph.Merged">Merged</see> event
            </summary>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.AttachEventHandlers">
            <summary>
            Helper method for attaching the necessary event handlers to the underlying graph
            </summary>
        </member>
        <member name="M:VDS.RDF.WrapperGraph.Dispose">
            <summary>
            Disposes of the wrapper and in doing so disposes of the underlying graph
            </summary>
        </member>
        <member name="P:VDS.RDF.WrapperGraph.BaseUri">
            <summary>
            Gets/Sets the Base URI of the Graph
            </summary>
        </member>
        <member name="P:VDS.RDF.WrapperGraph.IsEmpty">
            <summary>
            Gets whether the Graph is empty
            </summary>
        </member>
        <member name="P:VDS.RDF.WrapperGraph.NamespaceMap">
            <summary>
            Gets the Namespace Map for the Graph
            </summary>
        </member>
        <member name="P:VDS.RDF.WrapperGraph.Nodes">
            <summary>
            Gets the Nodes of the Graph
            </summary>
        </member>
        <member name="P:VDS.RDF.WrapperGraph.Triples">
            <summary>
            Gets the Triple Collection for the Graph
            </summary>
        </member>
        <member name="E:VDS.RDF.WrapperGraph.TripleAsserted">
            <summary>
            Event which is raised when a Triple is asserted in the Graph
            </summary>
        </member>
        <member name="E:VDS.RDF.WrapperGraph.TripleRetracted">
            <summary>
            Event which is raised when a Triple is retracted from the Graph
            </summary>
        </member>
        <member name="E:VDS.RDF.WrapperGraph.Changed">
            <summary>
            Event which is raised when the Graph contents change
            </summary>
        </member>
        <member name="E:VDS.RDF.WrapperGraph.ClearRequested">
            <summary>
            Event which is raised just before the Graph is cleared of its contents
            </summary>
        </member>
        <member name="E:VDS.RDF.WrapperGraph.Cleared">
            <summary>
            Event which is raised after the Graph is cleared of its contents
            </summary>
        </member>
        <member name="E:VDS.RDF.WrapperGraph.MergeRequested">
            <summary>
            Event which is raised when a Merge operation is requested on the Graph
            </summary>
        </member>
        <member name="E:VDS.RDF.WrapperGraph.Merged">
            <summary>
            Event which is raised when a Merge operation is completed on the Graph
            </summary>
        </member>
        <member name="T:VDS.RDF.Extensions">
            <summary>
            Provides useful Extension Methods for use elsewhere in the Library
            </summary>
        </member>
        <member name="M:VDS.RDF.Extensions.AsEnumerable``1(``0)">
            <summary>
            Takes a single item and generates an IEnumerable containing only it
            </summary>
            <typeparam name="T">Type of the enumerable</typeparam>
            <param name="item">Item to wrap in an IEnumerable</param>
            <returns></returns>
            <remarks>
            This method taken from Stack Overflow - see <a href="http://stackoverflow.com/questions/1577822/passing-a-single-item-as-ienumerablet">here</a>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Extensions.IsDisjoint``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Determines whether the contents of two enumerables are disjoint
            </summary>
            <typeparam name="T">Type Parameter</typeparam>
            <param name="x">An Enumerable</param>
            <param name="y">Another Enumerable</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Extensions.WithSubject(System.Collections.Generic.IEnumerable{VDS.RDF.Triple},VDS.RDF.INode)">
            <summary>
            Gets the Subset of Triples from an existing Enumerable that have a given Subject
            </summary>
            <param name="ts">Enumerable of Triples</param>
            <param name="subject">Subject to match</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Extensions.WithPredicate(System.Collections.Generic.IEnumerable{VDS.RDF.Triple},VDS.RDF.INode)">
            <summary>
            Gets the Subset of Triples from an existing Enumerable that have a given Predicate
            </summary>
            <param name="ts">Enumerable of Triples</param>
            <param name="predicate">Predicate to match</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Extensions.WithObject(System.Collections.Generic.IEnumerable{VDS.RDF.Triple},VDS.RDF.INode)">
            <summary>
            Gets the Subset of Triples from an existing Enumerable that have a given Object
            </summary>
            <param name="ts">Enumerable of Triples</param>
            <param name="obj">Object to match</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Extensions.BlankNodes(System.Collections.Generic.IEnumerable{VDS.RDF.INode})">
            <summary>
            Gets the Blank Nodes
            </summary>
            <param name="ns">Nodes</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Extensions.GraphLiteralNodes(System.Collections.Generic.IEnumerable{VDS.RDF.INode})">
            <summary>
            Gets the Graph Literal Nodes
            </summary>
            <param name="ns">Nodes</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Extensions.LiteralNodes(System.Collections.Generic.IEnumerable{VDS.RDF.INode})">
            <summary>
            Gets the Literal Nodes
            </summary>
            <param name="ns">Nodes</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Extensions.UriNodes(System.Collections.Generic.IEnumerable{VDS.RDF.INode})">
            <summary>
            Gets the URI Nodes
            </summary>
            <param name="ns">Nodes</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Extensions.VariableNodes(System.Collections.Generic.IEnumerable{VDS.RDF.INode})">
            <summary>
            Gets the Variable Nodes
            </summary>
            <param name="ns">Nodes</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Extensions.GetEnhancedHashCode(System.Uri)">
            <summary>
            Gets an Enhanced Hash Code for a Uri
            </summary>
            <param name="u">Uri to get Hash Code for</param>
            <returns></returns>
            <remarks>
            The .Net <see cref="T:System.Uri">Uri</see> class Hash Code ignores the Fragment ID when computing the Hash Code which means that URIs with the same basic URI but different Fragment IDs have identical Hash Codes.  This is perfectly acceptable and sensible behaviour for normal URI usage since Fragment IDs are only relevant to the Client and not the Server.  <strong>But</strong> in the case of URIs in RDF the Fragment ID is significant and so we need in some circumstances to compute a Hash Code which includes this information.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Extensions.GetSha256Hash(System.Uri)">
            <summary>
            Gets an SHA256 Hash for a URI
            </summary>
            <param name="u">URI to get Hash Code for</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Extensions.GetSha256Hash(System.String)">
            <summary>
            Gets a SHA256 Hash for a String
            </summary>
            <param name="s">String to hash</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Extensions.Assert(VDS.RDF.IGraph,VDS.RDF.INode,VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Asserts a new Triple in the Graph
            </summary>
            <param name="g">Graph to assert in</param>
            <param name="subj">Subject</param>
            <param name="pred">Predicate</param>
            <param name="obj">Object</param>
            <remarks>Handy method which means you can assert a Triple by specifying the Subject, Predicate and Object without having to explicity declare a new Triple</remarks>
        </member>
        <member name="M:VDS.RDF.Extensions.Retract(VDS.RDF.IGraph,VDS.RDF.INode,VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Retracts a Triple from the Graph
            </summary>
            <param name="g">Graph to retract from</param>
            <param name="subj">Subject</param>
            <param name="pred">Predicate</param>
            <param name="obj">Object</param>
            <remarks>Handy method which means you can retract a Triple by specifying the Subject, Predicate and Object without having to explicity declare a new Triple</remarks>
        </member>
        <member name="M:VDS.RDF.Extensions.AssertList``1(VDS.RDF.IGraph,System.Collections.Generic.IEnumerable{``0},System.Func{``0,VDS.RDF.INode})">
            <summary>
            Asserts a list as a RDF collection and returns the node that represents the root of the RDF collection
            </summary>
            <typeparam name="T">Type of Objects</typeparam>
            <param name="g">Graph to assert in</param>
            <param name="objects">Objects to place in the collection</param>
            <param name="mapFunc">Mapping from Object Type to <see cref="T:VDS.RDF.INode">INode</see></param>
            <returns>
            Either the blank node which is the root of the collection or <strong>rdf:nil</strong> for empty collections
            </returns>
        </member>
        <member name="M:VDS.RDF.Extensions.AssertList``1(VDS.RDF.IGraph,VDS.RDF.INode,System.Collections.Generic.IEnumerable{``0},System.Func{``0,VDS.RDF.INode})">
            <summary>
            Asserts a list as a RDF collection using an existing node as the list root
            </summary>
            <typeparam name="T">Type of Objects</typeparam>
            <param name="g">Graph to assert in</param>
            <param name="listRoot">Root Node for List</param>
            <param name="objects">Objects to place in the collection</param>
            <param name="mapFunc">Mapping from Object Type to <see cref="T:VDS.RDF.INode">INode</see></param>
        </member>
        <member name="M:VDS.RDF.Extensions.AssertList(VDS.RDF.IGraph,System.Collections.Generic.IEnumerable{VDS.RDF.INode})">
            <summary>
            Asserts a list as a RDF collection and returns the node that represents the root of the RDF collection
            </summary>
            <param name="g">Graph to assert in</param>
            <param name="objects">Objects to place in the collection</param>
            <returns>
            Either the blank node which is the root of the collection or <strong>rdf:nil</strong> for empty collections
            </returns>
        </member>
        <member name="M:VDS.RDF.Extensions.AssertList(VDS.RDF.IGraph,VDS.RDF.INode,System.Collections.Generic.IEnumerable{VDS.RDF.INode})">
            <summary>
            Asserts a list as a RDF collection using an existing node as the list root
            </summary>
            <param name="g">Graph to assert in</param>
            <param name="listRoot">Root Node for List</param>
            <param name="objects">Objects to place in the collection</param>
        </member>
        <member name="M:VDS.RDF.Extensions.GetListAsTriples(VDS.RDF.IGraph,VDS.RDF.INode)">
            <summary>
            Gets all the Triples that make up a list (aka a RDF collection)
            </summary>
            <param name="g">Graph</param>
            <param name="listRoot">Root Node for List</param>
            <returns>Triples that make up the List</returns>
        </member>
        <member name="M:VDS.RDF.Extensions.GetListItems(VDS.RDF.IGraph,VDS.RDF.INode)">
            <summary>
            Gets all the Nodes which are the items of the list (aka the RDF collection)
            </summary>
            <param name="g">Graph</param>
            <param name="listRoot">Root Node for List</param>
            <returns>Nodes that are the items in the list</returns>
        </member>
        <member name="M:VDS.RDF.Extensions.GetListNodes(VDS.RDF.IGraph,VDS.RDF.INode)">
            <summary>
            Gets all the Nodes which are the intermediate nodes in the list (aka the RDF collection).  These represents the nodes used to link the actual items of the list together rather than the actual items of the list
            </summary>
            <param name="g">Graph</param>
            <param name="listRoot">Root Node for List</param>
            <returns>Nodes that are the intermediate nodes of the list</returns>
        </member>
        <member name="M:VDS.RDF.Extensions.IsListRoot(VDS.RDF.INode,VDS.RDF.IGraph)">
            <summary>
            Gets whether a given Node is valid as a List Root, this does not guarantee that the list itself is valid simply that the Node appears to be the root of a list
            </summary>
            <param name="n">Node to check</param>
            <param name="g">Graph</param>
            <returns></returns>
            <remarks>
            We consider a node to be a list root if there are no incoming rdf:rest triples and only a single outgoing rdf:first triple
            </remarks>
        </member>
        <member name="M:VDS.RDF.Extensions.GetListTail(VDS.RDF.IGraph,VDS.RDF.INode)">
            <summary>
            Gets the Node that represents the last item in the list
            </summary>
            <param name="g">Graph</param>
            <param name="listRoot">Root Node for List</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Extensions.RetractList(VDS.RDF.IGraph,VDS.RDF.INode)">
            <summary>
            Retracts a List (aka a RDF collection)
            </summary>
            <param name="g">Graph</param>
            <param name="listRoot">Root Node for List</param>
        </member>
        <member name="M:VDS.RDF.Extensions.AddToList``1(VDS.RDF.IGraph,VDS.RDF.INode,System.Collections.Generic.IEnumerable{``0},System.Func{``0,VDS.RDF.INode})">
            <summary>
            Adds new items to the end of a list (aka a RDF collection)
            </summary>
            <typeparam name="T">Type of Objects</typeparam>
            <param name="g">Graph to assert in</param>
            <param name="listRoot">Root Node for the list</param>
            <param name="objects">Objects to add to the collection</param>
            <param name="mapFunc">Mapping from Object Type to <see cref="T:VDS.RDF.INode">INode</see></param>
        </member>
        <member name="M:VDS.RDF.Extensions.AddToList(VDS.RDF.IGraph,VDS.RDF.INode,System.Collections.Generic.IEnumerable{VDS.RDF.INode})">
            <summary>
            Adds new items to the end of a list (aka a RDF collection)
            </summary>
            <param name="g">Graph to assert in</param>
            <param name="listRoot">Root Node for the list</param>
            <param name="objects">Objects to add to the collection</param>
        </member>
        <member name="M:VDS.RDF.Extensions.RemoveFromList``1(VDS.RDF.IGraph,VDS.RDF.INode,System.Collections.Generic.IEnumerable{``0},System.Func{``0,VDS.RDF.INode})">
            <summary>
            Removes the given items from a list (aka a RDF collection), if an item occurs multiple times in the list all occurrences will be removed
            </summary>
            <typeparam name="T">Type of Objects</typeparam>
            <param name="g">Graph to retract from</param>
            <param name="listRoot">Root Node for the list</param>
            <param name="objects">Objects to remove from the collection</param>
            <param name="mapFunc">Mapping from Object Type to <see cref="T:VDS.RDF.INode">INode</see></param>
        </member>
        <member name="M:VDS.RDF.Extensions.RemoveFromList(VDS.RDF.IGraph,VDS.RDF.INode,System.Collections.Generic.IEnumerable{VDS.RDF.INode})">
            <summary>
            Removes the given items from a list (aka a RDF collection), if an item occurs multiple times in the list all occurrences will be removed
            </summary>
            <param name="g">Graph to retract from</param>
            <param name="listRoot">Root Node for the list</param>
            <param name="objects">Objects to remove from the collection</param>
        </member>
        <member name="M:VDS.RDF.Extensions.CopyNode(VDS.RDF.INode,VDS.RDF.IGraph)">
            <summary>
            Copies a Node to the target Graph
            </summary>
            <param name="n">Node to copy</param>
            <param name="target">Target Graph</param>
            <returns></returns>
            <remarks>Shorthand for the <see cref="M:VDS.RDF.Tools.CopyNode(VDS.RDF.INode,VDS.RDF.IGraph)">Tools.CopyNode()</see> method</remarks>
        </member>
        <member name="M:VDS.RDF.Extensions.CopyNode(VDS.RDF.INode,VDS.RDF.IGraph,System.Boolean)">
            <summary>
            Copies a Node to the target Graph
            </summary>
            <param name="n">Node to copy</param>
            <param name="target">Target Graph</param>
            <param name="keepOriginalGraphUri">Indicates whether Nodes should preserve the Graph Uri of the Graph they originated from</param>
            <returns></returns>
            <remarks>Shorthand for the <see cref="M:VDS.RDF.Tools.CopyNode(VDS.RDF.INode,VDS.RDF.IGraph,System.Boolean)">Tools.CopyNode()</see> method</remarks>
        </member>
        <member name="M:VDS.RDF.Extensions.CopyTriple(VDS.RDF.Triple,VDS.RDF.IGraph)">
            <summary>
            Copies a Triple to the target Graph
            </summary>
            <param name="t">Triple to copy</param>
            <param name="target">Target Graph</param>
            <returns></returns>
            <remarks>Shorthand for the <see cref="M:VDS.RDF.Tools.CopyTriple(VDS.RDF.Triple,VDS.RDF.IGraph)">Tools.CopyTriple()</see> method</remarks>
        </member>
        <member name="M:VDS.RDF.Extensions.CopyTriple(VDS.RDF.Triple,VDS.RDF.IGraph,System.Boolean)">
            <summary>
            Copies a Triple to the target Graph
            </summary>
            <param name="t">Triple to copy</param>
            <param name="target">Target Graph</param>
            <param name="keepOriginalGraphUri">Indicates whether Nodes should preserve the Graph Uri of the Graph they originated from</param>
            <returns></returns>
            <remarks>Shorthand for the <see cref="M:VDS.RDF.Tools.CopyTriple(VDS.RDF.Triple,VDS.RDF.IGraph,System.Boolean)">Tools.CopyTriple()</see> method</remarks>
        </member>
        <member name="M:VDS.RDF.Extensions.MapTriple(VDS.RDF.Triple,VDS.RDF.IGraph,System.Collections.Generic.Dictionary{VDS.RDF.INode,VDS.RDF.INode})">
            <summary>
            Copies a Triple from one Graph mapping Nodes as appropriate
            </summary>
            <param name="t">Triple to copy</param>
            <param name="target">TargetGraph</param>
            <param name="mapping">Mapping of Nodes</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Extensions.ToSafeString(System.Object)">
            <summary>
            Gets either the String representation of the Object or the Empty String if the object is null
            </summary>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Extensions.ToSafeString(System.Uri)">
            <summary>
            Gets either the String representation of the URI or the Empty String if the URI is null
            </summary>
            <param name="u">URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Extensions.ToSafeUri(System.String)">
            <summary>
            Turns a string into a safe URI
            </summary>
            <param name="str">String</param>
            <returns>Either null if the string is null/empty or a URI otherwise</returns>
        </member>
        <member name="M:VDS.RDF.Extensions.ToString(System.Uri,VDS.RDF.Writing.Formatting.IUriFormatter)">
            <summary>
            Gets the String representation of the URI formatted using the given Formatter
            </summary>
            <param name="u">URI</param>
            <param name="formatter">URI Formatter</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Extensions.AppendIndented(System.Text.StringBuilder,System.String,System.Int32)">
            <summary>
            Appends a String to the StringBuilder with an indent of <paramref name="indent"/> spaces
            </summary>
            <param name="builder">String Builder</param>
            <param name="line">String to append</param>
            <param name="indent">Indent</param>
        </member>
        <member name="M:VDS.RDF.Extensions.AppendLineIndented(System.Text.StringBuilder,System.String,System.Int32)">
            <summary>
            Appends a String to the StringBuilder with an indent of <paramref name="indent"/> spaces
            </summary>
            <param name="builder">String Builder</param>
            <param name="line">String to append</param>
            <param name="indent">Indent</param>
            <remarks>
            Strings containing new lines are split over multiple lines
            </remarks>
        </member>
        <member name="M:VDS.RDF.Extensions.EscapeBackslashes(System.String,System.Char[])">
            <summary>
            Takes a String and escapes any backslashes in it which are not followed by a valid escape character
            </summary>
            <param name="value">String value</param>
            <param name="cs">Valid Escape Characters i.e. characters which may follow a backslash</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Extensions.IsAscii(System.String)">
            <summary>
            Determines whether a string is ASCII
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Extensions.IsFullyEscaped(System.String,System.Char[],System.Char[])">
            <summary>
            Determines whether a String is fully escaped
            </summary>
            <param name="value">String value</param>
            <param name="cs">Valid Escape Characters i.e. characters which may follow a backslash</param>
            <param name="ds">Characters which must be escaped i.e. must be preceded by a backslash</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Extensions.Escape(System.String,System.Char)">
            <summary>
            Escapes all occurrences of a given character in a String
            </summary>
            <param name="value">String</param>
            <param name="toEscape">Character to escape</param>
            <returns></returns>
            <remarks>
            Ignores all existing escapes (indicated by a \) and so avoids double escaping as far as possible
            </remarks>
        </member>
        <member name="M:VDS.RDF.Extensions.Escape(System.String,System.Char,System.Char)">
            <summary>
            Escapes all occurrences of a given character in a String using the given escape character
            </summary>
            <param name="value">String</param>
            <param name="toEscape">Character to escape</param>
            <param name="escapeAs">Character to escape as</param>
            <returns></returns>
            <remarks>
            Ignores all existing escapes (indicated by a \) and so avoids double escaping as far as possible
            </remarks>
        </member>
        <member name="T:VDS.RDF.GraphExtensions">
            <summary>
            Provides useful Extension Methods for working with Graphs
            </summary>
        </member>
        <member name="M:VDS.RDF.GraphExtensions.AsTripleStore(VDS.RDF.IGraph)">
            <summary>
            Turns a Graph into a Triple Store
            </summary>
            <param name="g">Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphExtensions.ExecuteQuery(VDS.RDF.IGraph,System.String)">
            <summary>
            Executes a SPARQL Query on a Graph
            </summary>
            <param name="g">Graph to query</param>
            <param name="sparqlQuery">SPARQL Query</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphExtensions.ExecuteQuery(VDS.RDF.IGraph,VDS.RDF.IRdfHandler,VDS.RDF.ISparqlResultsHandler,System.String)">
            <summary>
            Executes a SPARQL Query on a Graph handling the results using the handlers provided
            </summary>
            <param name="g">Graph to query</param>
            <param name="rdfHandler">RDF Handler</param>
            <param name="resultsHandler">SPARQL Results Handler</param>
            <param name="sparqlQuery">SPARQL Query</param>
        </member>
        <member name="M:VDS.RDF.GraphExtensions.ExecuteQuery(VDS.RDF.IGraph,VDS.RDF.Query.SparqlParameterizedString)">
            <summary>
            Executes a SPARQL Query on a Graph
            </summary>
            <param name="g">Graph to query</param>
            <param name="sparqlQuery">SPARQL Query</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphExtensions.ExecuteQuery(VDS.RDF.IGraph,VDS.RDF.IRdfHandler,VDS.RDF.ISparqlResultsHandler,VDS.RDF.Query.SparqlParameterizedString)">
            <summary>
            Executes a SPARQL Query on a Graph handling the results using the handlers provided
            </summary>
            <param name="g">Graph to query</param>
            <param name="rdfHandler">RDF Handler</param>
            <param name="resultsHandler">SPARQL Results Handler</param>
            <param name="sparqlQuery">SPARQL Query</param>
        </member>
        <member name="M:VDS.RDF.GraphExtensions.ExecuteQuery(VDS.RDF.IGraph,VDS.RDF.Query.SparqlQuery)">
            <summary>
            Executes a SPARQL Query on a Graph
            </summary>
            <param name="g">Graph to query</param>
            <param name="query">SPARQL Query</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphExtensions.ExecuteQuery(VDS.RDF.IGraph,VDS.RDF.IRdfHandler,VDS.RDF.ISparqlResultsHandler,VDS.RDF.Query.SparqlQuery)">
            <summary>
            Executes a SPARQL Query on a Graph handling the results using the handlers provided
            </summary>
            <param name="g">Graph to query</param>
            <param name="rdfHandler">RDF Handler</param>
            <param name="resultsHandler">SPARQL Results Handler</param>
            <param name="query">SPARQL Query</param>
        </member>
        <member name="M:VDS.RDF.GraphExtensions.LoadFromString(VDS.RDF.IGraph,System.String,VDS.RDF.IRdfReader)">
            <summary>
            Loads RDF data from a String into a Graph
            </summary>
            <param name="g">Graph to load into</param>
            <param name="data">Data to load</param>
            <param name="parser">Parser to use</param>
            <remarks>
            This is just a shortcut to using the static <strong>Parse()</strong> methods from the <see cref="T:VDS.RDF.Parsing.StringParser">StringParser</see> class located in the <see cref="N:VDS.RDF.Parsing">Parsing</see> namespace
            </remarks>
        </member>
        <member name="M:VDS.RDF.GraphExtensions.LoadFromString(VDS.RDF.IGraph,System.String)">
            <summary>
            Loads RDF data from a String into a Graph
            </summary>
            <param name="g">Graph to load into</param>
            <param name="data">Data to load</param>
            <remarks>
            This is just a shortcut to using the static <strong>Parse()</strong> methods from the <see cref="T:VDS.RDF.Parsing.StringParser">StringParser</see> class located in the <see cref="N:VDS.RDF.Parsing">Parsing</see> namespace
            </remarks>
        </member>
        <member name="M:VDS.RDF.GraphExtensions.LoadFromEmbeddedResource(VDS.RDF.IGraph,System.String)">
            <summary>
            Loads RDF data from an Embedded Resource into a Graph
            </summary>
            <param name="g">Graph to load into</param>
            <param name="resource">Assembly qualified name of the resource to load from</param>
            <remarks>
            This is just a shortcut to using the static <strong>Load()</strong> methods from the <see cref="T:VDS.RDF.Parsing.EmbeddedResourceLoader">EmbeddedResourceLoader</see> class located in the <see cref="N:VDS.RDF.Parsing">Parsing</see> namespace
            </remarks>
        </member>
        <member name="M:VDS.RDF.GraphExtensions.LoadFromEmbeddedResource(VDS.RDF.IGraph,System.String,VDS.RDF.IRdfReader)">
            <summary>
            Loads RDF data from an Embedded Resource into a Graph
            </summary>
            <param name="g">Graph to load into</param>
            <param name="resource">Assembly qualified name of the resource to load from</param>
            <param name="parser">Parser to use</param>
            <remarks>
            This is just a shortcut to using the static <strong>Load()</strong> methods from the <see cref="T:VDS.RDF.Parsing.EmbeddedResourceLoader">EmbeddedResourceLoader</see> class located in the <see cref="N:VDS.RDF.Parsing">Parsing</see> namespace
            </remarks>
        </member>
        <member name="T:VDS.RDF.TripleStoreExtensions">
            <summary>
            Provides useful Extension Methods for working with Triple Stores
            </summary>
        </member>
        <member name="M:VDS.RDF.TripleStoreExtensions.LoadFromString(VDS.RDF.ITripleStore,System.String,VDS.RDF.IStoreReader)">
            <summary>
            Loads an RDF dataset from a String into a Triple Store
            </summary>
            <param name="store">Triple Store to load into</param>
            <param name="data">Data to load</param>
            <param name="parser">Parser to use</param>
            <remarks>
            This is just a shortcut to using the static <strong>ParseDataset()</strong> methods from the <see cref="T:VDS.RDF.Parsing.StringParser">StringParser</see> class located in the <see cref="N:VDS.RDF.Parsing">Parsing</see> namespace
            </remarks>
        </member>
        <member name="M:VDS.RDF.TripleStoreExtensions.LoadFromString(VDS.RDF.ITripleStore,System.String)">
            <summary>
            Loads an RDF dataset from a String into a Triple Store
            </summary>
            <param name="store">Triple Store to load into</param>
            <param name="data">Data to load</param>
            <remarks>
            This is just a shortcut to using the static <strong>ParseDataset()</strong> methods from the <see cref="T:VDS.RDF.Parsing.StringParser">StringParser</see> class located in the <see cref="N:VDS.RDF.Parsing">Parsing</see> namespace
            </remarks>
        </member>
        <member name="M:VDS.RDF.TripleStoreExtensions.LoadFromEmbeddedResource(VDS.RDF.ITripleStore,System.String,VDS.RDF.IStoreReader)">
            <summary>
            Loads an RDF dataset from an Embedded Resource into a Triple Store
            </summary>
            <param name="store">Triple Store to load into</param>
            <param name="resource">Assembly Qualified Name of the Embedded Resource to load from</param>
            <param name="parser">Parser to use</param>
            <remarks>
            This is just a shortcut to using the static <strong>Load()</strong> methods from the <see cref="T:VDS.RDF.Parsing.EmbeddedResourceLoader">EmbeddedResourceLoader</see> class located in the <see cref="N:VDS.RDF.Parsing">Parsing</see> namespace
            </remarks>
        </member>
        <member name="M:VDS.RDF.TripleStoreExtensions.LoadFromEmbeddedResource(VDS.RDF.ITripleStore,System.String)">
            <summary>
            Loads an RDF dataset from an Embedded Resource into a Triple Store
            </summary>
            <param name="store">Triple Store to load into</param>
            <param name="resource">Assembly Qualified Name of the Embedded Resource to load from</param>
            <remarks>
            This is just a shortcut to using the static <strong>Load()</strong> methods from the <see cref="T:VDS.RDF.Parsing.EmbeddedResourceLoader">EmbeddedResourceLoader</see> class located in the <see cref="N:VDS.RDF.Parsing">Parsing</see> namespace
            </remarks>
        </member>
        <member name="T:VDS.RDF.LiteralExtensions">
            <summary>
            Provides extension methods for converting primitive types into appropriately typed Literal Nodes
            </summary>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteral(System.Boolean,VDS.RDF.INodeFactory)">
            <summary>
            Creates a new Boolean typed literal
            </summary>
            <param name="b">Boolean</param>
            <param name="factory">Node Factory to use for Node creation</param>
            <returns>Literal representing the boolean</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the Factory argument is null</exception>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteral(System.Byte,VDS.RDF.INodeFactory)">
            <summary>
            Creates a new Byte typed literal
            </summary>
            <param name="b">Byte</param>
            <param name="factory">Node Factory to use for Node creation</param>
            <returns>Literal representing the byte</returns>
            <remarks>
            Byte in .Net is actually equivalent to Unsigned Byte in XML Schema so depending on the value of the Byte the type will either be xsd:byte if it fits or xsd:usignedByte
            </remarks>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteral(System.SByte,VDS.RDF.INodeFactory)">
            <summary>
            Creates a new Byte typed literal
            </summary>
            <param name="b">Byte</param>
            <param name="factory">Node Factory to use for Node creation</param>
            <returns>Literal representing the signed bytes</returns>
            <remarks>
            SByte in .Net is directly equivalent to Byte in XML Schema so the type will always be xsd:byte
            </remarks>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteral(System.DateTime,VDS.RDF.INodeFactory)">
            <summary>
            Creates a new Date Time typed literal
            </summary>
            <param name="dt">Date Time</param>
            <param name="factory">Node Factory to use for Node creation</param>
            <returns>Literal representing the date time</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the Factory argument is null</exception>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteral(System.DateTime,VDS.RDF.INodeFactory,System.Boolean)">
            <summary>
            Creates a new Date Time typed literal
            </summary>
            <param name="dt">Date Time</param>
            <param name="factory">Node Factory to use for Node creation</param>
            <param name="precise">Whether to preserve precisely i.e. include fractional seconds</param>
            <returns>Literal representing the date time</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the Factory argument is null</exception>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteral(System.DateTimeOffset,VDS.RDF.INodeFactory)">
            <summary>
            Creates a new Date Time typed literal
            </summary>
            <param name="dt">Date Time</param>
            <param name="factory">Node Factory to use for Node creation</param>
            <returns>Literal representing the date time</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the Factory argument is null</exception>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteral(System.DateTimeOffset,VDS.RDF.INodeFactory,System.Boolean)">
            <summary>
            Creates a new Date Time typed literal
            </summary>
            <param name="dt">Date Time</param>
            <param name="factory">Node Factory to use for Node creation</param>
            <param name="precise">Whether to preserve precisely i.e. include fractional seconds</param>
            <returns>Literal representing the date time</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the Factory argument is null</exception>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteralDate(System.DateTime,VDS.RDF.INodeFactory)">
            <summary>
            Creates a new Date typed literal
            </summary>
            <param name="dt">Date Time</param>
            <param name="factory">Node Factory to use for Node creation</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the Factory argument is null</exception>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteralDate(System.DateTimeOffset,VDS.RDF.INodeFactory)">
            <summary>
            Creates a new Date typed literal
            </summary>
            <param name="dt">Date Time</param>
            <param name="factory">Node Factory to use for Node creation</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the Factory argument is null</exception>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteralTime(System.DateTime,VDS.RDF.INodeFactory)">
            <summary>
            Creates a new Time typed literal
            </summary>
            <param name="dt">Date Time</param>
            <param name="factory">Node Factory to use for Node creation</param>
            <returns>Literal representing the time</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the Factory argument is null</exception>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteralTime(System.DateTime,VDS.RDF.INodeFactory,System.Boolean)">
            <summary>
            Creates a new Time typed literal
            </summary>
            <param name="dt">Date Time</param>
            <param name="factory">Node Factory to use for Node creation</param>
            <param name="precise">Whether to preserve precisely i.e. include fractional seconds</param>
            <returns>Literal representing the time</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the Factory argument is null</exception>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteral(System.TimeSpan,VDS.RDF.INodeFactory)">
            <summary>
            Creates a new duration typed literal
            </summary>
            <param name="t">Time Span</param>
            <param name="factory">Node Factory to use for Node creation</param>
            <returns>Literal representing the time span</returns>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteralTime(System.DateTimeOffset,VDS.RDF.INodeFactory)">
            <summary>
            Creates a new Time typed literal
            </summary>
            <param name="dt">Date Time</param>
            <param name="factory">Node Factory to use for Node creation</param>
            <returns>Literal representing the time</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the Factory argument is null</exception>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteralTime(System.DateTimeOffset,VDS.RDF.INodeFactory,System.Boolean)">
            <summary>
            Creates a new Time typed literal
            </summary>
            <param name="dt">Date Time</param>
            <param name="factory">Node Factory to use for Node creation</param>
            <param name="precise">Whether to preserve precisely i.e. include fractional seconds</param>
            <returns>Literal representing the time</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the Factory argument is null</exception>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteral(System.Decimal,VDS.RDF.INodeFactory)">
            <summary>
            Creates a new Decimal typed literal
            </summary>
            <param name="d">Decimal</param>
            <param name="factory">Node Factory to use for Node creation</param>
            <returns>Literal representing the decimal</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the Factory argument is null</exception>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteral(System.Double,VDS.RDF.INodeFactory)">
            <summary>
            Creates a new Double typed literal
            </summary>
            <param name="d">Double</param>
            <param name="factory">Node Factory to use for Node creation</param>
            <returns>Literal representing the double</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the Factory argument is null</exception>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteral(System.Single,VDS.RDF.INodeFactory)">
            <summary>
            Creates a new Float typed literal
            </summary>
            <param name="f">Float</param>
            <param name="factory">Node Factory to use for Node creation</param>
            <returns>Literal representing the float</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the Factory argument is null</exception>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteral(System.Int16,VDS.RDF.INodeFactory)">
            <summary>
            Creates a new Integer typed literal
            </summary>
            <param name="i">Integer</param>
            <param name="factory">Node Factory to use for Node creation</param>
            <returns>Literal representing the short</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the Factory argument is null</exception>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteral(System.Int32,VDS.RDF.INodeFactory)">
            <summary>
            Creates a new Integer typed literal
            </summary>
            <param name="i">Integer</param>
            <param name="factory">Node Factory to use for Node creation</param>
            <returns>Literal representing the integer</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the Factory argument is null</exception>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteral(System.Int64,VDS.RDF.INodeFactory)">
            <summary>
            Creates a new Integer typed literal
            </summary>
            <param name="l">Integer</param>
            <param name="factory">Node Factory to use for Node creation</param>
            <returns>Literal representing the integer</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the Factory argument is null</exception>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteral(System.String,VDS.RDF.INodeFactory)">
            <summary>
            Creates a new String typed literal
            </summary>
            <param name="s">String</param>
            <param name="factory">Node Factory to use for Node creation</param>
            <returns>Literal representing the string</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the Graph/String argument is null</exception>
        </member>
        <member name="T:VDS.RDF.ISparqlResultsReader">
            <summary>
            Interface for Reader Classes which parser Sparql Result Set syntaxes into Result Set objects
            </summary>
        </member>
        <member name="M:VDS.RDF.ISparqlResultsReader.Load(VDS.RDF.Query.SparqlResultSet,System.IO.StreamReader)">
            <summary>
            Loads a Result Set from the given Stream
            </summary>
            <param name="input">Stream to read from</param>
            <param name="results">Result Set to load into</param>
            <returns></returns>
            <remarks>Should throw an error if the Result Set is not empty</remarks>
        </member>
        <member name="M:VDS.RDF.ISparqlResultsReader.Load(VDS.RDF.Query.SparqlResultSet,System.IO.TextReader)">
            <summary>
            Loads a Result Set from the given Input
            </summary>
            <param name="input">Input to read from</param>
            <param name="results">Result Set to load into</param>
            <returns></returns>
            <remarks>Should throw an error if the Result Set is not empty</remarks>
        </member>
        <member name="M:VDS.RDF.ISparqlResultsReader.Load(VDS.RDF.ISparqlResultsHandler,System.IO.StreamReader)">
            <summary>
            Loads a Result Set using a Results Handler from the given Stream
            </summary>
            <param name="handler">Results Handler</param>
            <param name="input">Stream to read from</param>
        </member>
        <member name="M:VDS.RDF.ISparqlResultsReader.Load(VDS.RDF.ISparqlResultsHandler,System.IO.TextReader)">
            <summary>
            Loads a Result Set using a Results Handler from the given Input
            </summary>
            <param name="handler">Results Handler</param>
            <param name="input">Input to read from</param>
        </member>
        <member name="E:VDS.RDF.ISparqlResultsReader.Warning">
            <summary>
            Event raised when a non-fatal issue with the SPARQL Results being parsed is detected
            </summary>
        </member>
        <member name="T:VDS.RDF.ISparqlResultsWriter">
            <summary>
            Interface for Writer classes which serialize Sparql Result Sets into concrete results set syntaxes
            </summary>
        </member>
        <member name="M:VDS.RDF.ISparqlResultsWriter.Save(VDS.RDF.Query.SparqlResultSet,System.IO.TextWriter)">
            <summary>
            Saves the Result Set to the given Stream
            </summary>
            <param name="results">Result Set to save</param>
            <param name="output">Stream to save to</param>
        </member>
        <member name="E:VDS.RDF.ISparqlResultsWriter.Warning">
            <summary>
            Event raised when a non-fatal issue with the SPARQL Results being written is detected
            </summary>
        </member>
        <member name="T:VDS.RDF.LiteralEqualityMode">
            <summary>
            Possible Literal Equality Mode Settings
            </summary>
        </member>
        <member name="F:VDS.RDF.LiteralEqualityMode.Strict">
            <summary>
            Strict Mode compares Literals according to the official W3C RDF Specification
            </summary>
            <remarks>
            This means Literals are equal if and only if:
            <ol>
            <li>The Lexical Values are identical when compared using Ordinal Comparison</li>
            <li>The Language Tags if present are identical</li>
            <li>The Datatypes if present are identical</li>
            </ol>
            </remarks>
        </member>
        <member name="F:VDS.RDF.LiteralEqualityMode.Loose">
            <summary>
            Loose Mode compares Literals based on values (if they have known Datatypes)
            </summary>
            <remarks>
            This means Literals can be equal if they have lexically different values which are equivalent when converted to the Datatype.
            <br/><br/>
            Literals without Datatypes and those whose Datatypes are unknown or not handled by the Library will be compared using lexical equivalence as with <see cref="F:VDS.RDF.LiteralEqualityMode.Strict">Strict</see> mode.
            </remarks>
        </member>
        <member name="T:VDS.RDF.Options">
            <summary>
            Configures Global Static Options for the Library
            </summary>
            <remarks>
            Some of these are Debug Build only, please see the Remarks on individual members for more detail
            </remarks>
        </member>
        <member name="P:VDS.RDF.Options.LiteralEqualityMode">
            <summary>
            Gets/Sets the Mode used to compute Literal Equality (Default is <see cref="F:VDS.RDF.LiteralEqualityMode.Strict">Strict</see> which enforces the W3C RDF Specification)
            </summary>
        </member>
        <member name="P:VDS.RDF.Options.LiteralValueNormalization">
            <summary>
            Gets/Sets whether Literal Values should be normalized
            </summary>
        </member>
        <member name="P:VDS.RDF.Options.QueryExecutionTimeout">
            <summary>
            Gets/Sets the Hard Timeout limit for SPARQL Query Execution (in milliseconds)
            </summary>
            <remarks>
            This is used to stop SPARQL queries running away and never completing execution, it defaults to 3 mins (180,000 milliseconds)
            </remarks>
        </member>
        <member name="P:VDS.RDF.Options.QueryOptimisation">
            <summary>
            Gets/Sets whether Query Optimisation should be used
            </summary>
        </member>
        <member name="P:VDS.RDF.Options.AlgebraOptimisation">
            <summary>
            Gets/Sets whether Algebra Optimisation should be used
            </summary>
        </member>
        <member name="P:VDS.RDF.Options.UnsafeOptimisation">
            <summary>
            Gets/Sets whether some Optimisations considered unsafe can be used
            </summary>
            <remarks>
            <para>
            The notion of unsafe optimisations refers to optimisations that can make significant performance improvements to some types of queries but are disabled normally because they may lead to behaviour which does not strictly align with the SPARQL specification.
            </para>
            <para>
            One example of such an optimisation is an implicit join where the optimiser cannot be sure that the variables involved don't represent literals.
            </para>
            </remarks>
        </member>
        <member name="P:VDS.RDF.Options.QueryDefaultSyntax">
            <summary>
            Gets/Sets the default syntax used for parsing SPARQL queries
            </summary>
            <remarks>
            The default is SPARQL 1.1 unless you use this property to change it
            </remarks>
        </member>
        <member name="P:VDS.RDF.Options.QueryAllowUnknownFunctions">
            <summary>
            Gets/Sets whether functions that can't be parsed into Expressions should be represented by the <see cref="T:VDS.RDF.Query.Expressions.Functions.UnknownFunction">UnknownFunction</see>
            </summary>
            <remarks>When set to false a Parser Error will be thrown if the Function cannot be parsed into an Expression</remarks>
        </member>
        <member name="P:VDS.RDF.Options.RigorousEvaluation">
            <summary>
            Gets/Sets whether to use rigorous query evaluation
            </summary>
            <remarks>
            <para>
            Rigorous Query evaluation applies more checks to the triples produced by datasets to ensure they actually match the patterns being scanned.  If the underlying index structures are able to guarantee this then rigorous evaluation may be turned off for faster evaluation which it is by default since our default <see cref="T:VDS.RDF.TreeIndexedTripleCollection"/> and <see cref="T:VDS.RDF.TripleCollection"/> implementations will guarantee this.
            </para>
            </remarks>
        </member>
        <member name="P:VDS.RDF.Options.StrictOperators">
            <summary>
            Gets/Sets whether to use strict operators
            </summary>
            <remarks>
            <para>
            Strict Operators refers to the interpretation of certian operators like + and - in SPARQL expression evaluation.  If enabled then the operators will function only as specified in the SPARQL specification, if disabled (which is the default) then certain extensions (which the SPARQL specification allows an implementation to provide) will be allowed e.g. date time arithmetic.
            </para>
            <para>
            The only time you may want to disable this is if you are developing queries locally which you want to ensure are portable to other systems or when running the SPARQL compliance tests.
            </para>
            </remarks>
        </member>
        <member name="P:VDS.RDF.Options.UpdateExecutionTimeout">
            <summary>
            Gets/Sets the Hard Timeout limit for SPARQL Update Execution (in milliseconds)
            </summary>
            <remarks>
            This is used to stop SPARQL Updates running away and never completing execution, it defaults to 3 mins (180,000 milliseconds)
            </remarks>
        </member>
        <member name="P:VDS.RDF.Options.DefaultCompressionLevel">
            <summary>
            Gets/Sets the Default Compression Level used for Writers returned by the <see cref="T:VDS.RDF.MimeTypesHelper">MimeTypesHelper</see> class when the writers implement <see cref="T:VDS.RDF.Writing.ICompressingWriter">ICompressingWriter</see>
            </summary>
        </member>
        <member name="P:VDS.RDF.Options.FullTripleIndexing">
            <summary>
            Controls whether the indexed triple collections will create full indexes for the Triples inserted into it
            </summary>
            <remarks>
            <para>
            By default indexes triple collections creates indexes on Triples based upon Subjects, Predicates and Objects alone.  When full indexing is enabled it also creates indexes based on Subject-Predicate, Predicate-Object and Subject-Object pairs which may improve query speed but will use additional memory.
            </para>
            <para>
            Default setting for Full Indexing is enabled, enabling/disabling it only has an effect on indexed triple collection instances instantiated after full indexing was enabled/disabled i.e. existing Graphs in memory using the indexed triple collections continue to use the full indexing setting that was present when they were instantiated.
            </para>
            </remarks>
        </member>
        <member name="P:VDS.RDF.Options.UriLoaderTimeout">
            <summary>
            Gets/Sets the Timeout for URI Loader requests (Defaults to 15 seconds)
            </summary>
        </member>
        <member name="P:VDS.RDF.Options.UseBomForUtf8">
            <summary>
            Gets/Sets whether a UTF-8 BOM is used for UTF-8 Streams created by dotNetRDF (this does not affect Streams passed directly to methods as open streams cannot have their encoding changed)
            </summary>
        </member>
        <member name="P:VDS.RDF.Options.ValidateIris">
            <summary>
            Gets/Sets whether IRIs are validated by parsers which support this functionality
            </summary>
            <remarks>
            When enabled certain parsers will validate all IRIs they see to ensure that they are valid and throw a parser error if they are not.  Since there is a performance penalty associated with this and many older RDF standards were written pre-IRIs (thus enforcing IRI validity would reject data considered valid by those specifications) this feature is disabled by default.
            </remarks>
        </member>
        <member name="P:VDS.RDF.Options.ForceBlockingIO">
            <summary>
            Gets/Sets whether Blocking IO should be forced
            </summary>
            <remarks>
            Blocking IO refers to how the parsing sub-system reads in inputs, it will use Blocking/Non-Blocking IO depending on the input source.  In most cases the detection of which to use should never cause an issue but theoretically in some rare cases using non-blocking IO may lead to incorrect parsing errors being thrown (premature end of input detected), if you suspect this is the case try enabling this setting.  If you still experience this problem with this setting enabled then there is some other issue with your input.
            </remarks>
        </member>
        <member name="P:VDS.RDF.Options.ForceHttpBasicAuth">
            <summary>
            Gets/Sets whether Basic HTTP authentication should be forced
            </summary>
            <remarks>
            <para>
            There have been reported problems where some servers don't cope nicely with the HTTP authentication challenge response procedure resulting in failed HTTP requests.  If the server only uses Basic HTTP authentication then you can opt to force dotNetRDF to always include the HTTP basic authentication header in requests and thus workaround this problem.
            </para>
            <para>
            <strong>Warning:</strong> Under Silverlight this will only work correctly if usernames and passwords are composed only of characters within the ASCII range.
            </para>
            </remarks>
        </member>
        <member name="P:VDS.RDF.Options.UseDtd">
            <summary>
            Gets/Sets whether a DTD should be used for some XML formats to compress output
            </summary>
        </member>
        <member name="P:VDS.RDF.Options.AllowMultiThreadedWriting">
            <summary>
            Gets/Sets whether multi-theaded writing is permitted
            </summary>
            <remarks>
            In some contexts multi-threaded writing may not even work due to restrictions on thread types since we use the <see cref="!:System.Threading.WaitAll">WaitAll()</see> method which is only valid in <strong>MTA</strong> contexts.
            </remarks>
        </member>
        <member name="P:VDS.RDF.Options.InternUris">
            <summary>
            Gets/Sets whether the library will attempt to intern URIs to reduce memory usage
            </summary>
        </member>
        <member name="P:VDS.RDF.Options.DefaultTokenQueueMode">
            <summary>
            Gets/Sets the default token queue mode used for tokeniser based parsers
            </summary>
        </member>
        <member name="P:VDS.RDF.Options.HttpDebugging">
            <summary>
            Gets/Sets whether HTTP Request and Response Information should be output to the Console Standard Out for Debugging purposes
            </summary>
        </member>
        <member name="P:VDS.RDF.Options.HttpFullDebugging">
            <summary>
            Gets/Sets whether the HTTP Response Stream should be output to the Console Standard Output for Debugging purposes
            </summary>
        </member>
        <member name="P:VDS.RDF.Options.DefaultCulture">
            <summary>
            Gets/Sets the default culture literal comparison when literals are string or not implicitely comparable (different types, parse/cast error...)
            </summary>
            <remarks>
            The default is set to the invariant culture to preserve behavioural backwards compatibility with past versions of dotNetRDF
            </remarks>
        </member>
        <member name="P:VDS.RDF.Options.DefaultComparisonOptions">
            <summary>
            Gets/Sets the default collation for literal comparison when literals are string or not implicitely comparable (different types, parse/cast error...)
            </summary>
            <remarks>
            The default is set to <see cref="F:System.Globalization.CompareOptions.Ordinal"/> to preserve behavioural backwards compatibility with past versions of dotNetRDF
            </remarks>
        </member>
        <member name="T:VDS.RDF.TreeIndexedTripleCollection">
            <summary>
            An indexed triple collection that uses our <see cref="T:VDS.Common.Collections.MultiDictionary`2"/> and <see cref="T:VDS.Common.Trees.BinaryTree`3"/> implementations under the hood for the index structures
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="M:VDS.RDF.TreeIndexedTripleCollection.#ctor">
            <summary>
            Creates a new Tree Indexed triple collection
            </summary>
        </member>
        <member name="M:VDS.RDF.TreeIndexedTripleCollection.#ctor(VDS.Common.Collections.MultiDictionaryMode)">
            <summary>
            Creates a new Tree Indexed triple collection
            </summary>
            <param name="compoundIndexMode">Mode to use for compound indexes</param>
        </member>
        <member name="M:VDS.RDF.TreeIndexedTripleCollection.#ctor(System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,VDS.Common.Collections.MultiDictionaryMode)">
            <summary>
            Creates a new Tree Indexed triple collection with the given Indexing options
            </summary>
            <param name="subjIndex">Whether to create a subject index</param>
            <param name="predIndex">Whether to create a predicate index</param>
            <param name="objIndex">Whether to create an object index</param>
            <param name="subjPredIndex">Whether to create a subject predicate index</param>
            <param name="subjObjIndex">Whether to create a subject object index</param>
            <param name="predObjIndex">Whether to create a predicate object index</param>
            <param name="compoundIndexMode">Mode to use for compound indexes</param>
        </member>
        <member name="M:VDS.RDF.TreeIndexedTripleCollection.Index(VDS.RDF.Triple)">
            <summary>
            Indexes a Triple
            </summary>
            <param name="t">Triple</param>
        </member>
        <member name="M:VDS.RDF.TreeIndexedTripleCollection.IndexSimple(VDS.RDF.INode,VDS.RDF.Triple,VDS.Common.Collections.MultiDictionary{VDS.RDF.INode,System.Collections.Generic.List{VDS.RDF.Triple}})">
            <summary>
            Helper for indexing triples
            </summary>
            <param name="n">Node to index by</param>
            <param name="t">Triple</param>
            <param name="index">Index to insert into</param>
        </member>
        <member name="M:VDS.RDF.TreeIndexedTripleCollection.IndexCompound(VDS.RDF.Triple,VDS.Common.Collections.MultiDictionary{VDS.RDF.Triple,System.Collections.Generic.List{VDS.RDF.Triple}})">
            <summary>
            Helper for indexing triples
            </summary>
            <param name="t">Triple to index by</param>
            <param name="index">Index to insert into</param>
        </member>
        <member name="M:VDS.RDF.TreeIndexedTripleCollection.Unindex(VDS.RDF.Triple)">
            <summary>
            Unindexes a triple
            </summary>
            <param name="t">Triple</param>
        </member>
        <member name="M:VDS.RDF.TreeIndexedTripleCollection.UnindexSimple(VDS.RDF.INode,VDS.RDF.Triple,VDS.Common.Collections.MultiDictionary{VDS.RDF.INode,System.Collections.Generic.List{VDS.RDF.Triple}})">
            <summary>
            Helper for unindexing triples
            </summary>
            <param name="n">Node to index by</param>
            <param name="t">Triple</param>
            <param name="index">Index to remove from</param>
        </member>
        <member name="M:VDS.RDF.TreeIndexedTripleCollection.UnindexCompound(VDS.RDF.Triple,VDS.Common.Collections.MultiDictionary{VDS.RDF.Triple,System.Collections.Generic.List{VDS.RDF.Triple}})">
            <summary>
            Helper for unindexing triples
            </summary>
            <param name="t">Triple</param>
            <param name="index">Index to remove from</param>
        </member>
        <member name="M:VDS.RDF.TreeIndexedTripleCollection.Add(VDS.RDF.Triple)">
            <summary>
            Adds a Triple to the collection
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TreeIndexedTripleCollection.Contains(VDS.RDF.Triple)">
            <summary>
            Checks whether the collection contains a given Triple
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TreeIndexedTripleCollection.Delete(VDS.RDF.Triple)">
            <summary>
            Deletes a triple from the collection
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TreeIndexedTripleCollection.WithObject(VDS.RDF.INode)">
            <summary>
            Gets all the triples with a given object
            </summary>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TreeIndexedTripleCollection.WithPredicate(VDS.RDF.INode)">
            <summary>
            Gets all the triples with a given predicate
            </summary>
            <param name="pred">Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TreeIndexedTripleCollection.WithSubject(VDS.RDF.INode)">
            <summary>
            Gets all the triples with a given subject
            </summary>
            <param name="subj">Subject</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TreeIndexedTripleCollection.WithPredicateObject(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets all the triples with a given predicate and object
            </summary>
            <param name="pred">Predicate</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TreeIndexedTripleCollection.WithSubjectObject(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets all the triples with a given subject and object
            </summary>
            <param name="subj">Subject</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TreeIndexedTripleCollection.WithSubjectPredicate(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets all the triples with a given subject and predicate
            </summary>
            <param name="subj">Subject</param>
            <param name="pred">Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TreeIndexedTripleCollection.Dispose">
            <summary>
            Disposes of the collection
            </summary>
        </member>
        <member name="M:VDS.RDF.TreeIndexedTripleCollection.GetEnumerator">
            <summary>
            Gets the enumerator for the collection
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.TreeIndexedTripleCollection.Count">
            <summary>
            Gets the count of triples in the collection
            </summary>
        </member>
        <member name="P:VDS.RDF.TreeIndexedTripleCollection.Item(VDS.RDF.Triple)">
            <summary>
            Gets the specific instance of a Triple in the collection
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.TreeIndexedTripleCollection.ObjectNodes">
            <summary>
            Gets the Object Nodes
            </summary>
        </member>
        <member name="P:VDS.RDF.TreeIndexedTripleCollection.PredicateNodes">
            <summary>
            Gets the Predicate Nodes
            </summary>
        </member>
        <member name="P:VDS.RDF.TreeIndexedTripleCollection.SubjectNodes">
            <summary>
            Gets the Subject Nodes
            </summary>
        </member>
        <member name="T:VDS.RDF.WrapperTripleCollection">
            <summary>
            Abstract decorator for Triple Collections to make it easier to add additional functionality to existing collections
            </summary>
        </member>
        <member name="F:VDS.RDF.WrapperTripleCollection._triples">
            <summary>
            Underlying Triple Collection
            </summary>
        </member>
        <member name="M:VDS.RDF.WrapperTripleCollection.#ctor">
            <summary>
            Creates a new decorator over the default <see cref="T:VDS.RDF.TreeIndexedTripleCollection"/>
            </summary>
        </member>
        <member name="M:VDS.RDF.WrapperTripleCollection.#ctor(VDS.RDF.BaseTripleCollection)">
            <summary>
            Creates a new decorator around the given triple collection
            </summary>
            <param name="tripleCollection">Triple Collection</param>
        </member>
        <member name="M:VDS.RDF.WrapperTripleCollection.Add(VDS.RDF.Triple)">
            <summary>
            Adds a triple to the collection
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.WrapperTripleCollection.Contains(VDS.RDF.Triple)">
            <summary>
            Gets whether the collection contains the given Triple
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.WrapperTripleCollection.Delete(VDS.RDF.Triple)">
            <summary>
            Deletes a triple from the collection
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.WrapperTripleCollection.Dispose">
            <summary>
            Disposes of the collection
            </summary>
        </member>
        <member name="M:VDS.RDF.WrapperTripleCollection.GetEnumerator">
            <summary>
            Gets the enumerator for the collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.WrapperTripleCollection.WithObject(VDS.RDF.INode)">
            <summary>
            Gets all the triples with the given object
            </summary>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.WrapperTripleCollection.WithPredicate(VDS.RDF.INode)">
            <summary>
            Gets all the triples with the given predicate
            </summary>
            <param name="pred">Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.WrapperTripleCollection.WithPredicateObject(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets all the triples with the given predicate and object
            </summary>
            <param name="pred">Predicate</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.WrapperTripleCollection.WithSubject(VDS.RDF.INode)">
            <summary>
            Gets all the triples with the given subject
            </summary>
            <param name="subj">Subject</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.WrapperTripleCollection.WithSubjectObject(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets all the triples with the given subject and object
            </summary>
            <param name="subj">Subject</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.WrapperTripleCollection.WithSubjectPredicate(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets all the triples with the given subject and predicate
            </summary>
            <param name="subj">Subject</param>
            <param name="pred">Predicate</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.WrapperTripleCollection.Count">
            <summary>
            Counts the triples in the collection
            </summary>
        </member>
        <member name="P:VDS.RDF.WrapperTripleCollection.Item(VDS.RDF.Triple)">
            <summary>
            Gets the specific instance of a Triple from the collection
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.WrapperTripleCollection.ObjectNodes">
            <summary>
            Gets the object nodes
            </summary>
        </member>
        <member name="P:VDS.RDF.WrapperTripleCollection.PredicateNodes">
            <summary>
            Gets the predicate nodes
            </summary>
        </member>
        <member name="P:VDS.RDF.WrapperTripleCollection.SubjectNodes">
            <summary>
            Gets the subject nodes
            </summary>
        </member>
        <member name="T:VDS.RDF.WrapperTripleStore">
            <summary>
            Abstract decorator for Triple Stores to make it easier to add new functionality on top of existing implementations
            </summary>
        </member>
        <member name="F:VDS.RDF.WrapperTripleStore._store">
            <summary>
            Underlying store
            </summary>
        </member>
        <member name="F:VDS.RDF.WrapperTripleStore.GraphAddedHandler">
            <summary>
            Event Handler definitions
            </summary>
        </member>
        <member name="F:VDS.RDF.WrapperTripleStore.GraphRemovedHandler">
            <summary>
            Event Handler definitions
            </summary>
        </member>
        <member name="F:VDS.RDF.WrapperTripleStore.GraphChangedHandler">
            <summary>
            Event Handler definitions
            </summary>
        </member>
        <member name="F:VDS.RDF.WrapperTripleStore.GraphMergedHandler">
            <summary>
            Event Handler definitions
            </summary>
        </member>
        <member name="F:VDS.RDF.WrapperTripleStore.GraphClearedHandler">
            <summary>
            Event Handler definitions
            </summary>
        </member>
        <member name="M:VDS.RDF.WrapperTripleStore.#ctor">
            <summary>
            Creates a new triple store decorator that uses a default in-memory <see cref="T:VDS.RDF.TripleStore"/>
            </summary>
        </member>
        <member name="M:VDS.RDF.WrapperTripleStore.#ctor(VDS.RDF.ITripleStore)">
            <summary>
            Creates a new triple store decorator around the given <see cref="T:VDS.RDF.ITripleStore"/> instance
            </summary>
            <param name="store">Triple Store</param>
        </member>
        <member name="M:VDS.RDF.WrapperTripleStore.Add(VDS.RDF.IGraph)">
            <summary>
            Adds a Graph to the store
            </summary>
            <param name="g">Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.WrapperTripleStore.Add(VDS.RDF.IGraph,System.Boolean)">
            <summary>
            Adds a Graph to the store
            </summary>
            <param name="g">Graph</param>
            <param name="mergeIfExists">Whether to merge with an existing graph with the same URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.WrapperTripleStore.AddFromUri(System.Uri)">
            <summary>
            Adds a Graph to the store from a URI
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.WrapperTripleStore.AddFromUri(System.Uri,System.Boolean)">
            <summary>
            Adds a Graph to the store from a URI
            </summary>
            <param name="graphUri">Graph URI</param>
            <param name="mergeIfExists">Whether to merge with an existing graph with the same URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.WrapperTripleStore.Remove(System.Uri)">
            <summary>
            Removes a Graph from the store
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.WrapperTripleStore.HasGraph(System.Uri)">
            <summary>
            Gets whether a Graph exists in the store
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.WrapperTripleStore.RaiseGraphAdded(VDS.RDF.IGraph)">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.WrapperTripleStore.GraphAdded">Graph Added</see> event manually
            </summary>
            <param name="g">Graph</param>
        </member>
        <member name="M:VDS.RDF.WrapperTripleStore.RaiseGraphAdded(VDS.RDF.GraphEventArgs)">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.WrapperTripleStore.GraphAdded">Graph Added</see> event manually
            </summary>
            <param name="args">Graph Event Arguments</param>
        </member>
        <member name="M:VDS.RDF.WrapperTripleStore.OnGraphAdded(System.Object,VDS.RDF.TripleStoreEventArgs)">
            <summary>
            Event Handler which handles the <see cref="E:VDS.RDF.BaseGraphCollection.GraphAdded">Graph Added</see> event from the underlying Graph Collection and raises the Triple Store's <see cref="E:VDS.RDF.WrapperTripleStore.GraphAdded">Graph Added</see> event
            </summary>
            <param name="sender">Sender</param>
            <param name="args">Graph Event Arguments</param>
            <remarks>Override this method if your Triple Store implementation wishes to take additional actions when a Graph is added to the Store</remarks>
        </member>
        <member name="M:VDS.RDF.WrapperTripleStore.RaiseGraphRemoved(VDS.RDF.IGraph)">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.WrapperTripleStore.GraphRemoved">Graph Removed</see> event manually
            </summary>
            <param name="g">Graph</param>
        </member>
        <member name="M:VDS.RDF.WrapperTripleStore.RaiseGraphRemoved(VDS.RDF.GraphEventArgs)">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.WrapperTripleStore.GraphRemoved">Graph Removed</see> event manually
            </summary>
            <param name="args">Graph Event Arguments</param>
        </member>
        <member name="M:VDS.RDF.WrapperTripleStore.OnGraphRemoved(System.Object,VDS.RDF.TripleStoreEventArgs)">
            <summary>
            Event Handler which handles the <see cref="E:VDS.RDF.BaseGraphCollection.GraphRemoved">Graph Removed</see> event from the underlying Graph Collection and raises the Triple Stores's <see cref="E:VDS.RDF.WrapperTripleStore.GraphRemoved">Graph Removed</see> event
            </summary>
            <param name="sender">Sender</param>
            <param name="args">Graph Event Arguments</param>
        </member>
        <member name="M:VDS.RDF.WrapperTripleStore.RaiseGraphChanged(VDS.RDF.GraphEventArgs)">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.WrapperTripleStore.GraphChanged">Graph Changed</see> event manually
            </summary>
            <param name="args">Graph Event Arguments</param>
        </member>
        <member name="M:VDS.RDF.WrapperTripleStore.OnGraphChanged(System.Object,VDS.RDF.TripleStoreEventArgs)">
            <summary>
            Event Handler which handles the <see cref="E:VDS.RDF.IGraph.Changed">Changed</see> event of the contained Graphs by raising the Triple Store's <see cref="E:VDS.RDF.WrapperTripleStore.GraphChanged">Graph Changed</see> event
            </summary>
            <param name="sender">Sender</param>
            <param name="args">Graph Event Arguments</param>
        </member>
        <member name="M:VDS.RDF.WrapperTripleStore.RaiseGraphChanged(VDS.RDF.IGraph)">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.WrapperTripleStore.GraphChanged">Graph Changed</see> event manually
            </summary>
            <param name="g">Graph</param>
        </member>
        <member name="M:VDS.RDF.WrapperTripleStore.RaiseGraphCleared(VDS.RDF.GraphEventArgs)">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.WrapperTripleStore.GraphCleared">Graph Cleared</see> event manually
            </summary>
            <param name="args">Graph Event Arguments</param>
        </member>
        <member name="M:VDS.RDF.WrapperTripleStore.OnGraphCleared(System.Object,VDS.RDF.TripleStoreEventArgs)">
            <summary>
            Event Handler which handles the <see cref="E:VDS.RDF.IGraph.Cleared">Cleared</see> event of the contained Graphs by raising the Triple Stores's <see cref="E:VDS.RDF.WrapperTripleStore.GraphCleared">Graph Cleared</see> event
            </summary>
            <param name="sender">Sender</param>
            <param name="args">Graph Event Arguments</param>
        </member>
        <member name="M:VDS.RDF.WrapperTripleStore.RaiseGraphMerged(VDS.RDF.GraphEventArgs)">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.WrapperTripleStore.GraphMerged">Graph Merged</see> event manually
            </summary>
            <param name="args">Graph Event Arguments</param>
        </member>
        <member name="M:VDS.RDF.WrapperTripleStore.OnGraphMerged(System.Object,VDS.RDF.TripleStoreEventArgs)">
            <summary>
            Event Handler which handles the <see cref="E:VDS.RDF.IGraph.Merged">Merged</see> event of the contained Graphs by raising the Triple Store's <see cref="E:VDS.RDF.WrapperTripleStore.GraphMerged">Graph Merged</see> event
            </summary>
            <param name="sender">Sender</param>
            <param name="args">Graph Event Arguments</param>
        </member>
        <member name="M:VDS.RDF.WrapperTripleStore.Dispose">
            <summary>
            Disposes of the Triple Store
            </summary>
        </member>
        <member name="P:VDS.RDF.WrapperTripleStore.IsEmpty">
            <summary>
            Gets whether the store is empty
            </summary>
        </member>
        <member name="P:VDS.RDF.WrapperTripleStore.Graphs">
            <summary>
            Gets the Graphs of the store
            </summary>
        </member>
        <member name="P:VDS.RDF.WrapperTripleStore.Triples">
            <summary>
            Gets the triples of the store
            </summary>
        </member>
        <member name="P:VDS.RDF.WrapperTripleStore.Item(System.Uri)">
            <summary>
            Gets a Graph from the store
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
        </member>
        <member name="E:VDS.RDF.WrapperTripleStore.GraphAdded">
            <summary>
            Event which is raised when a graph is added
            </summary>
        </member>
        <member name="E:VDS.RDF.WrapperTripleStore.GraphRemoved">
            <summary>
            Events which is raised when a graph is removed
            </summary>
        </member>
        <member name="E:VDS.RDF.WrapperTripleStore.GraphChanged">
            <summary>
            Event which is raised when a graph is changed
            </summary>
        </member>
        <member name="E:VDS.RDF.WrapperTripleStore.GraphCleared">
            <summary>
            Event which is raised when a graph is cleared
            </summary>
        </member>
        <member name="E:VDS.RDF.WrapperTripleStore.GraphMerged">
            <summary>
            Event which is raised when a graph is merged
            </summary>
        </member>
        <member name="T:VDS.RDF.RdfException">
            <summary>
            Class for representing errors with RDF
            </summary>
        </member>
        <member name="M:VDS.RDF.RdfException.#ctor(System.String)">
            <summary>
            Creates a new RDF Exception with the given Message
            </summary>
            <param name="errorMsg">Error Message</param>
        </member>
        <member name="M:VDS.RDF.RdfException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new RDF Exception with the given Message and Inner Exception
            </summary>
            <param name="errorMsg">Error Message</param>
            <param name="cause">Inner Exception</param>
        </member>
        <member name="T:VDS.RDF.Configuration.DotNetRdfConfigurationException">
            <summary>
            Class for representing errors with dotNetRDF Configuration
            </summary>
            <remarks>
            <para>
            Configuration exceptions are thrown when the user tries to load objects using the <see cref="T:VDS.RDF.Configuration.ConfigurationLoader">ConfigurationLoader</see> and their is insufficient/invalid information to load the desired object
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Configuration.DotNetRdfConfigurationException.#ctor(System.String)">
            <summary>
            Creates a new dotNetRDF Configuration Exception
            </summary>
            <param name="errorMsg">Error Message</param>
        </member>
        <member name="M:VDS.RDF.Configuration.DotNetRdfConfigurationException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new dotNetRDF Configuration Exception
            </summary>
            <param name="errorMsg">Error Message</param>
            <param name="cause">Exception that caused this Exception</param>
        </member>
        <member name="T:VDS.RDF.Ontology.RdfOntologyException">
            <summary>
            Class for representing errors with Ontologies
            </summary>
        </member>
        <member name="M:VDS.RDF.Ontology.RdfOntologyException.#ctor(System.String)">
            <summary>
            Creates a new RDF Ontology Exception with the given message
            </summary>
            <param name="errorMsg">Error message</param>
        </member>
        <member name="M:VDS.RDF.Ontology.RdfOntologyException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new RDF Ontology Exception with the given message and inner exception
            </summary>
            <param name="errorMsg">Error message</param>
            <param name="cause">Inner Exception</param>
        </member>
        <member name="T:VDS.RDF.Parsing.RdfParseException">
            <summary>
            Class for representing errors in parsing RDF
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfParseException.#ctor(System.String)">
            <summary>
            Creates a new RDF Parse Exception with the given Message
            </summary>
            <param name="errorMsg">Error Message</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfParseException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new RDF Parse Exception with the given Message and Inner Exception
            </summary>
            <param name="errorMsg">Error Message</param>
            <param name="cause">Inner Exception</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfParseException.#ctor(System.String,VDS.RDF.Parsing.Tokens.IToken)">
            <summary>
            Creates a new RDF Parse Exception which contains Position Information taken from the given Token
            </summary>
            <param name="errorMsg">Error Message</param>
            <param name="t">Token</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfParseException.#ctor(System.String,VDS.RDF.Parsing.Tokens.IToken,System.Exception)">
            <summary>
            Creates a new RDF Parse Exception which contains Position Information taken from the given Token
            </summary>
            <param name="errorMsg">Error Message</param>
            <param name="t">Token</param>
            <param name="cause">Inner Exception</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfParseException.#ctor(System.String,System.Int32,System.Int32,System.Exception)">
            <summary>
            Creates a new RDF Parse Exception which contains Position Information
            </summary>
            <param name="errorMsg">Error Message</param>
            <param name="line">Line the error occurred on</param>
            <param name="pos">Column Position the error occurred at</param>
            <param name="cause">Exeception that caused this exception</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfParseException.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Creates a new RDF Parse Exception which contains Position Information
            </summary>
            <param name="errorMsg">Error Message</param>
            <param name="line">Line the error occurred on</param>
            <param name="pos">Column Position the error occurred at</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfParseException.#ctor(System.String,System.Int32,System.Int32,System.Int32,System.Exception)">
            <summary>
            Creates a new RDF Parse Exception which contains Position Information
            </summary>
            <param name="errorMsg">Error Message</param>
            <param name="line">Line the error occurred on</param>
            <param name="startPos">Column Position the error starts at</param>
            <param name="endPos">Column Position the error ends at</param>
            <param name="cause">Error that caused this exception</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfParseException.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new RDF Parse Exception which contains Position Information
            </summary>
            <param name="errorMsg">Error Message</param>
            <param name="line">Line the error occurred on</param>
            <param name="startPos">Column Position the error starts at</param>
            <param name="endPos">Column Position the error ends at</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfParseException.#ctor(System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Exception)">
            <summary>
            Creates a new RDF Parse Exception which contains Position Information
            </summary>
            <param name="errorMsg">Error Message</param>
            <param name="startLine">Line the error starts on</param>
            <param name="endLine">Line the error ends on</param>
            <param name="startPos">Column Position the error starts at</param>
            <param name="endPos">Column Position the error ends at</param>
            <param name="cause">Error that caused this exception</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfParseException.#ctor(System.String,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new RDF Parse Exception which contains Position Information
            </summary>
            <param name="errorMsg">Error Message</param>
            <param name="startLine">Line the error starts on</param>
            <param name="endLine">Line the error ends on</param>
            <param name="startPos">Column Position the error starts at</param>
            <param name="endPos">Column Position the error ends at</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfParseException.#ctor(System.String,VDS.RDF.Parsing.PositionInfo,System.Exception)">
            <summary>
            Creates a new RDF Parse Exception which contains Position Information
            </summary>
            <param name="errorMsg">Error Message</param>
            <param name="position">Position Information</param>
            <param name="cause">Error that caused this exception</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfParseException.#ctor(System.String,VDS.RDF.Parsing.PositionInfo)">
            <summary>
            Creates a new RDF Parse Exception which contains Position Information
            </summary>
            <param name="errorMsg">Error Message</param>
            <param name="position">Position Information</param>
        </member>
        <member name="P:VDS.RDF.Parsing.RdfParseException.HasPositionInformation">
            <summary>
            Gets whether the Exception has any position information
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.RdfParseException.StartLine">
            <summary>
            Gets the Start Line of the Error or -1 if no position information
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.RdfParseException.EndLine">
            <summary>
            Gets the End Line of the Error or -1 if no position information
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.RdfParseException.StartPosition">
            <summary>
            Gets the Start Column of the Error or -1 if no position information
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.RdfParseException.EndPosition">
            <summary>
            Gets the End Column of the Error or -1 if no position information
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.RdfThreadedParsingException">
            <summary>
            Class of exceptions that may occur when doing multi-threaded parsing of RDF
            </summary>
            <remarks>
            <para>
            Used when a process may result in multiple errors from different threads
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfThreadedParsingException.#ctor(System.String)">
            <summary>
            Creates a new Threaded RDF Parsing Exception
            </summary>
            <param name="message">Error Message</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfThreadedParsingException.AddException(System.Exception)">
            <summary>
            Adds an Exception to the list of Inner Exceptions
            </summary>
            <param name="ex">Exception</param>
        </member>
        <member name="P:VDS.RDF.Parsing.RdfThreadedParsingException.InnerExceptions">
            <summary>
            Gets the enumeration of Exceptions
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.RdfParserSelectionException">
            <summary>
            Class for representing errors in selecting an appropriate parser to parse RDF with
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfParserSelectionException.#ctor(System.String)">
            <summary>
            Creates a new RDF Parser Selection Exception with the given Message
            </summary>
            <param name="errorMsg">Error Message</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfParserSelectionException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new RDF Parser Selection Exception with the given Message and Inner Exception
            </summary>
            <param name="errorMsg">Error Message</param>
            <param name="cause">Inner Exception</param>
        </member>
        <member name="T:VDS.RDF.Parsing.RdfParsingTerminatedException">
            <summary>
            Class for representing that a parser has been terminated by a <see cref="T:VDS.RDF.IRdfHandler">IRdfHandler</see>
            </summary>
            <remarks>
            Used internally to help force execution to jump back to the point where we can handle by safely discarding this exception and stop parsing
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfParsingTerminatedException.#ctor">
            <summary>
            Creates a new Parsing Terminated exception
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.RdfQueryException">
            <summary>
            Class for representing errors that occur while querying RDF
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.RdfQueryException.#ctor(System.String)">
            <summary>
            Creates a new RDF Query Exception
            </summary>
            <param name="errorMsg">Error Message</param>
        </member>
        <member name="M:VDS.RDF.Query.RdfQueryException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new RDF Query Exception
            </summary>
            <param name="errorMsg">Error Message</param>
            <param name="cause">Exception that caused this Exception</param>
        </member>
        <member name="T:VDS.RDF.Query.RdfQueryTimeoutException">
            <summary>
            Class for representing Timeout errors that occur while querying RDF
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.RdfQueryTimeoutException.#ctor(System.String)">
            <summary>
            Creates a new RDF Query Timeout Exception
            </summary>
            <param name="errorMsg">Error Message</param>
        </member>
        <member name="T:VDS.RDF.Query.RdfReasoningException">
            <summary>
            Class for representing Exceptions occurring in RDF reasoners
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.RdfReasoningException.#ctor(System.String)">
            <summary>
            Creates a new RDF Reasoning Exception
            </summary>
            <param name="errorMsg">Error Message</param>
        </member>
        <member name="M:VDS.RDF.Query.RdfReasoningException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new RDF Reasoning Exception
            </summary>
            <param name="errorMsg">Error Message</param>
            <param name="cause">Exception that caused this exception</param>
        </member>
        <member name="T:VDS.RDF.Query.RdfQueryTerminatedException">
            <summary>
            Class for representing Termination errors
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.RdfQueryTerminatedException.#ctor">
            <summary>
            Creates a new RDF Query Termination Exception
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.RdfQueryPathFoundException">
            <summary>
            Class for representing Path Found terminations
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.RdfQueryPathFoundException.#ctor">
            <summary>
            Creates a new Path Found exception
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.RdfStorageException">
            <summary>
            Class for representing errors that occur in RDF Storage
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.RdfStorageException.#ctor(System.String)">
            <summary>
            Creates a new RDF Storage Exception
            </summary>
            <param name="errorMsg">Error Message</param>
        </member>
        <member name="M:VDS.RDF.Storage.RdfStorageException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new RDF Storage Exception
            </summary>
            <param name="errorMsg">Error Message</param>
            <param name="cause">Exception which caused this Exception</param>
        </member>
        <member name="T:VDS.RDF.Update.SparqlUpdateException">
            <summary>
            Class of exceptions that may occur when performing SPARQL Updates
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.SparqlUpdateException.#ctor(System.String)">
            <summary>
            Creates a new RDF Update Exception
            </summary>
            <param name="message">Error Message</param>
        </member>
        <member name="M:VDS.RDF.Update.SparqlUpdateException.#ctor(System.String,System.Exception)">
            <summary>
            Createa a new RDF Update Exception
            </summary>
            <param name="message">Error Message</param>
            <param name="cause">Exception that caused this exception to be thrown</param>
        </member>
        <member name="T:VDS.RDF.Update.SparqlUpdateTimeoutException">
            <summary>
            Class for representing Timeout errors that occur while updating RDF using SPARQL
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.SparqlUpdateTimeoutException.#ctor(System.String)">
            <summary>
            Creates a new SPARQL Update Timeout Exception
            </summary>
            <param name="errorMsg">Error Message</param>
        </member>
        <member name="T:VDS.RDF.Update.SparqlUpdatePermissionException">
            <summary>
            Class for representing Permissions errors with SPARQL Updates
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.SparqlUpdatePermissionException.#ctor(System.String)">
            <summary>
            Creates a new Permission Exception
            </summary>
            <param name="message">Error Message</param>
        </member>
        <member name="M:VDS.RDF.Update.SparqlUpdatePermissionException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new Permission Exception
            </summary>
            <param name="message">Error Message</param>
            <param name="cause">Exception that caused this exception to be thrown</param>
        </member>
        <member name="T:VDS.RDF.Update.SparqlUpdateMalformedException">
            <summary>
            Class for representing malformed SPARQL Updates
            </summary>
            <remarks>
            This is distinct from a <see cref="T:VDS.RDF.Parsing.RdfParseException">RdfParseException</see> as it is possible for an update to be syntactically valid but semantically malformed
            </remarks>
        </member>
        <member name="M:VDS.RDF.Update.SparqlUpdateMalformedException.#ctor(System.String)">
            <summary>
            Creates a new Malformed Update Exception
            </summary>
            <param name="message">Error Message</param>
        </member>
        <member name="M:VDS.RDF.Update.SparqlUpdateMalformedException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new Malformed Update Exception
            </summary>
            <param name="message">Error Message</param>
            <param name="cause">Exception that caused this exception to be thrown</param>
        </member>
        <member name="T:VDS.RDF.Update.Protocol.SparqlHttpProtocolException">
            <summary>
            Class of exceptions that may occur when using the SPARQL Graph Store HTTP Protocol for Graph Management
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.Protocol.SparqlHttpProtocolException.#ctor(System.String)">
            <summary>
            Creates a new SPARQL Graph Store HTTP Protocol Exception
            </summary>
            <param name="message">Error Message</param>
        </member>
        <member name="M:VDS.RDF.Update.Protocol.SparqlHttpProtocolException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new SPARQL Graph Store HTTP Protocol Exception
            </summary>
            <param name="message">Error Message</param>
            <param name="cause">Exception that caused this Exception</param>
        </member>
        <member name="T:VDS.RDF.Update.Protocol.SparqlHttpProtocolUriResolutionException">
            <summary>
            Exception that occurs when a Protocol Processor cannot resolve the URI for the Graph to be acted upon
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.Protocol.SparqlHttpProtocolUriResolutionException.#ctor">
            <summary>
            Creates a new Protocol URI Resolution Exception
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.Protocol.SparqlHttpProtocolUriResolutionException.#ctor(System.String)">
            <summary>
            Creates a new Protocol URI Resolution Exception
            </summary>
            <param name="message">Error Message</param>
        </member>
        <member name="T:VDS.RDF.Update.Protocol.SparqlHttpProtocolUriInvalidException">
            <summary>
            Exception that occurs when a Protocol Processor is provided with a invalid URI for the Graph to be acted upon
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.Protocol.SparqlHttpProtocolUriInvalidException.#ctor">
            <summary>
            Creates a new Protocol Invalid URI Exception
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.RdfOutputException">
            <summary>
            Class of exceptions that may occur when outputting RDF
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.RdfOutputException.#ctor(System.String)">
            <summary>
            Creates a new RDF Output Exception
            </summary>
            <param name="message">Error Message</param>
        </member>
        <member name="M:VDS.RDF.Writing.RdfOutputException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new RDF Output Exception
            </summary>
            <param name="message">Error Message</param>
            <param name="cause">Exception that caused this Exception</param>
        </member>
        <member name="T:VDS.RDF.Writing.RdfThreadedOutputException">
            <summary>
            Class of exceptions that may occur when doing multi-threaded output of RDF
            </summary>
            <remarks>
            <para>
            Used when a process may result in multiple errors from different threads
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Writing.RdfThreadedOutputException.#ctor(System.String)">
            <summary>
            Creates a new Threaded RDF Output Exception
            </summary>
            <param name="message">Error Message</param>
        </member>
        <member name="M:VDS.RDF.Writing.RdfThreadedOutputException.AddException(System.Exception)">
            <summary>
            Adds an Exception to the list of Inner Exceptions
            </summary>
            <param name="ex">Exception</param>
        </member>
        <member name="P:VDS.RDF.Writing.RdfThreadedOutputException.InnerExceptions">
            <summary>
            Gets the enumeration of Exceptions
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.RdfWriterSelectionException">
            <summary>
            Class for errors in selecting an appropriate Writer to output RDF with
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.RdfWriterSelectionException.#ctor(System.String)">
            <summary>
            Creates a new RDF Writer Selection Exception with the given Message
            </summary>
            <param name="errorMsg">Error Message</param>
        </member>
        <member name="M:VDS.RDF.Writing.RdfWriterSelectionException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new RDF Writer Selection Exception with the given Message and Inner Exception
            </summary>
            <param name="errorMsg">Error Message</param>
            <param name="cause">Inner Exception</param>
        </member>
        <member name="T:VDS.RDF.Nodes.TimeSpanNode">
            <summary>
            Valued Node representing a Time Span value
            </summary>
        </member>
        <member name="T:VDS.RDF.LiteralNode">
            <summary>
            Class for representing Literal Nodes
            </summary>
        </member>
        <member name="T:VDS.RDF.BaseLiteralNode">
            <summary>
            Abstract Base Class for Literal Nodes
            </summary>
        </member>
        <member name="T:VDS.RDF.BaseNode">
            <summary>
            Abstract Class for Nodes, implements the two basic properties of the INode Interface
            </summary>
        </member>
        <member name="T:VDS.RDF.INode">
            <summary>
            Interface for Nodes
            </summary>
        </member>
        <member name="M:VDS.RDF.INode.ToString">
            <summary>
            Gets the String representation of the Node
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.INode.ToString(VDS.RDF.Writing.Formatting.INodeFormatter)">
            <summary>
            Gets the String representation of the Node formatted with the given Node formatter
            </summary>
            <param name="formatter">Formatter</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.INode.ToString(VDS.RDF.Writing.Formatting.INodeFormatter,VDS.RDF.Writing.TripleSegment)">
            <summary>
            Gets the String representation of the Node formatted with the given Node formatter
            </summary>
            <param name="formatter">Formatter</param>
            <param name="segment">Triple Segment</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.INode.NodeType">
            <summary>
            Nodes have a Type
            </summary>
            <remarks>Primarily provided so can do quick integer comparison to see what type of Node you have without having to do actual full blown Type comparison</remarks>
        </member>
        <member name="P:VDS.RDF.INode.Graph">
            <summary>
            Gets the Graph the Node belongs to
            </summary>
        </member>
        <member name="P:VDS.RDF.INode.GraphUri">
            <summary>
            Gets/Sets the Graph URI associated with a Node
            </summary>
        </member>
        <member name="F:VDS.RDF.BaseNode._graph">
            <summary>
            Reference to the Graph that the Node belongs to
            </summary>
        </member>
        <member name="F:VDS.RDF.BaseNode._graphUri">
            <summary>
            Uri of the Graph that the Node belongs to
            </summary>
        </member>
        <member name="F:VDS.RDF.BaseNode._nodetype">
            <summary>
            Node Type for the Node
            </summary>
        </member>
        <member name="F:VDS.RDF.BaseNode._hashcode">
            <summary>
            Stores the computed Hash Code for this Node
            </summary>
        </member>
        <member name="M:VDS.RDF.BaseNode.#ctor(VDS.RDF.IGraph,VDS.RDF.NodeType)">
            <summary>
            Base Constructor which instantiates the Graph reference, Graph Uri and Node Type of the Node
            </summary>
            <param name="g">Graph this Node is in</param>
            <param name="type">Node Type</param>
        </member>
        <member name="M:VDS.RDF.BaseNode.Equals(System.Object)">
            <summary>
            Nodes must implement an Equals method
            </summary>
            <param name="obj">Object to compare against</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseNode.ToString">
            <summary>
            Nodes must implement a ToString method
            </summary>
            <returns></returns>
            <remarks>
            <para>
            Essential for the implementation of GetHashCode to work correctly, Nodes should generate a String representation that is 'unique' as far as that is possible.
            </para>
            <para>
            Any two Nodes which match via the Equals method (based on strict RDF Specification Equality) should produce the same String representation since Hash Codes are generated by calling GetHashCode on this String
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.BaseNode.ToString(VDS.RDF.Writing.Formatting.INodeFormatter)">
            <summary>
            Gets the String representation of the Node formatted with the given Node formatter
            </summary>
            <param name="formatter">Formatter</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseNode.ToString(VDS.RDF.Writing.Formatting.INodeFormatter,VDS.RDF.Writing.TripleSegment)">
            <summary>
            Gets the String representation of the Node formatted with the given Node formatter
            </summary>
            <param name="formatter">Formatter</param>
            <param name="segment">Triple Segment</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseNode.GetHashCode">
            <summary>
            Gets a Hash Code for a Node
            </summary>
            <returns></returns>
            <remarks>
            <para>
            Implemented by getting the Hash Code of the result of ToString for a Node prefixed with its Node Type, this is pre-computed for efficiency when a Node is created since Nodes are immutable.  See remarks on ToString for more detail.
            </para>
            <para>
            Since Hash Codes are based on a String representation there is no guarantee of uniqueness though the same Node will always give the same Hash Code (on a given Platform - see the MSDN Documentation for <see cref="M:System.String.GetHashCode">string.GetHashCode()</see> for further details)
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.BaseNode.op_Equality(VDS.RDF.BaseNode,VDS.RDF.BaseNode)">
            <summary>
            The Equality operator is defined for Nodes
            </summary>
            <param name="a">First Node</param>
            <param name="b">Second Node</param>
            <returns>Whether the two Nodes are equal</returns>
            <remarks>Uses the Equals method to evaluate the result</remarks>
        </member>
        <member name="M:VDS.RDF.BaseNode.op_Inequality(VDS.RDF.BaseNode,VDS.RDF.BaseNode)">
            <summary>
            The Non-Equality operator is defined for Nodes
            </summary>
            <param name="a">First Node</param>
            <param name="b">Second Node</param>
            <returns>Whether the two Nodes are non-equal</returns>
            <remarks>Uses the Equals method to evaluate the result</remarks>
        </member>
        <member name="M:VDS.RDF.BaseNode.CompareTo(VDS.RDF.INode)">
            <summary>
            Nodes must implement a CompareTo method to allow them to be Sorted
            </summary>
            <param name="other">Node to compare self to</param>
            <returns></returns>
            <remarks>
            Implementations should use the SPARQL Term Sort Order for ordering nodes (as opposed to value sort order).  Standard implementations of Node type specific comparisons can be found in <see cref="T:VDS.RDF.ComparisonHelper">ComparisonHelper</see>
            </remarks>
        </member>
        <member name="M:VDS.RDF.BaseNode.CompareTo(VDS.RDF.IBlankNode)">
            <summary>
            Nodes must implement a CompareTo method to allow them to be Sorted
            </summary>
            <param name="other">Node to compare self to</param>
            <returns></returns>
            <remarks>
            Implementations should use the SPARQL Term Sort Order for ordering nodes (as opposed to value sort order).  Standard implementations of Node type specific comparisons can be found in <see cref="T:VDS.RDF.ComparisonHelper">ComparisonHelper</see>
            </remarks>
        </member>
        <member name="M:VDS.RDF.BaseNode.CompareTo(VDS.RDF.IGraphLiteralNode)">
            <summary>
            Nodes must implement a CompareTo method to allow them to be Sorted
            </summary>
            <param name="other">Node to compare self to</param>
            <returns></returns>
            <remarks>
            Implementations should use the SPARQL Term Sort Order for ordering nodes (as opposed to value sort order).  Standard implementations of Node type specific comparisons can be found in <see cref="T:VDS.RDF.ComparisonHelper">ComparisonHelper</see>
            </remarks>
        </member>
        <member name="M:VDS.RDF.BaseNode.CompareTo(VDS.RDF.ILiteralNode)">
            <summary>
            Nodes must implement a CompareTo method to allow them to be Sorted
            </summary>
            <param name="other">Node to compare self to</param>
            <returns></returns>
            <remarks>
            Implementations should use the SPARQL Term Sort Order for ordering nodes (as opposed to value sort order).  Standard implementations of Node type specific comparisons can be found in <see cref="T:VDS.RDF.ComparisonHelper">ComparisonHelper</see>
            </remarks>
        </member>
        <member name="M:VDS.RDF.BaseNode.CompareTo(VDS.RDF.IUriNode)">
            <summary>
            Nodes must implement a CompareTo method to allow them to be Sorted
            </summary>
            <param name="other">Node to compare self to</param>
            <returns></returns>
            <remarks>
            Implementations should use the SPARQL Term Sort Order for ordering nodes (as opposed to value sort order).  Standard implementations of Node type specific comparisons can be found in <see cref="T:VDS.RDF.ComparisonHelper">ComparisonHelper</see>
            </remarks>
        </member>
        <member name="M:VDS.RDF.BaseNode.CompareTo(VDS.RDF.IVariableNode)">
            <summary>
            Nodes must implement a CompareTo method to allow them to be Sorted
            </summary>
            <param name="other">Node to compare self to</param>
            <returns></returns>
            <remarks>
            Implementations should use the SPARQL Term Sort Order for ordering nodes (as opposed to value sort order).  Standard implementations of Node type specific comparisons can be found in <see cref="T:VDS.RDF.ComparisonHelper">ComparisonHelper</see>
            </remarks>
        </member>
        <member name="M:VDS.RDF.BaseNode.Equals(VDS.RDF.INode)">
            <summary>
            Nodes must implement an Equals method so we can do type specific equality
            </summary>
            <param name="other">Node to check for equality</param>
            <returns></returns>
            <remarks>
            Nodes implementations are also required to implement an override of the non-generic Equals method.  Standard implementations of some equality comparisons can be found in <see cref="T:VDS.RDF.EqualityHelper">EqualityHelper</see>
            </remarks>
        </member>
        <member name="M:VDS.RDF.BaseNode.Equals(VDS.RDF.IBlankNode)">
            <summary>
            Nodes must implement an Equals method so we can do type specific equality
            </summary>
            <param name="other">Node to check for equality</param>
            <returns></returns>
            <remarks>
            Nodes implementations are also required to implement an override of the non-generic Equals method.  Standard implementations of some equality comparisons can be found in <see cref="T:VDS.RDF.EqualityHelper">EqualityHelper</see>
            </remarks>
        </member>
        <member name="M:VDS.RDF.BaseNode.Equals(VDS.RDF.IGraphLiteralNode)">
            <summary>
            Nodes must implement an Equals method so we can do type specific equality
            </summary>
            <param name="other">Node to check for equality</param>
            <returns></returns>
            <remarks>
            Nodes implementations are also required to implement an override of the non-generic Equals method.  Standard implementations of some equality comparisons can be found in <see cref="T:VDS.RDF.EqualityHelper">EqualityHelper</see>
            </remarks>
        </member>
        <member name="M:VDS.RDF.BaseNode.Equals(VDS.RDF.ILiteralNode)">
            <summary>
            Nodes must implement an Equals method so we can do type specific equality
            </summary>
            <param name="other">Node to check for equality</param>
            <returns></returns>
            <remarks>
            Nodes implementations are also required to implement an override of the non-generic Equals method.  Standard implementations of some equality comparisons can be found in <see cref="T:VDS.RDF.EqualityHelper">EqualityHelper</see>
            </remarks>
        </member>
        <member name="M:VDS.RDF.BaseNode.Equals(VDS.RDF.IUriNode)">
            <summary>
            Nodes must implement an Equals method so we can do type specific equality
            </summary>
            <param name="other">Node to check for equality</param>
            <returns></returns>
            <remarks>
            Nodes implementations are also required to implement an override of the non-generic Equals method.  Standard implementations of some equality comparisons can be found in <see cref="T:VDS.RDF.EqualityHelper">EqualityHelper</see>
            </remarks>
        </member>
        <member name="M:VDS.RDF.BaseNode.Equals(VDS.RDF.IVariableNode)">
            <summary>
            Nodes must implement an Equals method so we can do type specific equality
            </summary>
            <param name="other">Node to check for equality</param>
            <returns></returns>
            <remarks>
            Nodes implementations are also required to implement an override of the non-generic Equals method.  Standard implementations of some equality comparisons can be found in <see cref="T:VDS.RDF.EqualityHelper">EqualityHelper</see>
            </remarks>
        </member>
        <member name="P:VDS.RDF.BaseNode.NodeType">
            <summary>
            Nodes have a Type
            </summary>
        </member>
        <member name="P:VDS.RDF.BaseNode.Graph">
            <summary>
            Nodes belong to a Graph
            </summary>
        </member>
        <member name="P:VDS.RDF.BaseNode.GraphUri">
            <summary>
            Gets/Sets the Graph Uri of the Node
            </summary>
        </member>
        <member name="T:VDS.RDF.ILiteralNode">
            <summary>
            Interface for Literal Nodes
            </summary>
        </member>
        <member name="P:VDS.RDF.ILiteralNode.Value">
            <summary>
            Gets the Lexical Value of the Literal
            </summary>
        </member>
        <member name="P:VDS.RDF.ILiteralNode.Language">
            <summary>
            Gets the Language specifier (if any) of the Literal or the Empty String
            </summary>
        </member>
        <member name="P:VDS.RDF.ILiteralNode.DataType">
            <summary>
            Gets the DataType URI (if any) of the Literal or null
            </summary>
        </member>
        <member name="F:VDS.RDF.BaseLiteralNode.LangSpecLiteralHashCodeSalt">
            <summary>
            Constants used to add salt to the hashes of different Literal Nodes
            </summary>
        </member>
        <member name="F:VDS.RDF.BaseLiteralNode.DataTypedLiteralHashCodeSalt">
            <summary>
            Constants used to add salt to the hashes of different Literal Nodes
            </summary>
        </member>
        <member name="F:VDS.RDF.BaseLiteralNode.PlainLiteralHashCodeSalt">
            <summary>
            Constants used to add salt to the hashes of different Literal Nodes
            </summary>
        </member>
        <member name="M:VDS.RDF.BaseLiteralNode.#ctor(VDS.RDF.IGraph,System.String)">
            <summary>
            Internal Only Constructor for Literal Nodes
            </summary>
            <param name="g">Graph this Node is in</param>
            <param name="literal">String value of the Literal</param>
        </member>
        <member name="M:VDS.RDF.BaseLiteralNode.#ctor(VDS.RDF.IGraph,System.String,System.Boolean)">
            <summary>
            Internal Only Constructor for Literal Nodes
            </summary>
            <param name="g">Graph this Node is in</param>
            <param name="literal">String value of the Literal</param>
            <param name="normalize">Whether to Normalize the Literal Value</param>
        </member>
        <member name="M:VDS.RDF.BaseLiteralNode.#ctor(VDS.RDF.IGraph,System.String,System.String)">
            <summary>
            Internal Only Constructor for Literal Nodes
            </summary>
            <param name="g">Graph this Node is in</param>
            <param name="literal">String value of the Literal</param>
            <param name="langspec">String value for the Language Specifier for the Literal</param>
        </member>
        <member name="M:VDS.RDF.BaseLiteralNode.#ctor(VDS.RDF.IGraph,System.String,System.String,System.Boolean)">
            <summary>
            Internal Only Constructor for Literal Nodes
            </summary>
            <param name="g">Graph this Node is in</param>
            <param name="literal">String value of the Literal</param>
            <param name="langspec">String value for the Language Specifier for the Literal</param>
            <param name="normalize">Whether to Normalize the Literal Value</param>
        </member>
        <member name="M:VDS.RDF.BaseLiteralNode.#ctor(VDS.RDF.IGraph,System.String,System.Uri)">
            <summary>
            Internal Only Constructor for Literal Nodes
            </summary>
            <param name="g">Graph this Node is in</param>
            <param name="literal">String value of the Literal</param>
            <param name="datatype">Uri for the Literals Data Type</param>
        </member>
        <member name="M:VDS.RDF.BaseLiteralNode.#ctor(VDS.RDF.IGraph,System.String,System.Uri,System.Boolean)">
            <summary>
            Internal Only Constructor for Literal Nodes
            </summary>
            <param name="g">Graph this Node is in</param>
            <param name="literal">String value of the Literal</param>
            <param name="datatype">Uri for the Literals Data Type</param>
            <param name="normalize">Whether to Normalize the Literal Value</param>
        </member>
        <member name="M:VDS.RDF.BaseLiteralNode.#ctor">
            <summary>
            Deserialization Only Constructor
            </summary>
        </member>
        <member name="M:VDS.RDF.BaseLiteralNode.Equals(System.Object)">
            <summary>
            Implementation of the Equals method for Literal Nodes
            </summary>
            <param name="obj">Object to compare the Node with</param>
            <returns></returns>
            <remarks>
            The default behaviour is for Literal Nodes to be considered equal IFF
            <ol>
            <li>Their Language Specifiers are identical (or neither has a Language Specifier)</li>
            <li>Their Data Types are identical (or neither has a Data Type)</li>
            <li>Their String values are identical</li>
            </ol>
            This behaviour can be overridden to use value equality by setting the <see cref="P:VDS.RDF.Options.LiteralEqualityMode">LiteralEqualityMode</see> option to be <see cref="F:VDS.RDF.LiteralEqualityMode.Loose">Loose</see> if this is more suited to your application.
            </remarks>
        </member>
        <member name="M:VDS.RDF.BaseLiteralNode.Equals(VDS.RDF.INode)">
            <summary>
            Implementation of the Equals method for Literal Nodes
            </summary>
            <param name="other">Object to compare the Node with</param>
            <returns></returns>
            <remarks>
            The default behaviour is for Literal Nodes to be considered equal IFF
            <ol>
            <li>Their Language Specifiers are identical (or neither has a Language Specifier)</li>
            <li>Their Data Types are identical (or neither has a Data Type)</li>
            <li>Their String values are identical</li>
            </ol>
            This behaviour can be overridden to use value equality by setting the <see cref="P:VDS.RDF.Options.LiteralEqualityMode">LiteralEqualityMode</see> option to be <see cref="F:VDS.RDF.LiteralEqualityMode.Loose">Loose</see> if this is more suited to your application.
            </remarks>
        </member>
        <member name="M:VDS.RDF.BaseLiteralNode.Equals(VDS.RDF.IBlankNode)">
            <summary>
            Determines whether this Node is equal to a Blank Node (should always be false)
            </summary>
            <param name="other">Blank Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseLiteralNode.Equals(VDS.RDF.IGraphLiteralNode)">
            <summary>
            Determines whether this Node is equal to a Graph Literal Node (should always be false)
            </summary>
            <param name="other">Graph Literal Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseLiteralNode.Equals(VDS.RDF.ILiteralNode)">
            <summary>
            Determines whether this Node is equal to a Literal Node
            </summary>
            <param name="other">Literal Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseLiteralNode.Equals(VDS.RDF.IUriNode)">
            <summary>
            Determines whether this Node is equal to a URI Node (should always be false)
            </summary>
            <param name="other">URI Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseLiteralNode.Equals(VDS.RDF.IVariableNode)">
            <summary>
            Determines whether this Node is equal to a Variable Node (should always be false)
            </summary>
            <param name="other">Variable Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseLiteralNode.Equals(VDS.RDF.BaseLiteralNode)">
            <summary>
            Determines whether this Node is equal to a Literal Node
            </summary>
            <param name="other">Literal Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseLiteralNode.ToString">
            <summary>
            Gets a String representation of a Literal Node
            </summary>
            <returns></returns>
            <remarks>Gives a value without quotes (as some syntaxes use) with the Data Type/Language Specifier appended using Notation 3 syntax</remarks>
        </member>
        <member name="M:VDS.RDF.BaseLiteralNode.CompareTo(VDS.RDF.INode)">
            <summary>
            Implementation of CompareTo for Literal Nodes
            </summary>
            <param name="other">Node to Compare To</param>
            <returns></returns>
            <remarks>
            Literal Nodes are greater than Blank Nodes, Uri Nodes and Nulls, they are less than Graph Literal Nodes.
            <br /><br />
            Two Literal Nodes are initially compared based upon Data Type, untyped literals are less than typed literals.  Two untyped literals are compared purely on lexical value, Language Specifier has no effect on the ordering.  This means Literal Nodes are only partially ordered, for example "hello"@en and "hello"@en-us are considered to be the same for ordering purposes though they are different for equality purposes.  Datatyped Literals can only be properly ordered if they are one of a small subset of types (Integers, Booleans, Date Times, Strings and URIs).  If the datatypes for two Literals are non-matching they are ordered on Datatype Uri, this ensures that each range of Literal Nodes is sorted to some degree.  Again this also means that Literals are partially ordered since unknown datatypes will only be sorted based on lexical value and not on actual value.
            </remarks>
        </member>
        <member name="M:VDS.RDF.BaseLiteralNode.CompareTo(VDS.RDF.IBlankNode)">
            <summary>
            Returns an Integer indicating the Ordering of this Node compared to another Node
            </summary>
            <param name="other">Node to test against</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseLiteralNode.CompareTo(VDS.RDF.ILiteralNode)">
            <summary>
            Returns an Integer indicating the Ordering of this Node compared to another Node
            </summary>
            <param name="other">Node to test against</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseLiteralNode.CompareTo(VDS.RDF.IGraphLiteralNode)">
            <summary>
            Returns an Integer indicating the Ordering of this Node compared to another Node
            </summary>
            <param name="other">Node to test against</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseLiteralNode.CompareTo(VDS.RDF.IUriNode)">
            <summary>
            Returns an Integer indicating the Ordering of this Node compared to another Node
            </summary>
            <param name="other">Node to test against</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseLiteralNode.CompareTo(VDS.RDF.IVariableNode)">
            <summary>
            Returns an Integer indicating the Ordering of this Node compared to another Node
            </summary>
            <param name="other">Node to test against</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseLiteralNode.CompareTo(VDS.RDF.BaseLiteralNode)">
            <summary>
            Returns an Integer indicating the Ordering of this Node compared to another Node
            </summary>
            <param name="other">Node to test against</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.BaseLiteralNode.Value">
            <summary>
            Gives the String Value of the Literal
            </summary>
        </member>
        <member name="P:VDS.RDF.BaseLiteralNode.Language">
            <summary>
            Gives the Language Specifier for the Literal (if it exists) or the Empty String
            </summary>
        </member>
        <member name="P:VDS.RDF.BaseLiteralNode.DataType">
            <summary>
            Gives the Data Type Uri for the Literal (if it exists) or a null
            </summary>
        </member>
        <member name="F:VDS.RDF.LiteralNode.LangSpecLiteralHashCodeSalt">
            <summary>
            Constants used to add salt to the hashes of different Literal Nodes
            </summary>
        </member>
        <member name="F:VDS.RDF.LiteralNode.DataTypedLiteralHashCodeSalt">
            <summary>
            Constants used to add salt to the hashes of different Literal Nodes
            </summary>
        </member>
        <member name="F:VDS.RDF.LiteralNode.PlainLiteralHashCodeSalt">
            <summary>
            Constants used to add salt to the hashes of different Literal Nodes
            </summary>
        </member>
        <member name="M:VDS.RDF.LiteralNode.#ctor(VDS.RDF.IGraph,System.String)">
            <summary>
            Internal Only Constructor for Literal Nodes
            </summary>
            <param name="g">Graph this Node is in</param>
            <param name="literal">String value of the Literal</param>
        </member>
        <member name="M:VDS.RDF.LiteralNode.#ctor(VDS.RDF.IGraph,System.String,System.Boolean)">
            <summary>
            Internal Only Constructor for Literal Nodes
            </summary>
            <param name="g">Graph this Node is in</param>
            <param name="literal">String value of the Literal</param>
            <param name="normalize">Whether to Normalize the Literal Value</param>
        </member>
        <member name="M:VDS.RDF.LiteralNode.#ctor(VDS.RDF.IGraph,System.String,System.String)">
            <summary>
            Internal Only Constructor for Literal Nodes
            </summary>
            <param name="g">Graph this Node is in</param>
            <param name="literal">String value of the Literal</param>
            <param name="langspec">String value for the Language Specifier for the Literal</param>
        </member>
        <member name="M:VDS.RDF.LiteralNode.#ctor(VDS.RDF.IGraph,System.String,System.String,System.Boolean)">
            <summary>
            Internal Only Constructor for Literal Nodes
            </summary>
            <param name="g">Graph this Node is in</param>
            <param name="literal">String value of the Literal</param>
            <param name="langspec">String value for the Language Specifier for the Literal</param>
            <param name="normalize">Whether to Normalize the Literal Value</param>
        </member>
        <member name="M:VDS.RDF.LiteralNode.#ctor(VDS.RDF.IGraph,System.String,System.Uri)">
            <summary>
            Internal Only Constructor for Literal Nodes
            </summary>
            <param name="g">Graph this Node is in</param>
            <param name="literal">String value of the Literal</param>
            <param name="datatype">Uri for the Literals Data Type</param>
        </member>
        <member name="M:VDS.RDF.LiteralNode.#ctor(VDS.RDF.IGraph,System.String,System.Uri,System.Boolean)">
            <summary>
            Internal Only Constructor for Literal Nodes
            </summary>
            <param name="g">Graph this Node is in</param>
            <param name="literal">String value of the Literal</param>
            <param name="datatype">Uri for the Literals Data Type</param>
            <param name="normalize">Whether to Normalize the Literal Value</param>
        </member>
        <member name="M:VDS.RDF.LiteralNode.#ctor">
            <summary>
            Deserialization Only Constructor
            </summary>
        </member>
        <member name="M:VDS.RDF.LiteralNode.CompareTo(VDS.RDF.LiteralNode)">
            <summary>
            Implementation of Compare To for Literal Nodes
            </summary>
            <param name="other">Literal Node to Compare To</param>
            <returns></returns>
            <remarks>
            Simply invokes the more general implementation of this method
            </remarks>
        </member>
        <member name="M:VDS.RDF.LiteralNode.Equals(VDS.RDF.LiteralNode)">
            <summary>
            Determines whether this Node is equal to a Literal Node
            </summary>
            <param name="other">Literal Node</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Nodes.IValuedNode">
            <summary>
            Interface for Valued Nodes
            </summary>
            <remarks>
            <para>
            This interface extends the basic <see cref="T:VDS.RDF.INode">INode</see> interface with methods related to turning the lexical value into a strongly typed .Net value.  It is intended primarily for use within SPARQL expression evaluation where we need to do a lot of value conversions and currently waste a lot of effort (and thus performance) doing that.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Nodes.IValuedNode.AsString">
            <summary>
            Gets the String value of the Node
            </summary>
            <returns></returns>
            <remarks>
            This is distinct from <strong>ToString()</strong> because that method will typically include additional information like language specifier/datatype as appropriate whereas this method is used to produce a string as would be produced by applying the <strong>STR()</strong> function from SPARQL
            </remarks>
        </member>
        <member name="M:VDS.RDF.Nodes.IValuedNode.AsInteger">
            <summary>
            Gets the Long value of the Node
            </summary>
            <returns></returns>
            <exception cref="T:VDS.RDF.Query.RdfQueryException">Thrown if the Node cannot be converted to a Long</exception>
        </member>
        <member name="M:VDS.RDF.Nodes.IValuedNode.AsDecimal">
            <summary>
            Gets the Decimal value of the Node
            </summary>
            <returns></returns>
            <exception cref="T:VDS.RDF.Query.RdfQueryException">Thrown if the Node cannot be converted to a Decimal</exception>
        </member>
        <member name="M:VDS.RDF.Nodes.IValuedNode.AsFloat">
            <summary>
            Gets the Float value of the Node
            </summary>
            <returns></returns>
            <exception cref="T:VDS.RDF.Query.RdfQueryException">Thrown if the Node cannot be converted to a Float</exception>
        </member>
        <member name="M:VDS.RDF.Nodes.IValuedNode.AsDouble">
            <summary>
            Gets the Double value of the Node
            </summary>
            <returns></returns>
            <exception cref="T:VDS.RDF.Query.RdfQueryException">Thrown if the Node cannot be converted to a Double</exception>
        </member>
        <member name="M:VDS.RDF.Nodes.IValuedNode.AsBoolean">
            <summary>
            Gets the Boolean value of the Node
            </summary>
            <returns></returns>
            <exception cref="T:VDS.RDF.Query.RdfQueryException">Thrown if the Node cannot be converted to a Boolean</exception>
        </member>
        <member name="M:VDS.RDF.Nodes.IValuedNode.AsDateTime">
            <summary>
            Gets the Date Time value of the Node
            </summary>
            <returns></returns>
            <exception cref="T:VDS.RDF.Query.RdfQueryException">Thrown if the Node cannot be converted to a Date Time</exception>
        </member>
        <member name="M:VDS.RDF.Nodes.IValuedNode.AsDateTimeOffset">
            <summary>
            Gets the Date Time Offset value of the Node
            </summary>
            <returns></returns>
            <exception cref="T:VDS.RDF.Query.RdfQueryException">Thrown if the Node cannot be converted to a Date Time Offset</exception>
        </member>
        <member name="M:VDS.RDF.Nodes.IValuedNode.AsTimeSpan">
            <summary>
            Gets the Time Span value of the Node
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Nodes.IValuedNode.EffectiveType">
            <summary>
            Gets the URI of the datatype this valued node represents as a String
            </summary>
            <remarks>
            Either String.Empty if no type or the string form of the type URI
            </remarks>
        </member>
        <member name="P:VDS.RDF.Nodes.IValuedNode.NumericType">
            <summary>
            Gets the Numeric Type of the Node
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.TimeSpanNode.#ctor(VDS.RDF.IGraph,System.TimeSpan)">
            <summary>
            Creates a new Time span node
            </summary>
            <param name="g">Graph</param>
            <param name="value">Time Span</param>
        </member>
        <member name="M:VDS.RDF.Nodes.TimeSpanNode.#ctor(VDS.RDF.IGraph,System.TimeSpan,System.String)">
            <summary>
            Creates a new Time span node 
            </summary>
            <param name="g">Graph</param>
            <param name="value">Time Span</param>
            <param name="lexicalValue">Lexical value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.TimeSpanNode.#ctor(VDS.RDF.IGraph,System.TimeSpan,System.String,System.Uri)">
            <summary>
            Creates a new Time span node
            </summary>
            <param name="g">Graph</param>
            <param name="value">Time Span</param>
            <param name="lexicalValue">Lexical value</param>
            <param name="dtUri">Data type URI</param>
        </member>
        <member name="M:VDS.RDF.Nodes.TimeSpanNode.AsString">
            <summary>
            Gets the date time value as a string
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.TimeSpanNode.AsInteger">
            <summary>
            Throws an error as date times cannot be converted to integers
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.TimeSpanNode.AsDecimal">
            <summary>
            Throws an error as date times cannot be converted to decimals
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.TimeSpanNode.AsFloat">
            <summary>
            Throws an error as date times cannot be converted to floats
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.TimeSpanNode.AsDouble">
            <summary>
            Throws an error as date times cannot be converted to doubles
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.TimeSpanNode.AsBoolean">
            <summary>
            Throws an error as date times cannot be converted to booleans
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.TimeSpanNode.AsDateTime">
            <summary>
            Gets the date time value of the node
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.TimeSpanNode.AsDateTimeOffset">
            <summary>
            Gets the date time value of the node
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.TimeSpanNode.AsTimeSpan">
            <summary>
            Gets the time span value of the node
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Nodes.TimeSpanNode.EffectiveType">
            <summary>
            Gets the URI of the datatype this valued node represents as a String
            </summary>
        </member>
        <member name="P:VDS.RDF.Nodes.TimeSpanNode.NumericType">
            <summary>
            Gets the numeric type of the node
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.CommentIgnoringJsonTextReader">
            <summary>
            A subclass of <see cref="T:Newtonsoft.Json.JsonTextReader">JsonTextReader</see> which automatically ignores all comments
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.CommentIgnoringJsonTextReader.Read">
            <summary>
            Reads the next non-comment Token if one is available
            </summary>
            <returns>True if a Token was read, False otherwise</returns>
        </member>
        <member name="T:VDS.RDF.Parsing.Contexts.TurtleParserContext">
            <summary>
            Parser Context for Turtle parsing
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Contexts.TokenisingParserContext">
            <summary>
            Class for Parser Contexts for Tokeniser based Parsing
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Contexts.BaseParserContext">
            <summary>
            Base Class for Parser Contexts
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Contexts.IParserContext">
            <summary>
            Interface for Parser Contexts
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.IParserContext.Handler">
            <summary>
            Gets the RDF Handler which is used to instantiate Nodes and to handle the generated RDF
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.IParserContext.TraceParsing">
            <summary>
            Gets/Sets whether Parser Tracing should be used (if the Parser supports it)
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.IParserContext.Namespaces">
            <summary>
            Gets the Namespace Map for the Handler
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.IParserContext.BaseUri">
            <summary>
            Gets the Base URI for the Handler
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Contexts.BaseParserContext._handler">
            <summary>
            RDF Handler used to handle the generated RDF
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Contexts.BaseParserContext._traceParsing">
            <summary>
            Is Parsing Traced?
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.BaseParserContext.#ctor(VDS.RDF.IGraph)">
            <summary>
            Creates a new Base Parser Context
            </summary>
            <param name="g">Graph to parse into</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.BaseParserContext.#ctor(VDS.RDF.IGraph,System.Boolean)">
            <summary>
            Creates a new Base Parser Context
            </summary>
            <param name="g">Graph to parse into</param>
            <param name="traceParsing">Whether to trace parsing</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.BaseParserContext.#ctor(VDS.RDF.IRdfHandler)">
            <summary>
            Creates a new Base Parser Context
            </summary>
            <param name="handler">RDF Handler</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.BaseParserContext.#ctor(VDS.RDF.IRdfHandler,System.Boolean)">
            <summary>
            Creates a new Base Parser Context
            </summary>
            <param name="handler">RDF Handler</param>
            <param name="traceParsing">Whether to trace parsing</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.BaseParserContext.Handler">
            <summary>
            Gets the Handler used to handle the generated RDF
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.BaseParserContext.TraceParsing">
            <summary>
            Gets/Sets whether to trace parsing
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.BaseParserContext.Namespaces">
            <summary>
            Gets the Namespace Map for the parsing context
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.BaseParserContext.BaseUri">
            <summary>
            Gets the Base URI for the parsing context
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Contexts.ITokenisingParserContext">
            <summary>
            Interface for Parser Contexts which use Tokeniser based parsing
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.ITokenisingParserContext.TraceTokeniser">
            <summary>
            Gets/Sets whether Tokenisation is Traced
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.ITokenisingParserContext.LocalTokens">
            <summary>
            Gets the Local Tokens Stack
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.ITokenisingParserContext.Tokens">
            <summary>
            Gets the Token Queue
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Contexts.TokenisingParserContext._queue">
            <summary>
            Tokeniser
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Contexts.TokenisingParserContext._traceTokeniser">
            <summary>
            Is Tokeniser traced?
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Contexts.TokenisingParserContext._localTokens">
            <summary>
            Local Tokens
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TokenisingParserContext.#ctor(VDS.RDF.IGraph,VDS.RDF.Parsing.Tokens.ITokeniser)">
            <summary>
            Creates a new Tokenising Parser Context with default settings
            </summary>
            <param name="g">Graph to parse into</param>
            <param name="tokeniser">Tokeniser to use</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TokenisingParserContext.#ctor(VDS.RDF.IGraph,VDS.RDF.Parsing.Tokens.ITokeniser,VDS.RDF.Parsing.Tokens.TokenQueueMode)">
            <summary>
            Creates a new Tokenising Parser Context with custom settings
            </summary>
            <param name="g">Graph to parse into</param>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="queueMode">Tokeniser Queue Mode</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TokenisingParserContext.#ctor(VDS.RDF.IGraph,VDS.RDF.Parsing.Tokens.ITokeniser,System.Boolean,System.Boolean)">
            <summary>
            Creates a new Tokenising Parser Context with custom settings
            </summary>
            <param name="g">Graph to parse into</param>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="traceParsing">Whether to trace parsing</param>
            <param name="traceTokeniser">Whether to trace tokenisation</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TokenisingParserContext.#ctor(VDS.RDF.IGraph,VDS.RDF.Parsing.Tokens.ITokeniser,VDS.RDF.Parsing.Tokens.TokenQueueMode,System.Boolean,System.Boolean)">
            <summary>
            Creates a new Tokenising Parser Context with custom settings
            </summary>
            <param name="g">Graph to parse into</param>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="queueMode">Tokeniser Queue Mode</param>
            <param name="traceParsing">Whether to trace parsing</param>
            <param name="traceTokeniser">Whether to trace tokenisation</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TokenisingParserContext.#ctor(VDS.RDF.IRdfHandler,VDS.RDF.Parsing.Tokens.ITokeniser)">
            <summary>
            Creates a new Tokenising Parser Context with default settings
            </summary>
            <param name="handler">RDF Handler</param>
            <param name="tokeniser">Tokeniser to use</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TokenisingParserContext.#ctor(VDS.RDF.IRdfHandler,VDS.RDF.Parsing.Tokens.ITokeniser,VDS.RDF.Parsing.Tokens.TokenQueueMode)">
            <summary>
            Creates a new Tokenising Parser Context with custom settings
            </summary>
            <param name="handler">RDF Handler</param>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="queueMode">Tokeniser Queue Mode</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TokenisingParserContext.#ctor(VDS.RDF.IRdfHandler,VDS.RDF.Parsing.Tokens.ITokeniser,System.Boolean,System.Boolean)">
            <summary>
            Creates a new Tokenising Parser Context with custom settings
            </summary>
            <param name="handler">RDF Handler</param>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="traceParsing">Whether to trace parsing</param>
            <param name="traceTokeniser">Whether to trace tokenisation</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TokenisingParserContext.#ctor(VDS.RDF.IRdfHandler,VDS.RDF.Parsing.Tokens.ITokeniser,VDS.RDF.Parsing.Tokens.TokenQueueMode,System.Boolean,System.Boolean)">
            <summary>
            Creates a new Tokenising Parser Context with custom settings
            </summary>
            <param name="handler">RDF Handler</param>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="queueMode">Tokeniser Queue Mode</param>
            <param name="traceParsing">Whether to trace parsing</param>
            <param name="traceTokeniser">Whether to trace tokenisation</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.TokenisingParserContext.Tokens">
            <summary>
            Gets the Token Queue
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.TokenisingParserContext.LocalTokens">
            <summary>
            Gets the Local Tokens stack
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.TokenisingParserContext.TraceTokeniser">
            <summary>
            Gets/Sets whether tokeniser tracing is used
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TurtleParserContext.#ctor(VDS.RDF.IGraph,VDS.RDF.Parsing.Tokens.ITokeniser,VDS.RDF.Parsing.TurtleSyntax)">
            <summary>
            Creates a new Turtle Parser Context with default settings
            </summary>
            <param name="g">Graph to parse into</param>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="syntax">Turtle Syntax</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TurtleParserContext.#ctor(VDS.RDF.IGraph,VDS.RDF.Parsing.Tokens.ITokeniser,VDS.RDF.Parsing.TurtleSyntax,VDS.RDF.Parsing.Tokens.TokenQueueMode)">
            <summary>
            Creates a new Turtle Parser Context with custom settings
            </summary>
            <param name="g">Graph to parse into</param>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="syntax">Turtle Syntax</param>
            <param name="queueMode">Tokeniser Queue Mode</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TurtleParserContext.#ctor(VDS.RDF.IGraph,VDS.RDF.Parsing.Tokens.ITokeniser,VDS.RDF.Parsing.TurtleSyntax,System.Boolean,System.Boolean)">
            <summary>
            Creates a new Turtle Parser Context with custom settings
            </summary>
            <param name="g">Graph to parse into</param>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="syntax">Turtle Syntax</param>
            <param name="traceParsing">Whether to trace parsing</param>
            <param name="traceTokeniser">Whether to trace tokenisation</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TurtleParserContext.#ctor(VDS.RDF.IGraph,VDS.RDF.Parsing.Tokens.ITokeniser,VDS.RDF.Parsing.TurtleSyntax,VDS.RDF.Parsing.Tokens.TokenQueueMode,System.Boolean,System.Boolean)">
            <summary>
            Creates a new Turtle Parser Context with custom settings
            </summary>
            <param name="g">Graph to parse into</param>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="syntax">Turtle Syntax</param>
            <param name="queueMode">Tokeniser Queue Mode</param>
            <param name="traceParsing">Whether to trace parsing</param>
            <param name="traceTokeniser">Whether to trace tokenisation</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TurtleParserContext.#ctor(VDS.RDF.IRdfHandler,VDS.RDF.Parsing.Tokens.ITokeniser,VDS.RDF.Parsing.TurtleSyntax)">
            <summary>
            Creates a new Turtle Parser Context with default settings
            </summary>
            <param name="handler">RDF Handler</param>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="syntax">Turtle Syntax</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TurtleParserContext.#ctor(VDS.RDF.IRdfHandler,VDS.RDF.Parsing.Tokens.ITokeniser,VDS.RDF.Parsing.TurtleSyntax,VDS.RDF.Parsing.Tokens.TokenQueueMode)">
            <summary>
            Creates a new Turtle Parser Context with custom settings
            </summary>
            <param name="handler">RDF Handler</param>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="syntax">Turtle Syntax</param>
            <param name="queueMode">Tokeniser Queue Mode</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TurtleParserContext.#ctor(VDS.RDF.IRdfHandler,VDS.RDF.Parsing.Tokens.ITokeniser,VDS.RDF.Parsing.TurtleSyntax,System.Boolean,System.Boolean)">
            <summary>
            Creates a new Turtle Parser Context with custom settings
            </summary>
            <param name="handler">RDF Handler</param>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="syntax">Turtle Syntax</param>
            <param name="traceParsing">Whether to trace parsing</param>
            <param name="traceTokeniser">Whether to trace tokenisation</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TurtleParserContext.#ctor(VDS.RDF.IRdfHandler,VDS.RDF.Parsing.Tokens.ITokeniser,VDS.RDF.Parsing.TurtleSyntax,VDS.RDF.Parsing.Tokens.TokenQueueMode,System.Boolean,System.Boolean)">
            <summary>
            Creates a new Turtle Parser Context with custom settings
            </summary>
            <param name="handler">RDF Handler</param>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="syntax">Turtle Syntax</param>
            <param name="queueMode">Tokeniser Queue Mode</param>
            <param name="traceParsing">Whether to trace parsing</param>
            <param name="traceTokeniser">Whether to trace tokenisation</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.TurtleParserContext.Syntax">
            <summary>
            Gets the Turtle Syntax being used
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.TurtleParserContext.QNameUnescapeFunction">
            <summary>
            Function for unescaping QNames
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Handlers.ListUrisHandler">
            <summary>
            A Results Handler which extracts URIs from one/more variables in a Result Set
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Handlers.BaseResultsHandler">
            <summary>
            Abstract Base Class for SPARQL Results Handlers
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Handlers.BaseHandler">
            <summary>
            Abstract Base Class for Handlers
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.BaseHandler.#ctor">
            <summary>
            Creates a new Handler
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.BaseHandler.#ctor(VDS.RDF.INodeFactory)">
            <summary>
            Creates a new Handler using the given Node Factory
            </summary>
            <param name="factory">Node Factory</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.BaseHandler.CreateBlankNode">
            <summary>
            Creates a Blank Node
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.BaseHandler.CreateBlankNode(System.String)">
            <summary>
            Creates a Blank Node with the given ID
            </summary>
            <param name="nodeId">Node ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.BaseHandler.CreateGraphLiteralNode">
            <summary>
            Creates a Graph Literal Node
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.BaseHandler.CreateGraphLiteralNode(VDS.RDF.IGraph)">
            <summary>
            Creates a Graph Literal Node with the given sub-graph
            </summary>
            <param name="subgraph">Sub-graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.BaseHandler.CreateLiteralNode(System.String,System.Uri)">
            <summary>
            Creates a Literal Node with the given Datatype
            </summary>
            <param name="literal">Value</param>
            <param name="datatype">Datatype URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.BaseHandler.CreateLiteralNode(System.String)">
            <summary>
            Creates a Literal Node
            </summary>
            <param name="literal">Value</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.BaseHandler.CreateLiteralNode(System.String,System.String)">
            <summary>
            Creates a Literal Node with the given Language
            </summary>
            <param name="literal">Value</param>
            <param name="langspec">Language</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.BaseHandler.CreateUriNode(System.Uri)">
            <summary>
            Creates a URI Node
            </summary>
            <param name="uri">URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.BaseHandler.CreateVariableNode(System.String)">
            <summary>
            Creates a Variable Node
            </summary>
            <param name="varname">Variable Name</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.BaseHandler.GetNextBlankNodeID">
            <summary>
            Gets the next available Blank Node ID
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Parsing.Handlers.BaseHandler.NodeFactory">
            <summary>
            Gets/Sets the in-use Node Factory
            </summary>
        </member>
        <member name="T:VDS.RDF.ISparqlResultsHandler">
            <summary>
            Interface for Handlers which handle the SPARQL Results produced by parsers
            </summary>
        </member>
        <member name="M:VDS.RDF.ISparqlResultsHandler.StartResults">
            <summary>
            Starts the Handling of Results
            </summary>
        </member>
        <member name="M:VDS.RDF.ISparqlResultsHandler.EndResults(System.Boolean)">
            <summary>
            Ends the Handling of Results
            </summary>
            <param name="ok">Indicates whether parsing completed without error</param>
        </member>
        <member name="M:VDS.RDF.ISparqlResultsHandler.HandleBooleanResult(System.Boolean)">
            <summary>
            Handles a Boolean Result
            </summary>
            <param name="result">Result</param>
        </member>
        <member name="M:VDS.RDF.ISparqlResultsHandler.HandleVariable(System.String)">
            <summary>
            Handles a Variable Declaration
            </summary>
            <param name="var">Variable Name</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.ISparqlResultsHandler.HandleResult(VDS.RDF.Query.SparqlResult)">
            <summary>
            Handles a SPARQL Result
            </summary>
            <param name="result">Result</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.BaseResultsHandler.#ctor(VDS.RDF.INodeFactory)">
            <summary>
            Creates a new SPARQL Results Handler
            </summary>
            <param name="factory">Node Factory</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.BaseResultsHandler.#ctor">
            <summary>
            Creates a new SPARQL Results Handler
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.BaseResultsHandler.StartResults">
            <summary>
            Starts Results Handling
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.BaseResultsHandler.StartResultsInternal">
            <summary>
            Optionally used by derived classes to take additional actions on starting Results Handling
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.BaseResultsHandler.EndResults(System.Boolean)">
            <summary>
            Ends Results Handling
            </summary>
            <param name="ok">Whether parsing completed without error</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.BaseResultsHandler.EndResultsInternal(System.Boolean)">
            <summary>
            Optionally used by derived classes to take additional actions on ending Results Handling
            </summary>
            <param name="ok">Whether parsing completed without error</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.BaseResultsHandler.HandleBooleanResult(System.Boolean)">
            <summary>
            Handles a Boolean Results
            </summary>
            <param name="result">Result</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.BaseResultsHandler.HandleBooleanResultInternal(System.Boolean)">
            <summary>
            Must be overridden by derived handlers to appropriately handle boolean results
            </summary>
            <param name="result">Result</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.BaseResultsHandler.HandleVariable(System.String)">
            <summary>
            Handles a Variable declaration
            </summary>
            <param name="var">Variable Name</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.BaseResultsHandler.HandleVariableInternal(System.String)">
            <summary>
            Must be overridden by derived handlers to appropriately handle variable declarations
            </summary>
            <param name="var">Variable Name</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.BaseResultsHandler.HandleResult(VDS.RDF.Query.SparqlResult)">
            <summary>
            Handlers SPARQL Results
            </summary>
            <param name="result">Result</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.BaseResultsHandler.HandleResultInternal(VDS.RDF.Query.SparqlResult)">
            <summary>
            Must be overridden by derived handlers to appropriately handler SPARQL Results
            </summary>
            <param name="result">Result</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.ListUrisHandler.#ctor(System.String)">
            <summary>
            Creates a new List URIs Handler
            </summary>
            <param name="var">Variable to build the list from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.ListUrisHandler.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a new List URIs Handler
            </summary>
            <param name="vars">Variables to build the list from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.ListUrisHandler.StartResultsInternal">
            <summary>
            Starts handling results
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.ListUrisHandler.HandleBooleanResultInternal(System.Boolean)">
            <summary>
            Handles boolean results
            </summary>
            <param name="result">Result</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.ListUrisHandler.HandleVariableInternal(System.String)">
            <summary>
            Handles variable declarations
            </summary>
            <param name="var">Variable</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.ListUrisHandler.HandleResultInternal(VDS.RDF.Query.SparqlResult)">
            <summary>
            Handles results by extracting any URI values from the relevant variables
            </summary>
            <param name="result">Result</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Parsing.Handlers.ListUrisHandler.Uris">
            <summary>
            Gets the URIs
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Handlers.ListStringsHandler">
            <summary>
            A Results Handler which extracts Literals from one/more variables in a Result Set
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.ListStringsHandler.#ctor(System.String)">
            <summary>
            Creates a new List Strings handler
            </summary>
            <param name="var">Variable to build the list from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.ListStringsHandler.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a new List Strings handler
            </summary>
            <param name="vars">Variables to build the list from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.ListStringsHandler.StartResultsInternal">
            <summary>
            Starts handling results
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.ListStringsHandler.HandleBooleanResultInternal(System.Boolean)">
            <summary>
            Handles boolean results
            </summary>
            <param name="result">Result</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.ListStringsHandler.HandleVariableInternal(System.String)">
            <summary>
            Handles variable declarations
            </summary>
            <param name="var">Variable</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.ListStringsHandler.HandleResultInternal(VDS.RDF.Query.SparqlResult)">
            <summary>
            Handles results by extracting strings from relevant variables
            </summary>
            <param name="result">Result</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Parsing.Handlers.ListStringsHandler.Strings">
            <summary>
            Gets the Strings
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Handlers.UniqueBlankNodesHandler">
            <summary>
            A decorator for handlers which ensures that all blank nodes get unique IDs even if a blank node identifier is reused
            </summary>
            <remarks>
            <para>
            In most parsing scenarios this handler is not suitable for usage as it may unintentionally modify the RDF data being parsed, in non-parsing scenarios where this handler is instead being used as a means to generate RDF data from some non-RDF source it may prove very useful.
            </para>
            <para>
            This handler essentially works by redirecting all calls to the argument taking form of <see cref="M:VDS.RDF.INodeFactory.CreateBlankNode"/> with the non-argument form which should always generate a new blank node thus guaranteeing the uniqueness of nodes.
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Parsing.Handlers.BaseRdfHandler">
            <summary>
            Abstract Base Class for RDF Handlers
            </summary>
        </member>
        <member name="T:VDS.RDF.IRdfHandler">
            <summary>
            Interface for Handlers which handle the RDF produced by parsers
            </summary>
        </member>
        <member name="M:VDS.RDF.IRdfHandler.StartRdf">
            <summary>
            Start the Handling of RDF
            </summary>
            <exception cref="T:VDS.RDF.Parsing.RdfParseException">May be thrown if the Handler is already in use and the implementation is not thread-safe</exception>
        </member>
        <member name="M:VDS.RDF.IRdfHandler.EndRdf(System.Boolean)">
            <summary>
            End the Handling of RDF
            </summary>
            <param name="ok">Whether parsing finished without error</param>
        </member>
        <member name="M:VDS.RDF.IRdfHandler.HandleNamespace(System.String,System.Uri)">
            <summary>
            Handles a Namespace Definition
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="namespaceUri">Namespace URI</param>
            <returns>Should return <strong>true</strong> if parsing should continue or <strong>false</strong> if it should be aborted</returns>
        </member>
        <member name="M:VDS.RDF.IRdfHandler.HandleBaseUri(System.Uri)">
            <summary>
            Handles a Base URI Definition
            </summary>
            <param name="baseUri">Base URI</param>
            <returns>Should return <strong>true</strong> if parsing should continue or <strong>false</strong> if it should be aborted</returns>
        </member>
        <member name="M:VDS.RDF.IRdfHandler.HandleTriple(VDS.RDF.Triple)">
            <summary>
            Handles a Triple
            </summary>
            <param name="t">Triple</param>
            <returns>Should return <strong>true</strong> if parsing should continue or <strong>false</strong> if it should be aborted</returns>
        </member>
        <member name="P:VDS.RDF.IRdfHandler.AcceptsAll">
            <summary>
            Gets whether the Handler will always handle all data (i.e. won't terminate parsing early)
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.BaseRdfHandler.#ctor">
            <summary>
            Creates a new RDF Handler
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.BaseRdfHandler.#ctor(VDS.RDF.INodeFactory)">
            <summary>
            Creates a new RDF Handler using the given Node Factory
            </summary>
            <param name="factory">Node Factory</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.BaseRdfHandler.StartRdf">
            <summary>
            Starts the Handling of RDF
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.BaseRdfHandler.StartRdfInternal">
            <summary>
            Optionally used by derived Handlers to do additional actions on starting RDF handling
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.BaseRdfHandler.EndRdf(System.Boolean)">
            <summary>
            Ends the Handling of RDF
            </summary>
            <param name="ok">Whether the parsing completed without error</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.BaseRdfHandler.EndRdfInternal(System.Boolean)">
            <summary>
            Optionally used by derived Handlers to do additional actions on ending RDF handling
            </summary>
            <param name="ok">Whether the parsing completed without error</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.BaseRdfHandler.HandleNamespace(System.String,System.Uri)">
            <summary>
            Handles Namespace declarations
            </summary>
            <param name="prefix">Prefix</param>
            <param name="namespaceUri">Namespace URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.BaseRdfHandler.HandleNamespaceInternal(System.String,System.Uri)">
            <summary>
            Optionally used by derived Handlers to do additional actions on handling namespace declarations
            </summary>
            <param name="prefix">Prefix</param>
            <param name="namespaceUri">Namespace URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.BaseRdfHandler.HandleBaseUri(System.Uri)">
            <summary>
            Handles Base URI declarations
            </summary>
            <param name="baseUri">Base URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.BaseRdfHandler.HandleBaseUriInternal(System.Uri)">
            <summary>
            Optionally used by derived Handlers to do additional actions on handling Base URI declarations
            </summary>
            <param name="baseUri">Base URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.BaseRdfHandler.HandleTriple(VDS.RDF.Triple)">
            <summary>
            Handles Triples
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.BaseRdfHandler.HandleTripleInternal(VDS.RDF.Triple)">
            <summary>
            Must be overridden by derived handlers to take appropriate Triple handling action
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Parsing.Handlers.BaseRdfHandler.AcceptsAll">
            <summary>
            Gets whether the Handler will accept all Triples i.e. it will never abort handling early
            </summary>
        </member>
        <member name="T:VDS.RDF.IWrappingRdfHandler">
            <summary>
            Interface for Handlers which wrap other Handlers
            </summary>
        </member>
        <member name="P:VDS.RDF.IWrappingRdfHandler.InnerHandlers">
            <summary>
            Gets the Inner Handlers used by this Handler
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.UniqueBlankNodesHandler.#ctor(VDS.RDF.IRdfHandler)">
            <summary>
            Creates a new Unique Blank Nodes handler
            </summary>
            <param name="handler"></param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.UniqueBlankNodesHandler.CreateBlankNode(System.String)">
            <summary>
            Creates a Blank Node
            </summary>
            <param name="nodeId">Node ID which will be ignored by this Handler</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.UniqueBlankNodesHandler.StartRdfInternal">
            <summary>
            Starts handling RDF
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.UniqueBlankNodesHandler.EndRdfInternal(System.Boolean)">
            <summary>
            Ends handling RDF
            </summary>
            <param name="ok">Whether parsing completed OK</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.UniqueBlankNodesHandler.HandleBaseUriInternal(System.Uri)">
            <summary>
            Handles a Base URI declaration
            </summary>
            <param name="baseUri">Base URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.UniqueBlankNodesHandler.HandleNamespaceInternal(System.String,System.Uri)">
            <summary>
            Handles a Namespace declaration
            </summary>
            <param name="prefix">Prefix</param>
            <param name="namespaceUri">Namespace URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.UniqueBlankNodesHandler.HandleTripleInternal(VDS.RDF.Triple)">
            <summary>
            Handles a Triple
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Parsing.Handlers.UniqueBlankNodesHandler.InnerHandlers">
            <summary>
            Gets the inner handler
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Handlers.UniqueBlankNodesHandler.AcceptsAll">
            <summary>
            Gets whether the inner handler accepts all
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.NTriplesTokeniser">
            <summary>
            Tokeniser for NTriples RDF Syntax
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.BaseTokeniser">
            <summary>
            Abstract Base Class for Tokeniser which handles the Position tracking
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.ITokeniser">
            <summary>
            Interface for Tokenisers
            </summary>
            <remarks>
            A Tokeniser is a class that takes an input stream and produces textual tokens from it for use in token based parsers
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.ITokeniser.GetNextToken">
            <summary>
            Causes the Tokeniser to attempt to retrieve the next Token
            </summary>
            <returns></returns>
            <exception cref="T:VDS.RDF.Parsing.RdfParseException">Thrown if a valid Token cannot be parsed</exception>
            <exception cref="T:System.IO.IOException">Thrown if there is a problem reading the Input Stream</exception>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseTokeniser.#ctor(System.IO.TextReader)">
            <summary>
            Constructor for the BaseTokeniser which takes in a TextReader that the Tokeniser will generate Tokens from
            </summary>
            <param name="reader">TextReader to generator Tokens from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseTokeniser.GetNextToken">
            <summary>
            Gets the Next available Token from the Input
            </summary>
            <returns></returns>
            <exception cref="T:VDS.RDF.Parsing.RdfParseException">Parser Exception if a valid Token cannot be retrieved</exception>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseTokeniser.StartNewToken">
            <summary>
            Informs the Helper that you wish to start reading a new Token
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseTokeniser.Peek">
            <summary>
            Peeks at the next Character
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseTokeniser.Backtrack">
            <summary>
            Allows you to Backtrack one character (and no more)
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseTokeniser.ConsumeCharacter">
            <summary>
            Consumes a single Character into the Output Buffer and increments the Position Counters
            </summary>
            <exception cref="T:VDS.RDF.Parsing.RdfParseException">Thrown if the caller tries to read beyond the end of the Stream</exception>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseTokeniser.ConsumeCharacter(System.Boolean)">
            <summary>
            Consumes a single Character into the Output Buffer and increments the Position Counters
            </summary>
            <param name="allowEOF">Whether EOF is allowed</param>
            <returns>True if the EOF is reached</returns>
            <remarks>
            If <paramref name="allowEOF"/> is set to false then the normal behaviour is used and an error will be thrown on end of file
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseTokeniser.ConsumeNewLine(System.Boolean)">
            <summary>
            Consumes a New Line (which may be a single \n or \r or the two characters following each other)
            </summary>
            <param name="asOutput">Whether the New Line should be added to the Output Buffer</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseTokeniser.ConsumeNewLine(System.Boolean,System.Boolean)">
            <summary>
            Consumes a New Line (which may be a single \n or \r or the two characters following each other)
            </summary>
            <param name="asOutput">Whether the New Line should be added to the Output Buffer</param>
            <param name="allowEOF">Whether EOF is permitted instead of a New Line</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseTokeniser.SkipCharacter">
            <summary>
            Skips a single Character and increments the Position Counters
            </summary>
            <remarks>Use when you are reading characters into some local buffer and not the global token buffer, used in String escaping</remarks>
            <exception cref="T:VDS.RDF.Parsing.RdfParseException">Thrown if the caller tries to read beyond the end of the Stream</exception>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseTokeniser.DiscardWhiteSpace">
            <summary>
            Helper function which discards White Space which the Tokeniser doesn't care about and increments position counters correctly
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseTokeniser.HandleEscapes(VDS.RDF.Parsing.Tokens.TokeniserEscapeMode)">
            <summary>
            Handles the standard escapes supported in all the  UTF-8 based RDF serializations
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseTokeniser.HandleComplexLocalNameEscapes">
            <summary>
            Handles the complex escapes that can occur in a local name
            </summary>
            <remarks>
            Unlike <see cref="M:VDS.RDF.Parsing.Tokens.BaseTokeniser.HandleEscapes(VDS.RDF.Parsing.Tokens.TokeniserEscapeMode)">HandleEscapes()</see> this only unescapes unicode escapes, other escapes are simply validated and passed through for later unescaping
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseTokeniser.IsHexDigit(System.Char)">
            <summary>
            Determines whether a given Character can be valid as a Hex Digit
            </summary>
            <param name="c">Character to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseTokeniser.Error(System.String)">
            <summary>
            Helper Function for generating Standardised Parser Errors
            </summary>
            <param name="detail">The Error Message</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseTokeniser.UnexpectedCharacter(System.Char,System.String)">
            <summary>
            Helper Function for generating Standardised Parser Errors about unexpected characters
            </summary>
            <param name="c">Unexpected Character</param>
            <param name="expected">Message detailing what was expected (may be empty if no explicit expectation)</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseTokeniser.UnexpectedEndOfInput(System.String)">
            <summary>
            Helper Function for generating Standardised Parser Errors about unexpected end of input
            </summary>
            <param name="expected">Message detailing what was expected (may be empty if no explicit expectation)</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseTokeniser.UnexpectedNewLine(System.String)">
            <summary>
            Helper Function for generating Standardised Parser Errors about unexpected new lines
            </summary>
            <param name="expected">Message detailing what was expected (may be empty if no explicit expectation)</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseTokeniser.UnexpectedToken(System.String,VDS.RDF.Parsing.Tokens.IToken)">
            <summary>
            Helper Function for generating Standardised Parser Errors about unexpected tokens
            </summary>
            <param name="expected">Message detailing what was expected (may be empty if no explicity expectation)</param>
            <param name="t">Token that was parsed</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.BaseTokeniser.Format">
            <summary>
            Gets/Sets the Format that this Tokeniser is used for
            </summary>
            <remarks>The value set here will replace any instances of {0} specified in inputs to the <see cref="M:VDS.RDF.Parsing.Tokens.BaseTokeniser.Error(System.String)">Error()</see> function allowing messages regarding certain syntaxes not being valid in a given format to be provided</remarks>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.BaseTokeniser.Value">
            <summary>
            Gets the value of the Output Buffer
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.BaseTokeniser.Length">
            <summary>
            Gets the current length of the Output Buffer
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.BaseTokeniser.CurrentLine">
            <summary>
            Gets the Current Line in the Input Stream
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.BaseTokeniser.CurrentPosition">
            <summary>
            Gets the Current Position in the Input Stream
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.BaseTokeniser.StartLine">
            <summary>
            Gets the Start Line in the Input Stream of the current Token
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.BaseTokeniser.StartPosition">
            <summary>
            Gets the Start Position in the Input Stream of the current Token
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.BaseTokeniser.EndLine">
            <summary>
            Gets the End Line in the Input Stream of the current Token
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.BaseTokeniser.EndPosition">
            <summary>
            Gets the End Position in the Input Stream of the current Token
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.BaseTokeniser.LastTokenType">
            <summary>
            Gets/Sets the Last Token Type
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.BaseTokeniser.HasBacktracked">
            <summary>
            Gets whether the Tokeniser has backtracked
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.NTriplesTokeniser.#ctor(VDS.RDF.Parsing.ParsingTextReader,VDS.RDF.Parsing.NTriplesSyntax)">
            <summary>
            Creates a new NTriples Tokeniser which reads Tokens from the given Stream
            </summary>
            <param name="input">Stream to read Tokens from</param>
            <param name="syntax">NTriples syntax to tokenise</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.NTriplesTokeniser.#ctor(VDS.RDF.Parsing.ParsingTextReader)">
            <summary>
            Creates a new NTriples Tokeniser which reads Tokens from the given Stream
            </summary>
            <param name="input">Stream to read Tokens from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.NTriplesTokeniser.#ctor(System.IO.StreamReader)">
            <summary>
            Creates a new NTriples Tokeniser which reads Tokens from the given Stream
            </summary>
            <param name="input">Stream to read Tokens from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.NTriplesTokeniser.#ctor(System.IO.TextReader)">
            <summary>
            Creates a new NTriples Tokeniser which reads Tokens from the given Input
            </summary>
            <param name="input">Input to read Tokens from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.NTriplesTokeniser.#ctor(System.IO.StreamReader,VDS.RDF.Parsing.NTriplesSyntax)">
            <summary>
            Creates a new NTriples Tokeniser which reads Tokens from the given Stream
            </summary>
            <param name="input">Stream to read Tokens from</param>
            <param name="syntax">NTriples syntax to tokenise</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.NTriplesTokeniser.#ctor(System.IO.TextReader,VDS.RDF.Parsing.NTriplesSyntax)">
            <summary>
            Creates a new NTriples Tokeniser which reads Tokens from the given Input
            </summary>
            <param name="input">Input to read Tokens from</param>
            <param name="syntax">NTriples syntax to tokenise</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.NTriplesTokeniser.GetNextToken">
            <summary>
            Gets the next available Token from the Input Stream
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.NTriplesTokeniser.Syntax">
            <summary>
            Gets/Sets the NTriples syntax that should be supported
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.NTriplesTokeniser.NQuadsMode">
            <summary>
            Gets/Sets whether the output should be altered slightly to support NQuads parsing
            </summary>
            <remarks>
            <para>
            This is used internally to alter how DataTypes get tokenised, normally these are just returned as a <see cref="T:VDS.RDF.Parsing.Tokens.UriToken">UriToken</see> since a Literal can only occur as the Object in NTriples and so if we see a Uri after a Literal it must be it's datatype and not part of another Triple.
            </para>
            <para>
            In the case of NQuads a <see cref="T:VDS.RDF.Parsing.Tokens.UriToken">UriToken</see> may follow a Literal as the Context of that Triple and not its datatype so it's important to distinguish by using a <see cref="T:VDS.RDF.Parsing.Tokens.DataTypeToken">DataTypeToken</see> instead
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Parsing.RdfJsonParser">
            <summary>
            Parser for RDF/JSON Syntax
            </summary>
            <threadsafety instance="true">Designed to be Thread Safe - should be able to call Load from multiple threads on different Graphs without issue</threadsafety>
        </member>
        <member name="T:VDS.RDF.IRdfReader">
            <summary>
            Interface to be implemented by RDF Readers which parse Concrete RDF Syntax
            </summary>
        </member>
        <member name="M:VDS.RDF.IRdfReader.Load(VDS.RDF.IGraph,System.IO.StreamReader)">
            <summary>
            Method for Loading a Graph from some Concrete RDF Syntax via some arbitrary Stream
            </summary>
            <param name="g">Graph to load RDF into</param>
            <param name="input">The reader to read input from</param>
            <exception cref="T:VDS.RDF.RdfException">Thrown if the Parser tries to output something that is invalid RDF</exception>
            <exception cref="T:VDS.RDF.Parsing.RdfParseException">Thrown if the Parser cannot Parse the Input</exception>
            <exception cref="T:System.IO.IOException">Thrown if the Parser encounters an IO Error while trying to access/parse the Stream</exception>
        </member>
        <member name="M:VDS.RDF.IRdfReader.Load(VDS.RDF.IGraph,System.IO.TextReader)">
            <summary>
            Method for Loading a Graph from some Concrete RDF Syntax via some arbitrary Input
            </summary>
            <param name="g">Graph to load RDF into</param>
            <param name="input">The reader to read input from</param>
            <exception cref="T:VDS.RDF.RdfException">Thrown if the Parser tries to output something that is invalid RDF</exception>
            <exception cref="T:VDS.RDF.Parsing.RdfParseException">Thrown if the Parser cannot Parse the Input</exception>
            <exception cref="T:System.IO.IOException">Thrown if the Parser encounters an IO Error while trying to access/parse the Stream</exception>
        </member>
        <member name="M:VDS.RDF.IRdfReader.Load(VDS.RDF.IRdfHandler,System.IO.StreamReader)">
            <summary>
            Method for Loading RDF using a RDF Handler from some Concrete RDF Syntax via some arbitrary Stream
            </summary>
            <param name="handler">RDF Handler to use</param>
            <param name="input">The reader to read input from</param>
            <exception cref="T:VDS.RDF.RdfException">Thrown if the Parser tries to output something that is invalid RDF</exception>
            <exception cref="T:VDS.RDF.Parsing.RdfParseException">Thrown if the Parser cannot Parse the Input</exception>
            <exception cref="T:System.IO.IOException">Thrown if the Parser encounters an IO Error while trying to access/parse the Stream</exception>
        </member>
        <member name="M:VDS.RDF.IRdfReader.Load(VDS.RDF.IRdfHandler,System.IO.TextReader)">
            <summary>
            Method for Loading RDF using a RDF Handler from some Concrete RDF Syntax via some arbitrary Stream
            </summary>
            <param name="handler">RDF Handler to use</param>
            <param name="input">The reader to read input from</param>
            <exception cref="T:VDS.RDF.RdfException">Thrown if the Parser tries to output something that is invalid RDF</exception>
            <exception cref="T:VDS.RDF.Parsing.RdfParseException">Thrown if the Parser cannot Parse the Input</exception>
            <exception cref="T:System.IO.IOException">Thrown if the Parser encounters an IO Error while trying to access/parse the Stream</exception>
        </member>
        <member name="E:VDS.RDF.IRdfReader.Warning">
            <summary>
            Event which Readers can raise when they notice syntax that is ambigious/deprecated etc which can still be parsed
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfJsonParser.Load(VDS.RDF.IGraph,System.IO.StreamReader)">
            <summary>
            Read RDF/JSON Syntax from some Stream into a Graph
            </summary>
            <param name="g">Graph to read into</param>
            <param name="input">Stream to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfJsonParser.Load(VDS.RDF.IGraph,System.IO.TextReader)">
            <summary>
            Read RDF/JSON Syntax from some Input into a Graph
            </summary>
            <param name="g">Graph to read into</param>
            <param name="input">Input to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfJsonParser.Load(VDS.RDF.IRdfHandler,System.IO.StreamReader)">
            <summary>
            Read RDF/JSON Syntax from some Stream using a RDF Handler
            </summary>
            <param name="handler">RDF Handler to use</param>
            <param name="input">Stream to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfJsonParser.Load(VDS.RDF.IRdfHandler,System.IO.TextReader)">
            <summary>
            Read RDF/JSON Syntax from some Input using a RDF Handler
            </summary>
            <param name="handler">RDF Handler to use</param>
            <param name="input">Input to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfJsonParser.Parse(VDS.RDF.IRdfHandler,System.IO.TextReader)">
            <summary>
            Internal top level Parse method which parses the Json
            </summary>
            <param name="handler">RDF Handler to use</param>
            <param name="input">Stream to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfJsonParser.ParseGraphObject(VDS.RDF.Parsing.Contexts.JsonParserContext)">
            <summary>
            Parser method which parses the top level Json Object which represents the overall Graph
            </summary>
            <param name="context">Parser Context</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfJsonParser.ParseTriples(VDS.RDF.Parsing.Contexts.JsonParserContext)">
            <summary>
            Parser method which parses Json Objects representing Triples
            </summary>
            <param name="context">Parser Context</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfJsonParser.ParsePredicateObjectList(VDS.RDF.Parsing.Contexts.JsonParserContext,VDS.RDF.INode)">
            <summary>
            Parser method which parses Json Objects representing Predicate Object Lists
            </summary>
            <param name="context">Parser Context</param>
            <param name="subj">Subject of Triples which comes from the parent Json Object</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfJsonParser.ParseObjectList(VDS.RDF.Parsing.Contexts.JsonParserContext,VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Parser method which parses Json Arrays representing Object Lists
            </summary>
            <param name="context">Parser Context</param>
            <param name="subj">Subject of Triples which comes from the Grandparent Json Object</param>
            <param name="pred">Predicate of Triples which comes form the Parent Json Object</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfJsonParser.ParseObject(VDS.RDF.Parsing.Contexts.JsonParserContext,VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Parser method which parses Json Objects reprsenting Object Nodes
            </summary>
            <param name="context">Parser Context</param>
            <param name="subj">Subject of Triples which comes from the Great-Grandparent Json Object</param>
            <param name="pred">Predicate of Triples which comes form the Grandparent Json Object</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfJsonParser.Error(VDS.RDF.Parsing.Contexts.JsonParserContext,System.String)">
            <summary>
            Helper method for raising Error messages with attached Line Information
            </summary>
            <param name="context">Parser Context</param>
            <param name="message">Error Message</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfJsonParser.Error(VDS.RDF.Parsing.Contexts.JsonParserContext,System.String,VDS.RDF.Parsing.PositionInfo)">
            <summary>
            Helper method for raising Error messages with attached Position Information
            </summary>
            <param name="context">Parser Context</param>
            <param name="message">Error Message</param>
            <param name="startPos">Start Position</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfJsonParser.RaiseWarning(System.String)">
            <summary>
            Helper Method for raising the <see cref="E:VDS.RDF.Parsing.RdfJsonParser.Warning">Warning</see> event
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfJsonParser.ToString">
            <summary>
            Gets the String representation of the Parser which is a description of the syntax it parses
            </summary>
            <returns></returns>
        </member>
        <member name="E:VDS.RDF.Parsing.RdfJsonParser.Warning">
            <summary>
            Event which is raised if there's a non-fatal issue with the RDF/Json Syntax
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.RdfSpecsHelper">
            <summary>
            Helper class with useful constants relating to the RDF Specification
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.RdfSpecsHelper.RdfListFirst">
            <summary>
            URI for rdf:first
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.RdfSpecsHelper.RdfListRest">
            <summary>
            URI for rdf:rest
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.RdfSpecsHelper.RdfListNil">
            <summary>
            URI for rdf:nil
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.RdfSpecsHelper.RdfType">
            <summary>
            URI for rdf:type
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.RdfSpecsHelper.RdfXmlLiteral">
            <summary>
            URI for rdf:XMLLiteral
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.RdfSpecsHelper.RdfSubject">
            <summary>
            URI for rdf:subject
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.RdfSpecsHelper.RdfPredicate">
            <summary>
            URI for rdf:predicate
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.RdfSpecsHelper.RdfObject">
            <summary>
            URI for rdf:object
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.RdfSpecsHelper.RdfStatement">
            <summary>
            URI for rdf:Statement
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.RdfSpecsHelper.RdfLangString">
            <summary>
            URI for rdf:langString the implicit type of language specified literals
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.RdfSpecsHelper.ValidLangSpecifiersPattern">
            <summary>
            Pattern for Valid Language Specifiers
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.RdfSpecsHelper._validLangSpecifier">
            <summary>
            Regular Expression for Valid Language Specifiers
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfSpecsHelper.IsValidLangSpecifier(System.String)">
            <summary>
            Determines whether a given String is a valid Language Specifier
            </summary>
            <param name="value">String to test</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Parsing.SparqlJsonParser">
            <summary>
            Parser for SPARQL Results JSON Format
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlJsonParser.Load(VDS.RDF.Query.SparqlResultSet,System.IO.StreamReader)">
            <summary>
            Loads a Result Set from an Input Stream
            </summary>
            <param name="results">Result Set to load into</param>
            <param name="input">Input Stream to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlJsonParser.Load(VDS.RDF.Query.SparqlResultSet,System.IO.TextReader)">
            <summary>
            Loads a Result Set from an Input
            </summary>
            <param name="results">Result Set to load into</param>
            <param name="input">Input to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlJsonParser.Load(VDS.RDF.ISparqlResultsHandler,System.IO.TextReader)">
            <summary>
            Loads a Result Set from an Input using a Results Handler
            </summary>
            <param name="handler">Results Handler to use</param>
            <param name="input">Input to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlJsonParser.Load(VDS.RDF.ISparqlResultsHandler,System.IO.StreamReader)">
            <summary>
            Loads a Result Set from an Input Stream using a Results Handler
            </summary>
            <param name="handler">Results Handler to use</param>
            <param name="input">Input Stream to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlJsonParser.Parse(System.IO.TextReader,VDS.RDF.ISparqlResultsHandler)">
            <summary>
            Parser method which parses the Stream as Json
            </summary>
            <param name="input">Input Stream</param>
            <param name="handler">Results Handler</param>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlJsonParser.ParseResultSetObject(VDS.RDF.Parsing.Contexts.SparqlJsonParserContext)">
            <summary>
            Parser method which parses the top level Json Object which represents the overall Result Set
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlJsonParser.ParseHeader(VDS.RDF.Parsing.Contexts.SparqlJsonParserContext)">
            <summary>
            Parser method which parses the 'head' property of the top level Json Object which represents the Header of the Result Set
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlJsonParser.ParseHeader(VDS.RDF.Parsing.Contexts.SparqlJsonParserContext,System.Boolean)">
            <summary>
            Parser method which parses the 'head' property of the top level Json Object which represents the Header of the Result Set
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlJsonParser.ParseHeaderObject(VDS.RDF.Parsing.Contexts.SparqlJsonParserContext,System.Boolean)">
            <summary>
            Parser method which parses the Header Object of the Result Set
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlJsonParser.ParseHeaderProperties(VDS.RDF.Parsing.Contexts.SparqlJsonParserContext,System.Boolean)">
            <summary>
            Parser method which parses the Properties of the Header Object
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlJsonParser.ParseVariables(VDS.RDF.Parsing.Contexts.SparqlJsonParserContext,System.Boolean)">
            <summary>
            Parser method which parses the 'vars' property of the Header Object
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlJsonParser.ParseLink(VDS.RDF.Parsing.Contexts.SparqlJsonParserContext)">
            <summary>
            Parser method which parses the 'link' property of the Header Object
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlJsonParser.ParseBody(VDS.RDF.Parsing.Contexts.SparqlJsonParserContext)">
            <summary>
            Parser method which parses the Body of the Result Set which may be either a 'results' or 'boolean' property of the top level Json Object
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlJsonParser.ParseResults(VDS.RDF.Parsing.Contexts.SparqlJsonParserContext,System.Boolean)">
            <summary>
            Parser method which parses the Results Object of the Result Set
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlJsonParser.ParseBindings(VDS.RDF.Parsing.Contexts.SparqlJsonParserContext,System.Boolean)">
            <summary>
            Parser method which parses the 'bindings' property of the Results Object
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlJsonParser.ParseBinding(VDS.RDF.Parsing.Contexts.SparqlJsonParserContext,System.Boolean)">
            <summary>
            Parser method which parses a Binding Object which occurs in the array of Bindings
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlJsonParser.ParseBoundVariable(VDS.RDF.Parsing.Contexts.SparqlJsonParserContext,System.String,VDS.RDF.Query.SparqlResult,System.Boolean)">
            <summary>
            Parser method which parses a Bound Variable Object which occurs within a Binding Object
            </summary>
            <param name="context">Parser Context</param>
            <param name="var">Variable Name</param>
            <param name="r">Result Object that is being constructed from the Binding Object</param>
            <param name="headSeen"></param>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlJsonParser.ParseBoolean(VDS.RDF.Parsing.Contexts.SparqlJsonParserContext)">
            <summary>
            Parser method which parses the 'boolean' property of the Result Set
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlJsonParser.IsValidValue(VDS.RDF.Parsing.Contexts.SparqlJsonParserContext)">
            <summary>
            Checks whether a JSON Token is valid as the value for a RDF term
            </summary>
            <param name="context">Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlJsonParser.SkipToEndOfObject(VDS.RDF.Parsing.Contexts.SparqlJsonParserContext,System.Boolean)">
            <summary>
            Skips to the end of the current object
            </summary>
            <param name="context">Context</param>
            <param name="issueWarning">True if a warning should be issued</param>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlJsonParser.Error(VDS.RDF.Parsing.Contexts.SparqlJsonParserContext,System.String)">
            <summary>
            Helper method for raising Error messages with attached Line Information
            </summary>
            <param name="context">Parser Context</param>
            <param name="message">Error Message</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlJsonParser.RaiseWarning(System.String)">
            <summary>
            Helper Method which raises the Warning event when a non-fatal issue with the SPARQL Results being parsed is detected
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlJsonParser.ToString">
            <summary>
            Gets the String representation of the Parser which is a description of the syntax it parses
            </summary>
            <returns></returns>
        </member>
        <member name="E:VDS.RDF.Parsing.SparqlJsonParser.Warning">
            <summary>
            Event raised when a non-fatal issue with the SPARQL Results being parsed is detected
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.SparqlXmlParser">
            <summary>
            Parser for SPARQL Results XML Format
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlXmlParser.Load(VDS.RDF.Query.SparqlResultSet,System.IO.TextReader)">
            <summary>
            Loads a Result Set from an Input
            </summary>
            <param name="results">Result Set to load into</param>
            <param name="input">Input to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlXmlParser.Load(VDS.RDF.Query.SparqlResultSet,System.IO.StreamReader)">
            <summary>
            Loads a Result Set from an Input Stream
            </summary>
            <param name="results">Result Set to load into</param>
            <param name="input">Input Stream to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlXmlParser.Load(VDS.RDF.ISparqlResultsHandler,System.IO.TextReader)">
            <summary>
            Loads a Result Set from an Input using a Results Handler
            </summary>
            <param name="handler">Results Handler to use</param>
            <param name="input">Input to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlXmlParser.Load(VDS.RDF.ISparqlResultsHandler,System.IO.StreamReader)">
            <summary>
            Loads a Result Set from an Input using a Results Handler
            </summary>
            <param name="handler">Results Handler to use</param>
            <param name="input">Input Stream to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlXmlParser.GetSettings">
            <summary>
            Initialises the XML Reader settings
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlXmlParser.Parse(VDS.RDF.Parsing.Contexts.SparqlXmlParserContext)">
            <summary>
            Parses the XML Result Set format into a set of SPARQLResult objects
            </summary>
            <param name="context">Parser Context</param>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlXmlParser.ParseValue(VDS.RDF.Parsing.Contexts.SparqlXmlParserContext)">
            <summary>
            Internal Helper method which parses the child element of a &lt;binding&gt; element into an <see cref="T:VDS.RDF.INode">INode</see>
            </summary>
            <param name="context">Parser Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlXmlParser.RaiseWarning(System.String)">
            <summary>
            Helper Method which raises the Warning event when a non-fatal issue with the SPARQL Results being parsed is detected
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlXmlParser.ToString">
            <summary>
            Gets the String representation of the Parser which is a description of the syntax it parses
            </summary>
            <returns></returns>
        </member>
        <member name="E:VDS.RDF.Parsing.SparqlXmlParser.Warning">
            <summary>
            Event raised when a non-fatal issue with the SPARQL Results being parsed is detected
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.StringParser">
            <summary>
            Static Helper Class which allows raw strings of RDF/SPARQL Results to be parsed directly
            </summary>
            <remarks>
            The API structure for dotNetRDF means that our <see cref="T:VDS.RDF.IRdfReader">IRdfReader</see> classes which are our Parsers only have to support parsing from a file or a stream.  For most applications this is fine but there may be occassions when you wish to parse a small fragment of RDF and you don't want to have to put it into a file before you can parse it.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.StringParser.Parse(VDS.RDF.IGraph,System.String,VDS.RDF.IRdfReader)">
            <summary>
            Parses a raw RDF String using the given <see cref="T:VDS.RDF.IRdfReader">IRdfReader</see>
            </summary>
            <param name="g">Graph to load into</param>
            <param name="data">Raw RDF String</param>
            <param name="reader">Parser to use to read the data</param>
            <remarks>Use this when you have a raw RDF string and you know the syntax the RDF is in</remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.StringParser.Parse(VDS.RDF.IGraph,System.String)">
            <summary>
            Parses a raw RDF String (attempts to auto-detect the format)
            </summary>
            <param name="g">Graph to load into</param>
            <param name="data">Raw RDF String</param>
            <remarks>
            <p>
            Auto-detection is based on testing the string to see if it contains certain keyword constructs which might indicate a particular syntax has been used.  This detection may not always be accurate and it may choose a parser which is less expressive than the actual syntax e.g. <see cref="T:VDS.RDF.Parsing.TurtleParser">TurtleParser</see> instead of <see cref="T:VDS.RDF.Parsing.Notation3Parser">Notation3Parser</see> as it tends to guess downwards.  
            </p>
            <p>
            For example if you parsed a Notation 3 string that contained Graph Literals but didn't use any of the Notation 3 specific directives like @keywords it would be assumed to be Turtle but then would fail to parse
            </p>
            <p>
            The auto-detection rules used are as follows:
            </p>
            <ol>
            <li>If it contains &lt;?xml and &lt;rdf:RDF then it's most likely RDF/XML</li>
            <li>If it contains &lt;html then it's most likely HTML with possibly RDFa embedded</li>
            <li>
            If it contains @prefix or @base then its Turtle/Notation 3
                <ol>
                <li>If it contains @keywords, @forall or @forsome then it's Notation 3</li>
                <li>Otherwise it's Turtle</li>
                </ol>
            </li>
            <li>If it contains all of a set of terms and symbols that occur in RDF/JSON then it's most likely RDF/JSON.  These terms are "value","type",{,},[ and ]</li>
            <li>Otherwise try it as NTriples, NTriples has no real distinctive syntax so hard to test if it's NTriples other than by parsing it</li>
            </ol>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.StringParser.ParseDataset(VDS.RDF.ITripleStore,System.String,VDS.RDF.IStoreReader)">
            <summary>
            Parses a raw RDF Dataset String using the given Parser
            </summary>
            <param name="store">Store to load into</param>
            <param name="data">Raw RDF Dataset String</param>
            <param name="reader">Parser to use</param>
        </member>
        <member name="M:VDS.RDF.Parsing.StringParser.ParseDataset(VDS.RDF.ITripleStore,System.String)">
            <summary>
            Parses a raw RDF Dataset String (attempts to auto-detect the format)
            </summary>
            <param name="store">Store to load into</param>
            <param name="data">Raw RDF Dataset String</param>
            <remarks>
            <p>
            Auto-detection is based on testing the string to see if it contains certain keyword constructs which might indicate a particular syntax has been used.  This detection may not always be accurate.
            </p>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.StringParser.ParseResultSet(VDS.RDF.Query.SparqlResultSet,System.String)">
            <summary>
            Parses a raw SPARQL Results String (attempts to auto-detect the format)
            </summary>
            <param name="results">SPARQL Result Set to fill</param>
            <param name="data">Raw SPARQL Results String</param>
            <remarks>
            <p>
            Auto-detection is based on testing the string to see if it contains certain keyword constructs which might indicate a particular syntax has been used.  This detection may not always be accurate.
            </p>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.StringParser.ParseResultSet(VDS.RDF.Query.SparqlResultSet,System.String,VDS.RDF.ISparqlResultsReader)">
            <summary>
            Parses a raw SPARQL Results String using the given Parser
            </summary>
            <param name="results">SPARQL Result Set to fill</param>
            <param name="data">Raw SPARQL Results String</param>
            <param name="reader">Parser to use</param>
        </member>
        <member name="M:VDS.RDF.Parsing.StringParser.GetParser(System.String)">
            <summary>
            Uses the rules described in the remarks for the <see cref="M:VDS.RDF.Parsing.StringParser.Parse(VDS.RDF.IGraph,System.String)">Parse()</see> to return the most likely Parser
            </summary>
            <param name="data">Raw RDF String</param>
        </member>
        <member name="M:VDS.RDF.Parsing.StringParser.GetDatasetParser(System.String)">
            <summary>
            Uses the format detection rules to determine the most likely RDF Dataset Parser
            </summary>
            <param name="data">Raw RDF Dataset String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.StringParser.GetResultSetParser(System.String)">
            <summary>
            Uses the format detection rules to return the most likely SPARQL Results parser
            </summary>
            <param name="data">Raw SPARQL Results String</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.TokeniserEscapeMode">
            <summary>
            Possible Escape Handling Modes for the Tokeniser
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.TokeniserEscapeMode.Uri">
            <summary>
            Escaping for URIs (only \u and \U escapes are valid)
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.TokeniserEscapeMode.PermissiveUri">
            <summary>
            Permissive escaping for URIs (only \" is invalid)
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.TokeniserEscapeMode.QuotedLiterals">
            <summary>
            Escaping for Quoted Literals (every escape but \&lt; and \' is valid)
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.TokeniserEscapeMode.QuotedLiteralsAlternate">
            <summary>
            Escaping for single Quoted Literals (every escape but \&lt; and \" is valid)
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.TokeniserEscapeMode.QuotedLiteralsBoth">
            <summary>
            Escaping for Quoted Literals (every escape but \&lt; is valid), this differs from <see cref="F:VDS.RDF.Parsing.Tokens.TokeniserEscapeMode.QuotedLiterals"/> and <see cref="F:VDS.RDF.Parsing.Tokens.TokeniserEscapeMode.QuotedLiteralsAlternate"/> in that it allows both \' and \"
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.TokeniserEscapeMode.QName">
            <summary>
            Escaping for QNames (only Unicode espaces are valid)
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.TriGParser">
            <summary>
            Parser for parsing TriG (Turtle with Named Graphs) RDF Syntax into a Triple Store
            </summary>
            <remarks>The Default Graph (if any) will be given the special Uri <strong>trig:default-graph</strong></remarks>
        </member>
        <member name="T:VDS.RDF.IStoreReader">
            <summary>
            Interface to be implemented by Triple Store Readers
            </summary>
        </member>
        <member name="M:VDS.RDF.IStoreReader.Load(VDS.RDF.ITripleStore,System.IO.TextReader)">
            <summary>
            Loads a RDF dataset into a Triple Store
            </summary>
            <param name="store">Triple Store</param>
            <param name="input">Input to load from</param>
        </member>
        <member name="M:VDS.RDF.IStoreReader.Load(VDS.RDF.IRdfHandler,System.IO.TextReader)">
            <summary>
            Loads a RDF dataset using a RDF Handler
            </summary>
            <param name="handler">RDF Handler to use</param>
            <param name="input">Input to load from</param>
        </member>
        <member name="E:VDS.RDF.IStoreReader.Warning">
            <summary>
            Event which Readers can raise when they notice syntax that is ambigious/deprecated etc which can still be parsed
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.ITraceableTokeniser">
            <summary>
            Interface for Parsers that support Tokeniser Tracing
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.ITraceableTokeniser.TraceTokeniser">
            <summary>
            Gets/Sets whether Tokeniser Tracing is used
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.ITokenisingParser">
            <summary>
            Interface for parsers that use token based parsing
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.ITokenisingParser.TokenQueueMode">
            <summary>
            Gets/Sets the token queue mode used
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.TriGParser.#ctor">
            <summary>
            Creates a TriG Parser than uses the default syntax
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.TriGParser.#ctor(VDS.RDF.Parsing.TriGSyntax)">
            <summary>
            Creates a TriG Parser which uses the specified syntax
            </summary>
            <param name="syntax">Syntax</param>
        </member>
        <member name="M:VDS.RDF.Parsing.TriGParser.Load(VDS.RDF.ITripleStore,System.IO.TextReader)">
            <summary>
            Loads the named Graphs from the TriG input into the given Triple Store
            </summary>
            <param name="store">Triple Store to load into</param>
            <param name="input">Input to load from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.TriGParser.Load(VDS.RDF.IRdfHandler,System.IO.TextReader)">
            <summary>
            Loads the named Graphs from the TriG input using the given RDF Handler
            </summary>
            <param name="handler">RDF Handler to use</param>
            <param name="input">Input to load from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.TriGParser.TryParseDirective(VDS.RDF.Parsing.Contexts.TriGParserContext)">
            <summary>
            Tries to parse a directive
            </summary>
            <param name="context"></param>
        </member>
        <member name="M:VDS.RDF.Parsing.TriGParser.TryParseDirective(VDS.RDF.Parsing.Contexts.TriGParserContext,VDS.RDF.Parsing.Tokens.IToken)">
            <summary>
            Tries to parse directives
            </summary>
            <param name="context"></param>
            <param name="directive"></param>
            <remarks>
            This overload is needed because in some cases we may dequeue a token before we know it is a directive
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.TriGParser.RaiseWarning(System.String)">
            <summary>
            Helper method used to raise the Warning event if there is an event handler registered
            </summary>
            <param name="message">Warning message</param>
        </member>
        <member name="M:VDS.RDF.Parsing.TriGParser.ToString">
            <summary>
            Gets the String representation of the Parser which is a description of the syntax it parses
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Parsing.TriGParser.TraceTokeniser">
            <summary>
            Gets/Sets whether Tokeniser Tracing is used
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.TriGParser.Syntax">
            <summary>
            Gets/Sets the TriG syntax used
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.TriGParser.TokenQueueMode">
            <summary>
            Gets/Sets the token queue mode used
            </summary>
        </member>
        <member name="E:VDS.RDF.Parsing.TriGParser.Warning">
            <summary>
            Event which Readers can raise when they notice syntax that is ambigious/deprecated etc which can still be parsed
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.TriGTokeniser">
            <summary>
            Tokeniser for TriG (Turtle with Named Graphs) RDF Syntax
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TriGTokeniser.#ctor(System.IO.StreamReader)">
            <summary>
            Creates a new TriG Tokeniser which reads Tokens from the given Stream
            </summary>
            <param name="input">Stream to read Tokens from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TriGTokeniser.#ctor(System.IO.StreamReader,VDS.RDF.Parsing.TriGSyntax)">
            <summary>
            Creates a new TriG Tokeniser which reads Tokens from the given Stream using the specified syntax
            </summary>
            <param name="input">Stream to read Tokens from</param>
            <param name="syntax">Syntax</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TriGTokeniser.#ctor(VDS.RDF.Parsing.ParsingTextReader)">
            <summary>
            Creates a new TriG Tokeniser which reads Tokens from the given Stream
            </summary>
            <param name="input">Stream to read Tokens from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TriGTokeniser.#ctor(VDS.RDF.Parsing.ParsingTextReader,VDS.RDF.Parsing.TriGSyntax)">
            <summary>
            Creates a new TriG Tokeniser which reads Tokens from the given Stream
            </summary>
            <param name="input">Stream to read Tokens from</param>
            <param name="syntax">Syntax</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TriGTokeniser.#ctor(System.IO.TextReader)">
            <summary>
            Creates a new TriG Tokeniser which reads Tokens from the given Input
            </summary>
            <param name="input">Input to read Tokens from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TriGTokeniser.#ctor(System.IO.TextReader,VDS.RDF.Parsing.TriGSyntax)">
            <summary>
            Creates a new TriG Tokeniser which reads Tokens from the given Input
            </summary>
            <param name="input">Input to read Tokens from</param>
            <param name="syntax">Syntax</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TriGTokeniser.GetNextToken">
            <summary>
            Gets the next available Token from the Input Stream
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Parsing.TurtleSyntax">
            <summary>
            Acceptable Turtle syntaxes
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.TurtleSyntax.Original">
            <summary>
            Turtle as originally specified by the <a href="http://www.w3.org/TeamSubmission/turtle/">Turtle Team Submission</a>
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.TurtleSyntax.W3C">
            <summary>
            Turtle as standardised by the <a href="http://www.w3.org/TR/turtle/">W3C RDF Working Group</a>
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.TriGSyntax">
            <summary>
            Acceptable TriG syntaxes
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.TriGSyntax.Original">
            <summary>
            TriG as originally <a href="http://www4.wiwiss.fu-berlin.de/bizer/trig/">specified</a>
            </summary>
            <remarks>
            @base is not permitted and @prefix may only occur outside of graphs
            </remarks>
        </member>
        <member name="F:VDS.RDF.Parsing.TriGSyntax.MemberSubmission">
            <summary>
            TriG as specified by the <a href="http://www.w3.org/2010/01/Turtle/Trig">TriG Member Submission</a>
            </summary>
            <remarks>
            @base is permitted and both @base and @prefix may occur both inside and outside graphs but the tokens use Turtle Team Submission rules i.e. newer escape sequences and other changes in the official W3C specification of Turtle do not apply.
            </remarks>
        </member>
        <member name="T:VDS.RDF.Parsing.TurtleSpecsHelper">
            <summary>
            Helper function relating to the Turtle Specifications
            </summary>
            <remarks>Not currently used in the actual <see cref="T:VDS.RDF.Parsing.Tokens.TurtleTokeniser">TurtleTokeniser</see> or <see cref="T:VDS.RDF.Parsing.TurtleParser">TurtleParser</see> but is used for the new <see cref="T:VDS.RDF.Parsing.Tokens.TriGTokeniser">TriGTokeniser</see></remarks>
        </member>
        <member name="F:VDS.RDF.Parsing.TurtleSpecsHelper.ValidIntegerPattern">
            <summary>
            Pattern for Valid Integers in Turtle
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.TurtleSpecsHelper.ValidDecimalPattern">
            <summary>
            Pattern for Valid Decimals in Turtle
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.TurtleSpecsHelper.ValidDoublePattern">
            <summary>
            Pattern for Valid Doubles in Turtle
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.TurtleSpecsHelper.LongLiteralsPattern">
            <summary>
            Pattern for determining whether a given String should be serialized as a Long Literal
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleSpecsHelper.IsValidPlainLiteral(System.String,VDS.RDF.Parsing.TurtleSyntax)">
            <summary>
            Determines whether a given String is a valid Plain Literal
            </summary>
            <param name="value">String to test</param>
            <param name="syntax">Turtle Syntax</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleSpecsHelper.IsValidPlainLiteral(System.String,System.Uri,VDS.RDF.Parsing.TurtleSyntax)">
            <summary>
            Determines whether a given String is a valid Plain Literal for the given Datatype
            </summary>
            <param name="value">Value</param>
            <param name="dt">Datatype</param>
            <param name="syntax">Turtle Syntax</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleSpecsHelper.IsValidInteger(System.String)">
            <summary>
            Determines whether a given String is a valid Integer
            </summary>
            <param name="value">String to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleSpecsHelper.IsValidDecimal(System.String)">
            <summary>
            Determines whether a given String is a valid Decimal
            </summary>
            <param name="value">String to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleSpecsHelper.IsValidDouble(System.String)">
            <summary>
            Determines whether a given String is a valid Double
            </summary>
            <param name="value">String to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleSpecsHelper.IsValidQName(System.String)">
            <summary>
            Gets whether a QName is valid in Turtle (assumes Turtle as originally specified by Dave Beckett)
            </summary>
            <param name="value">QName</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleSpecsHelper.IsValidPrefix(System.String,VDS.RDF.Parsing.TurtleSyntax)">
            <summary>
            Gets whether the given value is a valid prefix in Turtle
            </summary>
            <param name="value">Value</param>
            <param name="syntax">Turtle Syntax</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleSpecsHelper.IsPNPrefix(System.String,VDS.RDF.Parsing.TurtleSyntax)">
            <summary>
            Gets whether the given value is the valid prefix portion of a prefixed name in Turtle
            </summary>
            <param name="value">Value</param>
            <param name="syntax">Turtle Syntax</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleSpecsHelper.IsValidLocalName(System.String,VDS.RDF.Parsing.TurtleSyntax)">
            <summary>
            Gets whether the given value is the valid local name portion of a prefixed name in Turtle
            </summary>
            <param name="value">Value</param>
            <param name="syntax">Turtle Syntax</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleSpecsHelper.IsPNLocal(System.String)">
            <summary>
            Gets whether the given value matches the PN_LOCAL rule from the Turtle specification
            </summary>
            <param name="value">Value</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleSpecsHelper.IsPLX(System.Char[],System.Int32,System.Int32@)">
            <summary>
            Checks whether a given String matches the PLX rule from the Turtle W3C Specification
            </summary>
            <param name="cs">String as character array</param>
            <param name="startIndex">Start Index</param>
            <param name="endIndex">Resulting End Index</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleSpecsHelper.IsHex(System.Char)">
            <summary>
            Gets whether a character is a Hex character
            </summary>
            <param name="c">Character</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleSpecsHelper.IsValidQName(System.String,VDS.RDF.Parsing.TurtleSyntax)">
            <summary>
            Determines whether a given String is a valid QName
            </summary>
            <param name="value">String to test</param>
            <param name="syntax">Turtle Syntax</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleSpecsHelper.UnescapeQName(System.String)">
            <summary>
            Unescapes local name escapes in a QName
            </summary>
            <param name="value">QName</param>
            <returns>Unescaped QName</returns>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleSpecsHelper.IsLongLiteral(System.String)">
            <summary>
            Determines whether a given String should be serialized as a Long Literal
            </summary>
            <param name="value">String to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleSpecsHelper.InferPlainLiteralType(VDS.RDF.Parsing.Tokens.PlainLiteralToken,VDS.RDF.Parsing.TurtleSyntax)">
            <summary>
            Infers the Type of a Plain Literal
            </summary>
            <param name="p">Plain Literal to infer the Type of</param>
            <param name="syntax">Turtle Syntax</param>
            <returns>A Uri  representing the XML Scheme Data Type for the Plain Literal</returns>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleSpecsHelper.IsPNCharsBase(System.Char)">
            <summary>
            Gets whether a character matches the PN_CHARS_BASE production from the Turtle specifications
            </summary>
            <param name="c">Character</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleSpecsHelper.IsPNCharsBase(System.Char,System.Char)">
            <summary>
            Gets whether a surrogate pair matches the PN_CHARS_BASE production from the Turtle specifications
            </summary>
            <param name="c">High surrogate</param>
            <param name="d">Low surrogate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleSpecsHelper.IsPNChars(System.Char)">
            <summary>
            Gets whether a character matches the PN_CHARS production from the Turtle specification
            </summary>
            <param name="c">Character</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleSpecsHelper.IsPNChars(System.Char,System.Char)">
            <summary>
            Gets whether a surrogate pair matches the PN_CHARS production from the Turtle specification
            </summary>
            <param name="c">High surrogate</param>
            <param name="d">Low surrogate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleSpecsHelper.IsPNCharsU(System.Char)">
            <summary>
            Gets whether a character matches the PN_CHARS_U production from the Turtle specification
            </summary>
            <param name="c">Character</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleSpecsHelper.IsPNCharsU(System.Char,System.Char)">
            <summary>
            Gets whether a surrogate pair matches the PN_CHARS_U production from the Turtle specification
            </summary>
            <param name="c">High surrogate</param>
            <param name="d">Low surrogate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleSpecsHelper.IsNameStartChar(System.Char)">
            <summary>
            Gets whether a character matches the nameStartChar production from the Turtle specification
            </summary>
            <param name="c">Character</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleSpecsHelper.IsNameStartChar(System.Char,System.Char)">
            <summary>
            Gets whether a surrogate pair matches the nameStartChar production from the Turtle specification
            </summary>
            <param name="c">High surrogate</param>
            <param name="d">Low surrogate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleSpecsHelper.IsNameChar(System.Char)">
            <summary>
            Gets whether a character matches the nameChar production from the Turtle specification
            </summary>
            <param name="c">Character</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleSpecsHelper.IsNameChar(System.Char,System.Char)">
            <summary>
            Gets whether a surrogate pair matches the nameChar production from the Turtle specification
            </summary>
            <param name="c">High surrogate</param>
            <param name="d">Low surrogate</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.FilteredProduct">
            <summary>
            Algebra operator which combines a Filter and a Product into a single operation for improved performance and reduced memory usage
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.IAbstractJoin">
            <summary>
            Represents an Algebra construct which is an Abstract Join (i.e. any kind of Join over two algebra operators)
            </summary>
            <remarks>
            Specific sub-interfaces are used to mark specific kinds of Join
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.ISparqlAlgebra">
            <summary>
            Interface for classes that represent the SPARQL Algebra and are used to evaluate queries
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.ISparqlAlgebra.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates the Algebra in the given Context
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.ISparqlAlgebra.ToQuery">
            <summary>
            Converts the Algebra back to a SPARQL Query
            </summary>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">Thrown if the given Algebra cannot be converted to a SPARQL Query</exception>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.ISparqlAlgebra.ToGraphPattern">
            <summary>
            Converts the Algebra back to a Graph Pattern
            </summary>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">Thrown if the given Algebra cannot be converted to a Graph Pattern</exception>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.ISparqlAlgebra.Variables">
            <summary>
            Gets the enumeration of Variables used in the Algebra
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.ISparqlAlgebra.FloatingVariables">
            <summary>
            Gets the enumeration of floating variables in the algebra i.e. variables that are not guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.ISparqlAlgebra.FixedVariables">
            <summary>
            Gets the enumeration of fixed variables in the algebra i.e. variables that are guaranteed to have a bound value
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.IAbstractJoin.Transform(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Transforms both sides of the Join using the given Optimiser
            </summary>
            <param name="optimiser">Optimser</param>
            <returns></returns>
            <remarks>
            The join should retain all it's existing properties and just return a new version of itself with the two sides of the join having had the given optimiser applied to them
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.IAbstractJoin.TransformLhs(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Transforms the LHS of the Join using the given Optimiser
            </summary>
            <param name="optimiser">Optimser</param>
            <returns></returns>
            <remarks>
            The join should retain all it's existing properties and just return a new version of itself with LHS side of the join having had the given optimiser applied to them
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.IAbstractJoin.TransformRhs(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Transforms the RHS of the Join using the given Optimiser
            </summary>
            <param name="optimiser">Optimser</param>
            <returns></returns>
            <remarks>
            The join should retain all it's existing properties and just return a new version of itself with RHS side of the join having had the given optimiser applied to them
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.IAbstractJoin.Lhs">
            <summary>
            Gets the LHS of the Join
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.IAbstractJoin.Rhs">
            <summary>
            Gets the RHS of the Join
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.FilteredProduct.#ctor(VDS.RDF.Query.Algebra.ISparqlAlgebra,VDS.RDF.Query.Algebra.ISparqlAlgebra,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Filtered Product
            </summary>
            <param name="lhs">LHS Algebra</param>
            <param name="rhs">RHS Algebra</param>
            <param name="expr">Expression to filter with</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.FilteredProduct.Transform(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Transforms the inner algebra with the given optimiser
            </summary>
            <param name="optimiser">Algebra Optimiser</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.FilteredProduct.TransformLhs(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Transforms the LHS algebra only with the given optimiser
            </summary>
            <param name="optimiser">Algebra Optimiser</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.FilteredProduct.TransformRhs(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Transforms the RHS algebra only with the given optimiser
            </summary>
            <param name="optimiser">Algebra Optimiser</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.FilteredProduct.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates the filtered product
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.FilteredProduct.ToQuery">
            <summary>
            Converts the algebra back into a query
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.FilteredProduct.ToGraphPattern">
            <summary>
            Converts the algebra back into a Graph Pattern
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.FilteredProduct.ToString">
            <summary>
            Gets the string represenation of the algebra
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.FilteredProduct.Lhs">
            <summary>
            Gets the LHS Algebra
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.FilteredProduct.Rhs">
            <summary>
            Gets the RHS Algebra
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.FilteredProduct.Variables">
            <summary>
            Gets the Variables used in the Algebra
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.FilteredProduct.FloatingVariables">
            <summary>
            Gets the enumeration of floating variables in the algebra i.e. variables that are not guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.FilteredProduct.FixedVariables">
            <summary>
            Gets the enumeration of fixed variables in the algebra i.e. variables that are guaranteed to have a bound value
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.PropertyFunction">
            <summary>
            Algebra that represents the application of a Property Function
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.IUnaryOperator">
            <summary>
            Interface for SPARQL Algebra constructs which are unary operators i.e. they apply over a single inner Algebra
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.IUnaryOperator.Transform(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Transforms the Inner Algebra using the given Optimiser
            </summary>
            <param name="optimiser">Optimiser</param>
            <returns></returns>
            <remarks>
            The operator should retain all it's existing properties and just return a new version of itself with the inner algebra having had the given optimiser applied to it
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.IUnaryOperator.InnerAlgebra">
            <summary>
            Gets the Inner Algebra
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.PropertyFunction.#ctor(VDS.RDF.Query.Algebra.ISparqlAlgebra,VDS.RDF.Query.PropertyFunctions.ISparqlPropertyFunction)">
            <summary>
            Creates a new Property function algebra
            </summary>
            <param name="algebra">Inner algebra</param>
            <param name="function">Property Function</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.PropertyFunction.Transform(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Transforms this algebra with the given optimiser
            </summary>
            <param name="optimiser">Optimiser</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.PropertyFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates the algebra in the given context
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.PropertyFunction.ToQuery">
            <summary>
            Throws an error because property functions cannot be converted back to queries
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.PropertyFunction.ToGraphPattern">
            <summary>
            Throws an error because property functions cannot be converted back to graph patterns
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.PropertyFunction.ToString">
            <summary>
            Gets the string representation of the algebra
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.PropertyFunction.InnerAlgebra">
            <summary>
            Gets the Inner Algebra
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.PropertyFunction.Variables">
            <summary>
            Gets the variables used in the algebra
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.PropertyFunction.FloatingVariables">
            <summary>
            Gets the enumeration of floating variables in the algebra i.e. variables that are not guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.PropertyFunction.FixedVariables">
            <summary>
            Gets the enumeration of fixed variables in the algebra i.e. variables that are guaranteed to have a bound value
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.Table">
            <summary>
            Represents a fixed set of solutions
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.ITerminalOperator">
            <summary>
            Marker Interface for SPARQL Algebra constructs which are terminal operators i.e. they contain no inner algebra operators
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Table.#ctor(VDS.RDF.Query.Algebra.BaseMultiset)">
            <summary>
            Creates a new fixed set of solutions
            </summary>
            <param name="table">Table</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Table.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Returns the fixed set of solutions
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Table.ToQuery">
            <summary>
            Throws an error as this cannot be converted back into a query
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Table.ToGraphPattern">
            <summary>
            Throws an error as this cannot be converted back into a graph pattern
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Table.ToString">
            <summary>
            Gets the string representation of the algebra
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Table.Variables">
            <summary>
            Gets the variables used in the algebra
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Table.FloatingVariables">
            <summary>
            Gets the enumeration of floating variables in the algebra i.e. variables that are not guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Table.FixedVariables">
            <summary>
            Gets the enumeration of fixed variables in the algebra i.e. variables that are guaranteed to have a bound value
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Datasets.BaseDemandDataset">
            <summary>
            Abstract Dataset wrapper implementation for datasets that can load graphs on demand
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Datasets.WrapperDataset">
            <summary>
            An abstract dataset wrapper that can be used to wrap another dataset and just modify some functionality i.e. provides a decorator over an existing dataset
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Datasets.ISparqlDataset">
            <summary>
            Interfaces for Datasets that SPARQL Queries and Updates can be applied to
            </summary>
            <remarks>
            <para>
            <strong>Note:</strong> For all operations that take a Graph URI a <em>null</em> Uri should be considered to refer to the Default Graph of the dataset
            </para>
            <h3>Default and Active Graph</h3>
            <para>
            Leviathan expects that a Query operates over the Dataset in the following order:
            <ol>
                <li>If an Active Graph is set then Queries operate over that</li>
                <li>Otherwise if a Default Graph is set then Queries operate over that</li>
                <li>Finally the Queries operate over the all triples, the notion of all triples may be dataset implementation specific i.e. may be union of all graphs, the default unnamed graph only or something else entirely</li>
            </ol>
            Please note that the Query may change the Active and Default Graph over the course of the query depending on the Query e.g. FROM, FROM NAMED and GRAPH all can potentially change these.
            </para>
            <para>
            You can limit your queries to use specific portions of your dataset by using the SetActiveGraph() and SetDefaultGraph() methods on your dataset instance before then passing it to the <see cref="T:VDS.RDF.Query.LeviathanQueryProcessor">LeviathanQueryProcessor</see>
            </para>
            <para>
            <strong>Note: </strong> By default the <see cref="T:VDS.RDF.Query.Datasets.InMemoryDataset">InMemoryDataset</see> uses the Union of all Graphs in the Dataset if no Active/Default Graph is otherwise specified.  Use the <see cref="P:VDS.RDF.Query.Datasets.ISparqlDataset.UsesUnionDefaultGraph">UsesUnionDefaultGraph</see> property to see whether a Dataset implementation behaves in this way.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.ISparqlDataset.SetActiveGraph(System.Collections.Generic.IEnumerable{System.Uri})">
            <summary>
            Sets the Active Graph to be the merge of the Graphs with the given URIs
            </summary>
            <param name="graphUris">Graph URIs</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.ISparqlDataset.SetActiveGraph(System.Uri)">
            <summary>
            Sets the Active Graph to be the Graph with the given URI
            </summary>
            <param name="graphUri">Graph URI</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.ISparqlDataset.SetDefaultGraph(System.Uri)">
            <summary>
            Sets the Default Graph to be the Graph with the given URI
            </summary>
            <param name="graphUri">Graph URI</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.ISparqlDataset.SetDefaultGraph(System.Collections.Generic.IEnumerable{System.Uri})">
            <summary>
            Sets the Default Graph to be the merge of the Graphs with the given URIs
            </summary>
            <param name="graphUris">Graph URIs</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.ISparqlDataset.ResetActiveGraph">
            <summary>
            Resets the Active Graph to the previous Active Graph
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.ISparqlDataset.ResetDefaultGraph">
            <summary>
            Resets the Default Graph to the previous Default Graph
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.ISparqlDataset.AddGraph(VDS.RDF.IGraph)">
            <summary>
            Adds a Graph to the Dataset
            </summary>
            <param name="g">Graph</param>
            <exception cref="T:System.NotSupportedException">May be thrown if the Dataset is immutable i.e. Updates not supported</exception>        /// <exception cref="T:System.NotSupportedException">May be thrown if the Dataset is immutable</exception>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.ISparqlDataset.RemoveGraph(System.Uri)">
            <summary>
            Removes a Graph from the Dataset
            </summary>
            <param name="graphUri">Graph URI</param>
            <exception cref="T:System.NotSupportedException">May be thrown if the Dataset is immutable i.e. Updates not supported</exception>        /// <exception cref="T:System.NotSupportedException">May be thrown if the Dataset is immutable</exception>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.ISparqlDataset.HasGraph(System.Uri)">
            <summary>
            Gets whether a Graph with the given URI is the Dataset
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.ISparqlDataset.GetModifiableGraph(System.Uri)">
            <summary>
            Gets the Graph with the given URI from the Dataset
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">May be thrown if the Dataset is immutable i.e. Updates not supported</exception>        /// <exception cref="T:System.NotSupportedException">May be thrown if the Dataset is immutable</exception>
            <remarks>
            <para>
            Graphs returned from this method must be modifiable and the Dataset must guarantee that when it is Flushed or Disposed of that any changes to the Graph are persisted
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.ISparqlDataset.ContainsTriple(VDS.RDF.Triple)">
            <summary>
            Gets whether the Dataset contains a specific Triple
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.ISparqlDataset.GetTriplesWithSubject(VDS.RDF.INode)">
            <summary>
            Gets all the Triples in the Dataset with the given Subject
            </summary>
            <param name="subj">Subject</param>
            <returns></returns>
            <remarks>
            <para>
            <strong>Note:</strong> The Triples returned from the method should be limited to those in the current Active Graph if present, otherwise those in the current Default Graph if present and finally the entire Dataset
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.ISparqlDataset.GetTriplesWithPredicate(VDS.RDF.INode)">
            <summary>
            Gets all the Triples in the Dataset with the given Predicate
            </summary>
            <param name="pred">Predicate</param>
            <returns></returns>
            <remarks>
            <para>
            <strong>Note:</strong> The Triples returned from the method should be limited to those in the current Active Graph if present, otherwise those in the current Default Graph if present and finally the entire Dataset
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.ISparqlDataset.GetTriplesWithObject(VDS.RDF.INode)">
            <summary>
            Gets all the Triples in the Dataset with the given Object
            </summary>
            <param name="obj">Object</param>
            <returns></returns>
            <remarks>
            <para>
            <strong>Note:</strong> The Triples returned from the method should be limited to those in the current Active Graph if present, otherwise those in the current Default Graph if present and finally the entire Dataset
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.ISparqlDataset.GetTriplesWithSubjectPredicate(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets all the Triples in the Dataset with the given Subject and Predicate
            </summary>
            <param name="subj">Subject</param>
            <param name="pred">Predicate</param>
            <returns></returns>
            <remarks>
            <para>
            <strong>Note:</strong> The Triples returned from the method should be limited to those in the current Active Graph if present, otherwise those in the current Default Graph if present and finally the entire Dataset
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.ISparqlDataset.GetTriplesWithSubjectObject(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets all the Triples in the Dataset with the given Subject and Object
            </summary>
            <param name="subj">Subject</param>
            <param name="obj">Object</param>
            <returns></returns>
            <remarks>
            <para>
            <strong>Note:</strong> The Triples returned from the method should be limited to those in the current Active Graph if present, otherwise those in the current Default Graph if present and finally the entire Dataset
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.ISparqlDataset.GetTriplesWithPredicateObject(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets all the Triples in the Dataset with the given Predicate and Object
            </summary>
            <param name="pred">Predicate</param>
            <param name="obj">Object</param>
            <returns></returns>
            <remarks>
            <para>
            <strong>Note:</strong> The Triples returned from the method should be limited to those in the current Active Graph if present, otherwise those in the current Default Graph if present and finally the entire Dataset
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.ISparqlDataset.Flush">
            <summary>
            Ensures that any changes to the Dataset (if any) are flushed to the underlying Storage
            </summary>
            <remarks>
            <para>
            While partly intended for use in implementations which support transactions though other implementations may wish to use this to ensure that changes to the dataset are persisted properly
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.ISparqlDataset.Discard">
            <summary>
            Ensures that any changes to the Dataset (if any) are discarded
            </summary>
            <remarks>
            <para>
            Primarily intended for use in implementations which support transactions though other implementations may wish to use this to ensure that changes to the dataset are persisted properly
            </para>
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.Datasets.ISparqlDataset.DefaultGraphUris">
            <summary>
            Gets the enumeration of the Graph URIs that currently make up the default graph
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Datasets.ISparqlDataset.ActiveGraphUris">
            <summary>
            Gets the enumeration of the Graph URIs that currently make up the active graph
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Datasets.ISparqlDataset.UsesUnionDefaultGraph">
            <summary>
            Gets whether the Default Graph is treated as being the union of all Graphs in the dataset when no Default Graph is otherwise set
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Datasets.ISparqlDataset.Graphs">
            <summary>
            Gets all the Graphs in the Dataset
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Datasets.ISparqlDataset.GraphUris">
            <summary>
            Gets all the URIs of Graphs in the Dataset
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Datasets.ISparqlDataset.Item(System.Uri)">
            <summary>
            Gets the Graph with the given URI from the Dataset
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
            <remarks>
            <para>
            This property need only return a read-only view of the Graph, code which wishes to modify Graphs should use the <see cref="M:VDS.RDF.Query.Datasets.ISparqlDataset.GetModifiableGraph(System.Uri)">GetModifiableGraph()</see> method to guarantee a Graph they can modify and will be persisted to the underlying storage
            </para>
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.Datasets.ISparqlDataset.HasTriples">
            <summary>
            Gets whether the Dataset has any Triples
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Datasets.ISparqlDataset.Triples">
            <summary>
            Gets all the Triples in the Dataset
            </summary>
            <remarks>
            <para>
            <strong>Note:</strong> The Triples returned from the method should be limited to those in the current Active Graph if present, otherwise those in the current Default Graph if present and finally the entire Dataset
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Configuration.IConfigurationSerializable">
            <summary>
            Interface for Objects which can have their configuration serialized to RDF
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.IConfigurationSerializable.SerializeConfiguration(VDS.RDF.Configuration.ConfigurationSerializationContext)">
            <summary>
            Serializes the Configuration in the given context
            </summary>
            <param name="context">Configuration Serialization Context</param>
        </member>
        <member name="F:VDS.RDF.Query.Datasets.WrapperDataset._dataset">
            <summary>
            Underlying Dataset
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.WrapperDataset.#ctor(VDS.RDF.Query.Datasets.ISparqlDataset)">
            <summary>
            Creates a new wrapped dataset
            </summary>
            <param name="dataset">Dataset</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.WrapperDataset.SetActiveGraph(System.Collections.Generic.IEnumerable{System.Uri})">
            <summary>
            Sets the Active Graph for the dataset
            </summary>
            <param name="graphUris">Graph URIs</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.WrapperDataset.SetActiveGraph(System.Uri)">
            <summary>
            Sets the Active Graph for the dataset
            </summary>
            <param name="graphUri">Graph URI</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.WrapperDataset.SetDefaultGraph(System.Uri)">
            <summary>
            Sets the Default Graph for the dataset
            </summary>
            <param name="graphUri">Graph URI</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.WrapperDataset.SetDefaultGraph(System.Collections.Generic.IEnumerable{System.Uri})">
            <summary>
            Sets the Default Graph for the dataset
            </summary>
            <param name="graphUris">Graph URIs</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.WrapperDataset.ResetActiveGraph">
            <summary>
            Resets the Active Graph
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.WrapperDataset.ResetDefaultGraph">
            <summary>
            Resets the Default Graph
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.WrapperDataset.AddGraph(VDS.RDF.IGraph)">
            <summary>
            Adds a Graph to the dataset
            </summary>
            <param name="g">Graph</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.WrapperDataset.RemoveGraph(System.Uri)">
            <summary>
            Removes a Graph from the dataset
            </summary>
            <param name="graphUri">Graph URI</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.WrapperDataset.HasGraph(System.Uri)">
            <summary>
            Gets whether the dataset contains a given Graph
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.WrapperDataset.GetModifiableGraph(System.Uri)">
            <summary>
            Gets a modifiable graph from the dataset
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.WrapperDataset.ContainsTriple(VDS.RDF.Triple)">
            <summary>
            Gets whether the dataset contains a given triple
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.WrapperDataset.GetTriplesWithSubject(VDS.RDF.INode)">
            <summary>
            Gets triples with a given subject
            </summary>
            <param name="subj">Subject</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.WrapperDataset.GetTriplesWithPredicate(VDS.RDF.INode)">
            <summary>
            Gets triples with a given predicate
            </summary>
            <param name="pred">Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.WrapperDataset.GetTriplesWithObject(VDS.RDF.INode)">
            <summary>
            Gets triples with a given object
            </summary>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.WrapperDataset.GetTriplesWithSubjectPredicate(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets triples with a given subject and predicate
            </summary>
            <param name="subj">Subject</param>
            <param name="pred">Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.WrapperDataset.GetTriplesWithSubjectObject(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets triples with a given subject and object
            </summary>
            <param name="subj">Subject</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.WrapperDataset.GetTriplesWithPredicateObject(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets triples with a given predicate and object
            </summary>
            <param name="pred">Predicate</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.WrapperDataset.Flush">
            <summary>
            Flushes any changes to the dataset
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.WrapperDataset.Discard">
            <summary>
            Discards any changes to the dataset
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.WrapperDataset.SerializeConfiguration(VDS.RDF.Configuration.ConfigurationSerializationContext)">
            <summary>
            Serializes the Configuration of the Dataset
            </summary>
            <param name="context">Serialization Context</param>
        </member>
        <member name="P:VDS.RDF.Query.Datasets.WrapperDataset.UnderlyingDataset">
            <summary>
            Gets the underlying dataset
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Datasets.WrapperDataset.DefaultGraphUris">
            <summary>
            Gets the Default Graph URIs
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Datasets.WrapperDataset.ActiveGraphUris">
            <summary>
            Gets the Active Graph URIs
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Datasets.WrapperDataset.UsesUnionDefaultGraph">
            <summary>
            Gets whether the default graph is the union of all graphs
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Datasets.WrapperDataset.Graphs">
            <summary>
            Gets the Graphs in the dataset
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Datasets.WrapperDataset.GraphUris">
            <summary>
            Gets the URIs of Graphs in the dataset
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Datasets.WrapperDataset.Item(System.Uri)">
            <summary>
            Gets a Graph from the dataset
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Datasets.WrapperDataset.HasTriples">
            <summary>
            Gets whether the dataset has any triples
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Datasets.WrapperDataset.Triples">
            <summary>
            Gets all triples from the dataset
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseDemandDataset.#ctor(VDS.RDF.Query.Datasets.ISparqlDataset)">
            <summary>
            Creates a new Demand Dataset
            </summary>
            <param name="dataset">Underlying Dataset</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseDemandDataset.HasGraph(System.Uri)">
            <summary>
            Sees if the underlying dataset has a graph and if not tries to load it on demand
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseDemandDataset.TryLoadGraph(System.Uri,VDS.RDF.IGraph@)">
            <summary>
            Method to be implemented by derived classes which implements the loading of graphs on demand
            </summary>
            <param name="graphUri">Graph URI</param>
            <param name="g">Graph</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.CallFunction">
            <summary>
            Class representing the SPARQL CALL() function
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.ISparqlExpression">
            <summary>
            Interface for SPARQL Expression Terms that can be used in Expression Trees while evaluating Sparql Queries
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.ISparqlExpression.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Evalutes a SPARQL Expression for the given binding in a given context
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
            <remarks>
            <para>
            Newly introduced in Version 0.6.0 to replace the variety of functions that were used previously for numeric vs non-numeric versions to allow our code to be simplified and improve performance
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.ISparqlExpression.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the arguments of the expression using the given transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.ISparqlExpression.Variables">
            <summary>
            Gets an enumeration of all the Variables used in an expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.ISparqlExpression.Type">
            <summary>
            Gets the SPARQL Expression Type
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.ISparqlExpression.Functor">
            <summary>
            Gets the Function Name or Operator Symbol - function names may be URIs of Keywords or the empty string in the case of primary expressions
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.ISparqlExpression.Arguments">
            <summary>
            Gets the Arguments of this Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.ISparqlExpression.CanParallelise">
            <summary>
            Gets whether an expression can safely be evaluated in parallel
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.CallFunction.#ctor(System.Collections.Generic.IEnumerable{VDS.RDF.Query.Expressions.ISparqlExpression})">
            <summary>
            Creates a new COALESCE function with the given expressions as its arguments
            </summary>
            <param name="expressions">Argument expressions</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.CallFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the value of the expression as evaluated in the given Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.CallFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.CallFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.CallFunction.Variables">
            <summary>
            Gets the Variables used in all the argument expressions of this function
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.CallFunction.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.CallFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.CallFunction.Arguments">
            <summary>
            Gets the Arguments of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.CallFunction.CanParallelise">
            <summary>
            Gets whether an expression can safely be evaluated in parallel
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.String.BaseUUIDFunction">
            <summary>
            Abstract Base Class for functions that generate UUIDs
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.BaseUUIDFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.BaseUUIDFunction.EvaluateInternal(System.Guid)">
            <summary>
            Method to be implemented by derived classes to implement the actual logic of turning the generated UUID into a RDF term
            </summary>
            <param name="uuid">UUID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.BaseUUIDFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Applies the transformer to the arguments of this expression
            </summary>
            <param name="transformer">Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.BaseUUIDFunction.Variables">
            <summary>
            Gets the variables used in the expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.BaseUUIDFunction.Type">
            <summary>
            Gets the Type of the expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.BaseUUIDFunction.Functor">
            <summary>
            Gets the Functor of the expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.BaseUUIDFunction.Arguments">
            <summary>
            Gets the arguments of the expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.BaseUUIDFunction.CanParallelise">
            <summary>
            Returns whether the function can be parallelised
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.String.UUIDFunction">
            <summary>
            Represents the SPARQL UUID Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.UUIDFunction.EvaluateInternal(System.Guid)">
            <summary>
            Evaluates the function by generating the URN UUID form based on the given UUID
            </summary>
            <param name="uuid">UUID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.UUIDFunction.Functor">
            <summary>
            Gets the functor for the expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrUUIDFunction">
            <summary>
            Represents the SPARQL STRUUID Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrUUIDFunction.EvaluateInternal(System.Guid)">
            <summary>
            Evaluates the function by returning the string form of the given UUID
            </summary>
            <param name="uuid">UUID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrUUIDFunction.Functor">
            <summary>
            Gets the functor for the expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Operators.BaseOperator">
            <summary>
            Abstract base class for SPARQL Operators which also makes their configuration serializable
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Operators.ISparqlOperator">
            <summary>
            Interface which represents an operator in SPARQL e.g. +
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Operators.ISparqlOperator.IsApplicable(VDS.RDF.Nodes.IValuedNode[])">
            <summary>
            Gets whether the operator can be applied to the given inputs
            </summary>
            <param name="ns">Inputs</param>
            <returns>True if applicable to the given inputs</returns>
        </member>
        <member name="M:VDS.RDF.Query.Operators.ISparqlOperator.Apply(VDS.RDF.Nodes.IValuedNode[])">
            <summary>
            Applies the operator to the given inputs
            </summary>
            <param name="ns">Inputs</param>
            <returns></returns>
            <exception cref="T:VDS.RDF.Query.RdfQueryException">Thrown if an error occurs in applying the operator</exception>
        </member>
        <member name="P:VDS.RDF.Query.Operators.ISparqlOperator.Operator">
            <summary>
            Gets the Operator this is an implementation of
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Operators.BaseOperator.IsApplicable(VDS.RDF.Nodes.IValuedNode[])">
            <summary>
            Gets whether the operator can be applied to the given inputs
            </summary>
            <param name="ns">Inputs</param>
            <returns>True if applicable to the given inputs</returns>
        </member>
        <member name="M:VDS.RDF.Query.Operators.BaseOperator.Apply(VDS.RDF.Nodes.IValuedNode[])">
            <summary>
            Applies the operator
            </summary>
            <param name="ns">Inputs</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Operators.BaseOperator.SerializeConfiguration(VDS.RDF.Configuration.ConfigurationSerializationContext)">
            <summary>
            Serializes the configuration of the operator
            </summary>
            <param name="context">Serialization Context</param>
        </member>
        <member name="P:VDS.RDF.Query.Operators.BaseOperator.Operator">
            <summary>
            Gets the operator this implementation represents
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Operators.DateTime.BaseDateTimeOperator">
            <summary>
            Abstract base operator for date time operations
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Operators.DateTime.BaseDateTimeOperator.IsApplicable(VDS.RDF.Nodes.IValuedNode[])">
            <summary>
            Gets whether the arguments are applicable for this operator
            </summary>
            <param name="ns">Arguments</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Operators.DateTime.BaseTimeSpanOperator">
            <summary>
            Abstract base operator for time span operations
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Operators.DateTime.BaseTimeSpanOperator.IsApplicable(VDS.RDF.Nodes.IValuedNode[])">
            <summary>
            Gets whether the operator is applicable for the arguments
            </summary>
            <param name="ns">Arguments</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Operators.DateTime.TimeSpanSubtraction">
            <summary>
            Represents the time span subtraction operator
            </summary>
            <remarks>
            Allows queries to subtract time spans from each other
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Operators.DateTime.TimeSpanSubtraction.Apply(VDS.RDF.Nodes.IValuedNode[])">
            <summary>
            Applies the operator
            </summary>
            <param name="ns">Arguments</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Operators.DateTime.TimeSpanSubtraction.Operator">
            <summary>
            Gets the operator type
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Operators.DateTime.DateTimeSubtraction">
            <summary>
            Represents the date time subtraction operation
            </summary>
            <remarks>
            Allows queries to subtract a duration from a date time
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Operators.DateTime.DateTimeSubtraction.Apply(VDS.RDF.Nodes.IValuedNode[])">
            <summary>
            Applies the operator
            </summary>
            <param name="ns">Arguments</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Operators.DateTime.DateTimeSubtraction.Operator">
            <summary>
            Gets the operator type
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Operators.DateTime.DateTimeAddition">
            <summary>
            Represents the date time addition operator
            </summary>
            <remarks>
            <para>
            Allows for queries to add durations to date times
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Operators.DateTime.DateTimeAddition.Apply(VDS.RDF.Nodes.IValuedNode[])">
            <summary>
            Applies the operator
            </summary>
            <param name="ns">Arguments</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Operators.DateTime.DateTimeAddition.Operator">
            <summary>
            Gets the operator type
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Operators.DateTime.TimeSpanAddition">
            <summary>
            Represents the time span addition operation
            </summary>
            <remarks>
            Allows queries to add time spans together
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Operators.DateTime.TimeSpanAddition.Apply(VDS.RDF.Nodes.IValuedNode[])">
            <summary>
            Applies the operator
            </summary>
            <param name="ns">Arguments</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Operators.DateTime.TimeSpanAddition.Operator">
            <summary>
            Gets the operator type
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Operators.Numeric.AdditionOperator">
            <summary>
            Represents the numeric addition operator
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Operators.Numeric.BaseNumericOperator">
            <summary>
            Abstract base class for numeric operators
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Operators.Numeric.BaseNumericOperator.IsApplicable(VDS.RDF.Nodes.IValuedNode[])">
            <summary>
            Operator is applicable if at least one input and all inputs are numeric
            </summary>
            <param name="ns">Inputs</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Operators.Numeric.AdditionOperator.Apply(VDS.RDF.Nodes.IValuedNode[])">
            <summary>
            Applies the operator
            </summary>
            <param name="ns">Arguments</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Operators.Numeric.AdditionOperator.Operator">
            <summary>
            Gets the operator type
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Operators.Numeric.MultiplicationOperator">
            <summary>
            Represents the numeric multiplication operator
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Operators.Numeric.MultiplicationOperator.Apply(VDS.RDF.Nodes.IValuedNode[])">
            <summary>
            Applies the operator
            </summary>
            <param name="ns">Arguments</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Operators.Numeric.MultiplicationOperator.Operator">
            <summary>
            Gets the operator type
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Operators.Numeric.DivisionOperator">
            <summary>
            Represents the numeric division operator
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Operators.Numeric.DivisionOperator.Apply(VDS.RDF.Nodes.IValuedNode[])">
            <summary>
            Applies the operator
            </summary>
            <param name="ns">Arguments</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Operators.Numeric.DivisionOperator.Operator">
            <summary>
            Gets the operator type
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Operators.Numeric.SubtractionOperator">
            <summary>
            Represents the numeric subtraction operator
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Operators.Numeric.SubtractionOperator.Apply(VDS.RDF.Nodes.IValuedNode[])">
            <summary>
            Applies the operator
            </summary>
            <param name="ns">Arguments</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Operators.Numeric.SubtractionOperator.Operator">
            <summary>
            Gets the operator type
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Operators.SparqlOperators">
            <summary>
            Registry of SPARQL Operators
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Operators.SparqlOperators.Init">
            <summary>
            Initializes the Operators registry
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Operators.SparqlOperators.AddOperator(VDS.RDF.Query.Operators.ISparqlOperator)">
            <summary>
            Registers a new operator
            </summary>
            <param name="op">Operator</param>
        </member>
        <member name="M:VDS.RDF.Query.Operators.SparqlOperators.RemoveOperator(VDS.RDF.Query.Operators.ISparqlOperator)">
            <summary>
            Removes the registration of an operator by instance reference
            </summary>
            <param name="op">Operator Reference</param>
        </member>
        <member name="M:VDS.RDF.Query.Operators.SparqlOperators.RemoveOperatorByType(VDS.RDF.Query.Operators.ISparqlOperator)">
            <summary>
            Removes the registration of an operator by instance type of the operator
            </summary>
            <param name="op">Operator</param>
        </member>
        <member name="M:VDS.RDF.Query.Operators.SparqlOperators.Reset">
            <summary>
            Resets Operator registry to default state
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Operators.SparqlOperators.IsRegistered(VDS.RDF.Query.Operators.ISparqlOperator)">
            <summary>
            Returns whether the given operator is registered
            </summary>
            <param name="op">Operator</param>
            <returns></returns>
            <remarks>
            Checking is done both by reference and instance type so you can check if an operator is registered even if you don't have the actual reference to the instance that registered
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Operators.SparqlOperators.GetOperators">
            <summary>
            Gets all registered Operators
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Operators.SparqlOperators.GetOperators(VDS.RDF.Query.Operators.SparqlOperatorType)">
            <summary>
            Gets all registered operators for the given Operator Type
            </summary>
            <param name="type">Operator Type</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Operators.SparqlOperators.TryGetOperator(VDS.RDF.Query.Operators.SparqlOperatorType,VDS.RDF.Query.Operators.ISparqlOperator@,VDS.RDF.Nodes.IValuedNode[])">
            <summary>
            Tries to return the operator which applies for the given inputs
            </summary>
            <param name="type">Operator Type</param>
            <param name="op">Operator</param>
            <param name="ns">Inputs</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Operators.SparqlOperatorType">
            <summary>
            Possible SPARQL operand types
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Operators.SparqlOperatorType.Add">
            <summary>
            Addition
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Operators.SparqlOperatorType.Subtract">
            <summary>
            Subtraction
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Operators.SparqlOperatorType.Multiply">
            <summary>
            Multiplication
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Operators.SparqlOperatorType.Divide">
            <summary>
            Division
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Optimisation.FilteredProductOptimiser">
            <summary>
            An Algebra Optimiser which implements the Filtered Product optimisation
            </summary>
            <remarks>
            <para>
            A filtered product is implied by any query where there is a product over a join or within a BGP around which there is a Filter which contains variables from both sides of the product.  So rather than computing the entire product and then applying the filter we want to push filter application into the product computation.
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.Optimisation.IAlgebraOptimiser">
            <summary>
            An Algebra Optimiser is a class that can transform a SPARQL algebra from one form to another typically for optimisation purposes
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.IAlgebraOptimiser.Optimise(VDS.RDF.Query.Algebra.ISparqlAlgebra)">
            <summary>
            Optimises the given Algebra
            </summary>
            <param name="algebra">Algebra to optimise</param>
            <returns></returns>
            <remarks>
            <strong>Important:</strong> An Algebra Optimiser must guarantee to return an equivalent algebra to the given algebra.  In the event of any error the optimiser <em>should</em> still return a valid algebra (or at least the original algebra)
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.IAlgebraOptimiser.IsApplicable(VDS.RDF.Query.SparqlQuery)">
            <summary>
            Determines whether an Optimiser is applicable based on the Query whose Algebra is being optimised
            </summary>
            <param name="q">SPARQL Query</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.IAlgebraOptimiser.IsApplicable(VDS.RDF.Update.SparqlUpdateCommandSet)">
            <summary>
            Determines whether an Optimiser is applicable based on the Update Command Set being optimised
            </summary>
            <param name="cmds">Update Command Set</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.FilteredProductOptimiser.Optimise(VDS.RDF.Query.Algebra.ISparqlAlgebra)">
            <summary>
            Optimises the Algebra to use implict joins where applicable
            </summary>
            <param name="algebra">Algebra</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.FilteredProductOptimiser.IsApplicable(VDS.RDF.Query.SparqlQuery)">
            <summary>
            Returns that this optimiser is applicable to all queries
            </summary>
            <param name="q">Query</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.FilteredProductOptimiser.IsApplicable(VDS.RDF.Update.SparqlUpdateCommandSet)">
            <summary>
            Returns that this optimiser is applicable to all updates
            </summary>
            <param name="cmds">Updates</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Optimisation.ImplicitJoinOptimiser">
            <summary>
            An Algebra Optimiser which implements the Implicit Join optimisation
            </summary>
            <remarks>
            <para>
            An implict join is implied by a query like the following:
            </para>
            <pre>
            SELECT *
            WHERE
            {
              ?x a ?type .
              ?y a ?type .
              FILTER (?x = ?y) .
            }
            </pre>
            <para>
            Such queries can be very expensive to calculate, the implict join optimisation attempts to substitute one variable for the other and use a BIND to ensure both variables are visible outside of the graph pattern affected i.e. the resulting query looks like the following:
            </para>
            <pre>
            SELECT *
            WHERE
            {
              ?x a ?type .
              ?x a ?type .
              BIND (?x AS ?y)
            }
            </pre>
            <para>
            Under normal circumstances this optimisation is only used when the implict join is denoted by a SAMETERM expression or the optimiser is sure the variables don't represent literals (they never occur in the Object position) since when value equality is involved substituing one variable for another changes the semantics of the query and may lead to unexpected results.  Since this optimisation may offer big performance benefits for some queries (at the cost of potentially incorrect results) this form of the optimisation is allowed when you set <see cref="P:VDS.RDF.Options.UnsafeOptimisation"/> to true.
            </para>
            <para>
            This optimiser is also capable of generating special algebra to deal with the case where there is an implicit join but the substitution based optimisation does not apply because variables cannot be substituted into the inner algebra, in this case a <see cref="T:VDS.RDF.Query.Algebra.FilteredProduct"/> is generated instead.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.ImplicitJoinOptimiser.Optimise(VDS.RDF.Query.Algebra.ISparqlAlgebra)">
            <summary>
            Optimises the Algebra to use implict joins where applicable
            </summary>
            <param name="algebra">Algebra</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.ImplicitJoinOptimiser.IsImplicitJoinExpression(VDS.RDF.Query.Expressions.ISparqlExpression,System.String@,System.String@,System.Boolean@)">
            <summary>
            Determines whether an expression is an Implicit Join Expression
            </summary>
            <param name="expr">Expression</param>
            <param name="lhsVar">LHS Variable</param>
            <param name="rhsVar">RHS Variable</param>
            <param name="equals">Whether the expression is an equals (true) or a same term (false)</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.ImplicitJoinOptimiser.IsApplicable(VDS.RDF.Query.SparqlQuery)">
            <summary>
            Returns that this optimiser is applicable to all queries
            </summary>
            <param name="q">Query</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.ImplicitJoinOptimiser.IsApplicable(VDS.RDF.Update.SparqlUpdateCommandSet)">
            <summary>
            Returns that this optimiser is applicable to all updates
            </summary>
            <param name="cmds">Updates</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Optimisation.PropertyFunctionOptimiser">
            <summary>
            An algebra optimiser that looks for property functions specified by simple triple patterns in BGPs and replaces them with actual property function patterns
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.PropertyFunctionOptimiser.Optimise(VDS.RDF.Query.Algebra.ISparqlAlgebra)">
            <summary>
            Optimises the algebra to include property functions
            </summary>
            <param name="algebra">Algebra</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.PropertyFunctionOptimiser.IsApplicable(VDS.RDF.Query.SparqlQuery)">
            <summary>
            Returns that the optimiser is applicable
            </summary>
            <param name="q">Query</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.PropertyFunctionOptimiser.IsApplicable(VDS.RDF.Update.SparqlUpdateCommandSet)">
            <summary>
            Returns that the optimiser is applicable
            </summary>
            <param name="cmds">Update Commands</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Optimisation.VariableSubstitutionTransformer">
            <summary>
            An optimiser for walking algebra and expression trees and replacing a Variable with another Variable or a Constant
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.PrimaryExpressionSubstituter">
            <summary>
            Abstract implementation of an Expression Transformer which substitutes primary expressions
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.IExpressionTransformer">
            <summary>
            An Expression Transformer is a class that can traverse a SPARQL Expression tree and apply transformations to it
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.IExpressionTransformer.Transform(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Transforms the expression using this transformer
            </summary>
            <param name="expr">Expression</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.PrimaryExpressionSubstituter.Transform(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Transforms an expression into a form where primary expressions may be substituted
            </summary>
            <param name="expr">Expression</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.PrimaryExpressionSubstituter.SubstitutePrimaryExpression(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Returns the substitution for a given primary expression
            </summary>
            <param name="expr">Expression</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.VariableSubstitutionTransformer.#ctor(System.String,System.String)">
            <summary>
            Create a transform that replaces one variable with another
            </summary>
            <param name="findVar">Find Variable</param>
            <param name="replaceVar">Replace Variable</param>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.VariableSubstitutionTransformer.#ctor(System.String,VDS.RDF.INode)">
            <summary>
            Create a transform that replaces a variable with a constant
            </summary>
            <param name="findVar">Find Variable</param>
            <param name="replaceTerm">Replace Constant</param>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.VariableSubstitutionTransformer.Optimise(VDS.RDF.Query.Algebra.ISparqlAlgebra)">
            <summary>
            Attempts to do variable substitution within the given algebra
            </summary>
            <param name="algebra">Algebra</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.VariableSubstitutionTransformer.IsApplicable(VDS.RDF.Query.SparqlQuery)">
            <summary>
            Returns false because this optimiser is never globally applicable
            </summary>
            <param name="q">Query</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.VariableSubstitutionTransformer.IsApplicable(VDS.RDF.Update.SparqlUpdateCommandSet)">
            <summary>
            Returns false because this optimiser is never globally applicable
            </summary>
            <param name="cmds">Update Commands</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.VariableSubstitutionTransformer.SubstitutePrimaryExpression(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Tries to substitute variables within primary expressions
            </summary>
            <param name="expr">Expression</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Optimisation.VariableSubstitutionTransformer.CanReplaceObjects">
            <summary>
            Gets/Sets whethe the Transformer is allowed to replace objects
            </summary>
            <remarks>
            <para>
            The transformer will intelligently select this depending on whether it is replacing with a constant (defaults to true) or a variable (defaults to false),  when replacing a variable the behaviour changes automatically.  If you set it explicitly the transformer will respect your setting regardless.
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.Patterns.GraphPattern">
            <summary>
            Class for representing Graph Patterns in Sparql Queries
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.GraphPattern.#ctor">
            <summary>
            Creates a new Graph Pattern
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.GraphPattern.#ctor(VDS.RDF.Query.Patterns.GraphPattern)">
            <summary>
            Creates a new Graph Pattern copied from an existing Graph Pattern
            </summary>
            <param name="gp">Graph Pattern</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.GraphPattern.AddTriplePattern(VDS.RDF.Query.Patterns.ITriplePattern)">
            <summary>
            Adds a Triple Pattern to the Graph Pattern respecting any BGP breaks
            </summary>
            <param name="p">Triple Pattern</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.GraphPattern.AddAssignment(VDS.RDF.Query.Patterns.IAssignmentPattern)">
            <summary>
            Adds an Assignment to the Graph Pattern respecting any BGP breaks
            </summary>
            <param name="p">Assignment Pattern</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.GraphPattern.AddFilter(VDS.RDF.Query.Filters.ISparqlFilter)">
            <summary>
            Adds a Filter to the Graph Pattern
            </summary>
            <param name="filter">Filter</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.GraphPattern.ResetFilters(System.Collections.Generic.IEnumerable{VDS.RDF.Query.Filters.ISparqlFilter})">
            <summary>
            Resets the set of Unplaced Filters to be a new set of 
            </summary>
            <param name="filters">Filters</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.GraphPattern.AddGraphPattern(VDS.RDF.Query.Patterns.GraphPattern)">
            <summary>
            Adds a child Graph Pattern to the Graph Pattern respecting any BGP breaks
            </summary>
            <param name="p">Graph Pattern</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.GraphPattern.AddInlineData(VDS.RDF.Query.Patterns.BindingsPattern)">
            <summary>
            Adds inline data to a Graph Pattern respecting any BGP breaks
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.GraphPattern.BreakBGP">
            <summary>
            Tells the Graph Pattern that any subsequent Graph/Triple Patterns added go in a new BGP
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.GraphPattern.SwapTriplePatterns(System.Int32,System.Int32)">
            <summary>
            Swaps the position of the two given Triple Patterns
            </summary>
            <param name="i">First Position</param>
            <param name="j">Second Position</param>
            <remarks>
            Intended for use by Query Optimisers
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.GraphPattern.InsertFilter(VDS.RDF.Query.Filters.ISparqlFilter,System.Int32)">
            <summary>
            Inserts a Filter at a given position
            </summary>
            <param name="filter">Filter</param>
            <param name="i">Position to insert at</param>
            <remarks>
            Intended for use by Query Optimisers
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.GraphPattern.InsertAssignment(VDS.RDF.Query.Patterns.IAssignmentPattern,System.Int32)">
            <summary>
            Inserts an Assignment at a given position
            </summary>
            <param name="assignment">Assignment</param>
            <param name="i">Position to insert at</param>
            <remarks>
            Intended for use by Query Optimisers
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.GraphPattern.LastChildPattern">
            <summary>
            Gets the Last Child Graph Pattern of this Pattern and removes it from this Pattern
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.GraphPattern.Optimise">
            <summary>
            Optimises the Graph Pattern using the current global optimiser
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.GraphPattern.Optimise(VDS.RDF.Query.Optimisation.IQueryOptimiser)">
            <summary>
            Optimises the Graph Pattern using the given optimiser
            </summary>
            <param name="optimiser">Query Optimiser</param>
            <remarks>
            <para>
            <strong>Important:</strong> If a Pattern has already been optimized then calling this again is a no-op.
            </para>
            <para>
            For finer grained control of what gets optimized you can use <see cref="P:VDS.RDF.Options.QueryOptimisation"/> to disable automatic optimisation and then manually call this method as necessary
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.GraphPattern.Optimise(VDS.RDF.Query.Optimisation.IQueryOptimiser,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Optimises the Graph Pattern using the given optimiser and with the given variables
            </summary>
            <param name="optimiser">Query Optimiser</param>
            <param name="vars">Variables</param>
            <remarks>
            <para>
            <strong>Important:</strong> If a Pattern has already been optimized then calling this again is a no-op.
            </para>
            <para>
            For finer grained control of what gets optimized you can use <see cref="P:VDS.RDF.Options.QueryOptimisation"/> to disable automatic optimisation and then manually call this method as necessary
            </para>
            <para>
            The <paramref name="vars">vars</paramref> parameter contains Variables mentioned in the parent Graph Pattern (if any) that can be used to guide optimisation of child graph patterns
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.GraphPattern.ToString">
            <summary>
            Gets the String representation of the Graph Pattern
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.GraphPattern.ToAlgebra">
            <summary>
            Gets the Algebra representation of the Graph Pattern
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.GraphPattern.IsOptional">
            <summary>
            Gets/Sets whether the Graph Pattern is Optional
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.GraphPattern.IsFiltered">
            <summary>
            Gets/Sets whether the Graph Pattern is Filtered
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.GraphPattern.IsUnion">
            <summary>
            Gets/Sets whether the Graph Pattern is a Union of its Child Graph Patterns
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.GraphPattern.IsGraph">
            <summary>
            Gets/Sets whether the Graph Pattern operates on a specific Graph
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.GraphPattern.IsEmpty">
            <summary>
            Gets whether this is an empty Graph Pattern
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.GraphPattern.IsExists">
            <summary>
            Gets/Sets whether the Graph Pattern is an EXISTS clause
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.GraphPattern.IsNotExists">
            <summary>
            Gets/Sets whether the Graph Pattern is a NOT EXISTS clause
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.GraphPattern.IsMinus">
            <summary>
            Gets/Sets whether the Graph Pattern is a MINUS clause
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.GraphPattern.IsService">
            <summary>
            Gets/Sets whether the Graph Pattern is a SERVICE clause
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.GraphPattern.IsOptimised">
            <summary>
            Gets whether Optimisation has been applied to this query
            </summary>
            <remarks>
            This only indicates that an Optimiser has been applied to the Pattern.  You can always reoptimise by calling the <see cref="M:VDS.RDF.Query.SparqlQuery.Optimise">Optimise()</see> method with an optimiser of your choice on the query to which this Pattern belongs
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.GraphPattern.IsSilent">
            <summary>
            Gets whether Evaluation Errors in this Graph Pattern are suppressed (currently only valid with SERVICE)
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.GraphPattern.HasInlineData">
            <summary>
            Gets whether this Graph Pattern contains an Inline Data block (VALUES clause)
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.GraphPattern.HasModifier">
            <summary>
            Determines whether the Graph Pattern has any kind of Modifier (GRAPH, MINUS, OPTIONAL etc) applied
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.GraphPattern.Filter">
            <summary>
            Gets/Sets the FILTER that applies to this Graph Pattern
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.GraphPattern.GraphSpecifier">
            <summary>
            Gets/Sets the Graph Specifier that applies to this Graph Pattern
            </summary>
            <remarks>
            This property is also used internally for SERVICE specifiers to save adding an additional property unnecessarily
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.GraphPattern.HasChildGraphPatterns">
            <summary>
            Checks whether this Pattern has any Child Graph Patterns
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.GraphPattern.ChildGraphPatterns">
            <summary>
            Gets the Child Graph Patterns of this Pattern
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.GraphPattern.TriplePatterns">
            <summary>
            Gets the Triple Patterns in this Pattern
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.GraphPattern.IsSimplifiable">
            <summary>
            Gets whether this Pattern can be simplified
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.GraphPattern.IsSubQuery">
            <summary>
            Gets whether this Graph Pattern is a Sub-query which can be simplified
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.GraphPattern.UsesDefaultDataset">
            <summary>
            Gets whether the Graph Pattern uses the Default Dataset
            </summary>
            <remarks>
            Graph Patterns generally use the Default Dataset unless they are a GRAPH pattern or they contain a Triple Pattern, child Graph Pattern or a FILTER/BIND which does not use the default dataset
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.GraphPattern.UnplacedFilters">
            <summary>
            Gets the enumeration of Filters that apply to this Graph Pattern which will have yet to be placed within the Graph Pattern
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.GraphPattern.UnplacedAssignments">
            <summary>
            Gets the enumeration of LET assignments that are in this Graph Pattern which will be placed appropriately later
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.GraphPattern.Variables">
            <summary>
            Gets the Variables used in the Pattern
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.GraphPattern.InlineData">
            <summary>
            Gets the inline data (VALUES block if any)
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.ISparqlCustomExpressionFactory">
            <summary>
            Interface for implementing SPARQL custom expression factories which turn URI specified functions into SPARQL Expressions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.ISparqlCustomExpressionFactory.TryCreateExpression(System.Uri,System.Collections.Generic.List{VDS.RDF.Query.Expressions.ISparqlExpression},System.Collections.Generic.Dictionary{System.String,VDS.RDF.Query.Expressions.ISparqlExpression},VDS.RDF.Query.Expressions.ISparqlExpression@)">
            <summary>
            Tries to Create a SPARQL Expression for a function with the given URI and set of arguments
            </summary>
            <param name="u">URI of the function</param>
            <param name="args">List of Arguments</param>
            <param name="scalarArguments">Dictionary of Scalar Arguments which are supportable by aggregates when Syntax is set to SPARQL 1.1 Extended</param>
            <param name="expr">Resulting Expression if able to generate</param>
            <returns>True if an expression is generated, false if not</returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.ISparqlCustomExpressionFactory.AvailableExtensionFunctions">
            <summary>
            Gets the Extension Function URIs that this Factory provides
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.ISparqlCustomExpressionFactory.AvailableExtensionAggregates">
            <summary>
            Gets the Extension Aggregate URIs that this Factory provides
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.SparqlExpressionFactory">
            <summary>
            Factory Class for generating Expressions for Sparql Extension Functions
            </summary>
            <remarks>
            <para>
            Allows for users of the Library to implement and register Custom Expression Factories which can generate Expressions for their own Extension functions which they wish to use in their SPARQL queries.   Custom factories may be globally scoped by registering them with the <see cref="M:VDS.RDF.Query.Expressions.SparqlExpressionFactory.AddCustomFactory(VDS.RDF.Query.Expressions.ISparqlCustomExpressionFactory)">AddCustomFactory()</see> method or locally by passing them to the three argument constructor of the <see cref="M:VDS.RDF.Query.Expressions.SparqlExpressionFactory.CreateExpression(System.Uri,System.Collections.Generic.List{VDS.RDF.Query.Expressions.ISparqlExpression},System.Collections.Generic.IEnumerable{VDS.RDF.Query.Expressions.ISparqlCustomExpressionFactory})">CreateExpression()</see> method.
            </para>
            </remarks>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.SparqlExpressionFactory._customFactories">
            <summary>
            List of Custom Expression factories
            </summary>
            <remarks>
            All the standard function libraries (XPath, Leviathan and ARQ) included in dotNetRDF are automatically registered
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.SparqlExpressionFactory.CreateExpression(System.Uri,System.Collections.Generic.List{VDS.RDF.Query.Expressions.ISparqlExpression})">
            <summary>
            Tries to create an Expression from the given function Uri and list of argument expressions
            </summary>
            <param name="u">Function Uri</param>
            <param name="args">List of Argument Expressions</param>
            <returns></returns>
            <remarks>
            <para>
            Uses only the globally scoped custom expression factories
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.SparqlExpressionFactory.CreateExpression(System.Uri,System.Collections.Generic.List{VDS.RDF.Query.Expressions.ISparqlExpression},System.Collections.Generic.IEnumerable{VDS.RDF.Query.Expressions.ISparqlCustomExpressionFactory})">
            <summary>
            Tries to create an Expression from the given function Uri and list of argument expressions
            </summary>
            <param name="u">Function Uri</param>
            <param name="args">List of Argument Expressions</param>
            <param name="factories">Enumeration of locally scoped expression factories to use</param>
            <returns></returns>
            <remarks>
            <para>
            Globally scoped custom expression factories are tried first and then any locally scoped expression factories are used
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.SparqlExpressionFactory.CreateExpression(System.Uri,System.Collections.Generic.List{VDS.RDF.Query.Expressions.ISparqlExpression},System.Collections.Generic.Dictionary{System.String,VDS.RDF.Query.Expressions.ISparqlExpression},System.Collections.Generic.IEnumerable{VDS.RDF.Query.Expressions.ISparqlCustomExpressionFactory})">
            <summary>
            Tries to create an Expression from the given function Uri and list of argument expressions
            </summary>
            <param name="u">Function Uri</param>
            <param name="args">List of Argument Expressions</param>
            <param name="scalarArgs">Scalar Arguments</param>
            <param name="factories">Enumeration of locally scoped expression factories to use</param>
            <returns></returns>
            <remarks>
            <para>
            Globally scoped custom expression factories are tried first and then any locally scoped expression factories are used
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.SparqlExpressionFactory.AddCustomFactory(VDS.RDF.Query.Expressions.ISparqlCustomExpressionFactory)">
            <summary>
            Registers a Custom Expression Factory
            </summary>
            <param name="factory">A Custom Expression Factory</param>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.SparqlExpressionFactory.Factories">
            <summary>
            Gets the Global Custom Expression Factories that are in use
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Filters.BaseUnaryFilter">
            <summary>
            Abstract Base class for Unary Filters that operate on a single Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Filters.ISparqlFilter">
            <summary>
            Interface for Classes which implement SPARQL Filter Functions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Filters.ISparqlFilter.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates a Filter in the given Evaluation Context
            </summary>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="P:VDS.RDF.Query.Filters.ISparqlFilter.Variables">
            <summary>
            Gets the enumeration of Variables that are used in the Filter
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Filters.ISparqlFilter.Expression">
            <summary>
            Gets the Expression that this Filter uses
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Filters.BaseUnaryFilter._arg">
            <summary>
            Expression which is the Argument to the Filter
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Filters.BaseUnaryFilter.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Base Unary Filter
            </summary>
            <param name="arg">Argument to the Filter</param>
        </member>
        <member name="M:VDS.RDF.Query.Filters.BaseUnaryFilter.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates a filter in the given Evaluation Context
            </summary>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.Filters.BaseUnaryFilter.ToString">
            <summary>
            Gets the String representation of the Filter
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Filters.BaseUnaryFilter.Variables">
            <summary>
            Gets the enumeration of Variables used in the Filter
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Filters.BaseUnaryFilter.Expression">
            <summary>
            Gets the inner expression this Filter uses
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Filters.BoundFilter">
            <summary>
            Filter that represents the Sparql BOUND() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Filters.BoundFilter.#ctor(VDS.RDF.Query.Expressions.Primary.VariableTerm)">
            <summary>
            Creates a new Bound Filter
            </summary>
            <param name="varTerm">Variable Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Filters.BoundFilter.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates a filter in the given Evaluation Context
            </summary>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.Filters.BoundFilter.ToString">
            <summary>
            Gets the String representation of the Filter
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Filters.UnaryExpressionFilter">
            <summary>
            Generic Filter for Filters which take a single sub-expression as an argument
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Filters.UnaryExpressionFilter.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Unary Expression Filter which filters on the basis of a single sub-expression
            </summary>
            <param name="expr">Expression to filter with</param>
        </member>
        <member name="M:VDS.RDF.Query.Filters.UnaryExpressionFilter.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates a filter in the given Evaluation Context
            </summary>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.Filters.UnaryExpressionFilter.ToString">
            <summary>
            Gets the String representation of the Filter
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Filters.ChainFilter">
            <summary>
            Generic Filter for use where multiple Filters are applied on a single Graph Pattern
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Filters.ChainFilter.#ctor(VDS.RDF.Query.Filters.ISparqlFilter,VDS.RDF.Query.Filters.ISparqlFilter)">
            <summary>
            Creates a new Chain Filter
            </summary>
            <param name="first">First Filter</param>
            <param name="second">Second Filter</param>
        </member>
        <member name="M:VDS.RDF.Query.Filters.ChainFilter.#ctor(System.Collections.Generic.IEnumerable{VDS.RDF.Query.Filters.ISparqlFilter})">
            <summary>
            Creates a new Chain Filter
            </summary>
            <param name="filters">Filters</param>
        </member>
        <member name="M:VDS.RDF.Query.Filters.ChainFilter.#ctor(VDS.RDF.Query.Filters.ISparqlFilter,System.Collections.Generic.IEnumerable{VDS.RDF.Query.Filters.ISparqlFilter})">
            <summary>
            Creates a new Chain Filter
            </summary>
            <param name="first">First Filter</param>
            <param name="rest">Additional Filters</param>
        </member>
        <member name="M:VDS.RDF.Query.Filters.ChainFilter.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates a filter in the given Evaluation Context
            </summary>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.Filters.ChainFilter.Add(VDS.RDF.Query.Filters.ISparqlFilter)">
            <summary>
            Adds an additional Filter to the Filter Chain
            </summary>
            <param name="filter">A Filter to add</param>
        </member>
        <member name="M:VDS.RDF.Query.Filters.ChainFilter.ToString">
            <summary>
            Gets the String representation of the Filters
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Filters.ChainFilter.Variables">
            <summary>
            Gets the enumeration of Variables used in the chained Filters
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Filters.ChainFilter.Expression">
            <summary>
            Gets the Inner Expression used by the Chained Filters
            </summary>
            <remarks>
            Equivalent to ANDing all the Chained Filters expressions
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.Ordering.BaseOrderBy">
            <summary>
            Base Class for implementing Sparql ORDER BYs
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Ordering.ISparqlOrderBy">
            <summary>
            Interface for classes that represent SPARQL ORDER BY clauses
            </summary>
            <remarks>A SPARQL Order By clause provides a list of orderings, when parsed into the dotNetRDF model this is represented as a single <see cref="T:VDS.RDF.Query.Ordering.ISparqlOrderBy">ISparqlOrderBy</see> for the first term in the clause chained to <see cref="T:VDS.RDF.Query.Ordering.ISparqlOrderBy">ISparqlOrderBy</see>'s for each subsequent term via the <see cref="P:VDS.RDF.Query.Ordering.ISparqlOrderBy.Child">Child</see> property.</remarks>
        </member>
        <member name="M:VDS.RDF.Query.Ordering.ISparqlOrderBy.GetComparer(VDS.RDF.Query.Patterns.IMatchTriplePattern)">
            <summary>
            Generates a Comparer than can be used to do Ordering based on the given Triple Pattern
            </summary>
            <param name="pattern">Triple Pattern</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Ordering.ISparqlOrderBy.Child">
            <summary>
            Gets/Sets the Child Ordering that applies if the two Objects are considered equal
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Ordering.ISparqlOrderBy.Context">
            <summary>
            Sets the Evaluation Context for the Order By
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Ordering.ISparqlOrderBy.Descending">
            <summary>
            Sets whether the Ordering is Descending
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Ordering.ISparqlOrderBy.IsSimple">
            <summary>
            Gets whether the Ordering is simple (i.e. applies on variables only)
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Ordering.ISparqlOrderBy.Variables">
            <summary>
            Gets all the Variables used in the Ordering
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Ordering.ISparqlOrderBy.Expression">
            <summary>
            Gets the Expression used to do the Ordering
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Ordering.BaseOrderBy._child">
            <summary>
            Holds the Child Order By (if any)
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Ordering.BaseOrderBy._context">
            <summary>
            Stores the Evaluation Context
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Ordering.BaseOrderBy._modifier">
            <summary>
            Modifier used to make ordering Descending
            </summary>
            <remarks>Implementations derived from this class should multiply their comparison results by the modifier to automatically provide Ascending/Descending order</remarks>
        </member>
        <member name="M:VDS.RDF.Query.Ordering.BaseOrderBy.Compare(VDS.RDF.Query.Algebra.ISet,VDS.RDF.Query.Algebra.ISet)">
            <summary>
            Abstract Compare method which derived classes should implement their ordering in
            </summary>
            <param name="x">A Set</param>
            <param name="y">A Set</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Ordering.BaseOrderBy.GetComparer(VDS.RDF.Query.Patterns.IMatchTriplePattern)">
            <summary>
            Generates a Comparer than can be used to do Ordering based on the given Triple Pattern
            </summary>
            <param name="pattern">Triple Pattern</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Ordering.BaseOrderBy.ToString">
            <summary>
            Gets the String representation of the Order By
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Ordering.BaseOrderBy.Child">
            <summary>
            Gets/Sets the Child Order By
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Ordering.BaseOrderBy.Context">
            <summary>
            Sets the Evaluation Context for the Ordering
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Ordering.BaseOrderBy.Descending">
            <summary>
            Sets the Ordering to Descending
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Ordering.BaseOrderBy.IsSimple">
            <summary>
            Gets whether the Ordering is Simple
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Ordering.BaseOrderBy.Variables">
            <summary>
            Gets all the Variables used in the Ordering
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Ordering.BaseOrderBy.Expression">
            <summary>
            Gets the Expression used in the Ordering
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Ordering.OrderByVariable">
            <summary>
            An ORDER BY which orders on the values bound to a particular variable
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Ordering.OrderByVariable.#ctor(System.String)">
            <summary>
            Creates a new Ordering based on the Value of a given Variable
            </summary>
            <param name="name">Variable to order upon</param>
        </member>
        <member name="M:VDS.RDF.Query.Ordering.OrderByVariable.Compare(VDS.RDF.Query.Algebra.ISet,VDS.RDF.Query.Algebra.ISet)">
            <summary>
            Compares Sets on the basis of their values for the Variable the class was instaniated with
            </summary>
            <param name="x">A Set</param>
            <param name="y">A Set</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Ordering.OrderByVariable.GetComparer(VDS.RDF.Query.Patterns.IMatchTriplePattern)">
            <summary>
            Generates a Comparer than can be used to do Ordering based on the given Triple Pattern
            </summary>
            <param name="pattern">Triple Pattern</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Ordering.OrderByVariable.ToString">
            <summary>
            Gets the String representation of the Order By
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Ordering.OrderByVariable.IsSimple">
            <summary>
            Gets whether the Ordering is Simple
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Ordering.OrderByVariable.Variables">
            <summary>
            Gets all the Variables used in the Ordering
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Ordering.OrderByVariable.Expression">
            <summary>
            Gets the Variable Expression Term used in the Ordering
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Ordering.OrderByExpression">
            <summary>
            An ORDER BY which orders based on the values of a Sparql Expression
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Ordering.OrderByExpression.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Order By using the given Expression
            </summary>
            <param name="expr">Expression to order by</param>
        </member>
        <member name="M:VDS.RDF.Query.Ordering.OrderByExpression.Compare(VDS.RDF.Query.Algebra.ISet,VDS.RDF.Query.Algebra.ISet)">
            <summary>
            Orders the sets based on the values resulting from evaluating the expression for both solutions
            </summary>
            <param name="x">A Set</param>
            <param name="y">A Set</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Ordering.OrderByExpression.GetComparer(VDS.RDF.Query.Patterns.IMatchTriplePattern)">
            <summary>
            Generates a Comparer than can be used to do Ordering based on the given Triple Pattern
            </summary>
            <param name="pattern">Triple Pattern</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Ordering.OrderByExpression.ToString">
            <summary>
            Gets the String representation of the Order By
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Ordering.OrderByExpression.IsSimple">
            <summary>
            Gets whether the Ordering is Simple
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Ordering.OrderByExpression.Variables">
            <summary>
            Gets all the Variables used in the Ordering
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Ordering.OrderByExpression.Expression">
            <summary>
            Gets the Expression used for Ordering
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Patterns.PropertyFunctionPattern">
            <summary>
            Class for representing property function patterns in SPARQL Query
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Patterns.BaseTriplePattern">
            <summary>
            Base class for representing all types of Triple Patterns in SPARQL queries
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Patterns.ITriplePattern">
            <summary>
            Interface for Triple Patterns
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.ITriplePattern.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates the Triple Pattern in the given Evaluation Context
            </summary>
            <param name="context">Query Evaluation Context</param>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.ITriplePattern.PatternType">
            <summary>
            Gets the Pattern Type
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.ITriplePattern.IsAcceptAll">
            <summary>
            Gets whether the Pattern accepts all
            </summary>
            <remarks>
            Indicates that a Pattern is of the form ?s ?p ?o
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.ITriplePattern.Variables">
            <summary>
            Gets the List of Variables used in the Pattern
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.ITriplePattern.FloatingVariables">
            <summary>
            Gets the enumeration of floating variables in the pattern i.e. variables that are not guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.ITriplePattern.FixedVariables">
            <summary>
            Gets the enumeration of fixed variables in the pattern i.e. variables that are guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.ITriplePattern.UsesDefaultDataset">
            <summary>
            Gets whether a Triple Pattern uses the Default Dataset when evaluated
            </summary>
            <remarks>
            Almost all Triple Patterns use the Default Dataset unless they are sub-query patterns which themselves don't use the Default Dataset or they contain an expression (in the case of BIND/LET/FILTERs) which does not use the Default Dataset
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.ITriplePattern.HasNoBlankVariables">
            <summary>
            Gets whether a Triple Pattern does not contain any Blank Variables
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Patterns.BaseTriplePattern._vars">
            <summary>
            Stores the list of variables that are used in the Pattern
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.BaseTriplePattern.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates the Triple Pattern in the given Evaluation Context
            </summary>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.BaseTriplePattern.CompareTo(VDS.RDF.Query.Patterns.ITriplePattern)">
            <summary>
            Compares a Triple Pattern to another Triple Pattern
            </summary>
            <param name="other">Other Triple Pattern</param>
            <returns></returns>
            <remarks>
            <para>
            The aim of this function is to sort Triple Patterns into what is hopefully an optimal order such that during execution the query space is restricted as early as possible.
            </para>
            <para>
            The basic rules of this are as follows:
            <ol>
                <li>Patterns with fewer variables should be executed first</li>
                <li>Patterns using the same variables should be executed in sequence</li>
                <li>Patterns using indexes which are considered more useful should be executed first</li>
            </ol>
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.BaseTriplePattern.ToString">
            <summary>
            Gets the String representation of the Pattern
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.BaseTriplePattern.IsAcceptAll">
            <summary>
            Returns whether the Triple Pattern is an accept all
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.BaseTriplePattern.PatternType">
            <summary>
            Gets the Triple Pattern Type
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.BaseTriplePattern.Variables">
            <summary>
            Gets the List of Variables used in the Pattern
            </summary>
            <remarks>
            These are sorted in alphabetical order
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.BaseTriplePattern.FloatingVariables">
            <summary>
            Gets the enumeration of floating variables in the pattern i.e. variables that are not guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.BaseTriplePattern.FixedVariables">
            <summary>
            Gets the enumeration of fixed variables in the pattern i.e. variables that are guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.BaseTriplePattern.UsesDefaultDataset">
            <summary>
            Gets whether a Triple Pattern is Thread Safe when evaluated
            </summary>
            <remarks>
            Almost all Triple Patterns are Thread Safe unless they are subquery patterns which themselves are not thread safe
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.BaseTriplePattern.HasNoBlankVariables">
            <summary>
            Gets whether the Pattern has no blank variables
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Patterns.IPropertyFunctionPattern">
            <summary>
            Interface for Triple Patterns that do property functions
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.IPropertyFunctionPattern.SubjectArgs">
            <summary>
            Gets the Subject arguments of the function
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.IPropertyFunctionPattern.ObjectArgs">
            <summary>
            Gets the Object arguments of the function
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.IPropertyFunctionPattern.PropertyFunction">
            <summary>
            Gets the property function
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.IPropertyFunctionPattern.OriginalPatterns">
            <summary>
            Gets the original triple patterns that made up this pattern
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.PropertyFunctionPattern.#ctor(VDS.RDF.Query.PropertyFunctions.PropertyFunctionInfo,VDS.RDF.Query.PropertyFunctions.ISparqlPropertyFunction)">
            <summary>
            Creates a new Property Function pattern
            </summary>
            <param name="info">Function information</param>
            <param name="propertyFunction">Property Function</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.PropertyFunctionPattern.#ctor(System.Collections.Generic.IEnumerable{VDS.RDF.Query.Patterns.ITriplePattern},System.Collections.Generic.IEnumerable{VDS.RDF.Query.Patterns.PatternItem},System.Collections.Generic.IEnumerable{VDS.RDF.Query.Patterns.PatternItem},VDS.RDF.Query.PropertyFunctions.ISparqlPropertyFunction)">
            <summary>
            Creates a new Property Function pattern
            </summary>
            <param name="origPatterns">Original Triple Patterns</param>
            <param name="lhsArgs">Subject Arguments</param>
            <param name="rhsArgs">Object Arguments</param>
            <param name="propertyFunction">Property Function</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.PropertyFunctionPattern.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates the property function
            </summary>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.PropertyFunctionPattern.CompareTo(VDS.RDF.Query.Patterns.PropertyFunctionPattern)">
            <summary>
            Compares a property function pattern to another
            </summary>
            <param name="other">Pattern</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.PropertyFunctionPattern.CompareTo(VDS.RDF.Query.Patterns.IPropertyFunctionPattern)">
            <summary>
            Compares a property function pattern to another
            </summary>
            <param name="other">Pattern</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.PropertyFunctionPattern.ToString">
            <summary>
            Gets the string representation of the pattern
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.PropertyFunctionPattern.PatternType">
            <summary>
            Gets the Pattern Type
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.PropertyFunctionPattern.SubjectArgs">
            <summary>
            Gets the Subject arguments
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.PropertyFunctionPattern.ObjectArgs">
            <summary>
            Gets the Object arguments
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.PropertyFunctionPattern.OriginalPatterns">
            <summary>
            Gets the original triple patterns
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.PropertyFunctionPattern.PropertyFunction">
            <summary>
            Gets the property function
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.PropertyFunctionPattern.FixedVariables">
            <summary>
            Returns the empty enumerable as cannot guarantee any variables are bound
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.PropertyFunctionPattern.FloatingVariables">
            <summary>
            Returns all variables mentioned in the property function as we can't guarantee they are bound
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.PropertyFunctionPattern.IsAcceptAll">
            <summary>
            Returns false because property functions are not accept-alls
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.PropertyFunctionPattern.HasNoBlankVariables">
            <summary>
            Returns true if none of the 
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Patterns.PatternItem">
            <summary>
            Class for representing Node Patterns in Sparql Queries
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Patterns.PatternItem._context">
            <summary>
            Binding Context for Pattern Item
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.PatternItem.Accepts(VDS.RDF.Query.SparqlEvaluationContext,VDS.RDF.INode)">
            <summary>
            Checks whether the Pattern Item accepts the given Node in the given Context
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="obj">Node to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.PatternItem.Construct(VDS.RDF.Query.Construct.ConstructContext)">
            <summary>
            Constructs a Node based on this Pattern for the given Set
            </summary>
            <param name="context">Construct Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.PatternItem.ToString">
            <summary>
            Gets the String representation of the Pattern
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.PatternItem.BindingContext">
            <summary>
            Sets the Binding Context for the Pattern Item
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.PatternItem.RigorousEvaluation">
            <summary>
            Gets/Sets whether rigorous evaluation is used, note that this setting may be overridden by the global <see cref="P:VDS.RDF.Options.RigorousEvaluation"/> option
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.PatternItem.VariableName">
            <summary>
            Gets the Variable Name if this is a Variable Pattern or null otherwise
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.PatternItem.Repeated">
            <summary>
            Gets/Sets whether the Variable is repeated in the Pattern
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Patterns.TriplePattern">
            <summary>
            Class for representing Triple Patterns in SPARQL Queries
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Patterns.IMatchTriplePattern">
            <summary>
            Inteface for Triple Patterns that do simple pattern matching
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.IMatchTriplePattern.GetTriples(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Gets the Triples that match this pattern
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.IMatchTriplePattern.Accepts(VDS.RDF.Query.SparqlEvaluationContext,VDS.RDF.Triple)">
            <summary>
            Gets whether a given triple is accepted by this pattern
            </summary>
            <param name="context">Context</param>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.IMatchTriplePattern.CreateResult(VDS.RDF.Triple)">
            <summary>
            Creates a set from a Triple
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.IMatchTriplePattern.IndexType">
            <summary>
            Gets the Index type that should be used in Pattern execution
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.IMatchTriplePattern.Subject">
            <summary>
            Gets the Subject of the Pattern
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.IMatchTriplePattern.Predicate">
            <summary>
            Gets the Predicate of the Pattern
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.IMatchTriplePattern.Object">
            <summary>
            Gets the Object of the Pattern
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Patterns.IConstructTriplePattern">
            <summary>
            Interface for Triple Patterns that can be used in a CONSTRUCT pattern
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.IConstructTriplePattern.Construct(VDS.RDF.Query.Construct.ConstructContext)">
            <summary>
            Constructs a Triple from a Set based on this Triple Pattern
            </summary>
            <param name="context">Construct Context</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.IConstructTriplePattern.Subject">
            <summary>
            Gets the Subject of the Pattern
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.IConstructTriplePattern.Predicate">
            <summary>
            Gets the Predicate of the Pattern
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.IConstructTriplePattern.Object">
            <summary>
            Gets the Object of the Pattern
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.IConstructTriplePattern.HasNoVariables">
            <summary>
            Gets whether the Pattern contains no Variables of any kind
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.IConstructTriplePattern.HasNoExplicitVariables">
            <summary>
            Gets whether the Pattern contains no Explicit Variables (i.e. Blank Node Variables are ignored)
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.TriplePattern.#ctor(VDS.RDF.Query.Patterns.PatternItem,VDS.RDF.Query.Patterns.PatternItem,VDS.RDF.Query.Patterns.PatternItem)">
            <summary>
            Creates a new Triple Pattern
            </summary>
            <param name="subj">Subject Pattern</param>
            <param name="pred">Predicate Pattern</param>
            <param name="obj">Object Pattern</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.TriplePattern.Accepts(VDS.RDF.Query.SparqlEvaluationContext,VDS.RDF.Triple)">
            <summary>
            Gets whether a given Triple is accepted by this Pattern in the given Context
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="obj">Triple to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.TriplePattern.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates a Triple Pattern in the given Evaluation Context
            </summary>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.TriplePattern.GetTriples(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Gets the Enumeration of Triples that should be assessed for matching the pattern
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.TriplePattern.FindResults(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Takes an enumerable and extracts Triples which match this pattern as results
            </summary>
            <param name="context">SPARQL Evaluation Context</param>
            <param name="ts">Enumerable of Triples</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.TriplePattern.CreateResult(VDS.RDF.Triple)">
            <summary>
            Generates a Result Set for a Triple that matches the Pattern
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.TriplePattern.Construct(VDS.RDF.Query.Construct.ConstructContext)">
            <summary>
            Constructs a Triple from a Set based on this Triple Pattern
            </summary>
            <param name="context">Construct Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.TriplePattern.CompareTo(VDS.RDF.Query.Patterns.TriplePattern)">
            <summary>
            Compares a triple pattern to another
            </summary>
            <param name="other">Pattern</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.TriplePattern.CompareTo(VDS.RDF.Query.Patterns.IMatchTriplePattern)">
            <summary>
            Compares a triple pattern to another
            </summary>
            <param name="other">Pattern</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.TriplePattern.ToString">
            <summary>
            Gets the String representation of this Pattern
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.TriplePattern.PatternType">
            <summary>
            Gets the pattern type
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.TriplePattern.IndexType">
            <summary>
            Gets the Index Type we will use for this Pattern
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.TriplePattern.Subject">
            <summary>
            Subject Pattern
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.TriplePattern.Predicate">
            <summary>
            Predicate Pattern
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.TriplePattern.Object">
            <summary>
            Object Pattern
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.TriplePattern.FixedVariables">
            <summary>
            Returns all variables mentioned as a match guarantees all variables are bound
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.TriplePattern.FloatingVariables">
            <summary>
            Returns an empty enumeration as a match guarantees all variables are bound
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.TriplePattern.IsAcceptAll">
            <summary>
            Returns whether the Triple Pattern is an accept all
            </summary>
            <remarks>
            True if all three Pattern Items are <see cref="T:VDS.RDF.Query.Patterns.VariablePattern">VariablePattern</see> and all the Variables names are distinct
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.TriplePattern.HasNoVariables">
            <summary>
            Gets whether the Pattern contains no Variables of any kind
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.TriplePattern.HasNoExplicitVariables">
            <summary>
            Gets whether the Pattern contains no Explicit Variables (i.e. Blank Node Variables are ignored)
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.TriplePattern.HasNoBlankVariables">
            <summary>
            Gets whether the Pattern contains no Explicit Variables (i.e. Blank Node Variables are ignored)
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Patterns.TriplePatternType">
            <summary>
            Possible Types of Triple Pattern
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Patterns.TriplePatternType.Match">
            <summary>
            Simple pattern matching
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Patterns.TriplePatternType.Filter">
            <summary>
            FILTER application
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Patterns.TriplePatternType.BindAssignment">
            <summary>
            BIND assignment
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Patterns.TriplePatternType.LetAssignment">
            <summary>
            LET assignment
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Patterns.TriplePatternType.SubQuery">
            <summary>
            Sub-query
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Patterns.TriplePatternType.Path">
            <summary>
            Property Path
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Patterns.TriplePatternType.PropertyFunction">
            <summary>
            Property Function
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Patterns.TriplePatternTypeComparer">
            <summary>
            Comparer for Triple Pattern Types
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.TriplePatternTypeComparer.Compare(VDS.RDF.Query.Patterns.TriplePatternType,VDS.RDF.Query.Patterns.TriplePatternType)">
            <summary>
            Compares two triple pattern types
            </summary>
            <param name="x">Pattern Type</param>
            <param name="y">Pattern Type</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.PropertyFunctions.IPropertyFunctionFactory">
            <summary>
            Interface for Property Function factories
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.PropertyFunctions.IPropertyFunctionFactory.IsPropertyFunction(System.Uri)">
            <summary>
            Gets whether the factory considers the given URI as representing a property function
            </summary>
            <param name="u">URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.PropertyFunctions.IPropertyFunctionFactory.TryCreatePropertyFunction(VDS.RDF.Query.PropertyFunctions.PropertyFunctionInfo,VDS.RDF.Query.Patterns.IPropertyFunctionPattern@)">
            <summary>
            Tries to create a property function pattern with the given information
            </summary>
            <param name="info">Function information</param>
            <param name="function">Property Function pattern</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.PropertyFunctions.PropertyFunctionHelper">
            <summary>
            Helper Class containing functions useful in working with property functions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.PropertyFunctions.PropertyFunctionHelper.ExtractPatterns(System.Collections.Generic.IEnumerable{VDS.RDF.Query.Patterns.ITriplePattern})">
            <summary>
            Used to extract the patterns that make up property functions
            </summary>
            <param name="patterns">Triple Patterns</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.PropertyFunctions.PropertyFunctionHelper.ExtractPatterns(System.Collections.Generic.IEnumerable{VDS.RDF.Query.Patterns.ITriplePattern},System.Collections.Generic.IEnumerable{VDS.RDF.Query.PropertyFunctions.IPropertyFunctionFactory})">
            <summary>
            Used to extract the patterns that make up property functions
            </summary>
            <param name="patterns">Triple Patterns</param>
            <param name="localFactories">Locally scoped factories</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.PropertyFunctions.PropertyFunctionHelper.ExtractRelatedPatterns(VDS.RDF.Query.Patterns.PatternItem,VDS.RDF.Query.Patterns.PatternItem,System.Collections.Generic.List{VDS.RDF.Query.Patterns.IMatchTriplePattern},System.Collections.Generic.Dictionary{VDS.RDF.Query.Patterns.PatternItem,VDS.RDF.Query.PropertyFunctions.PropertyFunctionInfo},System.Collections.Generic.List{VDS.RDF.Query.Patterns.PatternItem})">
            <summary>
            Used to help extract the patterns that make up a property function pattern
            </summary>
            <param name="key">Key</param>
            <param name="subj">Subject</param>
            <param name="ps">Patterns</param>
            <param name="funcInfo">Function Information</param>
            <param name="argList">Argument List to add discovered arguments to</param>
        </member>
        <member name="T:VDS.RDF.Query.PropertyFunctions.ISparqlPropertyFunction">
            <summary>
            Interface for SPARQL property functions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.PropertyFunctions.ISparqlPropertyFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates the function in the given context
            </summary>
            <param name="context">Context</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.PropertyFunctions.ISparqlPropertyFunction.FunctionUri">
            <summary>
            Gets the Function URI
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.PropertyFunctions.ISparqlPropertyFunction.Variables">
            <summary>
            Gets the variables used in the function
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.PropertyFunctions.PropertyFunctionFactory">
            <summary>
            Factory for creating property functions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.PropertyFunctions.PropertyFunctionFactory.AddFactory(VDS.RDF.Query.PropertyFunctions.IPropertyFunctionFactory)">
            <summary>
            Adds a globally registered factory
            </summary>
            <param name="factory">Factory</param>
        </member>
        <member name="M:VDS.RDF.Query.PropertyFunctions.PropertyFunctionFactory.RemoveFactory(VDS.RDF.Query.PropertyFunctions.IPropertyFunctionFactory)">
            <summary>
            Removes a globally registered factory
            </summary>
            <param name="factory">Factory</param>
        </member>
        <member name="M:VDS.RDF.Query.PropertyFunctions.PropertyFunctionFactory.IsRegisteredFactory(System.Type)">
            <summary>
            Gets whether a factory is registered
            </summary>
            <param name="factoryType">Factory Type</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.PropertyFunctions.PropertyFunctionFactory.IsRegisteredFactory(VDS.RDF.Query.PropertyFunctions.IPropertyFunctionFactory)">
            <summary>
            Gets whether a factory is registered
            </summary>
            <param name="factory">Factory</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.PropertyFunctions.PropertyFunctionFactory.IsPropertyFunction(System.Uri)">
            <summary>
            Gets whether a URI is considered a property function by the global factories
            </summary>
            <param name="u">Function URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.PropertyFunctions.PropertyFunctionFactory.IsPropertyFunction(System.Uri,System.Collections.Generic.IEnumerable{VDS.RDF.Query.PropertyFunctions.IPropertyFunctionFactory})">
            <summary>
            Gets whether a URI is considered a property function by any global/local factory
            </summary>
            <param name="u">Function URI</param>
            <param name="localFactories">Locally scoped factories</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.PropertyFunctions.PropertyFunctionFactory.TryCreatePropertyFunction(VDS.RDF.Query.PropertyFunctions.PropertyFunctionInfo,VDS.RDF.Query.Patterns.IPropertyFunctionPattern@)">
            <summary>
            Tries to create a property function
            </summary>
            <param name="info">Property Function information</param>
            <param name="function">Property Function</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.PropertyFunctions.PropertyFunctionFactory.TryCreatePropertyFunction(VDS.RDF.Query.PropertyFunctions.PropertyFunctionInfo,System.Collections.Generic.IEnumerable{VDS.RDF.Query.PropertyFunctions.IPropertyFunctionFactory},VDS.RDF.Query.Patterns.IPropertyFunctionPattern@)">
            <summary>
            Tries to create a property function
            </summary>
            <param name="info">Property Function information</param>
            <param name="localFactories">Locally Scoped factories</param>
            <param name="function">Property Function</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.PropertyFunctions.PropertyFunctionFactory.FactoryCount">
            <summary>
            Gets the number of globally registered factories
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.PropertyFunctions.PropertyFunctionInfo">
            <summary>
            Represents information about a property function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.PropertyFunctions.PropertyFunctionInfo.#ctor(System.Uri)">
            <summary>
            Creates new function information
            </summary>
            <param name="u">Function URI</param>
        </member>
        <member name="P:VDS.RDF.Query.PropertyFunctions.PropertyFunctionInfo.FunctionUri">
            <summary>
            Gets the function URI
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.PropertyFunctions.PropertyFunctionInfo.Patterns">
            <summary>
            Gets the triple patterns that compose the property function
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.PropertyFunctions.PropertyFunctionInfo.SubjectArgs">
            <summary>
            Gets the subject arguments to the function
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.PropertyFunctions.PropertyFunctionInfo.ObjectArgs">
            <summary>
            Gets the object arguments to the function
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.SparqlExpressionParser">
            <summary>
            Internal Class which parses SPARQL Expressions into Expression Trees
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SparqlExpressionParser.#ctor">
            <summary>
            Creates a new SPARQL Expression Parser
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SparqlExpressionParser.#ctor(VDS.RDF.Parsing.SparqlQueryParser)">
            <summary>
            Creates a new SPARQL Expression Parser which has a reference back to a Query Parser
            </summary>
            <param name="parser">Query Parser</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlExpressionParser.#ctor(System.Boolean)">
            <summary>
            Creates a new SPARQL Expression Parser
            </summary>
            <param name="allowAggregates">Whether Aggregates are allowed in Expressions</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlExpressionParser.#ctor(VDS.RDF.Parsing.SparqlQueryParser,System.Boolean)">
            <summary>
            Creates a new SPARQL Expression Parser which has a reference back to a Query Parser
            </summary>
            <param name="parser">Query Parser</param>
            <param name="allowAggregates">Whether Aggregates are allowed in Expressions</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlExpressionParser.Parse(System.Collections.Generic.Queue{VDS.RDF.Parsing.Tokens.IToken})">
            <summary>
            Parses a SPARQL Expression
            </summary>
            <param name="tokens">Tokens that the Expression should be parsed from</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlExpressionParser.Error(System.String,VDS.RDF.Parsing.Tokens.IToken)">
            <summary>
            Helper method for raising informative standardised Parser Errors
            </summary>
            <param name="msg">The Error Message</param>
            <param name="t">The Token that is the cause of the Error</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.SparqlExpressionParser.BaseUri">
            <summary>
            Sets the Base Uri used to resolve URIs and QNames
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlExpressionParser.NamespaceMap">
            <summary>
            Sets the Namespace Map used to resolve QNames
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlExpressionParser.AllowAggregates">
            <summary>
            Gets/Sets whether Aggregates are permitted in Expressions
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlExpressionParser.SyntaxMode">
            <summary>
            Gets/Sets the Syntax that should be supported
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlExpressionParser.QueryParser">
            <summary>
            Sets the Query Parser that the Expression Parser can call back into when needed
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlExpressionParser.ExpressionFactories">
            <summary>
            Gets/Sets the locally scoped custom expression factories
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.SparqlResult">
            <summary>
            Class for representing a Row of a Sparql Result Set
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResult.#ctor">
            <summary>
            Creates a new empty SPARQL Result which can only be filled by methods internal to the dotNetRDF Library
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResult.#ctor(VDS.RDF.Query.Algebra.ISet)">
            <summary>
            Creates a new SPARQL Result from the given Set
            </summary>
            <param name="s">Set</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResult.#ctor(VDS.RDF.Query.Algebra.ISet,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a new SPARQL Result from the given Set which contains only the given variables in the given order
            </summary>
            <param name="s">Set</param>
            <param name="variables">Variables</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResult.Value(System.String)">
            <summary>
            Gets the Value that is bound to the given Variable
            </summary>
            <param name="variable">Variable whose Value you wish to retrieve</param>
            <returns></returns>
            <exception cref="T:VDS.RDF.RdfException">Thrown if there is nothing bound to the given Variable Name for this Result</exception>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResult.TryGetValue(System.String,VDS.RDF.INode@)">
            <summary>
            Tries to get a value (which may be null) for the variable
            </summary>
            <param name="variable">Variable</param>
            <param name="value">Value</param>
            <returns>True if the variable was present (even it was unbound) and false otherwise</returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResult.TryGetBoundValue(System.String,VDS.RDF.INode@)">
            <summary>
            Tries to get a non-null value for the variable
            </summary>
            <param name="variable">Variable</param>
            <param name="value">Value</param>
            <returns>True if the variable was present and bound, false otherwise</returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResult.SetValue(System.String,VDS.RDF.INode)">
            <summary>
            Internal Only Method for setting the Value of a Result
            </summary>
            <param name="variable">Variable Name</param>
            <param name="value">Value bound to the Variable</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResult.SetVariableOrdering(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Sets the variable ordering for the result
            </summary>
            <param name="variables"></param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResult.HasValue(System.String)">
            <summary>
            Checks whether a given Variable has a value (which may be null) for this result
            </summary>
            <param name="variable">Variable Name</param>
            <returns>True if the variable is present, false otherwise</returns>
            <remarks>Returns true even if the value is null, use <see cref="M:VDS.RDF.Query.SparqlResult.HasBoundValue(System.String)"/> instead to see whether a non-null value is present for a variable.</remarks>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResult.HasBoundValue(System.String)">
            <summary>
            Checks whether a given Variable has a non-null value for this result
            </summary>
            <param name="variable">Variable Name</param>
            <returns>True if the variable is present and has a non-null value, false otherwise</returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResult.Trim">
            <summary>
            Removes all Variables Bindings where the Variable is Unbound
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResult.ToString">
            <summary>
            Displays the Result as a comma separated string of pairs of the form ?var = value
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResult.ToString(VDS.RDF.Writing.Formatting.INodeFormatter)">
            <summary>
            Displays the Result as a comma separated string of paris of the form ?var = value where values are formatted using the given Node Formatter
            </summary>
            <param name="formatter">Node Formatter</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResult.Equals(System.Object)">
            <summary>
            Override of the Equals method for Results
            </summary>
            <param name="obj"></param>
            <returns></returns>
            <remarks>Used implicitly in applying Distinct and Reduced modifiers to the Result Set</remarks>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResult.GetHashCode">
            <summary>
            Override of the GetHashCode method for Results
            </summary>
            <returns></returns>
            <remarks>Used implicitly in applying Distinct and Reduced modifiers to the Result Set</remarks>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResult.GetEnumerator">
            <summary>
            Enumerates the Bindings of Variable Names to Values in this Result
            </summary>
            <returns></returns>
            <remarks>
            Does not respect the ordering of the variables (if any)
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResult.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Enumerates the Bindings of Variable Names to Values in this Result
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.SparqlResult.Item(System.String)">
            <summary>
            Gets the Value that is bound to the given Variable
            </summary>
            <param name="variable">Variable whose Value you wish to retrieve</param>
            <returns></returns>
            <exception cref="T:VDS.RDF.RdfException">Thrown if there is nothing bound to the given Variable Name for this Result</exception>
        </member>
        <member name="P:VDS.RDF.Query.SparqlResult.Item(System.Int32)">
            <summary>
            Gets the Value that is bound at the given Index
            </summary>
            <param name="index">Index whose Value you wish to retrieve</param>
            <returns></returns>
            <remarks>
            As of 1.0.0 the order of variables in a result may/may not vary depending on the original query.  If a specific variable list was declared dotNetRDF tries to preserve that order but this may not always happen depending on how results are received.
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException">Thrown if there is nothing bound at the given Index</exception>
        </member>
        <member name="P:VDS.RDF.Query.SparqlResult.Count">
            <summary>
            Gets the number of Variables for which this Result contains Bindings
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlResult.Variables">
            <summary>
            Gets the set of Variables that are bound in this Result
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlResult.IsGroundResult">
            <summary>
            Gets whether a Result is a Ground Result
            </summary>
            <remarks>
            A <strong>Ground Result</strong> is a result which is considered to be a fixed fact.  In practise this means it contains no Blank Nodes
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.SparqlResultBinder">
            <summary>
            Helper Class used in the execution of Sparql Queries
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResultBinder.#ctor">
            <summary>
            Internal Empty Constructor for derived classes
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResultBinder.#ctor(VDS.RDF.Query.SparqlQuery)">
            <summary>
            Creates a new Results Binder
            </summary>
            <param name="query">Query this provides Result Binding to</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResultBinder.Value(System.String,System.Int32)">
            <summary>
            Gets the Value bound to a given Variable for a given Binding ID
            </summary>
            <param name="name">Variable Name</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResultBinder.Group(System.Int32)">
            <summary>
            Gets the Group referred to by the given ID
            </summary>
            <param name="groupID">Group ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResultBinder.IsGroup(System.Int32)">
            <summary>
            Checks whether the given ID refers to a Group
            </summary>
            <param name="groupID">Group ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResultBinder.SetGroupContext(System.Boolean)">
            <summary>
            Sets the Group Context for the Binder
            </summary>
            <param name="accessContents">Whether you want to access the Group Contents or the Groups themselves</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResultBinder.Dispose">
            <summary>
            Disposes of a Result Binder
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlResultBinder.Variables">
            <summary>
            Gets the Variables that the Binder stores Bindings for
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlResultBinder.BindingIDs">
            <summary>
            Gets the enumeration of valid Binding IDs
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlResultBinder.Groups">
            <summary>
            Gets the set of Groups that result from the Query this Binder provides Binding to
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.LeviathanResultBinder">
            <summary>
            Results Binder used by Leviathan
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanResultBinder.#ctor(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Creates a new Leviathan Results Binder
            </summary>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanResultBinder.Value(System.String,System.Int32)">
            <summary>
            Gets the Value for a given Variable from the Set with the given Binding ID
            </summary>
            <param name="name">Variable</param>
            <param name="bindingID">Set ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanResultBinder.IsGroup(System.Int32)">
            <summary>
            Determines whether a given ID is for of a Group
            </summary>
            <param name="groupID">Group ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanResultBinder.Group(System.Int32)">
            <summary>
            Returns the Group with the given ID
            </summary>
            <param name="groupID">Group ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanResultBinder.SetGroupContext(System.Boolean)">
            <summary>
            Sets the Group Context for the Binder
            </summary>
            <param name="accessContents">Whether you want to access the Group Contents or the Groups themselves</param>
        </member>
        <member name="P:VDS.RDF.Query.LeviathanResultBinder.Variables">
            <summary>
            Gets the Variables contained in the Input
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.LeviathanResultBinder.BindingIDs">
            <summary>
            Gets the IDs of Sets
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.LeviathanLeftJoinBinder">
            <summary>
            Special Temporary Results Binder used during LeftJoin's
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanLeftJoinBinder.#ctor(VDS.RDF.Query.Algebra.BaseMultiset)">
            <summary>
            Creates a new LeftJoin Binder
            </summary>
            <param name="multiset">Input Multiset</param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanLeftJoinBinder.Value(System.String,System.Int32)">
            <summary>
            Gets the Value for a given Variable from the Set with the given Binding ID
            </summary>
            <param name="name">Variable</param>
            <param name="bindingID">Set ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.LeviathanLeftJoinBinder.Variables">
            <summary>
            Gets the Variables in the Input Multiset
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.LeviathanLeftJoinBinder.BindingIDs">
            <summary>
            Gets the IDs of Sets
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.SparqlVariable">
            <summary>
            Class of Sparql Variables
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SparqlVariable.#ctor(System.String,System.Boolean)">
            <summary>
            Creates a new Sparql Variable
            </summary>
            <param name="name">Variable Name</param>
            <param name="isResultVar">Does this Variable appear in the Result Set?</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlVariable.#ctor(System.String)">
            <summary>
            Creates a new Sparql Variable
            </summary>
            <param name="name">Variable Name (with leading ?/$ removed)</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlVariable.#ctor(System.String,VDS.RDF.Query.Aggregates.ISparqlAggregate)">
            <summary>
            Creates a new Sparql Variable which is an Aggregate
            </summary>
            <param name="name">Variable Name (with leading ?/$ removed)</param>
            <param name="aggregate">Aggregate Function</param>
            <remarks>All Aggregate Variables are automatically considered as Result Variables</remarks>
        </member>
        <member name="M:VDS.RDF.Query.SparqlVariable.#ctor(System.String,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Sparql Variable which is a Projection Expression
            </summary>
            <param name="name">Variable Name (with leading ?/$ removed)</param>
            <param name="expr">Projection Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlVariable.ToString">
            <summary>
            Get the String representation of the Variable
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.SparqlVariable.Name">
            <summary>
            Variable Name
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlVariable.IsResultVariable">
            <summary>
            Gets whether the Variable appears in the Result Set
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlVariable.IsAggregate">
            <summary>
            Gets whether the Variable is an Aggregate 
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlVariable.IsProjection">
            <summary>
            Gets whether the Variable is a Projection Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlVariable.Aggregate">
            <summary>
            Gets the Aggregate Function for this Variable
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlVariable.Projection">
            <summary>
            Gets the Projection Expression for this Variable
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.BaseEvent">
            <summary>
            Abstract Base Class for <see cref="T:VDS.RDF.Parsing.Events.IEvent">IEvent</see> implementations
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.IEvent">
            <summary>
            Interface for parser events
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.IEvent.EventType">
            <summary>
            Gives some Integer representing the Event Type as understood by a specific Parser implementation
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.IEvent.Position">
            <summary>
            Gets the Position Information (if any)
            </summary>
            <remarks>
            Availability of Position Information depends on the how the source document was parsed
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.BaseEvent.#ctor(System.Int32,VDS.RDF.Parsing.PositionInfo)">
            <summary>
            Creates a new Event
            </summary>
            <param name="eventType">Event Type</param>
            <param name="info">Position Information</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.BaseEvent.#ctor(System.Int32)">
            <summary>
            Creates a new Event
            </summary>
            <param name="eventType">Event Type</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.BaseEvent.EventType">
            <summary>
            Gets the Type for this Event
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.BaseEvent.Position">
            <summary>
            Gets the Position Information (if any)
            </summary>
            <remarks>
            Availability of Position Information depends on the how the source document was parsed
            </remarks>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.BaseRdfXmlEvent">
            <summary>
            Abstract Base Class for <see cref="T:VDS.RDF.Parsing.Events.IRdfXmlEvent">IRdfXmlEvent</see> implementations
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.IRdfXmlEvent">
            <summary>
            Interface for RDF/XML events as defined by the RDF/XML Specification
            </summary>
            <remarks>Used to provide polymorphism for the XML/RDF Parser</remarks>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.IRdfXmlEvent.SourceXml">
            <summary>
            Gets the XML that produced the given event (if any)
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.BaseRdfXmlEvent.#ctor(System.Int32,System.String,VDS.RDF.Parsing.PositionInfo)">
            <summary>
            Creates an Event and fills in its Values
            </summary>
            <param name="eventType">Type of the Event</param>
            <param name="sourceXml">Source XML that generated the Event</param>
            <param name="pos">Position of the XML Event</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.BaseRdfXmlEvent.#ctor(System.Int32,System.String)">
            <summary>
            Creates an Event and fills in its Values
            </summary>
            <param name="eventType">Type of the Event</param>
            <param name="sourceXml">Source XML that generated the Event</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.BaseRdfXmlEvent.SourceXml">
            <summary>
            Gets the XML that this Event was generated from
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.BaseRdfAEvent">
            <summary>
            Abstract Base Class for <see cref="T:VDS.RDF.Parsing.Events.IRdfAEvent">IRdfAEvent</see> implementations
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.IRdfAEvent">
            <summary>
            Interface for RDFa events
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.IRdfAEvent.HasAttribute(System.String)">
            <summary>
            Gets whether the Event has a given attribute
            </summary>
            <param name="name">Attribute Name</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.IRdfAEvent.Attributes">
            <summary>
            Gets the attributes of the event i.e. the attributes of the source element
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.IRdfAEvent.Item(System.String)">
            <summary>
            Gets the value of a specific attribute
            </summary>
            <param name="name">Attribute Name</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.BaseRdfAEvent.#ctor(System.Int32,VDS.RDF.Parsing.PositionInfo,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <summary>
            Creates a new RDFa Event
            </summary>
            <param name="eventType">Event Type</param>
            <param name="pos">Position Info</param>
            <param name="attributes">Attributes</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.BaseRdfAEvent.HasAttribute(System.String)">
            <summary>
            Gets whether the Event has a given attribute
            </summary>
            <param name="name">Attribute Name</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.BaseRdfAEvent.Attributes">
            <summary>
            Gets the attributes of the event i.e. the attributes of the source element
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.BaseRdfAEvent.Item(System.String)">
            <summary>
            Gets the value of a specific attribute
            </summary>
            <param name="name">Attribute Name</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.BaseToken">
            <summary>
            Base Implementation of IToken used by all derived tokens for ease of implementation
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.IToken">
            <summary>
            Interface for defining Token classes to be used in Parsing RDF
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.IToken.TokenType">
            <summary>
            Gives some Integer representing the Token Type as understood by a specific Parser implementation
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.IToken.Value">
            <summary>
            Gives the Value of the Token
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.IToken.StartLine">
            <summary>
            Gives the Line at which the Token starts
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.IToken.EndLine">
            <summary>
            Gives the Line at which the Token ends
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.IToken.StartPosition">
            <summary>
            Gives the Position within the Start Line that the Token starts
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.IToken.EndPosition">
            <summary>
            Gives the Position within the End Line that the Token ends
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.IToken.Length">
            <summary>
            Gives the Length of the Token
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.BaseToken._tokentype">
            <summary>
            Variables for representing the Type and Position of the Token
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.BaseToken._startline">
            <summary>
            Variables for representing the Type and Position of the Token
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.BaseToken._endline">
            <summary>
            Variables for representing the Type and Position of the Token
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.BaseToken._startpos">
            <summary>
            Variables for representing the Type and Position of the Token
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.BaseToken._endpos">
            <summary>
            Variables for representing the Type and Position of the Token
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.BaseToken._value">
            <summary>
            Variable containg the value of the Token
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseToken.#ctor(System.Int32,System.String,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a Token and fills in its Values
            </summary>
            <param name="tokenType">Integer denoting the Tokens Type</param>
            <param name="value">String value that the Token represents (if any)</param>
            <param name="startLine">Line at which the Token starts</param>
            <param name="endLine">Line at which the Token ends</param>
            <param name="startPos">Column at which the Token starts</param>
            <param name="endPos">Column at which the Token ends</param>
            <remarks>All the derived classes use this Constructor to fill in the basic values of a Token</remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseToken.ToString">
            <summary>
            Gets a String representation of the Token Type and Value
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseToken.GetHashCode">
            <summary>
            Gets a Hash Code for a Token
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.BaseToken.TokenType">
            <summary>
            Gets an arbitrary integer which indicates the Type of the Token
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.BaseToken.Value">
            <summary>
            Gets the String Value which this Token represents (if any)
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.BaseToken.StartLine">
            <summary>
            Gets the Line at which this Token Starts
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.BaseToken.EndLine">
            <summary>
            Gets the Line at which this Token Ends
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.BaseToken.StartPosition">
            <summary>
            Gets the Column at which this Token Starts
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.BaseToken.EndPosition">
            <summary>
            Gets the Column at which this Token Ends
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.BaseToken.Length">
            <summary>
            Gets the Length of the Tokens Value
            </summary>
        </member>
        <member name="T:VDS.RDF.BaseBlankNode">
            <summary>
            Abstract Base Class for Blank Nodes
            </summary>
        </member>
        <member name="T:VDS.RDF.IBlankNode">
            <summary>
            Interface for Blank Nodes
            </summary>
        </member>
        <member name="P:VDS.RDF.IBlankNode.InternalID">
            <summary>
            Gets the Internal ID of the Blank Node
            </summary>
        </member>
        <member name="M:VDS.RDF.BaseBlankNode.#ctor(VDS.RDF.IGraph)">
            <summary>
            Internal Only Constructor for Blank Nodes
            </summary>
            <param name="g">Graph this Node belongs to</param>
        </member>
        <member name="M:VDS.RDF.BaseBlankNode.#ctor(VDS.RDF.IGraph,System.String)">
            <summary>
            Internal Only constructor for Blank Nodes
            </summary>
            <param name="g">Graph this Node belongs to</param>
            <param name="nodeId">Custom Node ID to use</param>
        </member>
        <member name="M:VDS.RDF.BaseBlankNode.#ctor(VDS.RDF.INodeFactory)">
            <summary>
            Internal Only constructor for Blank Nodes
            </summary>
            <param name="factory">Node Factory from which to obtain a Node ID</param>
        </member>
        <member name="M:VDS.RDF.BaseBlankNode.#ctor">
            <summary>
            Unparameterized Constructor for deserialization usage only
            </summary>
        </member>
        <member name="M:VDS.RDF.BaseBlankNode.Equals(System.Object)">
            <summary>
            Implementation of Equals for Blank Nodes
            </summary>
            <param name="obj">Object to compare with the Blank Node</param>
            <returns></returns>
            <remarks>
            Blank Nodes are considered equal if their internal IDs match precisely and they originate from the same Graph
            </remarks>
        </member>
        <member name="M:VDS.RDF.BaseBlankNode.Equals(VDS.RDF.INode)">
            <summary>
            Implementation of Equals for Blank Nodes
            </summary>
            <param name="other">Object to compare with the Blank Node</param>
            <returns></returns>
            <remarks>
            Blank Nodes are considered equal if their internal IDs match precisely and they originate from the same Graph
            </remarks>
        </member>
        <member name="M:VDS.RDF.BaseBlankNode.Equals(VDS.RDF.IBlankNode)">
            <summary>
            Determines whether this Node is equal to another
            </summary>
            <param name="other">Other Blank Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseBlankNode.Equals(VDS.RDF.IGraphLiteralNode)">
            <summary>
            Determines whether this Node is equal to a Graph Literal Node (should always be false)
            </summary>
            <param name="other">Graph Literal Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseBlankNode.Equals(VDS.RDF.ILiteralNode)">
            <summary>
            Determines whether this Node is equal to a Literal Node (should always be false)
            </summary>
            <param name="other">Literal Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseBlankNode.Equals(VDS.RDF.IUriNode)">
            <summary>
            Determines whether this Node is equal to a URI Node (should always be false)
            </summary>
            <param name="other">URI Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseBlankNode.Equals(VDS.RDF.IVariableNode)">
            <summary>
            Determines whether this Node is equal to a Variable Node (should always be false)
            </summary>
            <param name="other">Variable Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseBlankNode.Equals(VDS.RDF.BaseBlankNode)">
            <summary>
            Determines whether this Node is equal to a Blank Node
            </summary>
            <param name="other">Blank Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseBlankNode.CompareTo(VDS.RDF.INode)">
            <summary>
            Returns an Integer indicating the Ordering of this Node compared to another Node
            </summary>
            <param name="other">Node to test against</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseBlankNode.CompareTo(VDS.RDF.IBlankNode)">
            <summary>
            Returns an Integer indicating the Ordering of this Node compared to another Node
            </summary>
            <param name="other">Node to test against</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseBlankNode.CompareTo(VDS.RDF.IGraphLiteralNode)">
            <summary>
            Returns an Integer indicating the Ordering of this Node compared to another Node
            </summary>
            <param name="other">Node to test against</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseBlankNode.CompareTo(VDS.RDF.ILiteralNode)">
            <summary>
            Returns an Integer indicating the Ordering of this Node compared to another Node
            </summary>
            <param name="other">Node to test against</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseBlankNode.CompareTo(VDS.RDF.IUriNode)">
            <summary>
            Returns an Integer indicating the Ordering of this Node compared to another Node
            </summary>
            <param name="other">Node to test against</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseBlankNode.CompareTo(VDS.RDF.IVariableNode)">
            <summary>
            Returns an Integer indicating the Ordering of this Node compared to another Node
            </summary>
            <param name="other">Node to test against</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseBlankNode.CompareTo(VDS.RDF.BaseBlankNode)">
            <summary>
            Returns an Integer indicating the Ordering of this Node compared to another Node
            </summary>
            <param name="other">Node to test against</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseBlankNode.ToString">
            <summary>
            Returns a string representation of this Blank Node in QName form
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseBlankNode.AsString">
            <summary>
            Throws an error as a Blank Node cannot be cast to a String
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseBlankNode.AsInteger">
            <summary>
            Throws an error as a Blank Node cannot be cast to an integer
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseBlankNode.AsDecimal">
            <summary>
            Throws an error as a Blank Node cannot be cast to a decimal
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseBlankNode.AsFloat">
            <summary>
            Throws an error as a Blank Node cannot be cast to a float
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseBlankNode.AsDouble">
            <summary>
            Throws an error as a Blank Node cannot be cast to a double
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseBlankNode.AsBoolean">
            <summary>
            Throws an error as a Blank Node cannot be cast to a boolean
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseBlankNode.AsDateTime">
            <summary>
            Throws an error as a Blank Node cannot be cast to a date time
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseBlankNode.AsDateTimeOffset">
            <summary>
            Throws an error as a Blank Node cannot be cast to a date time offset
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseBlankNode.AsTimeSpan">
            <summary>
            Throws an error as a Blank Node cannot be case to a time span
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.BaseBlankNode.InternalID">
            <summary>
            Returns the Internal Blank Node ID this Node has in the Graph
            </summary>
            <remarks>
            Usually automatically assigned and of the form autosXXX where XXX is some number.  If an RDF document contains a Blank Node ID of this form that clashes with an existing auto-assigned ID it will be automatically remapped by the Graph using the <see cref="T:VDS.RDF.BlankNodeMapper">BlankNodeMapper</see> when it is created.
            </remarks>
        </member>
        <member name="P:VDS.RDF.BaseBlankNode.HasAutoAssignedID">
            <summary>
            Indicates whether this Blank Node had its ID assigned for it by the Graph
            </summary>
        </member>
        <member name="P:VDS.RDF.BaseBlankNode.EffectiveType">
            <summary>
            Gets the URI of the datatype this valued node represents as a String
            </summary>
        </member>
        <member name="P:VDS.RDF.BaseBlankNode.NumericType">
            <summary>
            Gets the Numeric Type of the Node
            </summary>
        </member>
        <member name="T:VDS.RDF.BlankNode">
            <summary>
            Class for representing Blank RDF Nodes
            </summary>
        </member>
        <member name="M:VDS.RDF.BlankNode.#ctor(VDS.RDF.IGraph)">
            <summary>
            Internal Only Constructor for Blank Nodes
            </summary>
            <param name="g">Graph this Node belongs to</param>
        </member>
        <member name="M:VDS.RDF.BlankNode.#ctor(VDS.RDF.IGraph,System.String)">
            <summary>
            Internal Only constructor for Blank Nodes
            </summary>
            <param name="g">Graph this Node belongs to</param>
            <param name="id">Custom Node ID to use</param>
        </member>
        <member name="M:VDS.RDF.BlankNode.#ctor(VDS.RDF.INodeFactory)">
            <summary>
            Internal Only constructor for Blank Nodes
            </summary>
            <param name="factory">Node Factory from which to obtain a Node ID</param>
        </member>
        <member name="M:VDS.RDF.BlankNode.#ctor">
            <summary>
            Constructor for deserialization usage only
            </summary>
        </member>
        <member name="M:VDS.RDF.BlankNode.CompareTo(VDS.RDF.BlankNode)">
            <summary>
            Implementation of Compare To for Blank Nodes
            </summary>
            <param name="other">Blank Node to Compare To</param>
            <returns></returns>
            <remarks>
            Simply invokes the more general implementation of this method
            </remarks>
        </member>
        <member name="M:VDS.RDF.BlankNode.Equals(VDS.RDF.BlankNode)">
            <summary>
            Determines whether this Node is equal to a Blank Node
            </summary>
            <param name="other">Blank Node</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.TokenQueue">
            <summary>
            Basic Token Queue which provides no Buffering except in the sense that it queues all possible Tokens when the InitialiseBuffer method is called
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.BaseTokenQueue">
            <summary>
            Abstract base implementation of a Token Queue
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.ITokenQueue">
            <summary>
            Interface for implementing Token Queues which provide Bufferable wrappers to Tokenisers
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.ITokenQueue.Dequeue">
            <summary>
            Removes the first Token from the Queue
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.ITokenQueue.Enqueue(VDS.RDF.Parsing.Tokens.IToken)">
            <summary>
            Adds a Token to the end of the Queue
            </summary>
            <param name="t">Token to add</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.ITokenQueue.Peek">
            <summary>
            Gets the first Token from the Queue without removing it
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.ITokenQueue.Clear">
            <summary>
            Clears the Token Queue
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.ITokenQueue.InitialiseBuffer">
            <summary>
            Initialises the Buffer
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.ITokenQueue.InitialiseBuffer(System.Int32)">
            <summary>
            Initialises the Buffer and sets the Buffering Level
            </summary>
            <param name="amount">Buffering Amount</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.ITokenQueue.Tokeniser">
            <summary>
            Tokeniser that this is a Queue for
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.ITokenQueue.Count">
            <summary>
            Gets the number of Tokens in the Queue
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.ITokenQueue.Tokens">
            <summary>
            Gets the underlying Queue of Tokens
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.ITokenQueue.Tracing">
            <summary>
            Gets/Sets whether Tokeniser Tracing should be used
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.ITokenQueue.LastTokenType">
            <summary>
            Gets the Token Type of the last Token dequeued
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.BaseTokenQueue._tokeniser">
            <summary>
            Tokeniser used to fill the Token Queue
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.BaseTokenQueue._tracing">
            <summary>
            Variable indicating whether Tokeniser Tracing is enabled
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.BaseTokenQueue._lasttokentype">
            <summary>
            Type of Last Token dequeued
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseTokenQueue.Dequeue">
            <summary>
            Abstract Definition of Interface Method
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseTokenQueue.Enqueue(VDS.RDF.Parsing.Tokens.IToken)">
            <summary>
            Abstract Definition of Interface Method
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseTokenQueue.Peek">
            <summary>
            Abstract Definition of Interface Method
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseTokenQueue.Clear">
            <summary>
            Abstract Definition of Interface Method
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseTokenQueue.InitialiseBuffer">
            <summary>
            Abstract Definition of Interface Method
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseTokenQueue.InitialiseBuffer(System.Int32)">
            <summary>
            Abstract Definition of Interface Method
            </summary>
            <param name="amount">Buffering Amount</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.BaseTokenQueue.Tokeniser">
            <summary>
            Sets the Tokeniser used by the Queue
            </summary>
            <remarks>Setting the Tokeniser causes the Queue to clear itself</remarks>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.BaseTokenQueue.Count">
            <summary>
            Abstract Definition of Interface Property
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.BaseTokenQueue.Tokens">
            <summary>
            Abstract Definition of Interface Property
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.BaseTokenQueue.Tracing">
            <summary>
            Gets/Sets Tracing for the Token Queue
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.BaseTokenQueue.LastTokenType">
            <summary>
            Gets the Token Type of the last Token dequeued
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.TokenQueue._tokens">
            <summary>
            Internal Queue object which this class is a wrapper around
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TokenQueue.#ctor">
            <summary>
            Creates a new Token Queue
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TokenQueue.#ctor(VDS.RDF.Parsing.Tokens.ITokeniser)">
            <summary>
            Creates a new Token Queue with the given Tokeniser
            </summary>
            <param name="tokeniser">Tokeniser</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TokenQueue.Dequeue">
            <summary>
            Removes and returns the first Token from the Queue
            </summary>
            <returns>First Token in the Queue</returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TokenQueue.Enqueue(VDS.RDF.Parsing.Tokens.IToken)">
            <summary>
            Adds a Token to the end of the Queue
            </summary>
            <param name="t">Token to add</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TokenQueue.Peek">
            <summary>
            Gets the first Token from the Queue without removing it
            </summary>
            <returns>First Token in the Queue</returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TokenQueue.Clear">
            <summary>
            Empties the Token Queue
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TokenQueue.InitialiseBuffer">
            <summary>
            Initialises the Token Queue Buffer
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TokenQueue.InitialiseBuffer(System.Int32)">
            <summary>
            Initialises the Token Queue Buffer to the set Buffer Amount
            </summary>
            <param name="amount">Amount of Tokens to Buffer</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TokenQueue.PrintTrace(VDS.RDF.Parsing.Tokens.IToken)">
            <summary>
            Internal Helper Method for Tokeniser Tracing
            </summary>
            <param name="t"></param>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.TokenQueue.Count">
            <summary>
            Gets the number of Tokens in the Queue
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.TokenQueue.Tokens">
            <summary>
            Gets the underlying Queue of Tokens
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.NonTokenisedTokenQueue">
            <summary>
            Token Queue which is not backed by a Tokeniser
            </summary>
            <remarks>
            Designed to be explicitly populated with Tokens for when a Parser needs to be invoked on a subset of the overall Tokens
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.NonTokenisedTokenQueue.#ctor">
            <summary>
            Creates a new non-Tokenised Queue
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.NonTokenisedTokenQueue.Dequeue">
            <summary>
            Removed and returns the first Token from the Queue
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.NonTokenisedTokenQueue.Peek">
            <summary>
            Gets the first Token from the Queue without removing it
            </summary>
            <returns>First Token in the Queue</returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.NonTokenisedTokenQueue.InitialiseBuffer">
            <summary>
            Initialises the Buffer by doing nothing since there is no buffering on this Queue
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.BufferedTokenQueue">
            <summary>
            A Buffered Queue for a Tokeniser which synchronously buffers a number of Tokens when the Queue is accessed and nothing is Buffered
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.BufferedTokenQueue._bufferAmount">
            <summary>
            Variable storing the Buffer Size
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BufferedTokenQueue.#ctor(VDS.RDF.Parsing.Tokens.ITokeniser)">
            <summary>
            Creates a new Buffered Queue for the given Tokeniser
            </summary>
            <param name="tokeniser">Tokeniser to Buffer</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BufferedTokenQueue.#ctor">
            <summary>
            Creates a new Buffered Queue
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BufferedTokenQueue.Dequeue">
            <summary>
            Gets the next Token in the Queue and removes it from the Queue
            </summary>
            <returns>Token at the front of the Queue</returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BufferedTokenQueue.Peek">
            <summary>
            Gets the next Token in the Queue without removing it from the Queue
            </summary>
            <returns>Token at the front of the Queue</returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BufferedTokenQueue.InitialiseBuffer">
            <summary>
            Causes the Buffer to be filled using the Default Buffering level of 10
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BufferedTokenQueue.InitialiseBuffer(System.Int32)">
            <summary>
            Causes the Buffer to be filled and sets the Buffering level for the Queue
            </summary>
            <param name="amount">Number of Tokens to Buffer</param>
            <remarks>If a Buffer amount of less than zero is given then Buffer size will stay at default size (10) or existing size if it's previously been set</remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BufferedTokenQueue.BufferInternal">
            <summary>
            Internal Helper Method which performs the Buffering
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.AsynchronousBufferedTokenQueue">
            <summary>
            For the Portable Class Library, this class is entirely delegated through to
            <see cref="T:VDS.RDF.Parsing.Tokens.BufferedTokenQueue"/>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.SparqlQueryType">
            <summary>
            Types of SPARQL Query
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlQueryType.Unknown">
            <summary>
            Unknown
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlQueryType.Ask">
            <summary>
            Ask
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlQueryType.Construct">
            <summary>
            Constuct
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlQueryType.Describe">
            <summary>
            Describe
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlQueryType.DescribeAll">
            <summary>
            Describe All
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlQueryType.Select">
            <summary>
            Select
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlQueryType.SelectDistinct">
            <summary>
            Select Distinct
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlQueryType.SelectReduced">
            <summary>
            Select Reduced
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlQueryType.SelectAll">
            <summary>
            Select All
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlQueryType.SelectAllDistinct">
            <summary>
            Select All Distinct
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlQueryType.SelectAllReduced">
            <summary>
            Select All Reduced
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.SparqlSpecialQueryType">
            <summary>
            Types of Special SPARQL Query which may be optimised in special ways by the libraries SPARQL Engines
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecialQueryType.DistinctGraphs">
            <summary>
            The Query is of the form SELECT DISTINCT ?g WHERE {GRAPH ?g {?s ?p ?o}}
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecialQueryType.NotApplicable">
            <summary>
            The Query has no applicable special optimisation
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecialQueryType.Unknown">
            <summary>
            The Query has not yet been tested to determine if special optimisations are applicable
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecialQueryType.AskAnyTriples">
            <summary>
            The Query is of the form ASK WHERE {?s ?p ?o}
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.SparqlQuery">
            <summary>
            Represents a SPARQL Query
            </summary>
            <remarks>
            <para>
            <strong>Note:</strong> This class is purposefully sealed and most setters are private/protected internal since generally you create a query by using the <see cref="T:VDS.RDF.Parsing.SparqlQueryParser"/> to parse a query string/file.
            </para>
            <para>
            To build a query programmatically you can use the <see cref="T:VDS.RDF.Query.Builder.QueryBuilder"/> class to generate a new query and then various extension methods to modify that query using a fluent style API.  A query is not immutable
            so if you use that API you are modifying the query, if you want to generate new queries by modifying an existing query consider using the <see cref="M:VDS.RDF.Query.SparqlQuery.Copy"/> method to take a copy of the existing query.
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.NodeFactory">
            <summary>
            A default implementation of a Node Factory which generates Nodes unrelated to Graphs (wherever possible we suggest using a Graph based implementation instead)
            </summary>
        </member>
        <member name="M:VDS.RDF.NodeFactory.#ctor">
            <summary>
            Creates a new Node Factory
            </summary>
        </member>
        <member name="M:VDS.RDF.NodeFactory.CreateBlankNode">
            <summary>
            Creates a Blank Node with a new automatically generated ID
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.NodeFactory.CreateBlankNode(System.String)">
            <summary>
            Creates a Blank Node with the given Node ID
            </summary>
            <param name="nodeId">Node ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.NodeFactory.CreateGraphLiteralNode">
            <summary>
            Creates a Graph Literal Node which represents the empty Subgraph
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.NodeFactory.CreateGraphLiteralNode(VDS.RDF.IGraph)">
            <summary>
            Creates a Graph Literal Node which represents the given Subgraph
            </summary>
            <param name="subgraph">Subgraph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.NodeFactory.CreateLiteralNode(System.String,System.Uri)">
            <summary>
            Creates a Literal Node with the given Value and Data Type
            </summary>
            <param name="literal">Value of the Literal</param>
            <param name="datatype">Data Type URI of the Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.NodeFactory.CreateLiteralNode(System.String)">
            <summary>
            Creates a Literal Node with the given Value
            </summary>
            <param name="literal">Value of the Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.NodeFactory.CreateLiteralNode(System.String,System.String)">
            <summary>
            Creates a Literal Node with the given Value and Language
            </summary>
            <param name="literal">Value of the Literal</param>
            <param name="langspec">Language Specifier for the Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.NodeFactory.CreateUriNode(System.Uri)">
            <summary>
            Creates a URI Node for the given URI
            </summary>
            <param name="uri">URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.NodeFactory.CreateVariableNode(System.String)">
            <summary>
            Creates a Variable Node for the given Variable Name
            </summary>
            <param name="varname"></param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.NodeFactory.GetNextBlankNodeID">
            <summary>
            Creates a new unused Blank Node ID and returns it
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlQuery.#ctor">
            <summary>
            Creates a new SPARQL Query
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SparqlQuery.#ctor(System.Boolean)">
            <summary>
            Creates a new SPARQL Query
            </summary>
            <param name="subquery">Whether the Query is a Sub-query</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlQuery.Copy">
            <summary>
            Creates a copy of the query
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlQuery.AddVariable(System.String)">
            <summary>
            Adds a Variable to the Query
            </summary>
            <param name="name">Variable Name</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlQuery.AddVariable(System.String,System.Boolean)">
            <summary>
            Adds a Variable to the Query
            </summary>
            <param name="name">Variable Name</param>
            <param name="isResultVar">Does the Variable occur in the Output Result Set/Graph</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlQuery.AddVariable(VDS.RDF.Query.SparqlVariable)">
            <summary>
            Adds a Variable to the Query
            </summary>
            <param name="var">Variable</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlQuery.AddDescribeVariable(VDS.RDF.Parsing.Tokens.IToken)">
            <summary>
            Adds a Describe Variable to the Query
            </summary>
            <param name="var">Variable/Uri/QName Token</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlQuery.AddDefaultGraph(System.Uri)">
            <summary>
            Adds a Default Graph URI
            </summary>
            <param name="u">Graph URI</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlQuery.AddNamedGraph(System.Uri)">
            <summary>
            Adds a Named Graph URI
            </summary>
            <param name="u">Graph URI</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlQuery.ClearDefaultGraphs">
            <summary>
            Removes all Default Graph URIs
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SparqlQuery.ClearNamedGraphs">
            <summary>
            Removes all Named Graph URIs
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SparqlQuery.Evaluate(VDS.RDF.IInMemoryQueryableStore)">
            <summary>
            Evaluates the SPARQL Query against the given Triple Store
            </summary>
            <param name="data">Triple Store</param>
            <returns>
            Either a <see cref="T:VDS.RDF.Query.SparqlResultSet">SparqlResultSet</see> or a <see cref="T:VDS.RDF.Graph">Graph</see> depending on the type of query executed
            </returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlQuery.Evaluate(VDS.RDF.IRdfHandler,VDS.RDF.ISparqlResultsHandler,VDS.RDF.IInMemoryQueryableStore)">
            <summary>
            Evaluates the SPARQL Query against the given Triple Store processing the results with the appropriate handler from those provided
            </summary>
            <param name="rdfHandler">RDF Handler</param>
            <param name="resultsHandler">Results Handler</param>
            <param name="data">Triple Store</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlQuery.Evaluate(VDS.RDF.Query.Datasets.ISparqlDataset)">
            <summary>
            Evaluates the SPARQL Query against the given Dataset
            </summary>
            <param name="dataset">Dataset</param>
            <returns>
            Either a <see cref="T:VDS.RDF.Query.SparqlResultSet">SparqlResultSet</see> or a <see cref="T:VDS.RDF.IGraph">IGraph</see> depending on the type of query executed
            </returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlQuery.Evaluate(VDS.RDF.IRdfHandler,VDS.RDF.ISparqlResultsHandler,VDS.RDF.Query.Datasets.ISparqlDataset)">
            <summary>
            Evaluates the SPARQL Query against the given Dataset processing the results with an appropriate handler form those provided
            </summary>
            <param name="rdfHandler">RDF Handler</param>
            <param name="resultsHandler">Results Handler</param>
            <param name="dataset">Dataset</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlQuery.Process(VDS.RDF.Query.ISparqlQueryProcessor)">
            <summary>
            Processes the Query using the given Query Processor
            </summary>
            <param name="processor">SPARQL Query Processor</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlQuery.Optimise">
            <summary>
            Applies optimisation to a Query using the default global optimiser
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SparqlQuery.Optimise(VDS.RDF.Query.Optimisation.IQueryOptimiser)">
            <summary>
            Applies optimisation to a Query using the specific optimiser
            </summary>
            <param name="optimiser">Query Optimiser</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlQuery.RewriteDescribeBNodes(VDS.RDF.Triple,System.Collections.Generic.Dictionary{System.String,VDS.RDF.INode},VDS.RDF.IGraph)">
            <summary>
            Helper method which rewrites Blank Node IDs for Describe Queries
            </summary>
            <param name="t">Triple</param>
            <param name="mapping">Mapping of IDs to new Blank Nodes</param>
            <param name="g">Graph of the Description</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlQuery.ToString">
            <summary>
            Generates a String representation of the Query
            </summary>
            <returns></returns>
            <remarks>This method may not return a complete representation of the Query depending on the Query it is called on as not all the classes which can be included in a Sparql query currently implement ToString methods</remarks>
        </member>
        <member name="M:VDS.RDF.Query.SparqlQuery.ToAlgebra">
            <summary>
            Converts the Query into it's SPARQL Algebra representation (as represented in the Leviathan API)
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlQuery.ApplyAlgebraOptimisations(VDS.RDF.Query.Algebra.ISparqlAlgebra)">
            <summary>
            Applies Algebra Optimisations to the Query
            </summary>
            <param name="algebra">Query Algebra</param>
            <returns>The Query Algebra which may have been transformed to a more optimal form</returns>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.NamespaceMap">
            <summary>
            Gets the Namespace Map for the Query
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.BaseUri">
            <summary>
            Gets/Sets the Base Uri for the Query
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.DefaultGraphs">
            <summary>
            Gets the Default Graph URIs for the Query
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.NamedGraphs">
            <summary>
            Gets the Named Graph URIs for the Query
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.Variables">
            <summary>
            Gets the Variables used in the Query
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.DescribeVariables">
            <summary>
            Gets the Variables, QNames and URIs used in the Describe Query
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.QueryType">
            <summary>
            Gets the type of the Query
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.SpecialType">
            <summary>
            Gets the Special Type of the Query (if any)
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.RootGraphPattern">
            <summary>
            Gets the top level Graph Pattern of the Query
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.ConstructTemplate">
            <summary>
            Gets/Sets the Construct Template for a Construct Query
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.OrderBy">
            <summary>
            Gets/Sets the Ordering for the Query
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.GroupBy">
            <summary>
            Gets/Sets the Grouping for the Query
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.Having">
            <summary>
            Gets/Sets the Having Clause for the Query
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.Bindings">
            <summary>
            Gets/Sets the VALUES Clause for the Query which are bindings that should be applied
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.Describer">
            <summary>
            Gets/Sets the <see cref="T:VDS.RDF.Query.Describe.ISparqlDescribe">ISparqlDescribe</see> which provides the Describe algorithm you wish to use
            </summary>
            <remarks>
            By default this will be the <see cref="T:VDS.RDF.Query.Describe.ConciseBoundedDescription">ConciseBoundedDescription</see> (CBD) algorithm.
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.AlgebraOptimisers">
            <summary>
            Gets/Sets the locally scoped Algebra Optimisers that are used to optimise the Query Algebra in addition to (but before) any global optimisers (specified by <see cref="P:VDS.RDF.Query.Optimisation.SparqlOptimiser.AlgebraOptimisers">SparqlOptimiser.AlgebraOptimisers</see>) that are applied
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.ExpressionFactories">
            <summary>
            Gets/Sets the locally scoped Expression Factories that may be used if the query is using the CALL() function to do dynamic function invocation
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.PropertyFunctionFactories">
            <summary>
            Gets/Sets the locally scoped Property Function factories that may be used by the <see cref="T:VDS.RDF.Query.Optimisation.PropertyFunctionOptimiser"/> when generating the algebra for the query
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.Limit">
            <summary>
            Gets the Result Set Limit for the Query
            </summary>
            <remarks>Values less than zero are counted as -1 which indicates no limit</remarks>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.Offset">
            <summary>
            Gets/Sets the Result Set Offset for the Query
            </summary>
            <remarks>Values less than zero are treated as 0 which indicates no offset</remarks>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.Timeout">
            <summary>
            Gets/Sets the Query Execution Timeout in milliseconds
            </summary>
            <remarks>
            <para>
            This Timeout (typically) only applies when executing the Query in memory.  If you have an instance of this class and pass its string representation (using <see cref="M:VDS.RDF.Query.SparqlQuery.ToString">ToString()</see>) you will lose the timeout information as this is not serialisable in SPARQL syntax.
            </para>
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.PartialResultsOnTimeout">
            <summary>
            Gets/Sets whether Partial Results should be returned in the event of Query Timeout
            </summary>
            <remarks>
            <para>
            Partial Results (typically) only applies when executing the Query in memory.  If you have an instance of this class and pass its string representation (using <see cref="M:VDS.RDF.Query.SparqlQuery.ToString">ToString()</see>) you will lose the partial results information as this is not serialisable in SPARQL syntax.
            </para>
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.QueryExecutionTime">
            <summary>
            Gets the Time taken to execute a Query
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown if you try and inspect the execution time before the Query has been executed</exception>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.IsAggregate">
            <summary>
            Gets whether the Query has an Aggregate as its Result
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.IsOptimised">
            <summary>
            Gets whether Optimisation has been applied to the query
            </summary>
            <remarks>
            This only indicates that an Optimiser has been applied.  You can always reoptimise the query using a different optimiser by using the relevant overload of the <see cref="M:VDS.RDF.Query.SparqlQuery.Optimise">Optimise()</see> method.
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.IsSubQuery">
            <summary>
            Gets whether this Query is a Sub-Query in another Query
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.HasDistinctModifier">
            <summary>
            Gets whether a Query has a DISTINCT modifier
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.HasSolutionModifier">
            <summary>
            Gets whether the Query has a Solution Modifier (a GROUP BY, HAVING, ORDER BY, LIMIT or OFFSET)
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.IsOptimisableOrderBy">
            <summary>
            Gets whether the Query's ORDER BY clause can be optimised with Lazy evaluation
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlQuery.UsesDefaultDataset">
            <summary>
            Gets whether a Query uses the Default Dataset against which it is evaluated
            </summary>
            <remarks>
            <para>
            If the value is true then the Query will use whatever dataset is it evaluated against.  If the value is false then the query changes the dataset at one/more points during its evaluation.
            </para>
            <para>
            Things that may change the dataset and cause a query not to use the Default Dataset are as follows:
            <ul>
                <li>FROM clauses (but not FROM NAMED)</li>
                <li>GRAPH clauses</li>
                <li>Subqueries which do not use the default dataset</li>
            </ul>
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Parsing.SparqlQuerySyntax">
            <summary>
            Available Query Syntaxes
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.SparqlQuerySyntax.Sparql_1_0">
            <summary>
            Use SPARQL 1.0
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.SparqlQuerySyntax.Sparql_1_1">
            <summary>
            Use SPARQL 1.1
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.SparqlQuerySyntax.Extended">
            <summary>
            Use the latest SPARQL specification supported by the library (currently SPARQL 1.1) with some extensions
            </summary>
            <remarks>
            <para>
            Extensions include the following:
            </para>
            <ul>
            <li><strong>LET</strong> assignments (we recommend using the SPARQL 1.1 standards BIND instead)</li>
            <li>Additional aggregates - <strong>NMAX</strong>, <strong>NMIN</strong>, <strong>MEDIAN</strong> and <strong>MODE</strong> (we recommend using the Leviathan Function Library URIs for these instead to make them usable in SPARQL 1.1 mode)</li>
            <li><strong>UNSAID</strong> alias for <strong>NOT EXISTS</strong> (we recommend using the SPARQL 1.1 standard NOT EXISTS instead</li>
            <li><strong>EXISTS</strong> and <strong>NOT EXISTS</strong> are permitted as Graph Patterns (only allowed in FILTERs in SPARQL 1.1)</li>
            </ul>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Parsing.SparqlQueryParser">
            <summary>
            Class for parsing SPARQL Queries into <see cref="T:VDS.RDF.Query.SparqlQuery">SparqlQuery</see> objects that can be used to query a Graph or Triple Store
            </summary>
        </member>
        <member name="T:VDS.RDF.IObjectParser`1">
            <summary>
            Interface for parsers that generate objects of some sort
            </summary>
            <typeparam name="T">Generated Object Type</typeparam>
            <remarks>
            <para>
            Primarily used as a marker interface in relation to <see cref="T:VDS.RDF.MimeTypesHelper">MimeTypesHelper</see> to provide a mechanism whereby parsers for arbitrary objects can be registered and associated with MIME Types and File Extensions
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.IObjectParser`1.Parse(System.IO.StreamReader)">
            <summary>
            Parses an Object from an Input Stream
            </summary>
            <param name="input">Input Stream</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IObjectParser`1.Parse(System.IO.TextReader)">
            <summary>
            Parses an Object from a Text Stream
            </summary>
            <param name="input">Text Stream</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IObjectParser`1.ParseFromString(System.String)">
            <summary>
            Parses an Object from a String
            </summary>
            <param name="data">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IObjectParser`1.ParseFromString(VDS.RDF.Query.SparqlParameterizedString)">
            <summary>
            Parses an Object from a Parameterized String
            </summary>
            <param name="cmdString">Parameterized String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlQueryParser.#ctor">
            <summary>
            Creates a new instance of the SPARQL Query Parser
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlQueryParser.#ctor(VDS.RDF.Parsing.SparqlQuerySyntax)">
            <summary>
            Creates a new instance of the SPARQL Query Parser which supports the given SPARQL Syntax
            </summary>
            <param name="syntax">SPARQL Syntax</param>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlQueryParser.#ctor(VDS.RDF.Parsing.Tokens.TokenQueueMode)">
            <summary>
            Creates a new instance of the SPARQL Query Parser using the given Tokeniser Queue Mode
            </summary>
            <param name="queueMode">Token Queue Mode</param>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlQueryParser.#ctor(VDS.RDF.Parsing.Tokens.TokenQueueMode,VDS.RDF.Parsing.SparqlQuerySyntax)">
            <summary>
            Creates a new instance of the SPARQL Query Parser using the given Tokeniser which supports the given SPARQL Syntax
            </summary>
            <param name="queueMode">Token Queue Mode</param>
            <param name="syntax">SPARQL Syntax</param>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlQueryParser.RaiseWarning(System.String)">
            <summary>
            Helper Method which raises the Warning event when a non-fatal issue with the SPARQL Query being parsed is detected
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlQueryParser.Parse(System.IO.StreamReader)">
            <summary>
            Parses a SPARQL Query from an arbitrary Input Stream
            </summary>
            <param name="input">Input Stream</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlQueryParser.Parse(System.IO.TextReader)">
            <summary>
            Parses a SPARQL Query from an arbitrary Input
            </summary>
            <param name="input">Input</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlQueryParser.ParseFromString(System.String)">
            <summary>
            Parses a SPARQL Query from a String
            </summary>
            <param name="queryString">A SPARQL Query</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlQueryParser.ParseFromString(VDS.RDF.Query.SparqlParameterizedString)">
            <summary>
            Parses a SPARQL Query from a SPARQL Parameterized String
            </summary>
            <param name="queryString">A SPARQL Parameterized String</param>
            <returns></returns>
            <remarks>
            The <see cref="T:VDS.RDF.Query.SparqlParameterizedString">SparqlParameterizedString</see> class allows you to use parameters in a String in a manner similar to SQL Commands in the ADO.Net model.  See the documentation for <see cref="T:VDS.RDF.Query.SparqlParameterizedString">SparqlParameterizedString</see> for details of this.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlQueryParser.TryParseGraphPattern(VDS.RDF.Parsing.Contexts.SparqlQueryParserContext,System.Boolean)">
            <summary>
            Tries to parse a Graph Pattern from the given Parser Context
            </summary>
            <param name="context">Parser Context</param>
            <param name="requireOpeningLeftBracket">Whether the opening Left Curly Bracket is required</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Parsing.SparqlQueryParser.TraceTokeniser">
            <summary>
            Gets/Sets whether Tokeniser progress is Traced to the Console
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.SparqlQueryParser.DefaultBaseUri">
            <summary>
            Gets/Sets the Default Base URI for Queries parsed by this Parser instance
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.SparqlQueryParser.SyntaxMode">
            <summary>
            Gets/Sets the Syntax that should be supported
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.SparqlQueryParser.ExpressionFactories">
            <summary>
            Gets/Sets the locally scoped custom expression factories
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.SparqlQueryParser.QueryOptimiser">
            <summary>
            Gets/Sets the locally scoped Query Optimiser applied to queries at the end of the parsing process
            </summary>
            <remarks>
            <para>
            May be null if no locally scoped optimiser is set in which case the globally scoped optimiser will be used
            </para>
            </remarks>
        </member>
        <member name="E:VDS.RDF.Parsing.SparqlQueryParser.Warning">
            <summary>
            Event raised when a non-fatal issue with the SPARQL Query being parsed is detected
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.SparqlTokeniser">
            <summary>
            A Class for Reading an Input Stream and generating SPARQL Tokens
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.SparqlTokeniser.#ctor(System.IO.StreamReader,VDS.RDF.Parsing.SparqlQuerySyntax)">
            <summary>
            Creates a new Instance of the Tokeniser
            </summary>
            <param name="input">The Input Stream to generate Tokens from</param>
            <param name="syntax">Syntax Mode to use when parsing</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.SparqlTokeniser.#ctor(VDS.RDF.Parsing.ParsingTextReader,VDS.RDF.Parsing.SparqlQuerySyntax)">
            <summary>
            Creates a new Instance of the Tokeniser
            </summary>
            <param name="input">The Input Stream to generate Tokens from</param>
            <param name="syntax">Syntax Mode to use when parsing</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.SparqlTokeniser.#ctor(System.IO.TextReader,VDS.RDF.Parsing.SparqlQuerySyntax)">
            <summary>
            Creates a new Instance of the Tokeniser
            </summary>
            <param name="input">The Input to generate Tokens from</param>
            <param name="syntax">Syntax Mode to use when parsing</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.SparqlTokeniser.GetNextToken">
            <summary>
            Gets the next parseable Token from the Input or raises an Error
            </summary>
            <returns></returns>
            <exception cref="T:VDS.RDF.Parsing.RdfParseException">Occurs when a Token cannot be parsed</exception>
        </member>
        <member name="T:VDS.RDF.Graph">
            <summary>
            Class for representing RDF Graphs
            </summary>
            <threadsafety instance="false">Safe for multi-threaded read-only access but unsafe if one/more threads may modify the Graph by using the <see cref="M:VDS.RDF.Graph.Assert(VDS.RDF.Triple)">Assert</see>, <see cref="M:VDS.RDF.Graph.Retract(VDS.RDF.Triple)">Retract</see> or <see cref="M:VDS.RDF.BaseGraph.Merge(VDS.RDF.IGraph)">Merge</see> methods</threadsafety>
        </member>
        <member name="M:VDS.RDF.Graph.#ctor">
            <summary>
            Creates a new instance of a Graph
            </summary>
        </member>
        <member name="M:VDS.RDF.Graph.#ctor(System.Boolean)">
            <summary>
            Creates a new instance of a Graph with an optionally empty Namespace Map
            </summary>
            <param name="emptyNamespaceMap">Whether the Namespace Map should be empty</param>
        </member>
        <member name="M:VDS.RDF.Graph.#ctor(VDS.RDF.BaseTripleCollection)">
            <summary>
            Creates a new instance of a Graph using the given Triple Collection
            </summary>
            <param name="tripleCollection">Triple Collection</param>
        </member>
        <member name="M:VDS.RDF.Graph.#ctor(VDS.RDF.BaseTripleCollection,System.Boolean)">
            <summary>
            Creates a new instance of a Graph using the given Triple Collection and an optionally empty Namespace Map
            </summary>
            <param name="tripleCollection">Triple Collection</param>
            <param name="emptyNamespaceMap">Whether the Namespace Map should be empty</param>
        </member>
        <member name="M:VDS.RDF.Graph.Assert(VDS.RDF.Triple)">
            <summary>
            Asserts a Triple in the Graph
            </summary>
            <param name="t">The Triple to add to the Graph</param>
        </member>
        <member name="M:VDS.RDF.Graph.Assert(System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Asserts a List of Triples in the graph
            </summary>
            <param name="ts">List of Triples in the form of an IEnumerable</param>
        </member>
        <member name="M:VDS.RDF.Graph.Retract(VDS.RDF.Triple)">
            <summary>
            Retracts a Triple from the Graph
            </summary>
            <param name="t">Triple to Retract</param>
            <remarks>Current implementation may have some defunct Nodes left in the Graph as only the Triple is retracted</remarks>
        </member>
        <member name="M:VDS.RDF.Graph.Retract(System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Retracts a enumeration of Triples from the graph
            </summary>
            <param name="ts">Enumeration of Triples to retract</param>
        </member>
        <member name="M:VDS.RDF.Graph.GetUriNode(System.Uri)">
            <summary>
            Returns the UriNode with the given Uri if it exists
            </summary>
            <param name="uri">The Uri of the Node to select</param>
            <returns>Either the UriNode Or null if no Node with the given Uri exists</returns>
        </member>
        <member name="M:VDS.RDF.Graph.GetUriNode(System.String)">
            <summary>
            Returns the UriNode with the given QName if it exists
            </summary>
            <param name="qname">The QName of the Node to select</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Graph.GetLiteralNode(System.String)">
            <summary>
            Returns the LiteralNode with the given Value if it exists
            </summary>
            <param name="literal">The literal value of the Node to select</param>
            <returns>Either the LiteralNode Or null if no Node with the given Value exists</returns>
            <remarks>The LiteralNode in the Graph must have no Language or DataType set</remarks>
        </member>
        <member name="M:VDS.RDF.Graph.GetLiteralNode(System.String,System.String)">
            <summary>
            Returns the LiteralNode with the given Value in the given Language if it exists
            </summary>
            <param name="literal">The literal value of the Node to select</param>
            <param name="langspec">The Language Specifier for the Node to select</param>
            <returns>Either the LiteralNode Or null if no Node with the given Value and Language Specifier exists</returns>
        </member>
        <member name="M:VDS.RDF.Graph.GetLiteralNode(System.String,System.Uri)">
            <summary>
            Returns the LiteralNode with the given Value and given Data Type if it exists
            </summary>
            <param name="literal">The literal value of the Node to select</param>
            <param name="datatype">The Uri for the Data Type of the Literal to select</param>
            <returns>Either the LiteralNode Or null if no Node with the given Value and Data Type exists</returns>
        </member>
        <member name="M:VDS.RDF.Graph.GetBlankNode(System.String)">
            <summary>
            Returns the Blank Node with the given Identifier
            </summary>
            <param name="nodeId">The Identifier of the Blank Node to select</param>
            <returns>Either the Blank Node or null if no Node with the given Identifier exists</returns>
        </member>
        <member name="M:VDS.RDF.Graph.GetTriples(VDS.RDF.INode)">
            <summary>
            Gets all the Triples involving the given Node
            </summary>
            <param name="n">The Node to find Triples involving</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.Graph.GetTriples(System.Uri)">
            <summary>
            Gets all the Triples involving the given Uri
            </summary>
            <param name="uri">The Uri to find Triples involving</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.Graph.GetTriplesWithSubject(VDS.RDF.INode)">
            <summary>
            Gets all the Triples with the given Node as the Subject
            </summary>
            <param name="n">The Node to find Triples with it as the Subject</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.Graph.GetTriplesWithSubject(System.Uri)">
            <summary>
            Gets all the Triples with the given Uri as the Subject
            </summary>
            <param name="u">The Uri to find Triples with it as the Subject</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.Graph.GetTriplesWithPredicate(VDS.RDF.INode)">
            <summary>
            Gets all the Triples with the given Node as the Predicate
            </summary>
            <param name="n">The Node to find Triples with it as the Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Graph.GetTriplesWithPredicate(System.Uri)">
            <summary>
            Gets all the Triples with the given Uri as the Predicate
            </summary>
            <param name="u">The Uri to find Triples with it as the Predicate</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.Graph.GetTriplesWithObject(VDS.RDF.INode)">
            <summary>
            Gets all the Triples with the given Node as the Object
            </summary>
            <param name="n">The Node to find Triples with it as the Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Graph.GetTriplesWithObject(System.Uri)">
            <summary>
            Gets all the Triples with the given Uri as the Object
            </summary>
            <param name="u">The Uri to find Triples with it as the Object</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.Graph.GetTriplesWithSubjectPredicate(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Selects all Triples with the given Subject and Predicate
            </summary>
            <param name="subj">Subject</param>
            <param name="pred">Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Graph.GetTriplesWithSubjectObject(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Selects all Triples with the given Subject and Object
            </summary>
            <param name="subj">Subject</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Graph.GetTriplesWithPredicateObject(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Selects all Triples with the given Predicate and Object
            </summary>
            <param name="pred">Predicate</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.NonIndexedGraph">
            <summary>
            Class for representing RDF Graphs when you don't want Indexing
            </summary>
            <remarks>
            Gives better load performance but poorer lookup performance
            </remarks>
        </member>
        <member name="M:VDS.RDF.NonIndexedGraph.#ctor">
            <summary>
            Creates a new Graph which is not indexed
            </summary>
        </member>
        <member name="T:VDS.RDF.GraphCollection">
            <summary>
            Wrapper class for Graph Collections
            </summary>
        </member>
        <member name="F:VDS.RDF.GraphCollection.DefaultGraphID">
            <summary>
            Internal Constant used as the Hash Code for the default graph
            </summary>
        </member>
        <member name="F:VDS.RDF.GraphCollection._graphs">
            <summary>
            Dictionary of Graph Uri Enhanced Hash Codes to Graphs
            </summary>
            <remarks>See <see cref="M:VDS.RDF.Extensions.GetEnhancedHashCode(System.Uri)">GetEnhancedHashCode()</see></remarks>
        </member>
        <member name="M:VDS.RDF.GraphCollection.#ctor">
            <summary>
            Creates a new Graph Collection
            </summary>
        </member>
        <member name="M:VDS.RDF.GraphCollection.Contains(System.Uri)">
            <summary>
            Checks whether the Graph with the given Uri exists in this Graph Collection
            </summary>
            <param name="graphUri">Graph Uri to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphCollection.Add(VDS.RDF.IGraph,System.Boolean)">
            <summary>
            Adds a Graph to the Collection
            </summary>
            <param name="g">Graph to add</param>
            <param name="mergeIfExists">Sets whether the Graph should be merged with an existing Graph of the same Uri if present</param>
            <exception cref="T:VDS.RDF.RdfException">Throws an RDF Exception if the Graph has no Base Uri or if the Graph already exists in the Collection and the <paramref name="mergeIfExists"/> parameter was not set to true</exception>
        </member>
        <member name="M:VDS.RDF.GraphCollection.Remove(System.Uri)">
            <summary>
            Removes a Graph from the Collection
            </summary>
            <param name="graphUri">Uri of the Graph to remove</param>
        </member>
        <member name="M:VDS.RDF.GraphCollection.GetEnumerator">
            <summary>
            Gets the Enumerator for the Collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets the Enumerator for this Collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphCollection.Dispose">
            <summary>
            Disposes of the Graph Collection
            </summary>
            <remarks>Invokes the <strong>Dispose()</strong> method of all Graphs contained in the Collection</remarks>
        </member>
        <member name="P:VDS.RDF.GraphCollection.Count">
            <summary>
            Gets the number of Graphs in the Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.GraphCollection.GraphUris">
            <summary>
            Provides access to the Graph URIs of Graphs in the Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.GraphCollection.Item(System.Uri)">
            <summary>
            Gets a Graph from the Collection
            </summary>
            <param name="graphUri">Graph Uri</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.ThreadSafeGraphCollection">
            <summary>
            Thread Safe decorator around a Graph collection
            </summary>
            <remarks>
            Dependings on your platform this either provides MRSW concurrency via a <see cref="!:ReaderWriterLockSlim"/> or exclusive access concurrency via a <see cref="T:System.Threading.Monitor"/>
            </remarks>
        </member>
        <member name="M:VDS.RDF.ThreadSafeGraphCollection.#ctor">
            <summary>
            Creates a new Thread Safe decorator around the default <see cref="T:VDS.RDF.GraphCollection"/>
            </summary>
        </member>
        <member name="M:VDS.RDF.ThreadSafeGraphCollection.#ctor(VDS.RDF.BaseGraphCollection)">
            <summary>
            Creates a new Thread Safe decorator around the supplied graph collection
            </summary>
            <param name="graphCollection">Graph Collection</param>
        </member>
        <member name="M:VDS.RDF.ThreadSafeGraphCollection.EnterWriteLock">
            <summary>
            Enters the write lock
            </summary>
        </member>
        <member name="M:VDS.RDF.ThreadSafeGraphCollection.ExitWriteLock">
            <summary>
            Exits the write lock
            </summary>
        </member>
        <member name="M:VDS.RDF.ThreadSafeGraphCollection.EnterReadLock">
            <summary>
            Enters the read lock
            </summary>
        </member>
        <member name="M:VDS.RDF.ThreadSafeGraphCollection.ExitReadLock">
            <summary>
            Exits the read lock
            </summary>
        </member>
        <member name="M:VDS.RDF.ThreadSafeGraphCollection.Contains(System.Uri)">
            <summary>
            Checks whether the Graph with the given Uri exists in this Graph Collection
            </summary>
            <param name="graphUri">Graph Uri to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.ThreadSafeGraphCollection.Add(VDS.RDF.IGraph,System.Boolean)">
            <summary>
            Adds a Graph to the Collection
            </summary>
            <param name="g">Graph to add</param>
            <param name="mergeIfExists">Sets whether the Graph should be merged with an existing Graph of the same Uri if present</param>
            <exception cref="T:VDS.RDF.RdfException">Throws an RDF Exception if the Graph has no Base Uri or if the Graph already exists in the Collection and the <paramref name="mergeIfExists"/> parameter was not set to true</exception>
        </member>
        <member name="M:VDS.RDF.ThreadSafeGraphCollection.Remove(System.Uri)">
            <summary>
            Removes a Graph from the Collection
            </summary>
            <param name="graphUri">Uri of the Graph to remove</param>
        </member>
        <member name="M:VDS.RDF.ThreadSafeGraphCollection.GetEnumerator">
            <summary>
            Gets the Enumerator for the Collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.ThreadSafeGraphCollection.Dispose">
            <summary>
            Disposes of the Graph Collection
            </summary>
            <remarks>Invokes the <strong>Dispose()</strong> method of all Graphs contained in the Collection</remarks>
        </member>
        <member name="P:VDS.RDF.ThreadSafeGraphCollection.Count">
            <summary>
            Gets the number of Graphs in the Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.ThreadSafeGraphCollection.GraphUris">
            <summary>
            Provides access to the Graph URIs of Graphs in the Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.ThreadSafeGraphCollection.Item(System.Uri)">
            <summary>
            Gets a Graph from the Collection
            </summary>
            <param name="graphUri">Graph Uri</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.BaseGraphLiteralNode">
            <summary>
            Abstract Base Class for Graph Literal Nodes
            </summary>
        </member>
        <member name="T:VDS.RDF.IGraphLiteralNode">
            <summary>
            Interface for Graph Literal Nodes
            </summary>
        </member>
        <member name="P:VDS.RDF.IGraphLiteralNode.SubGraph">
            <summary>
            Gets the Sub-graph the Graph Literal represents
            </summary>
        </member>
        <member name="M:VDS.RDF.BaseGraphLiteralNode.#ctor(VDS.RDF.IGraph,VDS.RDF.IGraph)">
            <summary>
            Creates a new Graph Literal Node in the given Graph which represents the given Subgraph
            </summary>
            <param name="g">Graph this node is in</param>
            <param name="subgraph">Sub Graph this node represents</param>
        </member>
        <member name="M:VDS.RDF.BaseGraphLiteralNode.#ctor(VDS.RDF.IGraph)">
            <summary>
            Creates a new Graph Literal Node whose value is an empty Subgraph
            </summary>
            <param name="g">Graph this node is in</param>
        </member>
        <member name="M:VDS.RDF.BaseGraphLiteralNode.#ctor">
            <summary>
            Deserialization Only constructor
            </summary>
        </member>
        <member name="M:VDS.RDF.BaseGraphLiteralNode.Equals(System.Object)">
            <summary>
            Implementation of the Equals method for Graph Literal Nodes.  Graph Literals are considered Equal if their respective Subgraphs are equal
            </summary>
            <param name="obj">Object to compare the Node with</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraphLiteralNode.Equals(VDS.RDF.INode)">
            <summary>
            Implementation of the Equals method for Graph Literal Nodes.  Graph Literals are considered Equal if their respective Subgraphs are equal
            </summary>
            <param name="other">Object to compare the Node with</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraphLiteralNode.Equals(VDS.RDF.IBlankNode)">
            <summary>
            Determines whether this Node is equal to a Blank Node (should always be false)
            </summary>
            <param name="other">Blank Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraphLiteralNode.Equals(VDS.RDF.IGraphLiteralNode)">
            <summary>
            Determines whether this Node is equal to a Graph Literal Node
            </summary>
            <param name="other">Graph Literal Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraphLiteralNode.Equals(VDS.RDF.ILiteralNode)">
            <summary>
            Determines whether this Node is equal to a Literal Node (should always be false)
            </summary>
            <param name="other">Literal Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraphLiteralNode.Equals(VDS.RDF.IUriNode)">
            <summary>
            Determines whether this Node is equal to a URI Node (should always be false)
            </summary>
            <param name="other">URI Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraphLiteralNode.Equals(VDS.RDF.IVariableNode)">
            <summary>
            Determines whether this Node is equal to a Variable Node (should always be false)
            </summary>
            <param name="other">Variable Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraphLiteralNode.Equals(VDS.RDF.BaseGraphLiteralNode)">
            <summary>
            Determines whether this Node is equal to a Graph Literal Node
            </summary>
            <param name="other">Graph Literal Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraphLiteralNode.ToString">
            <summary>
            Implementation of ToString for Graph Literals which produces a String representation of the Subgraph in N3 style syntax
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraphLiteralNode.CompareTo(VDS.RDF.INode)">
            <summary>
            Implementation of CompareTo for Graph Literals
            </summary>
            <param name="other">Node to compare to</param>
            <returns></returns>
            <remarks>
            Graph Literal Nodes are greater than Blank Nodes, Uri Nodes, Literal Nodes and Nulls
            </remarks>
        </member>
        <member name="M:VDS.RDF.BaseGraphLiteralNode.CompareTo(VDS.RDF.IBlankNode)">
            <summary>
            Returns an Integer indicating the Ordering of this Node compared to another Node
            </summary>
            <param name="other">Node to test against</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraphLiteralNode.CompareTo(VDS.RDF.IGraphLiteralNode)">
            <summary>
            Returns an Integer indicating the Ordering of this Node compared to another Node
            </summary>
            <param name="other">Node to test against</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraphLiteralNode.CompareTo(VDS.RDF.ILiteralNode)">
            <summary>
            Returns an Integer indicating the Ordering of this Node compared to another Node
            </summary>
            <param name="other">Node to test against</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraphLiteralNode.CompareTo(VDS.RDF.IUriNode)">
            <summary>
            Returns an Integer indicating the Ordering of this Node compared to another Node
            </summary>
            <param name="other">Node to test against</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraphLiteralNode.CompareTo(VDS.RDF.IVariableNode)">
            <summary>
            Returns an Integer indicating the Ordering of this Node compared to another Node
            </summary>
            <param name="other">Node to test against</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraphLiteralNode.CompareTo(VDS.RDF.BaseGraphLiteralNode)">
            <summary>
            Returns an Integer indicating the Ordering of this Node compared to another Node
            </summary>
            <param name="other">Node to test against</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraphLiteralNode.AsString">
            <summary>
            Throws an error as Graph Literals cannot be cast to a string
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraphLiteralNode.AsInteger">
            <summary>
            Throws an error as Graph Literals cannot be cast to an integer
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraphLiteralNode.AsDecimal">
            <summary>
            Throws an error as Graph Literals cannot be cast to a decimal
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraphLiteralNode.AsFloat">
            <summary>
            Throws an error as Graph Literals cannot be cast to a float
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraphLiteralNode.AsDouble">
            <summary>
            Throws an error as Graph Literals cannot be cast to a double
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraphLiteralNode.AsBoolean">
            <summary>
            Throws an error as Graph Literals cannot be cast to a boolean
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraphLiteralNode.AsDateTime">
            <summary>
            Throws an error as Graph Literals cannot be cast to a date time
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraphLiteralNode.AsDateTimeOffset">
            <summary>
            Throws an error as Graph Literals cannot be cast to a date time
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseGraphLiteralNode.AsTimeSpan">
            <summary>
            Throws an error as Graph Literals cannot be cast to a time span
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.BaseGraphLiteralNode.SubGraph">
            <summary>
            Gets the Subgraph that this Node represents
            </summary>
        </member>
        <member name="P:VDS.RDF.BaseGraphLiteralNode.EffectiveType">
            <summary>
            Gets the URI of the datatype this valued node represents as a String
            </summary>
        </member>
        <member name="P:VDS.RDF.BaseGraphLiteralNode.NumericType">
            <summary>
            Gets the numeric type of the node
            </summary>
        </member>
        <member name="T:VDS.RDF.GraphLiteralNode">
            <summary>
            Class for representing Graph Literal Nodes which are supported in highly expressive RDF syntaxes like Notation 3
            </summary>
        </member>
        <member name="M:VDS.RDF.GraphLiteralNode.#ctor(VDS.RDF.IGraph)">
            <summary>
            Creates a new Graph Literal Node in the given Graph which represents the given Subgraph
            </summary>
            <param name="g">Graph this node is in</param>
        </member>
        <member name="M:VDS.RDF.GraphLiteralNode.#ctor(VDS.RDF.IGraph,VDS.RDF.IGraph)">
            <summary>
            Creates a new Graph Literal Node whose value is an empty Subgraph
            </summary>
            <param name="g">Graph this node is in</param>
            <param name="subgraph">Sub-graph this node represents</param>
        </member>
        <member name="M:VDS.RDF.GraphLiteralNode.#ctor">
            <summary>
            Deserialization Only Constructor
            </summary>
        </member>
        <member name="M:VDS.RDF.GraphLiteralNode.CompareTo(VDS.RDF.GraphLiteralNode)">
            <summary>
            Implementation of Compare To for Graph Literal Nodes
            </summary>
            <param name="other">Graph Literal Node to Compare To</param>
            <returns></returns>
            <remarks>
            Simply invokes the more general implementation of this method
            </remarks>
        </member>
        <member name="M:VDS.RDF.GraphLiteralNode.Equals(VDS.RDF.GraphLiteralNode)">
            <summary>
            Determines whether this Node is equal to a Graph Literal Node
            </summary>
            <param name="other">Graph Literal Node</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Storage.AsyncStorageExtensions">
            <summary>
            Static Helper class containing internal extensions methods used to support the <see cref="T:VDS.RDF.Storage.BaseAsyncSafeConnector">BaseAsyncSafeConnector</see> class
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.AsyncStorageExtensions.AsyncLoadGraph(VDS.RDF.Storage.IStorageProvider,VDS.RDF.IGraph,System.Uri,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Loads a Graph asynchronously
            </summary>
            <param name="storage">Storage Provider</param>
            <param name="g">Graph to load into</param>
            <param name="graphUri">URI of the Graph to load</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.AsyncStorageExtensions.AsyncLoadGraph(VDS.RDF.Storage.IStorageProvider,VDS.RDF.IRdfHandler,System.Uri,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Loads a Graph asynchronously
            </summary>
            <param name="storage">Storage Provider</param>
            <param name="handler">Handler to load with</param>
            <param name="graphUri">URI of the Graph to load</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.AsyncStorageExtensions.AsyncSaveGraph(VDS.RDF.Storage.IStorageProvider,VDS.RDF.IGraph,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Saves a Graph aynchronously
            </summary>
            <param name="storage">Storage Provider</param>
            <param name="g">Graph to save</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.AsyncStorageExtensions.AsyncUpdateGraph(VDS.RDF.Storage.IStorageProvider,System.Uri,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple},VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Updates a Graph asynchronously
            </summary>
            <param name="storage">Storage Provider</param>
            <param name="graphUri">URI of the Graph to update</param>
            <param name="additions">Triples to add</param>
            <param name="removals">Triples to remove</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.AsyncStorageExtensions.AsyncDeleteGraph(VDS.RDF.Storage.IStorageProvider,System.Uri,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Deletes a Graph asynchronously
            </summary>
            <param name="storage">Storage Provider</param>
            <param name="graphUri">URI of the Graph to delete</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.AsyncStorageExtensions.AsyncListGraphs(VDS.RDF.Storage.IStorageProvider,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Lists Graphs in the store asynchronously
            </summary>
            <param name="storage">Storage Provider</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.AsyncStorageExtensions.AsyncQuery(VDS.RDF.Storage.IQueryableStorage,System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Queries a store asynchronously
            </summary>
            <param name="storage">Storage Provider</param>
            <param name="query">SPARQL Query</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.AsyncStorageExtensions.AsyncQueryHandlers(VDS.RDF.Storage.IQueryableStorage,System.String,VDS.RDF.IRdfHandler,VDS.RDF.ISparqlResultsHandler,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Queries a store asynchronously
            </summary>
            <param name="storage">Storage Provider</param>
            <param name="query">SPARQL Query</param>
            <param name="rdfHandler">RDF Handler</param>
            <param name="resultsHandler">Results Handler</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.AsyncStorageExtensions.AsyncUpdate(VDS.RDF.Storage.IUpdateableStorage,System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Updates a store asynchronously
            </summary>
            <param name="storage">Storage Provider</param>
            <param name="updates">SPARQL Update</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="T:VDS.RDF.Storage.BaseAsyncSafeConnector">
            <summary>
            Abstract Base Class for <see cref="T:VDS.RDF.Storage.IStorageProvider">IStorageProvider</see> implementations for which it is safe to do the <see cref="T:VDS.RDF.Storage.IAsyncStorageProvider">IAsyncStorageProvider</see> implementation simply by farming out calls to the synchronous methods onto background threads (i.e. non-HTTP based connectors)
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.IStorageProvider">
            <summary>
            Interface for storage providers which provide the read/write functionality to some arbitrary storage layer
            </summary>
            <remarks>
            Designed to allow for arbitrary Triple Stores to be plugged into the library as required by the end user
            </remarks>
        </member>
        <member name="T:VDS.RDF.Storage.IStorageCapabilities">
            <summary>
            Interface which describes the capabilities of some storage provider
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.IStorageCapabilities.IsReady">
            <summary>
            Gets whether the connection with the underlying Store is ready for use
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.IStorageCapabilities.IsReadOnly">
            <summary>
            Gets whether the connection with the underlying Store is read-only
            </summary>
            <remarks>
            Any Manager which indicates it is read-only should also return false for the <see cref="P:VDS.RDF.Storage.IStorageCapabilities.UpdateSupported">UpdatedSupported</see> property and should throw a <see cref="T:VDS.RDF.Storage.RdfStorageException">RdfStorageException</see> if the <strong>SaveGraph()</strong> or <strong>UpdateGraph()</strong> methods are called
            </remarks>
        </member>
        <member name="P:VDS.RDF.Storage.IStorageCapabilities.IOBehaviour">
            <summary>
            Gets the Save Behaviour the Store uses
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.IStorageCapabilities.UpdateSupported">
            <summary>
            Gets whether the triple level updates are supported
            </summary>
            <remarks>
            Some Stores do not support updates at the Triple level and may as designated in the interface defintion throw a <see cref="T:System.NotSupportedException">NotSupportedException</see> if the <strong>UpdateGraph()</strong> method is called.  This property allows for calling code to check in advance whether Updates are supported
            </remarks>
        </member>
        <member name="P:VDS.RDF.Storage.IStorageCapabilities.DeleteSupported">
            <summary>
            Gets whether the deletion of graphs is supported
            </summary>
            <remarks>
            Some Stores do not support the deletion of Graphs and may as designated in the interface definition throw a <see cref="T:System.NotSupportedException">NotSupportedException</see> if the <strong>DeleteGraph()</strong> method is called.  This property allows for calling code to check in advance whether Deletion of Graphs is supported.
            </remarks>
        </member>
        <member name="P:VDS.RDF.Storage.IStorageCapabilities.ListGraphsSupported">
            <summary>
            Gets whether the Store supports Listing Graphs
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.IStorageProvider.LoadGraph(VDS.RDF.IGraph,System.Uri)">
            <summary>
            Loads a Graph from the Store
            </summary>
            <param name="g">Graph to load into</param>
            <param name="graphUri">Uri of the Graph to load</param>
            <remarks>
            <para>
            If the Graph being loaded into is Empty then it's Base Uri should become the Uri of the Graph being loaded, otherwise it should be merged into the existing non-empty Graph whose Base Uri should be unaffected.
            </para>
            <para>
            Behaviour of this method with regards to non-existent Graphs is up to the implementor, an empty Graph may be returned or an error thrown.  Implementors <strong>should</strong> state in the XML comments for their implementation what behaviour is implemented.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.IStorageProvider.LoadGraph(VDS.RDF.IGraph,System.String)">
            <summary>
            Loads a Graph from the Store
            </summary>
            <param name="g">Graph to load into</param>
            <param name="graphUri">URI of the Graph to load</param>
            <remarks>
            <para>
            If the Graph being loaded into is Empty then it's Base Uri should become the Uri of the Graph being loaded, otherwise it should be merged into the existing non-empty Graph whose Base Uri should be unaffected.
            </para>
            <para>
            Behaviour of this method with regards to non-existent Graphs is up to the implementor, an empty Graph may be returned or an error thrown.  Implementors <strong>should</strong> state in the XML comments for their implementation what behaviour is implemented.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.IStorageProvider.LoadGraph(VDS.RDF.IRdfHandler,System.Uri)">
            <summary>
            Loads a Graph from the Store using the RDF Handler
            </summary>
            <param name="handler">RDF Handler</param>
            <param name="graphUri">URI of the Graph to load</param>
            <remarks>
            <para>
            Behaviour of this method with regards to non-existent Graphs is up to the implementor, an empty Graph may be returned or an error thrown.  Implementors <strong>should</strong> state in the XML comments for their implementation what behaviour is implemented.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.IStorageProvider.LoadGraph(VDS.RDF.IRdfHandler,System.String)">
            <summary>
            Loads a Graph from the Store using the RDF Handler
            </summary>
            <param name="handler">RDF Handler</param>
            <param name="graphUri">URI of the Graph to load</param>
            <remarks>
            <para>
            Behaviour of this method with regards to non-existent Graphs is up to the implementor, an empty Graph may be returned or an error thrown.  Implementors <strong>should</strong> state in the XML comments for their implementation what behaviour is implemented.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.IStorageProvider.SaveGraph(VDS.RDF.IGraph)">
            <summary>
            Saves a Graph to the Store
            </summary>
            <param name="g">Graph to Save</param>
            <remarks>
            Uri of the Graph should be taken from the <see cref="P:VDS.RDF.IGraph.BaseUri">BaseUri</see> property
            <br/><br/>
            Behaviour of this method with regards to whether it overwrites/updates/merges with existing Graphs of the same Uri is up to the implementor and may be dependent on the underlying store.  Implementors <strong>should</strong> state in the XML comments for their implementations what behaviour is implemented.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.IStorageProvider.UpdateGraph(System.Uri,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Updates a Graph in the Store
            </summary>
            <param name="graphUri">Uri of the Graph to update</param>
            <param name="additions">Triples to add to the Graph</param>
            <param name="removals">Triples to remove from the Graph</param>
            <remarks>
            <para>
            <strong>Note:</strong> Not all Stores are capable of supporting update at the individual Triple level and as such it is acceptable for such a Store to throw a <see cref="T:System.NotSupportedException">NotSupportedException</see> if the Store cannot provide this functionality
            </para>
            <para>
            Behaviour of this method with regards to non-existent Graph is up to the implementor, it may create a new empty Graph and apply the updates to that or it may throw an error.  Implementors <strong>should</strong> state in the XML comments for their implementation what behaviour is implemented.
            </para>
            <para>
            Implementers <strong>MUST</strong> allow for either the additions or removals argument to be null
            </para>
            </remarks>
            <exception cref="T:System.NotSupportedException">May be thrown if the underlying Store is not capable of doing Updates at the Triple level</exception>
            <exception cref="T:VDS.RDF.Storage.RdfStorageException">May be thrown if the underlying Store is not capable of doing Updates at the Triple level or if some error occurs while attempting the Update</exception>
        </member>
        <member name="M:VDS.RDF.Storage.IStorageProvider.UpdateGraph(System.String,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Updates a Graph in the Store
            </summary>
            <param name="graphUri">Uri of the Graph to update</param>
            <param name="additions">Triples to add to the Graph</param>
            <param name="removals">Triples to remove from the Graph</param>
            <remarks>
            <para>
            <strong>Note:</strong> Not all Stores are capable of supporting update at the individual Triple level and as such it is acceptable for such a Store to throw a <see cref="T:System.NotSupportedException">NotSupportedException</see> or an <see cref="T:VDS.RDF.Storage.RdfStorageException">RdfStorageException</see> if the Store cannot provide this functionality
            </para>
            <para>
            Behaviour of this method with regards to non-existent Graph is up to the implementor, it may create a new empty Graph and apply the updates to that or it may throw an error.  Implementors <strong>should</strong> state in the XML comments for their implementation what behaviour is implemented.
            </para>
            <para>
            Implementers <strong>MUST</strong> allow for either the additions or removals argument to be null
            </para>
            </remarks>
            <exception cref="T:System.NotSupportedException">May be thrown if the underlying Store is not capable of doing Updates at the Triple level</exception>
            <exception cref="T:VDS.RDF.Storage.RdfStorageException">May be thrown if the underlying Store is not capable of doing Updates at the Triple level or if some error occurs while attempting the Update</exception>
        </member>
        <member name="M:VDS.RDF.Storage.IStorageProvider.DeleteGraph(System.Uri)">
            <summary>
            Deletes a Graph from the Store
            </summary>
            <param name="graphUri">URI of the Graph to be deleted</param>
            <exception cref="T:System.NotSupportedException">May be thrown if the underlying Store is not capable of doing Deleting a Graph</exception>
            <exception cref="T:VDS.RDF.Storage.RdfStorageException">May be thrown if the underlying Store is not capable of Deleting a Graph or an error occurs while performing the delete</exception>
            <remarks>
            <para>
            <strong>Note:</strong> Not all Stores are capable of Deleting a Graph so it is acceptable for such a Store to throw a <see cref="T:System.NotSupportedException">NotSupportedException</see> or an <see cref="T:VDS.RDF.Storage.RdfStorageException">RdfStorageException</see> if the Store cannot provide this functionality
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.IStorageProvider.DeleteGraph(System.String)">
            <summary>
            Deletes a Graph from the Store
            </summary>
            <param name="graphUri">URI of the Graph to be deleted</param>
            <exception cref="T:System.NotSupportedException">May be thrown if the underlying Store is not capable of doing Deleting a Graph</exception>
            <exception cref="T:VDS.RDF.Storage.RdfStorageException">May be thrown if the underlying Store is not capable of Deleting a Graph or an error occurs while performing the delete</exception>
            <remarks>
            <para>
            <strong>Note:</strong> Not all Stores are capable of Deleting a Graph so it is acceptable for such a Store to throw a <see cref="T:System.NotSupportedException">NotSupportedException</see> or an <see cref="T:VDS.RDF.Storage.RdfStorageException">RdfStorageException</see> if the Store cannot provide this functionality
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.IStorageProvider.ListGraphs">
            <summary>
            Gets a List of Graph URIs for the graphs in the store
            </summary>
            <returns></returns>
            <remarks>
            <para>
            Implementations should implement this method only if they need to provide a custom way of listing Graphs.  If the Store for which you are providing a manager can efficiently return the Graphs using a SELECT DISTINCT ?g WHERE { GRAPH ?g { ?s ?p ?o } } query then there should be no need to implement this function.
            </para>
            </remarks>
        </member>
        <member name="P:VDS.RDF.Storage.IStorageProvider.ParentServer">
            <summary>
            Gets the Parent Server on which this store is hosted (if any)
            </summary>
            <remarks>
            <para>
            For storage backends which support multiple stores this is useful because it provides a way to access all the stores on that backend.  For stores which are standalone they should simply return null
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Storage.IAsyncStorageProvider">
            <summary>
            Interface for storage providers which provide asynchronous read/write functionality to some arbitrary storage layer
            </summary>
            <remarks>
            Designed to allow for arbitrary Triple Stores to be plugged into the library as required by the end user
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.IAsyncStorageProvider.LoadGraph(VDS.RDF.IGraph,System.Uri,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Loads a Graph from the Store asynchronously
            </summary>
            <param name="g">Graph to load into</param>
            <param name="graphUri">URI of the Graph to load</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.IAsyncStorageProvider.LoadGraph(VDS.RDF.IGraph,System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Loads a Graph from the Store asynchronously
            </summary>
            <param name="g">Graph to load into</param>
            <param name="graphUri">URI of the Graph to load</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.IAsyncStorageProvider.LoadGraph(VDS.RDF.IRdfHandler,System.Uri,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Loads a Graph from the Store asynchronously
            </summary>
            <param name="handler">Handler to load with</param>
            <param name="graphUri">URI of the Graph to load</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.IAsyncStorageProvider.LoadGraph(VDS.RDF.IRdfHandler,System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Loads a Graph from the Store asynchronously
            </summary>
            <param name="handler">Handler to load with</param>
            <param name="graphUri">URI of the Graph to load</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.IAsyncStorageProvider.SaveGraph(VDS.RDF.IGraph,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Saves a Graph to the Store asynchronously
            </summary>
            <param name="g">Graph to save</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.IAsyncStorageProvider.UpdateGraph(System.Uri,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple},VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Updates a Graph in the Store asychronously
            </summary>
            <param name="graphUri">URI of the Graph to update</param>
            <param name="additions">Triples to be added</param>
            <param name="removals">Triples to be removed</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.IAsyncStorageProvider.UpdateGraph(System.String,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple},VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Updates a Graph in the Store asychronously
            </summary>
            <param name="graphUri">URI of the Graph to update</param>
            <param name="additions">Triples to be added</param>
            <param name="removals">Triples to be removed</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.IAsyncStorageProvider.DeleteGraph(System.Uri,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Deletes a Graph from the Store
            </summary>
            <param name="graphUri">URI of the Graph to delete</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.IAsyncStorageProvider.DeleteGraph(System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Deletes a Graph from the Store
            </summary>
            <param name="graphUri">URI of the Graph to delete</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.IAsyncStorageProvider.ListGraphs(VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Lists the Graphs in the Store asynchronously
            </summary>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="P:VDS.RDF.Storage.IAsyncStorageProvider.AsyncParentServer">
            <summary>
            Gets the Parent Server on which this store is hosted (if any)
            </summary>
            <remarks>
            <para>
            For storage backends which support multiple stores this is useful because it provides a way to access all the stores on that backend.  For stores which are standalone they should simply return null
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.BaseAsyncSafeConnector.LoadGraph(VDS.RDF.IGraph,System.Uri)">
            <summary>
            Loads a Graph from the Store
            </summary>
            <param name="g">Graph to load into</param>
            <param name="graphUri">URI of the Graph to load</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseAsyncSafeConnector.LoadGraph(VDS.RDF.IGraph,System.String)">
            <summary>
            Loads a Graph from the Store
            </summary>
            <param name="g">Graph to load into</param>
            <param name="graphUri">URI of the Graph to load</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseAsyncSafeConnector.LoadGraph(VDS.RDF.IRdfHandler,System.Uri)">
            <summary>
            Loads a Graph from the Store
            </summary>
            <param name="handler">Handler to load with</param>
            <param name="graphUri">URI of the Graph to load</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseAsyncSafeConnector.LoadGraph(VDS.RDF.IRdfHandler,System.String)">
            <summary>
            Loads a Graph from the Store
            </summary>
            <param name="handler">Handler to load with</param>
            <param name="graphUri">URI of the Graph to load</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseAsyncSafeConnector.SaveGraph(VDS.RDF.IGraph)">
            <summary>
            Saves a Graph to the Store
            </summary>
            <param name="g">Graph to save</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseAsyncSafeConnector.UpdateGraph(System.Uri,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Updates a Graph in the Store
            </summary>
            <param name="graphUri">URI of the Graph to update</param>
            <param name="additions">Triples to be added</param>
            <param name="removals">Triples to be removed</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseAsyncSafeConnector.UpdateGraph(System.String,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Updates a Graph in the Store
            </summary>
            <param name="graphUri">URI of the Graph to update</param>
            <param name="additions">Triples to be added</param>
            <param name="removals">Triples to be removed</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseAsyncSafeConnector.DeleteGraph(System.Uri)">
            <summary>
            Deletes a Graph from the Store
            </summary>
            <param name="graphUri">URI of the Graph to delete</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseAsyncSafeConnector.DeleteGraph(System.String)">
            <summary>
            Deletes a Graph from the Store
            </summary>
            <param name="graphUri">URI of the Graph to delete</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseAsyncSafeConnector.ListGraphs">
            <summary>
            Lists the Graphs in the Store
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.BaseAsyncSafeConnector.Dispose">
            <summary>
            Diposes of the Store
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.BaseAsyncSafeConnector.LoadGraph(VDS.RDF.IGraph,System.Uri,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Loads a Graph from the Store asynchronously
            </summary>
            <param name="g">Graph to load into</param>
            <param name="graphUri">URI of the Graph to load</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseAsyncSafeConnector.LoadGraph(VDS.RDF.IGraph,System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Loads a Graph from the Store asynchronously
            </summary>
            <param name="g">Graph to load into</param>
            <param name="graphUri">URI of the Graph to load</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseAsyncSafeConnector.LoadGraph(VDS.RDF.IRdfHandler,System.Uri,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Loads a Graph from the Store asynchronously
            </summary>
            <param name="handler">Handler to load with</param>
            <param name="graphUri">URI of the Graph to load</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseAsyncSafeConnector.LoadGraph(VDS.RDF.IRdfHandler,System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Loads a Graph from the Store asynchronously
            </summary>
            <param name="handler">Handler to load with</param>
            <param name="graphUri">URI of the Graph to load</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseAsyncSafeConnector.SaveGraph(VDS.RDF.IGraph,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Saves a Graph to the Store asynchronously
            </summary>
            <param name="g">Graph to save</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseAsyncSafeConnector.UpdateGraph(System.Uri,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple},VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Updates a Graph in the Store asychronously
            </summary>
            <param name="graphUri">URI of the Graph to update</param>
            <param name="additions">Triples to be added</param>
            <param name="removals">Triples to be removed</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseAsyncSafeConnector.UpdateGraph(System.String,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple},VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Updates a Graph in the Store asychronously
            </summary>
            <param name="graphUri">URI of the Graph to update</param>
            <param name="additions">Triples to be added</param>
            <param name="removals">Triples to be removed</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseAsyncSafeConnector.DeleteGraph(System.Uri,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Deletes a Graph from the Store
            </summary>
            <param name="graphUri">URI of the Graph to delete</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseAsyncSafeConnector.DeleteGraph(System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Deletes a Graph from the Store
            </summary>
            <param name="graphUri">URI of the Graph to delete</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseAsyncSafeConnector.ListGraphs(VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Lists the Graphs in the Store asynchronously
            </summary>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="P:VDS.RDF.Storage.BaseAsyncSafeConnector.ParentServer">
            <summary>
            Gets the parent server (if any)
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.BaseAsyncSafeConnector.AsyncParentServer">
            <summary>
            Gets the parent server (if any)
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.BaseAsyncSafeConnector.IsReady">
            <summary>
            Indicates whether the Store is ready to accept requests
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.BaseAsyncSafeConnector.IsReadOnly">
            <summary>
            Gets whether the Store is read only
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.BaseAsyncSafeConnector.IOBehaviour">
            <summary>
            Gets the IO Behaviour of the Store
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.BaseAsyncSafeConnector.UpdateSupported">
            <summary>
            Gets whether the Store supports Triple level updates via the <see cref="M:VDS.RDF.Storage.BaseAsyncSafeConnector.UpdateGraph(System.Uri,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">UpdateGraph()</see> method
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.BaseAsyncSafeConnector.DeleteSupported">
            <summary>
            Gets whether the Store supports Graph deletion via the <see cref="M:VDS.RDF.Storage.BaseAsyncSafeConnector.DeleteGraph(System.Uri)">DeleteGraph()</see> method
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.BaseAsyncSafeConnector.ListGraphsSupported">
            <summary>
            Gets whether the Store supports listing graphs via the <see cref="M:VDS.RDF.Storage.BaseAsyncSafeConnector.ListGraphs">ListGraphs()</see> method
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.IQueryableStorage">
            <summary>
            Interface for storage providers which allow SPARQL Queries to be made against them
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.IQueryableStorage.Query(System.String)">
            <summary>
            Makes a SPARQL Query against the underlying store
            </summary>
            <param name="sparqlQuery">SPARQL Query</param>
            <returns><see cref="T:VDS.RDF.Query.SparqlResultSet">SparqlResultSet</see> or a <see cref="T:VDS.RDF.Graph">Graph</see> depending on the Sparql Query</returns>
            <exception cref="T:VDS.RDF.Query.RdfQueryException">Thrown if an error occurs performing the query</exception>
            <exception cref="T:VDS.RDF.Storage.RdfStorageException">Thrown if an error occurs performing the query</exception>
            <exception cref="T:VDS.RDF.Parsing.RdfParseException">Thrown if the query is invalid when validated by dotNetRDF prior to passing the query request to the store or if the request succeeds but the store returns malformed results</exception>
            <exception cref="T:VDS.RDF.Parsing.RdfParserSelectionException">Thrown if the store returns results in a format dotNetRDF does not understand</exception>
        </member>
        <member name="M:VDS.RDF.Storage.IQueryableStorage.Query(VDS.RDF.IRdfHandler,VDS.RDF.ISparqlResultsHandler,System.String)">
            <summary>
            Makes a SPARQL Query against the underlying store processing the resulting Graph/Result Set with a handler of your choice
            </summary>
            <param name="rdfHandler">RDF Handler</param>
            <param name="resultsHandler">SPARQL Results Handler</param>
            <param name="sparqlQuery">SPARQL Query</param>
            <exception cref="T:VDS.RDF.Query.RdfQueryException">Thrown if an error occurs performing the query</exception>
            <exception cref="T:VDS.RDF.Storage.RdfStorageException">Thrown if an error occurs performing the query</exception>
            <exception cref="T:VDS.RDF.Parsing.RdfParseException">Thrown if the query is invalid when validated by dotNetRDF prior to passing the query request to the store or if the request succeeds but the store returns malformed results</exception>
            <exception cref="T:VDS.RDF.Parsing.RdfParserSelectionException">Thrown if the store returns results in a format dotNetRDF does not understand</exception>
        </member>
        <member name="T:VDS.RDF.Storage.IUpdateableStorage">
            <summary>
            Interface for storage providers which allow SPARQL Updates to be made against them
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.IUpdateableStorage.Update(System.String)">
            <summary>
            Processes a SPARQL Update command against the underlying Store
            </summary>
            <param name="sparqlUpdate">SPARQL Update</param>
        </member>
        <member name="T:VDS.RDF.Storage.IAsyncQueryableStorage">
            <summary>
            Interface for storage providers which allow SPARQL Queries to be made against them asynchronously
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.IAsyncQueryableStorage.Query(System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Queries the store asynchronously
            </summary>
            <param name="sparqlQuery">SPARQL Query</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
            <exception cref="T:VDS.RDF.Query.RdfQueryException">Thrown if an error occurs performing the query</exception>
            <exception cref="T:VDS.RDF.Storage.RdfStorageException">Thrown if an error occurs performing the query</exception>
            <exception cref="T:VDS.RDF.Parsing.RdfParseException">Thrown if the query is invalid when validated by dotNetRDF prior to passing the query request to the store or if the request succeeds but the store returns malformed results</exception>
            <exception cref="T:VDS.RDF.Parsing.RdfParserSelectionException">Thrown if the store returns results in a format dotNetRDF does not understand</exception>
        </member>
        <member name="M:VDS.RDF.Storage.IAsyncQueryableStorage.Query(VDS.RDF.IRdfHandler,VDS.RDF.ISparqlResultsHandler,System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Queries the store asynchronously
            </summary>
            <param name="sparqlQuery">SPARQL Query</param>
            <param name="rdfHandler">RDF Handler</param>
            <param name="resultsHandler">Results Handler</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
            <exception cref="T:VDS.RDF.Query.RdfQueryException">Thrown if an error occurs performing the query</exception>
            <exception cref="T:VDS.RDF.Storage.RdfStorageException">Thrown if an error occurs performing the query</exception>
            <exception cref="T:VDS.RDF.Parsing.RdfParseException">Thrown if the query is invalid when validated by dotNetRDF prior to passing the query request to the store or if the request succeeds but the store returns malformed results</exception>
            <exception cref="T:VDS.RDF.Parsing.RdfParserSelectionException">Thrown if the store returns results in a format dotNetRDF does not understand</exception>
        </member>
        <member name="T:VDS.RDF.Storage.IAsyncUpdateableStorage">
            <summary>
            Interface for storage providers which allow SPARQL Updates to be made against them asynchronously
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.IAsyncUpdateableStorage.Update(System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Updates the store asynchronously
            </summary>
            <param name="sparqlUpdates">SPARQL Update</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="T:VDS.RDF.Storage.ITransactionalStorage">
            <summary>
            Interface for storage providers which have controllable transactions
            </summary>
            <remarks>
            <para>
            It is up to the implementation whether transactions are per-thread or global and how transactions interact with operations performed on the storage provider.  Please see individual implementations for notes on how transactions are implemented.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.ITransactionalStorage.Begin">
            <summary>
            Begins a transaction
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.ITransactionalStorage.Commit">
            <summary>
            Commits a transaction
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.ITransactionalStorage.Rollback">
            <summary>
            Rolls back a transaction
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.IAsyncTransactionalStorage">
            <summary>
            Interface for storage providers which have controllable transactions which can be managed asynchronously
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.IAsyncTransactionalStorage.Begin(VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Begins a transaction asynchronously
            </summary>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.IAsyncTransactionalStorage.Commit(VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Commits a transaction asynchronously
            </summary>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.IAsyncTransactionalStorage.Rollback(VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Rolls back a transaction asynchronously
            </summary>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="T:VDS.RDF.Storage.Management.AllegroGraphServer">
            <summary>
            Represents an AllegroGraph server, may be used to access and manage stores within a catalog on the server
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.Management.SesameServer">
            <summary>
            Represents a connection to a Sesame Server
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.BaseHttpConnector">
            <summary>
            Abstract Base Class for HTTP based Storage API implementations
            </summary>
            <remarks>
            <para>
            Does not actually implement any interface rather it provides common functionality around HTTP Proxying
            </para>
            <para>
            If the library is compiled with the NO_PROXY symbol then this code adds no functionality
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.BaseHttpConnector.#ctor">
            <summary>
            Creates a new connector
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.BaseHttpConnector.ApplyRequestOptions(System.Net.HttpWebRequest)">
            <summary>
            Helper method which applies standard request options to the request, these currently include proxy settings and HTTP timeout
            </summary>
            <param name="request">HTTP Web Request</param>
            <returns>HTTP Web Request with standard options applied</returns>
        </member>
        <member name="M:VDS.RDF.Storage.BaseHttpConnector.SerializeStandardConfig(VDS.RDF.INode,VDS.RDF.Configuration.ConfigurationSerializationContext)">
            <summary>
            Helper method which adds standard configuration information (proxy and timeout settings) to serialized configuration
            </summary>
            <param name="objNode">Object Node representing the <see cref="T:VDS.RDF.Storage.IStorageProvider">IStorageProvider</see> whose configuration is being serialized</param>
            <param name="context">Serialization Context</param>
        </member>
        <member name="P:VDS.RDF.Storage.BaseHttpConnector.Timeout">
            <summary>
            Gets/Sets the HTTP Timeouts used specified in milliseconds
            </summary>
            <remarks>
            <para>
            Defaults to 30 seconds (i.e. the default value is 30,000)
            </para>
            <para>
            It is important to understand that this timeout only applies to the HTTP request portions of any operation performed and that the timeout may apply more than once if a POST operation is used since the timeout applies separately to obtaining the request stream to POST the request and obtaining the response stream.  Also the timeout does not in any way apply to subsequent work that may be carried out before the operation can return so if you need a hard timeout on an operation you should manage that yourself.
            </para>
            <para>
            When set to a zero/negative value then the standard .Net timeout of 100 seconds will apply, use <see cref="F:System.Int32.MaxValue"/> if you want the maximum possible timeout i.e. if you expect to launch extremely long running operations.
            </para>
            <para>
            Not supported under Silverlight, Windows Phone and Portable Class Library builds
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Storage.Management.IAsyncStorageServer">
            <summary>
            Interface for storage providers which are capable of managing multiple stores asynchronously
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.Management.IAsyncStorageServer.ListStores(VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Lists the available stores asynchronously
            </summary>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.Management.IAsyncStorageServer.GetDefaultTemplate(System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Gets a default template for creating a store with the given ID
            </summary>
            <param name="id">ID</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Management.IAsyncStorageServer.GetAvailableTemplates(System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Gets all available templates for creating a store with the given ID
            </summary>
            <param name="id">ID</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.Management.IAsyncStorageServer.CreateStore(VDS.RDF.Storage.Management.Provisioning.IStoreTemplate,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Creates a store asynchronously
            </summary>
            <param name="template">Template for the store to be created</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
            <remarks>
            Behaviour with regards to whether creating a store overwrites an existing store with the same ID is at the discretion of the implementation and <em>SHOULD</em> be documented in an implementations comments
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Management.IAsyncStorageServer.DeleteStore(System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Deletes a store asynchronously
            </summary>
            <param name="storeID">ID of the store to delete</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.Management.IAsyncStorageServer.GetStore(System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Gets a store asynchronously
            </summary>
            <param name="storeID">Store ID</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="P:VDS.RDF.Storage.Management.IAsyncStorageServer.IOBehaviour">
            <summary>
            Gets information on the IO Behaviour of the Server
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.SesameServer.SystemRepositoryID">
            <summary>
            System Repository ID
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.SesameServer._baseUri">
            <summary>
            Base Uri for the Server
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.SesameServer._username">
            <summary>
            Username for accessing the Server
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.SesameServer._pwd">
            <summary>
            Password for accessing the Server
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.SesameServer._hasCredentials">
            <summary>
            Whether the User has provided credentials for accessing the Server using authentication
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.SesameServer._repositoriesPrefix">
            <summary>
            Repositories Prefix
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.SesameServer._templateTypes">
            <summary>
            Available Sesame template types
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.Management.SesameServer.#ctor(System.String)">
            <summary>
            Creates a new connection to a Sesame HTTP Protocol supporting Store
            </summary>
            <param name="baseUri">Base Uri of the Store</param>
        </member>
        <member name="M:VDS.RDF.Storage.Management.SesameServer.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new connection to a Sesame HTTP Protocol supporting Store
            </summary>
            <param name="baseUri">Base Uri of the Store</param>
            <param name="username">Username to use for requests that require authentication</param>
            <param name="password">Password to use for requests that require authentication</param>
        </member>
        <member name="M:VDS.RDF.Storage.Management.SesameServer.GetDefaultTemplate(System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Gets a default template for creating a store
            </summary>
            <param name="id">Store ID</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Management.SesameServer.GetAvailableTemplates(System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Gets all available templates for creating a store
            </summary>
            <param name="id">Store ID</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Management.SesameServer.CreateStore(VDS.RDF.Storage.Management.Provisioning.IStoreTemplate,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Creates a new store based on the given template
            </summary>
            <param name="template">Template</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
            <remarks>
            <para>
            Template must inherit from <see cref="T:VDS.RDF.Storage.Management.Provisioning.Sesame.BaseSesameTemplate"/>
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Management.SesameServer.GetStore(System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Gets a store asynchronously
            </summary>
            <param name="storeID">Store ID</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
            <remarks>
            If the store ID requested matches the current instance an instance <em>MAY</em> invoke the callback immediately returning a reference to itself
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Management.SesameServer.DeleteStore(System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Deletes a store asynchronously
            </summary>
            <param name="storeID">ID of the store to delete</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.Management.SesameServer.ListStores(VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Lists the available stores asynchronously
            </summary>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.Management.SesameServer.CreateRequest(System.String,System.String,System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Helper method for creating HTTP Requests to the Store
            </summary>
            <param name="servicePath">Path to the Service requested</param>
            <param name="accept">Acceptable Content Types</param>
            <param name="method">HTTP Method</param>
            <param name="queryParams">Querystring Parameters</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Management.SesameServer.EnsureSystemConnection">
            <summary>
            Ensures the connection to the Sesame SYSTEM repository is prepared if it isn't already
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.Management.SesameServer.Dispose">
            <summary>
            Disposes of the server
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.Management.SesameServer.SerializeConfiguration(VDS.RDF.Configuration.ConfigurationSerializationContext)">
            <summary>
            Serializes the connection's configuration
            </summary>
            <param name="context">Configuration Serialization Context</param>
        </member>
        <member name="P:VDS.RDF.Storage.Management.SesameServer.IOBehaviour">
            <summary>
            Gets the IO Behaviour of the server
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.Management.AllegroGraphServer.#ctor(System.String,System.String)">
            <summary>
            Creates a new Connection to an AllegroGraph store
            </summary>
            <param name="baseUri">Base URI for the Store</param>
            <param name="catalogID">Catalog ID</param>
        </member>
        <member name="M:VDS.RDF.Storage.Management.AllegroGraphServer.#ctor(System.String)">
            <summary>
            Creates a new Connection to an AllegroGraph store in the Root Catalog (AllegroGraph 4.x and higher)
            </summary>
            <param name="baseUri">Base Uri for the Store</param>
        </member>
        <member name="M:VDS.RDF.Storage.Management.AllegroGraphServer.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Creates a new Connection to an AllegroGraph store
            </summary>
            <param name="baseUri">Base Uri for the Store</param>
            <param name="catalogID">Catalog ID</param>
            <param name="username">Username for connecting to the Store</param>
            <param name="password">Password for connecting to the Store</param>
        </member>
        <member name="M:VDS.RDF.Storage.Management.AllegroGraphServer.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new Connection to an AllegroGraph store in the Root Catalog (AllegroGraph 4.x and higher)
            </summary>
            <param name="baseUri">Base Uri for the Store</param>
            <param name="username">Username for connecting to the Store</param>
            <param name="password">Password for connecting to the Store</param>
        </member>
        <member name="M:VDS.RDF.Storage.Management.AllegroGraphServer.ListStores(VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Gets the List of Stores available  on the server within the current catalog asynchronously
            </summary>
            <param name="callback">Callback</param>
            <param name="state">State to pass to callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.Management.AllegroGraphServer.GetDefaultTemplate(System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Gets a default template for creating a new Store
            </summary>
            <param name="id">Store ID</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to callback</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Management.AllegroGraphServer.GetAvailableTemplates(System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Gets all available templates for creating a new Store
            </summary>
            <param name="id">Store ID</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to callback</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Management.AllegroGraphServer.CreateStore(VDS.RDF.Storage.Management.Provisioning.IStoreTemplate,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Creates a new Store on the server within the current catalog asynchronously
            </summary>
            <param name="template">Template to create the store from</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.Management.AllegroGraphServer.DeleteStore(System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Deletes a Store from the server within the current catalog asynchronously
            </summary>
            <param name="storeID">Store ID</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.Management.AllegroGraphServer.GetStore(System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Gets a Store within the current catalog asynchronously
            </summary>
            <param name="storeID">Store ID</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to call back</param>
            <returns></returns>
            <remarks>
            AllegroGraph groups stores by catalog, you may only use this method to obtain stores within your current catalogue
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Management.AllegroGraphServer.CreateRequest(System.String,System.String,System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Helper method for creating HTTP Requests to the Store
            </summary>
            <param name="servicePath">Path to the Service requested</param>
            <param name="accept">Acceptable Content Types</param>
            <param name="method">HTTP Method</param>
            <param name="queryParams">Querystring Parameters</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Management.AllegroGraphServer.SerializeConfiguration(VDS.RDF.Configuration.ConfigurationSerializationContext)">
            <summary>
            Serializes the connection's configuration
            </summary>
            <param name="context">Configuration Serialization Context</param>
        </member>
        <member name="T:VDS.RDF.Storage.Management.IStorageServer">
            <summary>
            Interface for storage servers which are systems capable of managing multiple stores which are exposed as <see cref="T:VDS.RDF.Storage.IStorageProvider"/> instances
            </summary>
            <remarks>
            This interface may be implemented either separately or alongside <see cref="T:VDS.RDF.Storage.IStorageProvider"/>.  It is quite acceptable for an implementation of <see cref="T:VDS.RDF.Storage.IStorageProvider"/> that provides a connection to a store sitting on a server that manages multiple stores to also provide an implementation of this interface in order to allow access to other stores on the server.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Management.IStorageServer.ListStores">
            <summary>
            Gets the list of available stores
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Management.IStorageServer.GetDefaultTemplate(System.String)">
            <summary>
            Gets a default template for creating a store with the given ID
            </summary>
            <param name="id">ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Management.IStorageServer.GetAvailableTemplates(System.String)">
            <summary>
            Gets all possible templates for creating a store with the given ID
            </summary>
            <param name="id">ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Management.IStorageServer.CreateStore(VDS.RDF.Storage.Management.Provisioning.IStoreTemplate)">
            <summary>
            Creates a new Store with the given ID
            </summary>
            <param name="template">Template for the new store</param>
            <returns>Whether creation succeeded</returns>
        </member>
        <member name="M:VDS.RDF.Storage.Management.IStorageServer.DeleteStore(System.String)">
            <summary>
            Deletes the Store with the given ID
            </summary>
            <param name="storeID">Store ID</param>
            <remarks>
            Whether attempting to delete the Store that you are accessing is permissible is up to the implementation
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Management.IStorageServer.GetStore(System.String)">
            <summary>
            Gets the Store with the given ID
            </summary>
            <param name="storeID">Store ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Storage.Management.IStorageServer.IOBehaviour">
            <summary>
            Returns information on the IO behaviour of a Server
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.Management.Provisioning.Sesame.BaseSesameTemplate">
            <summary>
            Abstract base class for templates for creating new stores in Sesame
            </summary>
            <remarks>
            <para>
            Sesame templates generate a configuration graph like the one <a href="http://www.openrdf.org/doc/sesame2/users/ch07.html#section-repository-config">mentioned</a> in the Sesame documentation, this graph is POSTed to the SYSTEM repository causing a new store to be created.
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Storage.Management.Provisioning.StoreTemplate">
            <summary>
            A basic store template where the only parameter is the Store ID
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.Management.Provisioning.IStoreTemplate">
            <summary>
            Interface for templates for the provisioning of new stores
            </summary>
            <remarks>
            <para>
            This interface is intentionally very limited, the generic type constraints on the <see cref="T:VDS.RDF.Storage.Management.IStorageServer"/> interface allow for specific implementations of that interface to futher constrain their implementation to accept only relevant implementations of this interface when provisioning new stores.
            </para>
            <para>
            Specific implementations will likely add various properties that allow end users to configure implementation specific parameters.  It is suggested that implementors include System.ComponentModel attributes on their implementations.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Management.Provisioning.IStoreTemplate.Validate">
            <summary>
            Validates the template returning an enumeration of error messages
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Storage.Management.Provisioning.IStoreTemplate.ID">
            <summary>
            Gets/Sets the ID for the Store
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Management.Provisioning.IStoreTemplate.TemplateName">
            <summary>
            Gets the name of the type of store the template will create
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Management.Provisioning.IStoreTemplate.TemplateDescription">
            <summary>
            Gets the description of the type of store the template will create
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.Management.Provisioning.StoreTemplate.#ctor(System.String)">
            <summary>
            Creates a new template
            </summary>
            <param name="id">Store ID</param>
        </member>
        <member name="M:VDS.RDF.Storage.Management.Provisioning.StoreTemplate.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new template
            </summary>
            <param name="id">Store ID</param>
            <param name="name">Template Name</param>
            <param name="description">Template Description</param>
        </member>
        <member name="M:VDS.RDF.Storage.Management.Provisioning.StoreTemplate.Validate">
            <summary>
            Validates the template
            </summary>
            <returns></returns>
            <remarks>
            This default implementation does no validation, derived classes must override this to add their required validation
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Management.Provisioning.StoreTemplate.ToString">
            <summary>
            Gets the string representation of the template which is the Template Name
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Storage.Management.Provisioning.StoreTemplate.ID">
            <summary>
            Gets/Sets the Store ID
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Management.Provisioning.StoreTemplate.TemplateName">
            <summary>
            Gets the name of the type of store the template will create
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Management.Provisioning.StoreTemplate.TemplateDescription">
            <summary>
            Gets the description of the type of store the template will create
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.Provisioning.Sesame.BaseSesameTemplate.RepositoryNamespace">
            <summary>
            Constants for Sesame repository configuration namespaces
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.Provisioning.Sesame.BaseSesameTemplate.RepositorySailNamespace">
            <summary>
            Constants for Sesame repository configuration namespaces
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.Provisioning.Sesame.BaseSesameTemplate.RepositoryHttpNamespace">
            <summary>
            Constants for Sesame repository configuration namespaces
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.Provisioning.Sesame.BaseSesameTemplate.SailNamespace">
            <summary>
            Constants for Sesame repository configuration namespaces
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.Provisioning.Sesame.BaseSesameTemplate.SailMemoryNamespace">
            <summary>
            Constants for Sesame repository configuration namespaces
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.Provisioning.Sesame.BaseSesameTemplate.SailNativeNamespace">
            <summary>
            Constants for Sesame repository configuration namespaces
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.Management.Provisioning.Sesame.BaseSesameTemplate.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new Sesame template
            </summary>
            <param name="id">ID</param>
            <param name="name">Template name</param>
            <param name="description">Template description</param>
        </member>
        <member name="M:VDS.RDF.Storage.Management.Provisioning.Sesame.BaseSesameTemplate.GetTemplateGraph">
            <summary>
            Gets a Graph representing the RDF that must be inserted into Sesame's SYSTEM repository in order to create the desired store
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Management.Provisioning.Sesame.BaseSesameTemplate.GetBaseTemplateGraph">
            <summary>
            Gets the basic template graph which is a graph with all the required namespaces registered and the ID and label filled in
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Storage.Management.Provisioning.Sesame.BaseSesameTemplate.Label">
            <summary>
            Gets/Sets the descriptive label for a Sesame store
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Management.Provisioning.Sesame.BaseSesameTemplate.ContextNode">
            <summary>
            Gets the Node used to refer to the store configuration context
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.Management.Provisioning.Sesame.SesameHttpTemplate">
            <summary>
            Templates for creating remote Sesame stores
            </summary>
            <remarks>
            <para>
            This template generates a Sesame repository config graph like the following, depending on exact options the graph may differ:
            </para>
            <code>
            @prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;.
            @prefix rep: &lt;http://www.openrdf.org/config/repository#&gt;.
            @prefix hr: &lt;http://www.openrdf.org/config/repository/http#&gt;.
            
            [] a rep:Repository ;
            rep:repositoryImpl [
                  rep:repositoryType "openrdf:HTTPRepository" ;
                  hr:repositoryURL &lt;{%Sesame server location|http://localhost:8080/openrdf-sesame%}/repositories/{%Remote repository ID|SYSTEM%}&gt;
               ];
               rep:repositoryID "{this.ID}" ;
               rdfs:label "{this.Label}" .
            </code>
            <para>
            The placeholders of the form <strong>{this.Property}</strong> represent properties of this class whose values will be inserted into the repository config graph and used to create a new store in Sesame.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Management.Provisioning.Sesame.SesameHttpTemplate.#ctor(System.String)">
            <summary>
            Creates a new Template
            </summary>
            <param name="id">Store ID</param>
        </member>
        <member name="M:VDS.RDF.Storage.Management.Provisioning.Sesame.SesameHttpTemplate.GetTemplateGraph">
            <summary>
            Gets the template graph
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Storage.Management.Provisioning.Sesame.SesameHttpTemplate.RemoteServer">
            <summary>
            Gets/Sets the remote Sesame server to connect to
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Management.Provisioning.Sesame.SesameHttpTemplate.RemoteRepositoryID">
            <summary>
            Gets/Sets the ID of the remote repository to connect to
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.Management.Provisioning.Sesame.SesameMemTemplate">
            <summary>
            Template for creating Sesame memory stores
            </summary>
            <remarks>
            <para>
            This template generates a Sesame repository config graph like the following, depending on exact options the graph may differ:
            </para>
            <code>
            @prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;.
            @prefix rep: &lt;http://www.openrdf.org/config/repository#&gt;.
            @prefix sr: &lt;http://www.openrdf.org/config/repository/sail#&gt;.
            @prefix sail: &lt;http://www.openrdf.org/config/sail#&gt;.
            @prefix ms: &lt;http://www.openrdf.org/config/sail/memory#&gt;.
            
            [] a rep:Repository ;
            rep:repositoryID "{this.ID}" ;
            rdfs:label "{this.Label}" ;    
               rep:repositoryImpl [
                  rep:repositoryType "openrdf:SailRepository" ;
                  sr:sailImpl [
                     sail:sailType "openrdf:MemoryStore" ;
                     ms:persist {this.Persist} ;
                     ms:syncDelay {this.SyncDelay}
                  ]
              ].
            </code>
            <para>
            The placeholders of the form <strong>{this.Property}</strong> represent properties of this class whose values will be inserted into the repository config graph and used to create a new store in Sesame.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Management.Provisioning.Sesame.SesameMemTemplate.#ctor(System.String)">
            <summary>
            Creates a new memory store template
            </summary>
            <param name="id">Store ID</param>
        </member>
        <member name="M:VDS.RDF.Storage.Management.Provisioning.Sesame.SesameMemTemplate.GetTemplateGraph">
            <summary>
            Gets the template graph used to create the store
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Storage.Management.Provisioning.Sesame.SesameMemTemplate.Persist">
            <summary>
            Gets/Sets whether to persist the store
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Management.Provisioning.Sesame.SesameMemTemplate.SyncDelay">
            <summary>
            Gets/Sets the sync delay
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Management.Provisioning.Sesame.SesameMemTemplate.DirectTypeHierarchyInferencing">
            <summary>
            Gets/Sets whether to enable direct type hierarchy inferencing
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Management.Provisioning.Sesame.SesameMemTemplate.RdfSchemaInferencing">
            <summary>
            Gets/Sets whether to enable RDF Schema Inferencing
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.Management.Provisioning.Sesame.SesameNativeIndexMode">
            <summary>
            Sesame Native index modes
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.Provisioning.Sesame.SesameNativeIndexMode.SPOC">
            <summary>
            SPOC indexes
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.Provisioning.Sesame.SesameNativeIndexMode.POSC">
            <summary>
            POSC indexes
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.Management.Provisioning.Sesame.SesameNativeTemplate">
            <summary>
            Template for creating Sesame Native stores
            </summary>
            <remarks>
            <para>
            This template generates a Sesame repository config graph like the following, depending on exact options the graph may differ:
            </para>
            <code>
            @prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;.
            @prefix rep: &lt;http://www.openrdf.org/config/repository#&gt;.
            @prefix sr: &lt;http://www.openrdf.org/config/repository/sail#&gt;.
            @prefix sail: &lt;http://www.openrdf.org/config/sail#&gt;.
            @prefix ns: &lt;http://www.openrdf.org/config/sail/native#&gt;.
            
            [] a rep:Repository ;
               rep:repositoryID "{this.ID}" ;
               rdfs:label "{this.Label}" ;
               rep:repositoryImpl [
                  rep:repositoryType "openrdf:SailRepository" ;
                  sr:sailImpl [
                     sail:sailType "openrdf:NativeStore" ;
                     ns:tripleIndexes "{this.IndexMode}"
                  ]
               ].
            </code>
            <para>
            The placeholders of the form <strong>{this.Property}</strong> represent properties of this class whose values will be inserted into the repository config graph and used to create a new store in Sesame.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Management.Provisioning.Sesame.SesameNativeTemplate.#ctor(System.String)">
            <summary>
            Creates a Sesame Native store template
            </summary>
            <param name="id">Store ID</param>
        </member>
        <member name="M:VDS.RDF.Storage.Management.Provisioning.Sesame.SesameNativeTemplate.GetTemplateGraph">
            <summary>
            Gets the template graph used to specify the configuration of a Sesame repository
            </summary>
            <returns>Template Graph</returns>
        </member>
        <member name="P:VDS.RDF.Storage.Management.Provisioning.Sesame.SesameNativeTemplate.IndexMode">
            <summary>
            Gets/Sets the Indexing Mode
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Management.Provisioning.Sesame.SesameNativeTemplate.DirectTypeHierarchyInferencing">
            <summary>
            Gets/Sets whether to enable direct type hierarchy inferencing
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Management.Provisioning.Sesame.SesameNativeTemplate.RdfSchemaInferencing">
            <summary>
            Gets/Sets whether to enable RDF Schema Inferencing
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.Management.Provisioning.Stardog.BaseStardogTemplate">
            <summary>
            Abstract base implementation of a Store Template for creating Stardog Stores
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.Management.Provisioning.Stardog.BaseStardogTemplate.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Creates a new Stardog Template
            </summary>
            <param name="id">Store ID</param>
            <param name="name">Template Name</param>
            <param name="descrip">Template Description</param>
            <param name="dbtype">Stardog Database Type</param>
        </member>
        <member name="M:VDS.RDF.Storage.Management.Provisioning.Stardog.BaseStardogTemplate.Validate">
            <summary>
            Validates that the template is filled out such that a store can be created from it
            </summary>
            <returns>Enumeration of errors that occurred</returns>
        </member>
        <member name="M:VDS.RDF.Storage.Management.Provisioning.Stardog.BaseStardogTemplate.ValidateInternal(System.Collections.Generic.List{System.String})">
            <summary>
            Does any additional validation a derived template may require
            </summary>
            <param name="errors">Error collection to add to</param>
        </member>
        <member name="M:VDS.RDF.Storage.Management.Provisioning.Stardog.BaseStardogTemplate.GetTemplateJson">
            <summary>
            Gets the JSON Template for creating a store
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Storage.Management.Provisioning.Stardog.BaseStardogTemplate.DatabaseType">
            <summary>
            Gets the Database Type
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Management.Provisioning.Stardog.BaseStardogTemplate.MinDifferentialIndexLimit">
            <summary>
            Gets/Sets the minimum differential index limit
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Management.Provisioning.Stardog.BaseStardogTemplate.MaxDifferentialIndexLimit">
            <summary>
            Gets/Sets the maximum differential merge limit
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Management.Provisioning.Stardog.BaseStardogTemplate.CanoncialiseLiterals">
            <summary>
            Gets/Sets whether the database should canonicalise literals
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Management.Provisioning.Stardog.BaseStardogTemplate.IndexNamedGraphs">
            <summary>
            Gets/Sets whether to optimize indexes for named graph queries
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Management.Provisioning.Stardog.BaseStardogTemplate.PersistIndexes">
            <summary>
            Gets/Sets whether to persist indexes
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Management.Provisioning.Stardog.BaseStardogTemplate.PersistIndexesSynchronously">
            <summary>
            Gets/Sets whether to persist indexes synchronously
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Management.Provisioning.Stardog.BaseStardogTemplate.AutoUpdateStatistics">
            <summary>
            Gets/Sets whether to automatically update statistics
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Management.Provisioning.Stardog.BaseStardogTemplate.IcvActiveGraphs">
            <summary>
            Gets/Sets the active graphs for ICV
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Management.Provisioning.Stardog.BaseStardogTemplate.IcvEnabled">
            <summary>
            Enables/Disables ICV
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Management.Provisioning.Stardog.BaseStardogTemplate.IcvReasoningMode">
            <summary>
            Gets/Sets the reasoning mode for ICV
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Management.Provisioning.Stardog.BaseStardogTemplate.ConsistencyChecking">
            <summary>
            Gets/Sets whether to perform automatic consistency checking on transactions
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Management.Provisioning.Stardog.BaseStardogTemplate.EnablePunning">
            <summary>
            Enables/Disables punning
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Management.Provisioning.Stardog.BaseStardogTemplate.SchemaGraphs">
            <summary>
            Gets/Sets the graphs that contain the schema (TBox) that are used for reasoning
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Management.Provisioning.Stardog.BaseStardogTemplate.FullTextSearch">
            <summary>
            Enables/Disables Full Text search
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Management.Provisioning.Stardog.BaseStardogTemplate.SearchReindexMode">
            <summary>
            Gets/Sets the Search re-indexing mode
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Management.Provisioning.Stardog.BaseStardogTemplate.DurableTransactions">
            <summary>
            Gets/Sets whether to use durable transactions
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.Management.Provisioning.Stardog.StardogDiskTemplate">
            <summary>
            Template for creating Stardog Disk stores
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.Management.Provisioning.Stardog.StardogDiskTemplate.#ctor(System.String)">
            <summary>
            Creates a new template
            </summary>
            <param name="id">Store ID</param>
        </member>
        <member name="T:VDS.RDF.Storage.Management.Provisioning.Stardog.StardogMemTemplate">
            <summary>
            Template for creating Stardog in-memory stores
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.Management.Provisioning.Stardog.StardogMemTemplate.#ctor(System.String)">
            <summary>
            Creates a new template
            </summary>
            <param name="id">Store ID</param>
        </member>
        <member name="T:VDS.RDF.Storage.Management.BaseStardogServer">
            <summary>
            Abstract implementation of a management connection to a Stardog server using the HTTP protocol
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.BaseStardogServer._templateTypes">
            <summary>
            Available Stardog template types
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.Management.BaseStardogServer.#ctor(System.String)">
            <summary>
            Creates a new connection to a Stardog Server
            </summary>
            <param name="baseUri">Base Uri of the Server</param>
        </member>
        <member name="M:VDS.RDF.Storage.Management.BaseStardogServer.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new connection to a Stardog Server
            </summary>
            <param name="baseUri">Base Uri of the Server</param>
            <param name="username">Username</param>
            <param name="password">Password</param>
        </member>
        <member name="M:VDS.RDF.Storage.Management.BaseStardogServer.ListStores(VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Lists all databases available on the server
            </summary>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.Management.BaseStardogServer.GetDefaultTemplate(System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Gets a default template for creating a new Store
            </summary>
            <param name="id">Store ID</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Management.BaseStardogServer.GetAvailableTemplates(System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Gets all available templates for creating a new Store
            </summary>
            <param name="id">Store ID</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Management.BaseStardogServer.CreateStore(VDS.RDF.Storage.Management.Provisioning.IStoreTemplate,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Creates a new store based on the given template
            </summary>
            <param name="template">Template</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
            <remarks>
            <para>
            Template must inherit from <see cref="T:VDS.RDF.Storage.Management.Provisioning.Stardog.BaseStardogTemplate"/>
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Management.BaseStardogServer.DeleteStore(System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Deletes a database from the server
            </summary>
            <param name="storeID">Store ID</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.Management.BaseStardogServer.GetStore(System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Gets a database from the server
            </summary>
            <param name="storeID">Store ID</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.Management.BaseStardogServer.Dispose">
            <summary>
            Disposes of the server
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.Management.BaseStardogServer.SerializeConfiguration(VDS.RDF.Configuration.ConfigurationSerializationContext)">
            <summary>
            Serializes the connection's configuration
            </summary>
            <param name="context">Configuration Serialization Context</param>
        </member>
        <member name="P:VDS.RDF.Storage.Management.BaseStardogServer.IOBehaviour">
            <summary>
            Gets the IO Behaviour of the server
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.Management.BaseStardogServer.DatabaseOptions">
            <summary>
            Static Class containing constants relevant to provisioning new Stardog stores
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.BaseStardogServer.DatabaseOptions.Online">
            <summary>
            Constants for valid Stardog Options
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.BaseStardogServer.DatabaseOptions.IcvActiveGraphs">
            <summary>
            Constants for valid Stardog Options
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.BaseStardogServer.DatabaseOptions.IcvEnabled">
            <summary>
            Constants for valid Stardog Options
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.BaseStardogServer.DatabaseOptions.IcvReasoningType">
            <summary>
            Constants for valid Stardog Options
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.BaseStardogServer.DatabaseOptions.IndexDifferentialEnableLimit">
            <summary>
            Constants for valid Stardog Options
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.BaseStardogServer.DatabaseOptions.IndexDifferentialMergeLimit">
            <summary>
            Constants for valid Stardog Options
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.BaseStardogServer.DatabaseOptions.IndexLiteralsCanonical">
            <summary>
            Constants for valid Stardog Options
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.BaseStardogServer.DatabaseOptions.IndexNamedGraphs">
            <summary>
            Constants for valid Stardog Options
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.BaseStardogServer.DatabaseOptions.IndexPersistTrue">
            <summary>
            Constants for valid Stardog Options
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.BaseStardogServer.DatabaseOptions.IndexPersistSync">
            <summary>
            Constants for valid Stardog Options
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.BaseStardogServer.DatabaseOptions.IndexStatisticsAutoUpdate">
            <summary>
            Constants for valid Stardog Options
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.BaseStardogServer.DatabaseOptions.IndexType">
            <summary>
            Constants for valid Stardog Options
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.BaseStardogServer.DatabaseOptions.ReasoningAutoConsistency">
            <summary>
            Constants for valid Stardog Options
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.BaseStardogServer.DatabaseOptions.ReasoningPunning">
            <summary>
            Constants for valid Stardog Options
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.BaseStardogServer.DatabaseOptions.ReasoningSchemaGraphs">
            <summary>
            Constants for valid Stardog Options
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.BaseStardogServer.DatabaseOptions.SearchEnabled">
            <summary>
            Constants for valid Stardog Options
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.BaseStardogServer.DatabaseOptions.SearchReIndexMode">
            <summary>
            Constants for valid Stardog Options
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.BaseStardogServer.DatabaseOptions.TransactionsDurable">
            <summary>
            Constants for valid Stardog Options
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.BaseStardogServer.DatabaseOptions.DatabaseTypeDisk">
            <summary>
            Constants for valid Stardog Database types
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.BaseStardogServer.DatabaseOptions.DatabaseTypeMemory">
            <summary>
            Constants for valid Stardog Database types
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.BaseStardogServer.DatabaseOptions.SearchReIndexModeSync">
            <summary>
            Constanst for valid Search Re-Index Modes
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.BaseStardogServer.DatabaseOptions.SearchReIndexModeAsync">
            <summary>
            Constanst for valid Search Re-Index Modes
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.BaseStardogServer.DatabaseOptions.SpecialNamedGraphDefault">
            <summary>
            Constants for special named graph URIs
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.BaseStardogServer.DatabaseOptions.SpecialNamedGraphUnionAll">
            <summary>
            Constants for special named graph URIs
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.BaseStardogServer.DatabaseOptions.DefaultIcvReasoningMode">
            <summary>
            Constants for various Stardog reasoning settings
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.BaseStardogServer.DatabaseOptions.DefaultMinDifferentialIndexLimit">
            <summary>
            Constant for various Stardog integer settings
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.BaseStardogServer.DatabaseOptions.DefaultMaxDifferentialIndexLimit">
            <summary>
            Constant for various Stardog integer settings
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.BaseStardogServer.DatabaseOptions.DefaultCanonicaliseLiterals">
            <summary>
            Constants for various Stardog boolean flags
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.BaseStardogServer.DatabaseOptions.DefaultNamedGraphIndexing">
            <summary>
            Constants for various Stardog boolean flags
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.BaseStardogServer.DatabaseOptions.DefaultPersistIndex">
            <summary>
            Constants for various Stardog boolean flags
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.BaseStardogServer.DatabaseOptions.DefaultPersistIndexSync">
            <summary>
            Constants for various Stardog boolean flags
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.BaseStardogServer.DatabaseOptions.DefaultAutoUpdateStats">
            <summary>
            Constants for various Stardog boolean flags
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.BaseStardogServer.DatabaseOptions.DefaultIcvEnabled">
            <summary>
            Constants for various Stardog boolean flags
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.BaseStardogServer.DatabaseOptions.DefaultConsistencyChecking">
            <summary>
            Constants for various Stardog boolean flags
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.BaseStardogServer.DatabaseOptions.DefaultPunning">
            <summary>
            Constants for various Stardog boolean flags
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.BaseStardogServer.DatabaseOptions.DefaultFullTextSearch">
            <summary>
            Constants for various Stardog boolean flags
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.BaseStardogServer.DatabaseOptions.DefaultDurableTransactions">
            <summary>
            Constants for various Stardog boolean flags
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.Management.BaseStardogServer.DatabaseOptions.ValidDatabaseNamePattern">
            <summary>
            Pattern for valid Stardog database names
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.Management.BaseStardogServer.DatabaseOptions.IsValidDatabaseName(System.String)">
            <summary>
            Validates whether a Database Name is valid
            </summary>
            <param name="name">Database Name</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Management.BaseStardogServer.DatabaseOptions.IsValidDatabaseType(System.String)">
            <summary>
            Validates whether a Database Type is valid
            </summary>
            <param name="type">Database Type</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Management.BaseStardogServer.DatabaseOptions.IsValidSearchReIndexMode(System.String)">
            <summary>
            Validates whether a Search Re-Index Mode is valid
            </summary>
            <param name="mode">Mode</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Management.BaseStardogServer.DatabaseOptions.IsValidNamedGraph(System.String)">
            <summary>
            Validates whether a Named Graph URI is valid
            </summary>
            <param name="uri">URI</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Storage.Management.StardogV1Server">
            <summary>
            Management connection for Stardog 1.* servers
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.Management.StardogV1Server.#ctor(System.String)">
            <summary>
            Creates a new connection to a Stardog Server
            </summary>
            <param name="baseUri">Base Uri of the Server</param>
        </member>
        <member name="M:VDS.RDF.Storage.Management.StardogV1Server.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new connection to a Stardog Server
            </summary>
            <param name="baseUri">Base Uri of the Server</param>
            <param name="username">Username</param>
            <param name="password">Password</param>
        </member>
        <member name="M:VDS.RDF.Storage.Management.StardogV1Server.GetStore(System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Gets a database from the server
            </summary>
            <param name="storeID">Store ID</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="T:VDS.RDF.Storage.Management.StardogV2Server">
            <summary>
            Management connection for Stardog 2.* servers
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.Management.StardogV2Server.#ctor(System.String)">
            <summary>
            Creates a new connection to a Stardog Server
            </summary>
            <param name="baseUri">Base Uri of the Server</param>
        </member>
        <member name="M:VDS.RDF.Storage.Management.StardogV2Server.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new connection to a Stardog Server
            </summary>
            <param name="baseUri">Base Uri of the Server</param>
            <param name="username">Username</param>
            <param name="password">Password</param>
        </member>
        <member name="M:VDS.RDF.Storage.Management.StardogV2Server.GetStore(System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Gets a database from the server
            </summary>
            <param name="storeID">Store ID</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="T:VDS.RDF.Storage.Management.StardogServer">
            <summary>
            Management connection for Stardog servers running the latest version, current this is 2.*
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.Management.StardogServer.#ctor(System.String)">
            <summary>
            Creates a new connection to a Stardog Server
            </summary>
            <param name="baseUri">Base Uri of the Server</param>
        </member>
        <member name="M:VDS.RDF.Storage.Management.StardogServer.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new connection to a Stardog Server
            </summary>
            <param name="baseUri">Base Uri of the Server</param>
            <param name="username">Username</param>
            <param name="password">Password</param>
        </member>
        <member name="T:VDS.RDF.Storage.AsyncStorageOperation">
            <summary>
            Possible Async Storage API Actions
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.AsyncStorageOperation.LoadGraph">
            <summary>
            Loaded a Graph
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.AsyncStorageOperation.LoadWithHandler">
            <summary>
            Loaded data with a RDF Handler
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.AsyncStorageOperation.SaveGraph">
            <summary>
            Saved a Graph
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.AsyncStorageOperation.UpdateGraph">
            <summary>
            Updates a Graph
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.AsyncStorageOperation.DeleteGraph">
            <summary>
            Deleted a Graph
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.AsyncStorageOperation.ListGraphs">
            <summary>
            Listed Graphs
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.AsyncStorageOperation.SparqlQuery">
            <summary>
            Made a SPARQL Query
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.AsyncStorageOperation.SparqlQueryWithHandler">
            <summary>
            Made a SPARQL Query with a handler
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.AsyncStorageOperation.SparqlUpdate">
            <summary>
            Made a SPARQL Update
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.AsyncStorageOperation.TransactionBegin">
            <summary>
            Began a Transaction
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.AsyncStorageOperation.TransactionCommit">
            <summary>
            Committed a Transaction
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.AsyncStorageOperation.TransactionRollback">
            <summary>
            Rolled back a Transaction
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.AsyncStorageOperation.NewTemplate">
            <summary>
            Gettting a new store template
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.AsyncStorageOperation.AvailableTemplates">
            <summary>
            Getting all available templates
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.AsyncStorageOperation.CreateStore">
            <summary>
            Created a Store
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.AsyncStorageOperation.DeleteStore">
            <summary>
            Deleted a Store
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.AsyncStorageOperation.GetStore">
            <summary>
            Retrieved a reference to a Store
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.AsyncStorageOperation.ListStores">
            <summary>
            Got the list of Stores
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.AsyncStorageOperation.Unknown">
            <summary>
            Unknown Action
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.AsyncStorageCallbackArgs">
            <summary>
            Represents arguments passed to callbacks on success/failure of a async storage API call
            </summary>
            <remarks>
            <para>
            Primarily used to provide simple method signatures on the async storage API callbacks
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.AsyncStorageCallbackArgs.#ctor(VDS.RDF.Storage.AsyncStorageOperation)">
            <summary>
            Creates new callback arguments
            </summary>
            <param name="operation">Operation</param>
        </member>
        <member name="M:VDS.RDF.Storage.AsyncStorageCallbackArgs.#ctor(VDS.RDF.Storage.AsyncStorageOperation,System.Exception)">
            <summary>
            Creates new callback arguments
            </summary>
            <param name="operation">Operation</param>
            <param name="ex">Error that occurred</param>
        </member>
        <member name="M:VDS.RDF.Storage.AsyncStorageCallbackArgs.#ctor(VDS.RDF.Storage.AsyncStorageOperation,VDS.RDF.IGraph)">
            <summary>
            Creates new callback arguments
            </summary>
            <param name="operation">Operation</param>
            <param name="g">Graph to return</param>
        </member>
        <member name="M:VDS.RDF.Storage.AsyncStorageCallbackArgs.#ctor(VDS.RDF.Storage.AsyncStorageOperation,VDS.RDF.IGraph,System.Exception)">
            <summary>
            Creates new callback arguments
            </summary>
            <param name="operation">Operation</param>
            <param name="g">Graph to return</param>
            <param name="e">Error that occurred</param>
        </member>
        <member name="M:VDS.RDF.Storage.AsyncStorageCallbackArgs.#ctor(VDS.RDF.Storage.AsyncStorageOperation,System.Uri)">
            <summary>
            Creates new callback arguments
            </summary>
            <param name="operation">Operation</param>
            <param name="graphUri">URI of the affected Graph</param>
        </member>
        <member name="M:VDS.RDF.Storage.AsyncStorageCallbackArgs.#ctor(VDS.RDF.Storage.AsyncStorageOperation,System.Uri,System.Exception)">
            <summary>
            Creates new callback arguments
            </summary>
            <param name="operation">Operation</param>
            <param name="graphUri">URI of the affected Graph</param>
            <param name="e">Error that occurred</param>
        </member>
        <member name="M:VDS.RDF.Storage.AsyncStorageCallbackArgs.#ctor(VDS.RDF.Storage.AsyncStorageOperation,System.Collections.Generic.IEnumerable{System.Uri})">
            <summary>
            Creates new callback arguments
            </summary>
            <param name="operation">Operation</param>
            <param name="graphUris">Enumeration of Graph URIs</param>
        </member>
        <member name="M:VDS.RDF.Storage.AsyncStorageCallbackArgs.#ctor(VDS.RDF.Storage.AsyncStorageOperation,VDS.RDF.IRdfHandler)">
            <summary>
            Creates new callback arguments
            </summary>
            <param name="operation">Operation</param>
            <param name="handler">Handler to return</param>
        </member>
        <member name="M:VDS.RDF.Storage.AsyncStorageCallbackArgs.#ctor(VDS.RDF.Storage.AsyncStorageOperation,VDS.RDF.IRdfHandler,System.Exception)">
            <summary>
            Creates new callback arguments
            </summary>
            <param name="operation">Operation</param>
            <param name="handler">Handler to return</param>
            <param name="e">Error that occurred</param>
        </member>
        <member name="M:VDS.RDF.Storage.AsyncStorageCallbackArgs.#ctor(VDS.RDF.Storage.AsyncStorageOperation,System.String,VDS.RDF.IRdfHandler,VDS.RDF.ISparqlResultsHandler)">
            <summary>
            Creates new callback arguments
            </summary>
            <param name="operation">Operation</param>
            <param name="query">SPARQL Query</param>
            <param name="rdfHandler">RDF Handler to return</param>
            <param name="resultsHandler">Results Handler to return</param>
        </member>
        <member name="M:VDS.RDF.Storage.AsyncStorageCallbackArgs.#ctor(VDS.RDF.Storage.AsyncStorageOperation,System.String,VDS.RDF.IRdfHandler,VDS.RDF.ISparqlResultsHandler,System.Exception)">
            <summary>
            Creates new callback arguments
            </summary>
            <param name="operation">Operation</param>
            <param name="query">SPARQL Query</param>
            <param name="rdfHandler">RDF Handler</param>
            <param name="resultsHandler">Results Handler</param>
            <param name="e">Error that occurred</param>
        </member>
        <member name="M:VDS.RDF.Storage.AsyncStorageCallbackArgs.#ctor(VDS.RDF.Storage.AsyncStorageOperation,System.String,System.Object)">
            <summary>
            Creates new callback arguments
            </summary>
            <param name="operation">Operation</param>
            <param name="query">SPARQL Query</param>
            <param name="queryResults">Results to return</param>
        </member>
        <member name="M:VDS.RDF.Storage.AsyncStorageCallbackArgs.#ctor(VDS.RDF.Storage.AsyncStorageOperation,System.String,System.Object,System.Exception)">
            <summary>
            Creates new callback arguments
            </summary>
            <param name="operation">Operation</param>
            <param name="query">SPARQL Query</param>
            <param name="queryResults">Results to return</param>
            <param name="e">Error that occurred</param>
        </member>
        <member name="M:VDS.RDF.Storage.AsyncStorageCallbackArgs.#ctor(VDS.RDF.Storage.AsyncStorageOperation,System.String)">
            <summary>
            Creates new callback arguments
            </summary>
            <param name="operation">Operation</param>
            <param name="data">Data to return</param>
        </member>
        <member name="M:VDS.RDF.Storage.AsyncStorageCallbackArgs.#ctor(VDS.RDF.Storage.AsyncStorageOperation,System.String,System.Exception)">
            <summary>
            Creates new callback arguments
            </summary>
            <param name="operation">Operation</param>
            <param name="data">Data to return</param>
            <param name="e">Error that occurred</param>
        </member>
        <member name="M:VDS.RDF.Storage.AsyncStorageCallbackArgs.#ctor(VDS.RDF.Storage.AsyncStorageOperation,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates new callback arguments
            </summary>
            <param name="operation">Operation</param>
            <param name="stores">Enumeration of Store IDs</param>
        </member>
        <member name="M:VDS.RDF.Storage.AsyncStorageCallbackArgs.#ctor(VDS.RDF.Storage.AsyncStorageOperation,System.Collections.Generic.IEnumerable{System.String},System.Exception)">
            <summary>
            Creates new callback arguments
            </summary>
            <param name="operation">Operation</param>
            <param name="stores">Enumeration of Store IDs</param>
            <param name="e">Error that occurred</param>
        </member>
        <member name="M:VDS.RDF.Storage.AsyncStorageCallbackArgs.#ctor(VDS.RDF.Storage.AsyncStorageOperation,System.String,VDS.RDF.Storage.IAsyncStorageProvider,System.Exception)">
            <summary>
            Creates new callback arguments
            </summary>
            <param name="operation">Operation</param>
            <param name="storeID">Store ID</param>
            <param name="provider">Storage Provider</param>
            <param name="e">Error that occurred</param>
        </member>
        <member name="M:VDS.RDF.Storage.AsyncStorageCallbackArgs.#ctor(VDS.RDF.Storage.AsyncStorageOperation,System.String,VDS.RDF.Storage.Management.Provisioning.IStoreTemplate)">
            <summary>
            Creates new callback arguments
            </summary>
            <param name="operation">Operation</param>
            <param name="storeID">Store ID</param>
            <param name="template">Template</param>
        </member>
        <member name="M:VDS.RDF.Storage.AsyncStorageCallbackArgs.#ctor(VDS.RDF.Storage.AsyncStorageOperation,System.String,System.Collections.Generic.IEnumerable{VDS.RDF.Storage.Management.Provisioning.IStoreTemplate})">
            <summary>
            Creates new callback arguments
            </summary>
            <param name="operation">Operation</param>
            <param name="storeID">Store ID</param>
            <param name="templates">Templates</param>
        </member>
        <member name="M:VDS.RDF.Storage.AsyncStorageCallbackArgs.SetData(System.String)">
            <summary>
            Sets the Data to the appropriate property based on the operation type
            </summary>
            <param name="data">Data</param>
        </member>
        <member name="P:VDS.RDF.Storage.AsyncStorageCallbackArgs.WasSuccessful">
            <summary>
            Gets whether the async operation succeeded (no error occurred)
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.AsyncStorageCallbackArgs.Graph">
            <summary>
            Gets the Graph that was saved/loaded (if applicable)
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.AsyncStorageCallbackArgs.Error">
            <summary>
            Gets the error that occurred (for failed operations)
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.AsyncStorageCallbackArgs.GraphUri">
            <summary>
            Gets the URI of the Graph affected by the operation
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.AsyncStorageCallbackArgs.GraphUris">
            <summary>
            Gets the list of Graph URIs (if applicable)
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.AsyncStorageCallbackArgs.RdfHandler">
            <summary>
            Gets the RDF Handler used (if applicable)
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.AsyncStorageCallbackArgs.ResultsHandler">
            <summary>
            Gets the Results Handler used (if applicable)
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.AsyncStorageCallbackArgs.QueryResults">
            <summary>
            Gets the Query Results (if applicable)
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.AsyncStorageCallbackArgs.Query">
            <summary>
            Gets the SPARQL Query (if applicable)
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.AsyncStorageCallbackArgs.Updates">
            <summary>
            Gets the SPARQL Update (if applicable)
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.AsyncStorageCallbackArgs.StoreID">
            <summary>
            Gets the Store ID (if applicable)
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.AsyncStorageCallbackArgs.StoreIDs">
            <summary>
            Gets the list of Store IDs (if applicable)
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.AsyncStorageCallbackArgs.StorageProvider">
            <summary>
            Gets the Storage Provider (if applicable)
            </summary>
            <remarks>
            <para>
            For the <see cref="F:VDS.RDF.Storage.AsyncStorageOperation.GetStore"/> operation this will be the reference to the newly returned store instance
            </para>
            </remarks>
        </member>
        <member name="P:VDS.RDF.Storage.AsyncStorageCallbackArgs.Operation">
            <summary>
            Gets the operation that was performed
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.AsyncStorageCallbackArgs.Template">
            <summary>
            Gets the template that was created (if any)
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.AsyncStorageCallbackArgs.AvailableTemplates">
            <summary>
            Gets the templates that were created (if any)
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.AsyncStorageCallback">
            <summary>
            Generic callback for async storage API operations
            </summary>
            <param name="sender">Originator of the callback</param>
            <param name="args">Callback Arguments</param>
            <param name="state">State object originally passed to the async call</param>
        </member>
        <member name="T:VDS.RDF.Storage.StorageHelper">
            <summary>
            Static Helper for the Storage API
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.StorageHelper.HttpMultipartContentTemplate">
            <summary>
            Template for posting form data as part of a HTTP multipart request
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.StorageHelper.HandleHttpQueryError(System.Net.WebException)">
            <summary>
            Handles HTTP Query Errors obtaining additional information from the HTTP response if possible
            </summary>
            <param name="webEx">HTTP Error</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.StorageHelper.HandleHttpError(System.Net.WebException,System.String)">
            <summary>
            Handles HTTP Errors obtaining additional information from the HTTP response if possible
            </summary>
            <param name="webEx">HTTP Error</param>
            <param name="action">Action being performed</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.StorageHelper.HandleHttpError``1(System.Net.WebException,System.String,System.Func{System.String,System.Exception,``0})">
            <summary>
            Handles HTTP Errors obtaining additional information from the HTTP response if possible
            </summary>
            <param name="webEx">HTTP Error</param>
            <param name="action">Action being performed</param>
            <param name="errorProvider">Function that generates the actual errors</param>
            <remarks>
            Adapted from Ron Michael's Zettlemoyer's original patch for this in Stardog to use it across all operations as far as possible
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.StorageHelper.GetStatusLine(System.Net.WebException)">
            <summary>
            Tries to get the status line for inclusion in the HTTP error message
            </summary>
            <param name="webEx">Web exception</param>
            <returns>Status line if available, empty string otherwise</returns>
        </member>
        <member name="M:VDS.RDF.Storage.StorageHelper.HandleQueryError(System.Exception)">
            <summary>
            Handles Query Errors
            </summary>
            <param name="ex">Error</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.StorageHelper.HandleError(System.Exception,System.String)">
            <summary>
            Handles Errors
            </summary>
            <param name="ex">Error</param>
            <param name="action">Action being performed</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.StorageHelper.HandleError``1(System.Exception,System.String,System.Func{System.String,System.Exception,``0})">
            <summary>
            Handles Errors
            </summary>
            <typeparam name="T">Error Type</typeparam>
            <param name="ex">Error</param>
            <param name="action">Action being performed</param>
            <param name="errorProvider">Function that generates the actual errors</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Storage.StorageHelper.HttpMultipartBoundary">
            <summary>
            Gets a new unique boundary for HTTP mutlipart requests
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.CompressingTurtleWriter">
            <summary>
            Class for generating Turtle Concrete RDF Syntax which provides varying levels of Syntax Compression
            </summary>
            <remarks>
            Similar in speed to the standard <see cref="T:VDS.RDF.Writing.TurtleWriter">TurtleWriter</see> but capable of using more syntax compressions depending on the Compression level set
            </remarks>
            <threadsafety instance="true">Designed to be Thread Safe - should be able to call the Save() method from multiple threads on different Graphs without issue</threadsafety>
        </member>
        <member name="T:VDS.RDF.IRdfWriter">
            <summary>
            Interface to be implemented by RDF Writers which generate RDF Concrete Syntax
            </summary>
        </member>
        <member name="M:VDS.RDF.IRdfWriter.Save(VDS.RDF.IGraph,System.IO.TextWriter)">
            <summary>
            Method for Saving a Graph to a Concrete RDF Syntax via some arbitrary <see cref="T:System.IO.TextWriter">TextWriter</see>
            </summary>
            <param name="g">The Graph to Save</param>
            <param name="output">The <see cref="T:System.IO.TextWriter">TextWriter</see> to save the Graph to</param>
            <exception cref="T:VDS.RDF.RdfException">Thrown if the RDF in the Graph is not representable by the Writer</exception>
            <exception cref="T:System.IO.IOException">Thrown if the Writer is unable to write to the underlying storage of the <see cref="T:System.IO.TextWriter">TextWriter</see> specified in the <paramref name="output"/></exception>
        </member>
        <member name="E:VDS.RDF.IRdfWriter.Warning">
            <summary>
            Event which writers can raise to indicate possible ambiguities or issues in the syntax they are producing
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.IPrettyPrintingWriter">
            <summary>
            Interface for Writers that Support Pretty Printing
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.IPrettyPrintingWriter.PrettyPrintMode">
            <summary>
            Gets/Sets whether Pretty Printing Mode should be used
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.IHighSpeedWriter">
            <summary>
            Interface for Writers that Support engaging High Speed Write Mode for some Graphs
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.IHighSpeedWriter.HighSpeedModePermitted">
            <summary>
            Gets/Sets whether the Writer can use High Speed Write Mode if the Graph is deemed suitable for this
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.ICompressingWriter">
            <summary>
            Interface for Writers that support varying levels of Syntax Compression
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.ICompressingWriter.CompressionLevel">
            <summary>
            Gets/Sets the Compression Level that the Writer is using
            </summary>
            <remarks>Compression Level is an arbitrary figure that the Writer can interpret as it wants, implementations of this interface should state in the XML Comments for this property what the different values mean.  The Standard Compression levels provided by the <see cref="T:VDS.RDF.Writing.WriterCompressionLevel">WriterCompressionLevel</see> enumeration are intended as guides and Writers may interpret these as they desire.</remarks>
        </member>
        <member name="T:VDS.RDF.Writing.INamespaceWriter">
            <summary>
            Interface for Writers that support the use of Namespaces and allows a set of Default Namespaces to be defined
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.INamespaceWriter.DefaultNamespaces">
            <summary>
            Gets/Sets the Default Namespaces used for writing
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.IFormatterBasedWriter">
            <summary>
            Interface for writers which use formatters from the Formatting namespace
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.IFormatterBasedWriter.TripleFormatterType">
            <summary>
            Gets the Type for the Triple Formatter this writer uses
            </summary>
            <remarks>
            This should be the type descriptor for a type that implements <see cref="T:VDS.RDF.Writing.Formatting.ITripleFormatter">ITripleFormatter</see>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Writing.CompressingTurtleWriter.#ctor">
            <summary>
            Creates a new Compressing Turtle Writer which uses the Default Compression Level
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.CompressingTurtleWriter.#ctor(System.Int32)">
            <summary>
            Creates a new Compressing Turtle Writer which uses the given Compression Level
            </summary>
            <param name="compressionLevel">Desired Compression Level</param>
            <remarks>See Remarks for this classes <see cref="P:VDS.RDF.Writing.CompressingTurtleWriter.CompressionLevel">CompressionLevel</see> property to see what effect different compression levels have</remarks>
        </member>
        <member name="M:VDS.RDF.Writing.CompressingTurtleWriter.#ctor(VDS.RDF.Parsing.TurtleSyntax)">
            <summary>
            Creates a new compressing Turtle writer using the given syntax level
            </summary>
            <param name="syntax">Syntax Level</param>
        </member>
        <member name="M:VDS.RDF.Writing.CompressingTurtleWriter.#ctor(System.Int32,VDS.RDF.Parsing.TurtleSyntax)">
            <summary>
            Creates a new Compressing Turtle Writer which uses the given Compression Level and Syntax Level
            </summary>
            <param name="compressionLevel">Desired Compression Level</param>
            <param name="syntax">Syntax Level</param>
            <remarks>See Remarks for this classes <see cref="P:VDS.RDF.Writing.CompressingTurtleWriter.CompressionLevel">CompressionLevel</see> property to see what effect different compression levels have</remarks>
        </member>
        <member name="M:VDS.RDF.Writing.CompressingTurtleWriter.Save(VDS.RDF.IGraph,System.IO.TextWriter)">
            <summary>
            Saves a Graph to the given Stream using Turtle Syntax
            </summary>
            <param name="g">Graph to save</param>
            <param name="output">Stream to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.CompressingTurtleWriter.GenerateOutput(VDS.RDF.Writing.Contexts.CompressingTurtleWriterContext)">
            <summary>
            Generates the Turtle Syntax for the Graph
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.CompressingTurtleWriter.GenerateTripleOutput(VDS.RDF.Writing.Contexts.CompressingTurtleWriterContext,VDS.RDF.Triple)">
            <summary>
            Generates Output for Triples as a single "s p o." Triple
            </summary>
            <param name="context">Writer Context</param>
            <param name="t">Triple to output</param>
            <returns></returns>
            <remarks>Used only in High Speed Write Mode</remarks>
        </member>
        <member name="M:VDS.RDF.Writing.CompressingTurtleWriter.GenerateNodeOutput(VDS.RDF.Writing.Contexts.CompressingTurtleWriterContext,VDS.RDF.INode,VDS.RDF.Writing.TripleSegment,System.Int32)">
            <summary>
            Generates Output for Nodes in Turtle syntax
            </summary>
            <param name="context">Writer Context</param>
            <param name="n">Node to generate output for</param>
            <param name="segment">Segment of the Triple being written</param>
            <param name="indent">Indentation</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.CompressingTurtleWriter.GenerateCollectionOutput(VDS.RDF.Writing.Contexts.CompressingTurtleWriterContext,VDS.RDF.Writing.OutputRdfCollection,System.Int32)">
            <summary>
            Internal Helper method which converts a Collection into Turtle Syntax
            </summary>
            <param name="context">Writer Context</param>
            <param name="c">Collection to convert</param>
            <param name="indent">Indentation</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.CompressingTurtleWriter.RaiseWarning(System.String)">
            <summary>
            Helper method for generating Parser Warning Events
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="M:VDS.RDF.Writing.CompressingTurtleWriter.ToString">
            <summary>
            Gets the String representation of the writer which is a description of the syntax it produces
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Writing.CompressingTurtleWriter.PrettyPrintMode">
            <summary>
            Gets/Sets whether Pretty Printing is used
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.CompressingTurtleWriter.HighSpeedModePermitted">
            <summary>
            Gets/Sets whether High Speed Write Mode should be allowed
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.CompressingTurtleWriter.CompressionLevel">
            <summary>
            Gets/Sets the Compression Level to be used
            </summary>
            <remarks>
            <para>
            If the Compression Level is set to <see cref="F:VDS.RDF.Writing.WriterCompressionLevel.None">None</see> then High Speed mode will always be used regardless of the input Graph and the <see cref="P:VDS.RDF.Writing.CompressingTurtleWriter.HighSpeedModePermitted">HighSpeedMorePermitted</see> property.
            </para>
            <para>
            If the Compression Level is set to <see cref="F:VDS.RDF.Writing.WriterCompressionLevel.Minimal">Minimal</see> or above then full Predicate Object lists will be used for Triples.
            </para>
            <para>
            If the Compression Level is set to <see cref="F:VDS.RDF.Writing.WriterCompressionLevel.More">More</see> or above then Blank Node Collections and Collection syntax will be used if the Graph contains Triples that can be compressed in that way.</para>
            </remarks>
        </member>
        <member name="P:VDS.RDF.Writing.CompressingTurtleWriter.DefaultNamespaces">
            <summary>
            Gets/Sets the Default Namespaces that are always available
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.CompressingTurtleWriter.TripleFormatterType">
            <summary>
            Gets the type of the Triple Formatter used by the writer
            </summary>
        </member>
        <member name="E:VDS.RDF.Writing.CompressingTurtleWriter.Warning">
            <summary>
            Event which is raised when there is a non-fatal issue with the Graph being written
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.GraphVizWriter">
            <summary>
            A Writer which generates GraphViz DOT Format files from an RDF Graph
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.GraphVizWriter.Save(VDS.RDF.IGraph,System.IO.TextWriter)">
            <summary>
            Saves a Graph into GraphViz DOT Format
            </summary>
            <param name="g">Graph to save</param>
            <param name="output">Stream to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.GraphVizWriter.TripleToDot(VDS.RDF.Triple,VDS.RDF.Writing.Contexts.BaseWriterContext)">
            <summary>
            Internal Helper Method for converting a Triple into DOT notation
            </summary>
            <param name="t">Triple to convert</param>
            <param name="context">Writer Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.GraphVizWriter.NodeToDot(VDS.RDF.INode,VDS.RDF.Writing.Contexts.BaseWriterContext)">
            <summary>
            Internal Helper method for converting a Node into DOT notation
            </summary>
            <param name="n">Node to Convert</param>
            <param name="context">Writer Context</param>
            <returns></returns>
            <remarks>Currently Graphs containing Graph Literal Nodes cannot be converted</remarks>
        </member>
        <member name="M:VDS.RDF.Writing.GraphVizWriter.UriNodeToDot(VDS.RDF.IUriNode,VDS.RDF.Writing.Contexts.BaseWriterContext)">
            <summary>
            Internal Helper method for converting Uri Nodes to DOT Notation
            </summary>
            <param name="u">Uri Node to convert</param>
            <param name="context">Writer Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.GraphVizWriter.BlankNodeToDot(VDS.RDF.IBlankNode)">
            <summary>
            Internal Helper Method for converting Blank Nodes to DOT notation
            </summary>
            <param name="b">Blank Node to Convert</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.GraphVizWriter.LiteralNodeToDot(VDS.RDF.ILiteralNode)">
            <summary>
            Internal Helper Method for converting Literal Nodes to DOT notation
            </summary>
            <param name="l">Literal Node to convert</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.GraphVizWriter.OnWarning(System.String)">
            <summary>
            Internal Helper method which handles raising the Warning event if an Event Handler is registered to it
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="M:VDS.RDF.Writing.GraphVizWriter.ToString">
            <summary>
            Gets the String representation of the writer which is a description of the syntax it produces
            </summary>
            <returns></returns>
        </member>
        <member name="E:VDS.RDF.Writing.GraphVizWriter.Warning">
            <summary>
            Event that is raised if there is a potential problem with the RDF being output
            </summary>
            <remarks>Not used by this Writer</remarks>
        </member>
        <member name="T:VDS.RDF.ITransactionalGraph">
            <summary>
            Interface for RDF Graphs which provide Transactions i.e. changes to them can be Flushed (committed) or Discard (rolled back) as desired
            </summary>
        </member>
        <member name="M:VDS.RDF.ITransactionalGraph.Flush">
            <summary>
            Flushes any changes to the Graph
            </summary>
        </member>
        <member name="M:VDS.RDF.ITransactionalGraph.Discard">
            <summary>
            Discards any changes to the Graph
            </summary>
        </member>
        <member name="T:VDS.RDF.NodeType">
            <summary>
            Node Type Values
            </summary>
        </member>
        <member name="F:VDS.RDF.NodeType.Blank">
            <summary>
            A Blank Node
            </summary>
        </member>
        <member name="F:VDS.RDF.NodeType.Uri">
            <summary>
            A Uri Node
            </summary>
        </member>
        <member name="F:VDS.RDF.NodeType.Literal">
            <summary>
            A Literal Node
            </summary>
        </member>
        <member name="F:VDS.RDF.NodeType.GraphLiteral">
            <summary>
            A Graph Literal Node
            </summary>
        </member>
        <member name="F:VDS.RDF.NodeType.Variable">
            <summary>
            A Variable Node (currently only used in N3)
            </summary>
        </member>
        <member name="T:VDS.RDF.IUriNode">
            <summary>
            Interface for URI Nodes
            </summary>
        </member>
        <member name="P:VDS.RDF.IUriNode.Uri">
            <summary>
            Gets the URI the Node represents
            </summary>
        </member>
        <member name="T:VDS.RDF.IVariableNode">
            <summary>
            Interface for Variable Nodes
            </summary>
        </member>
        <member name="P:VDS.RDF.IVariableNode.VariableName">
            <summary>
            Gets the Variable Name
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.ITraceableParser">
            <summary>
            Interface for Parsers that support Parser Tracing
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.ITraceableParser.TraceParsing">
            <summary>
            Gets/Sets whether Parser Tracing is used
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.IDtdWriter">
            <summary>
            Interface for Writers that support use of DTDs to compress output
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.IDtdWriter.UseDtd">
            <summary>
            Gets/Sets whether DTDs can be used
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.IAttributeWriter">
            <summary>
            Interface for Writers that can use attributes (e.g. XML or HTML based writers) which allows you to control whether the writer will choose to use attributes to encode data which could otherwise be expressed as elements
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.IAttributeWriter.UseAttributes">
            <summary>
            Gets/Sets whether literal objects can be compressed as attributes
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.IMultiThreadedWriter">
            <summary>
            Interface for Writers that support multi-threaded writing
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.IMultiThreadedWriter.UseMultiThreadedWriting">
            <summary>
            Gets/Sets whether multi-threading is used
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.IHtmlWriter">
            <summary>
            Interface for Writers that generate HTML
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.IHtmlWriter.Stylesheet">
            <summary>
            Gets/Sets a Stylesheet file used to format the HTML
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.IHtmlWriter.CssClassUri">
            <summary>
            Gets/Sets the CSS class used for the anchor tags used to display the URIs of URI Nodes
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.IHtmlWriter.CssClassBlankNode">
            <summary>
            Gets/Sets the CSS class used for the span tags used to display Blank Node IDs
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.IHtmlWriter.CssClassLiteral">
            <summary>
            Gets/Sets the CSS class used for the span tags used to display Literals
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.IHtmlWriter.CssClassDatatype">
            <summary>
            Gets/Sets the CSS class used for the anchor tags used to display Literal datatypes
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.IHtmlWriter.CssClassLangSpec">
            <summary>
            Gets/Sets the CSS class used for the span tags used to display Literal language specifiers
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.IHtmlWriter.CssClassBox">
            <summary>
            Gets/Sets the CSS class used for the div tags used to group chunks of markup into a box
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.IHtmlWriter.UriPrefix">
            <summary>
            Gets/Sets a Prefix that is applied to all href attributes
            </summary>
        </member>
        <member name="T:VDS.RDF.IStoreWriter">
            <summary>
            Interface to be implemented by Triple Store Writers
            </summary>
        </member>
        <member name="M:VDS.RDF.IStoreWriter.Save(VDS.RDF.ITripleStore,System.IO.TextWriter)">
            <summary>
            Method for saving data to a Triple Store
            </summary>
            <param name="store">Triple Store</param>
            <param name="output">Write to save to</param>
        </member>
        <member name="E:VDS.RDF.IStoreWriter.Warning">
            <summary>
            Event which writers can raise to indicate possible ambiguities or issues in the syntax they are producing
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.TokenQueueMode">
            <summary>
            Token Queue Mode Constants
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.TokenQueueMode.QueueAllBeforeParsing">
            <summary>
            No Buffering used
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.TokenQueueMode.SynchronousBufferDuringParsing">
            <summary>
            Synchronous Buffering used
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.TokenQueueMode.AsynchronousBufferDuringParsing">
            <summary>
            Asynchronous Buffering used
            </summary>
        </member>
        <member name="T:VDS.RDF.ITripleContext">
            <summary>
            An Interface for classes which provide Context Information for Triples thus allowing you to create Quads with arbitrary extra information attached to Triples via your Context Objects
            </summary>
            <remarks>
            A Triple Context is simply a name-value pair collection of arbitrary data that can be attached to a Triple.  Internal representation of this is left to the implementor.
            </remarks>
        </member>
        <member name="M:VDS.RDF.ITripleContext.HasProperty(System.String)">
            <summary>
            A Method which will indicate whether the Context contains some arbitrary property
            </summary>
        </member>
        <member name="P:VDS.RDF.ITripleContext.Item(System.String)">
            <summary>
            A Property which exposes the arbitrary properties of the Context as an Key Based Index
            </summary>
            <param name="name">Name of the Property</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.BasicTripleContext">
            <summary>
            Class which implements a very basic Triple Context
            </summary>
            <remarks>
            The Name Value collection is represented internally as a Dictionary
            </remarks>
        </member>
        <member name="M:VDS.RDF.BasicTripleContext.#ctor">
            <summary>
            Creates a new Basic Triple Context without a Source
            </summary>
        </member>
        <member name="M:VDS.RDF.BasicTripleContext.HasProperty(System.String)">
            <summary>
            Checks whether a given property is defined in this Context object
            </summary>
            <param name="name">Name of the Property</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.BasicTripleContext.Item(System.String)">
            <summary>
            Gets/Sets the value of a Property
            </summary>
            <param name="name">Name of the Property</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.IInMemoryQueryableStore">
            <summary>
            Interface for Triple Stores which can be queried in memory using method calls or the SPARQL implementation contained in this library
            </summary>
            <remarks>
            <para>
            An in memory Triple Store will typically load most of the Graphs and consequently Triples contained within it into Memory as the in memory SPARQL implementation only operates over the part of the Triple Store loaded in memory.  This being said there is no reason why an in memory store can't provide a Snapshot view of an underlying store to allow only the relevant parts of Store to be loaded and queried.
            </para>
            <para>
            All the Selection Methods which do not specify a subset of Graphs on such a Triple Store <strong>should</strong> operate over the entire store
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.Contains(VDS.RDF.Triple)">
            <summary>
            Returns whether a given Triple is contained anywhere in the Query Triples
            </summary>
            <param name="t">Triple to check for existence of</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetTriples(System.Uri)">
            <summary>
            Selects all Triples which have a Uri Node with the given Uri from all the Query Triples
            </summary>
            <param name="uri">Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetTriples(VDS.RDF.INode)">
            <summary>
            Selects all Triples which contain the given Node from all the Query Triples
            </summary>
            <param name="n">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetTriplesWithObject(System.Uri)">
            <summary>
            Selects all Triples where the Object is a Uri Node with the given Uri from all the Query Triples
            </summary>
            <param name="u">Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetTriplesWithObject(VDS.RDF.INode)">
            <summary>
            Selects all Triples where the Object is a given Node from all the Query Triples
            </summary>
            <param name="n">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetTriplesWithPredicate(VDS.RDF.INode)">
            <summary>
            Selects all Triples where the Predicate is a given Node from all the Query Triples
            </summary>
            <param name="n">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetTriplesWithPredicate(System.Uri)">
            <summary>
            Selects all Triples where the Predicate is a Uri Node with the given Uri from all the Query Triples
            </summary>
            <param name="u">Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetTriplesWithSubject(VDS.RDF.INode)">
            <summary>
            Selects all Triples where the Subject is a given Node from all the Query Triples
            </summary>
            <param name="n">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetTriplesWithSubject(System.Uri)">
            <summary>
            Selects all Triples where the Subject is a Uri Node with the given Uri from all the Query Triples
            </summary>
            <param name="u">Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetTriplesWithSubjectPredicate(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Selects all the Triples with the given Subject-Predicate pair from all the Query Triples
            </summary>
            <param name="subj">Subject</param>
            <param name="pred">Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetTriplesWithPredicateObject(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Selects all the Triples with the given Predicate-Object pair from all the Query Triples
            </summary>
            <param name="pred">Predicate</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetTriplesWithSubjectObject(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Selects all the Triples with the given Subject-Object pair from all the Query Triples
            </summary>
            <param name="subj">Subject</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetTriples(System.Collections.Generic.List{System.Uri},System.Uri)">
            <summary>
            Selects all Triples which have a Uri Node with the given Uri from a Subset of Graphs in the Triple Store
            </summary>
            <param name="graphUris">List of the Graph URIs of Graphs you want to select over</param>
            <param name="uri">Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetTriples(System.Collections.Generic.List{System.Uri},VDS.RDF.INode)">
            <summary>
            Selects all Triples which contain the given Node from a Subset of Graphs in the Triple Store
            </summary>
            <param name="graphUris">List of the Graph URIs of Graphs you want to select over</param>
            <param name="n">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetTriplesWithObject(System.Collections.Generic.List{System.Uri},System.Uri)">
            <summary>
            Selects all Triples where the Object is a Uri Node with the given Uri from a Subset of Graphs in the Triple Store
            </summary>
            <param name="graphUris">List of the Graph URIs of Graphs you want to select over</param>
            <param name="u">Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetTriplesWithObject(System.Collections.Generic.List{System.Uri},VDS.RDF.INode)">
            <summary>
            Selects all Triples where the Object is a given Node from a Subset of Graphs in the Triple Store
            </summary>
            <param name="graphUris">List of the Graph URIs of Graphs you want to select over</param>
            <param name="n">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetTriplesWithPredicate(System.Collections.Generic.List{System.Uri},VDS.RDF.INode)">
            <summary>
            Selects all Triples where the Predicate is a given Node from a Subset of Graphs in the Triple Store
            </summary>
            <param name="graphUris">List of the Graph URIs of Graphs you want to select over</param>
            <param name="n">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetTriplesWithPredicate(System.Collections.Generic.List{System.Uri},System.Uri)">
            <summary>
            Selects all Triples where the Predicate is a Uri Node with the given Uri from a Subset of Graphs in the Triple Store
            </summary>
            <param name="graphUris">List of the Graph URIs of Graphs you want to select over</param>
            <param name="u">Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetTriplesWithSubject(System.Collections.Generic.List{System.Uri},VDS.RDF.INode)">
            <summary>
            Selects all Triples where the Subject is a given Node from a Subset of Graphs in the Triple Store
            </summary>
            <param name="graphUris">List of the Graph URIs of Graphs you want to select over</param>
            <param name="n">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.GetTriplesWithSubject(System.Collections.Generic.List{System.Uri},System.Uri)">
            <summary>
            Selects all Triples where the Subject is a Uri Node with the given Uri from a Subset of Graphs in the Triple Store
            </summary>
            <param name="graphUris">List of the Graph URIs of Graphs you want to select over</param>
            <param name="u">Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.ExecuteQuery(System.String)">
            <summary>
            Executes a SPARQL Query on the Triple Store
            </summary>
            <param name="query">SPARQL Query as an unparsed string</param>
            <returns></returns>
            <remarks>
            <para>
            This method of making queries often leads to no results because of misconceptions about what data is being queries.  dotNetRDF's SPARQL engine only queries the default unnamed graph of the triple store (the graph added with a null URI) by default unless your query uses FROM clauses to change the default graph or you use GRAPH clauses to access named graphs in the store.  Therefore a common mistake is to add a single graph to the store and then query the store which typically results in no results because usually the added graph is named and so is not queried.
            </para>
            <para>
            We recommend using a <see cref="T:VDS.RDF.Query.ISparqlQueryProcessor"/> instead for making queries over in-memory data since using our standard implementation (<see cref="T:VDS.RDF.Query.LeviathanQueryProcessor"/>) affords you much more explicit control over which graphs are queried.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.ExecuteQuery(VDS.RDF.Query.SparqlQuery)">
            <summary>
            Executes a SPARQL Query on the Triple Store
            </summary>
            <param name="query">SPARQL Query as a <see cref="T:VDS.RDF.Query.SparqlQuery">SparqlQuery</see> instance</param>
            <returns></returns>
            <remarks>
            <para>
            This method of making queries often leads to no results because of misconceptions about what data is being queries.  dotNetRDF's SPARQL engine only queries the default unnamed graph of the triple store (the graph added with a null URI) by default unless your query uses FROM clauses to change the default graph or you use GRAPH clauses to access named graphs in the store.  Therefore a common mistake is to add a single graph to the store and then query the store which typically results in no results because usually the added graph is named and so is not queried.
            </para>
            <para>
            We recommend using a <see cref="T:VDS.RDF.Query.ISparqlQueryProcessor"/> instead for making queries over in-memory data since using our standard implementation (<see cref="T:VDS.RDF.Query.LeviathanQueryProcessor"/>) affords you much more explicit control over which graphs are queried.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.ExecuteQuery(VDS.RDF.IRdfHandler,VDS.RDF.ISparqlResultsHandler,System.String)">
            <summary>
            Executes a SPARQL Query on the Triple Store processing the results with an appropriate handler from those provided
            </summary>
            <param name="rdfHandler">RDF Handler</param>
            <param name="resultsHandler">Results Handler</param>
            <param name="query">SPARQL Query as an unparsed string</param>
            <returns></returns>
            <remarks>
            <para>
            This method of making queries often leads to no results because of misconceptions about what data is being queries.  dotNetRDF's SPARQL engine only queries the default unnamed graph of the triple store (the graph added with a null URI) by default unless your query uses FROM clauses to change the default graph or you use GRAPH clauses to access named graphs in the store.  Therefore a common mistake is to add a single graph to the store and then query the store which typically results in no results because usually the added graph is named and so is not queried.
            </para>
            <para>
            We recommend using a <see cref="T:VDS.RDF.Query.ISparqlQueryProcessor"/> instead for making queries over in-memory data since using our standard implementation (<see cref="T:VDS.RDF.Query.LeviathanQueryProcessor"/>) affords you much more explicit control over which graphs are queried.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.IInMemoryQueryableStore.ExecuteQuery(VDS.RDF.IRdfHandler,VDS.RDF.ISparqlResultsHandler,VDS.RDF.Query.SparqlQuery)">
            <summary>
            Executes a SPARQL Query on the Triple Store processing the results with an appropriate handler from those provided
            </summary>
            <param name="rdfHandler">RDF Handler</param>
            <param name="resultsHandler">Results Handler</param>
            <param name="query">Parsed SPARQL Query</param>
            <returns></returns>
            <remarks>
            <para>
            This method of making queries often leads to no results because of misconceptions about what data is being queries.  dotNetRDF's SPARQL engine only queries the default unnamed graph of the triple store (the graph added with a null URI) by default unless your query uses FROM clauses to change the default graph or you use GRAPH clauses to access named graphs in the store.  Therefore a common mistake is to add a single graph to the store and then query the store which typically results in no results because usually the added graph is named and so is not queried.
            </para>
            <para>
            We recommend using a <see cref="T:VDS.RDF.Query.ISparqlQueryProcessor"/> instead for making queries over in-memory data since using our standard implementation (<see cref="T:VDS.RDF.Query.LeviathanQueryProcessor"/>) affords you much more explicit control over which graphs are queried.
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.INativelyQueryableStore">
            <summary>
            Interface for Triple Stores which can be queried natively i.e. the Stores provide their own SPARQL implementations
            </summary>
            <remarks>
            A Natively Queryable store will typically not load its Graphs and Triples into memory as this is generally unecessary.
            </remarks>
        </member>
        <member name="M:VDS.RDF.INativelyQueryableStore.ExecuteQuery(System.String)">
            <summary>
            Executes a SPARQL Query on the Triple Store
            </summary>
            <param name="query">Sparql Query as unparsed String</param>
            <returns></returns>
            <remarks>
            This assumes that the Store has access to some native SPARQL query processor on/at the Store which will be used to return the results.  Implementations should parse the returned result into a <see cref="T:VDS.RDF.Query.SparqlResultSet">SparqlResultSet</see> or <see cref="T:VDS.RDF.Graph">Graph</see>.
            </remarks>
        </member>
        <member name="M:VDS.RDF.INativelyQueryableStore.ExecuteQuery(VDS.RDF.IRdfHandler,VDS.RDF.ISparqlResultsHandler,System.String)">
            <summary>
            Executes a SPARQL Query on the Triple Store processing the results using an appropriate handler from those provided
            </summary>
            <param name="rdfHandler">RDF Handler</param>
            <param name="resultsHandler">Results Handler</param>
            <param name="query">SPARQL Query as unparsed String</param>
        </member>
        <member name="T:VDS.RDF.IUpdateableTripleStore">
            <summary>
            Interface for Triple Stores which support SPARQL Update as per the SPARQL 1.1 specifications
            </summary>
            <remarks>
            <para>
            A Store which supports this may implement various access control mechanisms which limit what operations are actually permitted
            </para>
            <para>
            It is the responsibility of the Store class to ensure that commands are permissible before invoking them
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.IUpdateableTripleStore.ExecuteUpdate(System.String)">
            <summary>
            Executes an Update against the Triple Store
            </summary>
            <param name="update">SPARQL Update Command(s)</param>
            <remarks>
            As per the SPARQL 1.1 Update specification the command string may be a sequence of commands
            </remarks>
        </member>
        <member name="M:VDS.RDF.IUpdateableTripleStore.ExecuteUpdate(VDS.RDF.Update.SparqlUpdateCommand)">
            <summary>
            Executes a single Update Command against the Triple Store
            </summary>
            <param name="update">SPARQL Update Command</param>
        </member>
        <member name="M:VDS.RDF.IUpdateableTripleStore.ExecuteUpdate(VDS.RDF.Update.SparqlUpdateCommandSet)">
            <summary>
            Executes a set of Update Commands against the Triple Store
            </summary>
            <param name="updates">SPARQL Update Command Set</param>
        </member>
        <member name="T:VDS.RDF.IInferencingTripleStore">
            <summary>
            Interface for Triple Stores which can have a <see cref="T:VDS.RDF.Query.Inference.IInferenceEngine">IInferenceEngine</see> attached to them
            </summary>
        </member>
        <member name="M:VDS.RDF.IInferencingTripleStore.AddInferenceEngine(VDS.RDF.Query.Inference.IInferenceEngine)">
            <summary>
            Adds an Inference Engine to the Triple Store
            </summary>
            <param name="reasoner">Reasoner to add</param>
        </member>
        <member name="M:VDS.RDF.IInferencingTripleStore.RemoveInferenceEngine(VDS.RDF.Query.Inference.IInferenceEngine)">
            <summary>
            Removes an Inference Engine from the Triple Store
            </summary>
            <param name="reasoner">Reasoner to remove</param>
        </member>
        <member name="M:VDS.RDF.IInferencingTripleStore.ClearInferenceEngines">
            <summary>
            Clears all Inference Engines from the Triple Store
            </summary>
        </member>
        <member name="M:VDS.RDF.IInferencingTripleStore.ApplyInference(VDS.RDF.IGraph)">
            <summary>
            Applies Inference to the given Graph
            </summary>
            <param name="g">Graph to apply inference to</param>
            <remarks>
            Allows you to apply Inference to a Graph even if you're not putting that Graph into the Store
            </remarks>
        </member>
        <member name="T:VDS.RDF.ITransactionalStore">
            <summary>
            Interface for Triple Stores which are backed by some storage layer that may delay persistence and thus require flushing to ensure changes are persisted to the backing store, as a by product such stores will typically have some notion of transactionality
            </summary>
        </member>
        <member name="M:VDS.RDF.ITransactionalStore.Flush">
            <summary>
            Flushes any outstanding changes to the underlying store
            </summary>
        </member>
        <member name="M:VDS.RDF.ITransactionalStore.Discard">
            <summary>
            Discards any outstanding changes to the underlying store
            </summary>
        </member>
        <member name="T:VDS.RDF.NonNormalizedLiteralNode">
            <summary>
            Class for representing Literal Nodes where the Literal values are not normalized
            </summary>
        </member>
        <member name="M:VDS.RDF.NonNormalizedLiteralNode.#ctor(VDS.RDF.IGraph,System.String)">
            <summary>
            Internal Only Constructor for Literal Nodes
            </summary>
            <param name="g">Graph this Node is in</param>
            <param name="literal">String value of the Literal</param>
        </member>
        <member name="M:VDS.RDF.NonNormalizedLiteralNode.#ctor(VDS.RDF.IGraph,System.String,System.String)">
            <summary>
            Internal Only Constructor for Literal Nodes
            </summary>
            <param name="g">Graph this Node is in</param>
            <param name="literal">String value of the Literal</param>
            <param name="langspec">Lanaguage Specifier for the Literal</param>
        </member>
        <member name="M:VDS.RDF.NonNormalizedLiteralNode.#ctor(VDS.RDF.IGraph,System.String,System.Uri)">
            <summary>
            Internal Only Constructor for Literal Nodes
            </summary>
            <param name="g">Graph this Node is in</param>
            <param name="literal">String value of the Literal</param>
            <param name="datatype">Uri for the Literals Data Type</param>
        </member>
        <member name="M:VDS.RDF.NonNormalizedLiteralNode.#ctor">
            <summary>
            Deserialization Only Constructor
            </summary>
        </member>
        <member name="M:VDS.RDF.NonNormalizedLiteralNode.CompareTo(VDS.RDF.NonNormalizedLiteralNode)">
            <summary>
            Implementation of Compare To for Literal Nodes
            </summary>
            <param name="other">Literal Node to Compare To</param>
            <returns></returns>
            <remarks>
            Simply invokes the more general implementation of this method
            </remarks>
        </member>
        <member name="T:VDS.RDF.MimeTypesHelper">
            <summary>
            Helper Class containing definitions of MIME Types for the various RDF Concrete Syntaxes and Content Negotation Methods
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.W3CFormatsNamespace">
            <summary>
            Constant for W3C File Formats Namespace
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.Any">
            <summary>
            MIME Type for accept any content Type
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.WWWFormURLEncoded">
            <summary>
            MIME Type for URL Encoded WWW Form Content used when POSTing over HTTP
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.Utf8WWWFormURLEncoded">
            <summary>
            MIME Type for URL Enoded WWW Form Content used when POSTing over HTTP in UTF-8 encoding
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.FormMultipart">
            <summary>
            MIME Type for Multipart Form Data
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.SparqlQuery">
            <summary>
            MIME Type for SPARQL Queries
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.SparqlUpdate">
            <summary>
            MIME Type for SPARQL Updates
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.DefaultTurtleExtension">
            <summary>
            Default File Extension for Turtle Files
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.DefaultRdfXmlExtension">
            <summary>
            Default File Extension for RDF/XML
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.DefaultNotation3Extension">
            <summary>
            Default File Extension for Notation 3
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.DefaultNTriplesExtension">
            <summary>
            Default File Extension for NTriples
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.DefaultJsonExtension">
            <summary>
            Default File Extension for Json formats
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.DefaultRdfJsonExtension">
            <summary>
            Default File Extension for RDF/JSON
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.DefaultSparqlXmlExtension">
            <summary>
            Default File Extension for SPARQL XML Results Format
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.DefaultSparqlJsonExtension">
            <summary>
            Default File Extension for SPARQL JSON Results Format
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.DefaultTriGExtension">
            <summary>
            Default File Extension for TriG
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.DefaultNQuadsExtension">
            <summary>
            Default File Extension for NQuads
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.DefaultTriXExtension">
            <summary>
            Default File Extension for TriX
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.DefaultCsvExtension">
            <summary>
            Default File Extension for CSV
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.DefaultTsvExtension">
            <summary>
            Default File Extension for TSV
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.DefaultHtmlExtension">
            <summary>
            Default File Extension for HTML
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.DefaultXHtmlExtension">
            <summary>
            Default File Extension for XHTML
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.DefaultSparqlQueryExtension">
            <summary>
            Default File Extension for SPARQL Queries
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.DefaultSparqlUpdateExtension">
            <summary>
            Default File Extension for SPARQL Updates
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.DefaultGZipExtension">
            <summary>
            Default File Extension for GZip
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.CharsetUtf8">
            <summary>
            Charset constants
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.CharsetUtf16">
            <summary>
            Charset constants
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.Turtle">
            <summary>
            MIME Types for Turtle
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.RdfXml">
            <summary>
            MIME Types for RDF/XML
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.Notation3">
            <summary>
            MIME Types for Notation 3
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.NTriples">
            <summary>
            MIME Types for NTriples
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.NQuads">
            <summary>
            MIME Types for NQuads
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.TriG">
            <summary>
            MIME Types for TriG
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.TriX">
            <summary>
            MIME Types for TriX
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.Json">
            <summary>
            MIME Types for RDF/JSON
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.SparqlResults">
            <summary>
            MIME Types for SPARQL Result Sets
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.SparqlResultsXml">
            <summary>
            MIME Types for SPARQL Results XML
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.SparqlResultsJson">
            <summary>
            MIME Types for SPARQL Results JSON
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.SparqlResultsBoolean">
            <summary>
            MIME Types for SPARQL Boolean Result
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.Csv">
            <summary>
            MIME Types for CSV
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.Tsv">
            <summary>
            MIME Types for TSV
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.Html">
            <summary>
            MIME Types for HTML
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper.AllowedStackableExtensions">
            <summary>
            Extensions which are considered stackable
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper._mimeTypes">
            <summary>
            List of MIME Type Definition
            </summary>
        </member>
        <member name="F:VDS.RDF.MimeTypesHelper._init">
            <summary>
            Whether MIME Type Definitions have been initialised
            </summary>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.IsValidMimeType(System.String)">
            <summary>
            Checks whether something is a valid MIME Type
            </summary>
            <param name="type">MIME Type</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.IsValidMimeTypePart(System.String)">
            <summary>
            Determines whether the given string is valid as a type/subtype for a MIME type
            </summary>
            <param name="part">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.Init">
            <summary>
            Initialises the MIME Type definitions
            </summary>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.ResetDefinitions">
            <summary>
            Resets the MIME Type Definitions (the associations between file extensions, MIME types and their respective parsers and writers) to the library defaults
            </summary>
            <remarks>
            <para>
            May be useful if you've altered the definitions and caused something to stop working as a result
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.AddDefinition(VDS.RDF.MimeTypeDefinition)">
            <summary>
            Adds a new MIME Type Definition
            </summary>
            <param name="definition">MIME Type Definition</param>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.RegisterParser(VDS.RDF.IRdfReader,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Registers a parser as the default RDF Parser for all the given MIME types and updates relevant definitions to include the MIME types and file extensions
            </summary>
            <param name="parser">RDF Parser</param>
            <param name="mimeTypes">MIME Types</param>
            <param name="fileExtensions">File Extensions</param>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.RegisterParser(VDS.RDF.IStoreReader,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Registers a parser as the default RDF Dataset Parser for all the given MIME types and updates relevant definitions to include the MIME types and file extensions
            </summary>
            <param name="parser">RDF Dataset Parser</param>
            <param name="mimeTypes">MIME Types</param>
            <param name="fileExtensions">File Extensions</param>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.RegisterParser(VDS.RDF.ISparqlResultsReader,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Registers a parser as the default SPARQL Rsults Parser for all the given MIME types and updates relevant definitions to include the MIME types and file extensions
            </summary>
            <param name="parser">SPARQL Results Parser</param>
            <param name="mimeTypes">MIME Types</param>
            <param name="fileExtensions">File Extensions</param>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.RegisterWriter(VDS.RDF.IRdfWriter,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Registers a writer as the default RDF Writer for all the given MIME types and updates relevant definitions to include the MIME types and file extensions
            </summary>
            <param name="writer">RDF Writer</param>
            <param name="mimeTypes">MIME Types</param>
            <param name="fileExtensions">File Extensions</param>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.RegisterWriter(VDS.RDF.IStoreWriter,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Registers a writer as the default RDF Dataset Writer for all the given MIME types and updates relevant definitions to include the MIME types and file extensions
            </summary>
            <param name="writer">RDF Dataset Writer</param>
            <param name="mimeTypes">MIME Types</param>
            <param name="fileExtensions">File Extensions</param>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.RegisterWriter(VDS.RDF.ISparqlResultsWriter,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Registers a writer as the default SPARQL Results Writer for all the given MIME types and updates relevant definitions to include the MIME types and file extensions
            </summary>
            <param name="writer">SPARQL Results Writer</param>
            <param name="mimeTypes">MIME Types</param>
            <param name="fileExtensions">File Extensions</param>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetDefinitions(System.String)">
            <summary>
            Gets all MIME Type definitions which support the given MIME Type
            </summary>
            <param name="mimeType">MIME Type</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetDefinitions(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Gets all MIME Type definitions which support the given MIME Types
            </summary>
            <param name="mimeTypes">MIME Types</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetDefinitionsByFileExtension(System.String)">
            <summary>
            Gets all MIME Types definitions which are associated with a given file extension
            </summary>
            <param name="fileExt">File Extension</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.CustomHttpAcceptHeader(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a Custom HTTP Accept Header containing the given selection of MIME Types
            </summary>
            <param name="mimeTypes">Enumeration of MIME Types to use</param>
            <returns></returns>
            <remarks>
            <para>
            <strong>Note:</strong> No validation is done on MIME Types so it is possible to generated a malformed header using this function
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.CustomHttpAcceptHeader(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a Custom HTTP Accept Header containing the given selection of MIME Types where those MIME Types also appear in the list of supported Types
            </summary>
            <param name="mimeTypes">Enumeration of MIME Types to use</param>
            <param name="supportedTypes">Enumeration of supported MIME Types</param>
            <returns></returns>
            <remarks>
            <para>
            <strong>Note:</strong> No validation is done on MIME Types so it is possible to generated a malformed header using this function
            </para>
            <para>
            Use this function when you wish to generate a Custom Accept Header where the URI to which you are making requests supports a set range of URIs (given in the <paramref name="mimeTypes"/> parameter) where that range of types may exceed the range of types actually supported by the library or your response processing code.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.CustomHttpAcceptHeader(VDS.RDF.IRdfReader)">
            <summary>
            Creates a Custom HTTP Accept Header containing only the Accept Types supported by a specific parser
            </summary>
            <param name="parser">RDF Parser</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.CustomHttpAcceptHeader(VDS.RDF.IStoreReader)">
            <summary>
            Creates a Custom HTTP Accept Header containing only the Accept Types supported by a specific parser
            </summary>
            <param name="parser">RDF Parser</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetFilenameFilter">
            <summary>
            Generates a Filename Filter that can be used with any .Net application and includes all formats that dotNetRDF is aware of
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetFilenameFilter(System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Generates a Filename Filter that can be used with any .Net application and includes a user dictated subset of the formats that dotNetRDF is aware of
            </summary>
            <param name="rdf">Allow RDF Graph formats (e.g. Turtle)</param>
            <param name="rdfDatasets">Allow RDF Dataset formats (e.g. NQuads)</param>
            <param name="sparqlResults">Allow SPARQL Results formats (e.g. SPARQL Results XML)</param>
            <param name="sparqlQuery">Allow SPARQL Query (i.e. .rq files)</param>
            <param name="sparqlUpdate">Allow SPARQL Update (i.e. .ru files)</param>
            <param name="allFiles">Allow All Files (i.e. */*)</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.ApplyWriterOptions(System.Object)">
            <summary>
            Applies global options to a writer
            </summary>
            <param name="writer">Writer</param>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.ApplyParserOptions(System.Object)">
            <summary>
            Applies global options to a parser
            </summary>
            <param name="parser">Parser</param>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetWriter(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Selects an appropriate <see cref="T:VDS.RDF.IRdfWriter">IRdfWriter</see> based on the given MIME Types
            </summary>
            <param name="ctypes">MIME Types</param>
            <returns></returns>
            <remarks>
            <para>
            This method does not take account of any quality/charset preference parameters included in the Accept Header
            </para>
            <para>
            Global options pertaining to writers will be applied to the selected writer
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetWriter(System.Collections.Generic.IEnumerable{System.String},System.String@)">
            <summary>
            Selects an appropriate <see cref="T:VDS.RDF.IRdfWriter">IRdfWriter</see> based on the given MIME Types
            </summary>
            <param name="ctypes">MIME Types</param>
            <param name="contentType">The Content Type header that should be sent in the Response to the Request</param>
            <remarks>
            <para>
            This method does not take account of any quality/charset preference parameters included in the Accept Header
            </para>
            <para>
            Global options pertaining to writers will be applied to the selected writer
            </para>
            </remarks>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetWriter(System.String,System.String@)">
            <summary>
            Selects an appropriate <see cref="T:VDS.RDF.IRdfWriter">IRdfWriter</see> based on the HTTP Accept header form a HTTP Request
            </summary>
            <param name="acceptHeader">Value of the HTTP Accept Header</param>
            <param name="contentType">The Content Type header that should be sent in the Response to the Request</param>
            <returns>A Writer for a Content Type the client accepts and the Content Type that should be sent to the client</returns>
            <remarks>
            <para>
            This method does not take account of any quality/charset preference parameters included in the Accept Header
            </para>
            <para>
            Global options pertaining to writers will be applied to the selected writer
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetWriter(System.String)">
            <summary>
            Selects an appropriate <see cref="T:VDS.RDF.IRdfWriter">IRdfWriter</see> based on the HTTP Accept header form a HTTP Request
            </summary>
            <param name="acceptHeader">Value of the HTTP Accept Header</param>
            <returns>A Writer for a Content Type the client accepts</returns>
            <remarks>
            <para>
            This method does not take account of any quality/charset preference parameters included in the Accept Header
            </para>
            <para>
            Global options pertaining to writers will be applied to the selected writer
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetWriterByFileExtension(System.String)">
            <summary>
            Selects a <see cref="T:VDS.RDF.IRdfWriter"/> based on the file extension
            </summary>
            <param name="fileExt">File Extension</param>
            <exception cref="T:VDS.RDF.Writing.RdfWriterSelectionException">Thrown if no writers are associated with the given file extension</exception>
            <remarks>
            <para>
            Global options pertaining to writers will be applied to the selected writer
            </para>
            </remarks>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetWriterByFileExtension(System.String,System.String@)">
            <summary>
            Selects a <see cref="T:VDS.RDF.IRdfWriter"/> based on the file extension
            </summary>
            <param name="fileExt">File Extension</param>
            <param name="contentType">Content Type of the chosen writer</param>
            <exception cref="T:VDS.RDF.Writing.RdfWriterSelectionException">Thrown if no writers are associated with the given file extension</exception>
            <remarks>
            <para>
            Global options pertaining to writers will be applied to the selected writer
            </para>
            </remarks>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetParser(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Selects an appropriate <see cref="T:VDS.RDF.IRdfReader">IRdfReader</see> based on the given MIME Types
            </summary>
            <param name="ctypes">MIME TYpes</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetParser(System.String)">
            <summary>
            Selects an appropriate <see cref="T:VDS.RDF.IRdfReader">IRdfReader</see> based on the HTTP Content-Type header from a HTTP Response
            </summary>
            <param name="contentType">Value of the HTTP Content-Type Header</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetParserByFileExtension(System.String)">
            <summary>
            Selects a <see cref="T:VDS.RDF.IRdfReader"/> based on the file extension
            </summary>
            <param name="fileExt">File Extension</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetSparqlParser(System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
            <summary>
            Selects a SPARQL Parser based on the MIME types
            </summary>
            <param name="ctypes">MIME Types</param>
            <param name="allowPlainTextResults">Whether to allow for plain text results</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetSparqlParser(System.String)">
            <summary>
            Selects an appropriate <see cref="T:VDS.RDF.ISparqlResultsReader">ISparqlResultsReader</see> based on the HTTP Content-Type header from a HTTP Response
            </summary>
            <param name="contentType">Value of the HTTP Content-Type Header</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetSparqlParser(System.String,System.Boolean)">
            <summary>
            Selects an appropriate <see cref="T:VDS.RDF.ISparqlResultsReader">ISparqlResultsReader</see> based on the HTTP Content-Type header from a HTTP Response
            </summary>
            <param name="contentType">Value of the HTTP Content-Type Header</param>
            <param name="allowPlainTextResults">Whether you allow Sparql Boolean results in text/plain format (Boolean results in text/boolean are handled properly but text/plain results can be conflated with CONSTRUCT/DESCRIBE results in NTriples format)</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetSparqlParserByFileExtension(System.String)">
            <summary>
            Selects a <see cref="T:VDS.RDF.ISparqlResultsReader"/> based on the file extension
            </summary>
            <param name="fileExt">File Extension</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetSparqlWriter(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Selects an appropriate <see cref="T:VDS.RDF.ISparqlResultsWriter">ISparqlResultsWriter</see> based on the given MIME Types
            </summary>
            <param name="ctypes">MIME Types</param>
            <returns>A Writer for a Content Type the client accepts</returns>
            <remarks>
            <para>
            This method does not take account of any quality/charset preference parameters included in the Accept Header
            </para>
            <para>
            Global options pertaining to writers will be applied to the selected writer
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetSparqlWriter(System.Collections.Generic.IEnumerable{System.String},System.String@)">
            <summary>
            Selects an appropriate <see cref="T:VDS.RDF.ISparqlResultsWriter">ISparqlResultsWriter</see> based on the HTTP Accept header form a HTTP Request
            </summary>
            <param name="ctypes">String array of accepted Content Types</param>
            <param name="contentType">The Content Type header that should be sent in the Response to the Request</param>
            <returns>A Writer for a Content Type the client accepts and the Content Type that should be sent to the client</returns>
            <remarks>
            <para>
            This method does not take account of any quality/charset preference parameters included in the Accept Header
            </para>
            <para>
            Global options pertaining to writers will be applied to the selected writer
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetSparqlWriter(System.String,System.String@)">
            <summary>
            Selects an appropriate <see cref="T:VDS.RDF.ISparqlResultsWriter">ISparqlResultsWriter</see> based on the HTTP Accept header form a HTTP Request
            </summary>
            <param name="acceptHeader">Value of the HTTP Accept Header</param>
            <param name="contentType">The Content Type header that should be sent in the Response to the Request</param>
            <returns>A Writer for a Content Type the client accepts and the Content Type that should be sent to the client</returns>
            <remarks>
            <para>
            This method does not take account of any quality/charset preference parameters included in the Accept Header
            </para>
            <para>
            Global options pertaining to writers will be applied to the selected writer
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetSparqlWriter(System.String)">
            <summary>
            Selects an appropriate <see cref="T:VDS.RDF.ISparqlResultsWriter">ISparqlResultsWriter</see> based on the HTTP Accept header form a HTTP Request
            </summary>
            <param name="acceptHeader">Value of the HTTP Accept Header</param>
            <returns>A Writer for a Content Type the client accepts</returns>
            <remarks>
            <para>
            This method does not take account of any quality/charset preference parameters included in the Accept Header
            </para>
            <para>
            Global options pertaining to writers will be applied to the selected writer
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetSparqlWriterByFileExtension(System.String)">
            <summary>
            Selects a <see cref="T:VDS.RDF.ISparqlResultsWriter"/> based on a file extension
            </summary>
            <param name="fileExt">File Extension</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetSparqlWriterByFileExtension(System.String,System.String@)">
            <summary>
            Selects a <see cref="T:VDS.RDF.ISparqlResultsWriter"/> based on a file extension
            </summary>
            <param name="fileExt">File Extension</param>
            <param name="contentType">Content Type of the selected writer</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetStoreParser(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Selects a Store parser based on the MIME types
            </summary>
            <param name="ctypes">MIME Types</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetStoreParser(System.String)">
            <summary>
            Selects an appropriate <see cref="T:VDS.RDF.IStoreReader">IStoreReader</see> based on the HTTP Content-Type header from a HTTP Response
            </summary>
            <param name="contentType">Value of the HTTP Content-Type Header</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetStoreParserByFileExtension(System.String)">
            <summary>
            Selects a Store parser based on the file extension
            </summary>
            <param name="fileExt">File Extension</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetStoreWriter(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Selects an appropriate <see cref="T:VDS.RDF.IStoreWriter">IStoreWriter</see> based on the given MIME Types
            </summary>
            <param name="ctypes">MIME Types</param>
            <returns></returns>
            <remarks>
            <para>
            This method does not take account of any quality/charset preference parameters included in the Accept Header
            </para>
            <para>
            For writers which support <see cref="T:VDS.RDF.Writing.ICompressingWriter">ICompressingWriter</see> they will be instantiated with the Compression Level specified by <see cref="P:VDS.RDF.Options.DefaultCompressionLevel">Options.DefaultCompressionLevel</see>
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetStoreWriter(System.Collections.Generic.IEnumerable{System.String},System.String@)">
            <summary>
            Selects an appropriate <see cref="T:VDS.RDF.IStoreWriter">IStoreWriter</see> based on the given MIME Types
            </summary>
            <param name="ctypes">MIME Types</param>
            <param name="contentType">The Content Type header that should be sent in the Response to the Request</param>
            <returns></returns>
            <remarks>
            <para>
            This method does not take account of any quality/charset preference parameters included in the Accept Header
            </para>
            <para>
            For writers which support <see cref="T:VDS.RDF.Writing.ICompressingWriter">ICompressingWriter</see> they will be instantiated with the Compression Level specified by <see cref="P:VDS.RDF.Options.DefaultCompressionLevel">Options.DefaultCompressionLevel</see>
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetStoreWriter(System.String,System.String@)">
            <summary>
            Selects an appropriate <see cref="T:VDS.RDF.IStoreWriter">IStoreWriter</see> based on the HTTP Accept header form a HTTP Request
            </summary>
            <param name="acceptHeader">Value of the HTTP Accept Header</param>
            <param name="contentType">The Content Type header that should be sent in the Response to the Request</param>
            <returns>A Writer for a Content Type the client accepts and the Content Type that should be sent to the client</returns>
            <remarks>This method does not take account of any quality/charset preference parameters included in the Accept Header</remarks>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetStoreWriter(System.String)">
            <summary>
            Selects an appropriate <see cref="T:VDS.RDF.IStoreWriter">IStoreWriter</see> based on the HTTP Accept header form a HTTP Request
            </summary>
            <param name="acceptHeader">Value of the HTTP Accept Header</param>
            <returns>A Writer for a Content Type the client accepts</returns>
            <remarks>This method does not take account of any quality/charset preference parameters included in the Accept Header</remarks>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetStoreWriterByFileExtension(System.String)">
            <summary>
            Selects a <see cref="T:VDS.RDF.IStoreWriter"/> by file extension
            </summary>
            <param name="fileExt">File Extension</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetStoreWriterByFileExtension(System.String,System.String@)">
            <summary>
            Selects a <see cref="T:VDS.RDF.IStoreWriter"/> by file extension
            </summary>
            <param name="fileExt">File Extension</param>
            <param name="contentType">Content Type of the selected writer</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetMimeType(System.String)">
            <summary>
            Selects the appropriate MIME Type for the given File Extension if the File Extension is a standard extension for an RDF format
            </summary>
            <param name="fileExt">File Extension</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetMimeTypes(System.String)">
            <summary>
            Gets all the MIME Types associated with a given File Extension
            </summary>
            <param name="fileExt">File Extension</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetTrueFileExtension(System.String)">
            <summary>
            Gets the true file extension for a filename
            </summary>
            <param name="filename"></param>
            <returns></returns>
            <remarks>
            <para>
            This is an alternative to using <see cref="!:System.IO.Path.GetExtension(String)"/> which is designed to take into account known extensions which are used in conjunction with other extensions and mask the true extension, for example <strong>.gz</strong>
            </para>
            <para>
            Consider the filename <strong>example.ttl.gz</strong>, obtaining the extension the standard way gives only <strong>.gz</strong> which is unhelpful since it doesn't actually tell us the underlying format of the data only that it is GZipped and if it is GZipped we almost certainly want to stream the data rather than read all into memory and heuristically detect the actual format.  Instead we'd like to get <strong>.ttl.gz</strong> as the file extension which is much more useful and this is what this function does.
            </para>
            <para>
            <strong>Important:</strong> This method does not blindly return double extensions whenever they are present (since they may simply by period characters in the filename and not double extensions at all) rather it returns double extensions only when the standard extension is an extension is known to be used with double extensions e.g. <strong>.gz</strong> that is relevan to the library
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetTrueResourceExtension(System.String)">
            <summary>
            Gets the true extension for a resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetFileExtension(System.String)">
            <summary>
            Selects the appropriate File Extension for the given MIME Type
            </summary>
            <param name="mimeType">MIME Type</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetFileExtension(VDS.RDF.IRdfWriter)">
            <summary>
            Selects the appropriate File Extension for the given RDF Writer
            </summary>
            <param name="writer">RDF Writer</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypesHelper.GetFileExtension(VDS.RDF.IStoreWriter)">
            <summary>
            Selects the appropriate File Extension for the given Store Writer
            </summary>
            <param name="writer">Store Writer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.MimeTypesHelper.Definitions">
            <summary>
            Gets the available MIME Type Definitions
            </summary>
        </member>
        <member name="P:VDS.RDF.MimeTypesHelper.HttpAcceptHeader">
            <summary>
            Builds the String for the HTTP Accept Header that should be used when you want to ask for content in RDF formats (except Sparql Results)
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.MimeTypesHelper.HttpSparqlAcceptHeader">
            <summary>
            Builds the String for the HTTP Accept Header that should be used for querying Sparql Endpoints where the response will be a SPARQL Result Set format
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.MimeTypesHelper.HttpRdfOrSparqlAcceptHeader">
            <summary>
            Builds the String for the HTTP Accept Header that should be used for making HTTP Requests where the returned data may be RDF or a SPARQL Result Set
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.MimeTypesHelper.HttpRdfDatasetAcceptHeader">
            <summary>
            Builds the String for the HTTP Accept Header that should be used for making HTTP Requests where the returned data will be an RDF dataset
            </summary>
        </member>
        <member name="P:VDS.RDF.MimeTypesHelper.HttpRdfOrDatasetAcceptHeader">
            <summary>
            Builds the String for the HTTP Accept Header that should be used for making HTTP Requests where the returned data may be RDF or an RDF dataset
            </summary>
        </member>
        <member name="P:VDS.RDF.MimeTypesHelper.SupportedRdfMimeTypes">
            <summary>
            Gets the Enumeration of supported MIME Types for RDF Graphs
            </summary>
        </member>
        <member name="P:VDS.RDF.MimeTypesHelper.SupportedRdfDatasetMimeTypes">
            <summary>
            Gets the Enumeration of supported MIME Types for RDF Datasets
            </summary>
        </member>
        <member name="P:VDS.RDF.MimeTypesHelper.SupportedSparqlMimeTypes">
            <summary>
            Gets the Enumeration of supported MIME Types for SPARQL Results
            </summary>
        </member>
        <member name="P:VDS.RDF.MimeTypesHelper.SupportedRdfOrSparqlMimeTypes">
            <summary>
            Gets the Enumeration of supported MIME Types for RDF Graphs or SPARQL Results
            </summary>
        </member>
        <member name="T:VDS.RDF.NamespaceDoc">
            <summary>
            <para>
            Top Level Namespace for the <strong>dotNetRDF Library</strong> which embodies a simple but powerful API for working with RDF and SPARQL.   
            </para>
            <para>
            Specific Namespaces within the Hierarchy provide <see cref="N:VDS.RDF.Parsing">Parsing</see> and <see cref="N:VDS.RDF.Writing">Serialization</see> functionality along with a host of related classes to support these functions.
            </para>
            <para>
            Support for querying RDF is provided in the <see cref="N:VDS.RDF.Query">Query</see> namespace which includes SPARQL Query, limited reasoning support in the <see cref="N:VDS.RDF.Query.Inference">Query.Inference</see> namespace and a Pellet Server client in the <see cref="N:VDS.RDF.Query.Inference.Pellet">Query.Inference.Pellet</see> namespace.
            </para>
            <para>
            Support for updating RDF based on the SPARQL 1.1 Update and Graph Store HTTP Protocol for RDF Graph Management is provided in the <see cref="N:VDS.RDF.Update">Update</see> and <see cref="N:VDS.RDF.Update.Protocol">Update.Protocol</see> namespaces.
            </para>
            <h3>Third Party Storage</h3>
            <para>For communicating with arbitrary Triple Stores we have a dedicated <see cref="N:VDS.RDF.Storage">Storage</see> namespace.  As of this release we support the following Triple Stores:
            <ul>
                <li>AllegroGraph</li>
                <li>Dydra</li>
                <li>4store</li>
                <li>Fuseki</li>
                <li>Any Sesame HTTP Protocol compliant store e.g. Sesame, OWLIM</li>
                <li>Any SPARQL Graph Store HTTP Protocol for RDF Graph Management compliant stores</li>
                <li>Any SPARQL store that exposes a Query and/or Update endpoint</li>
                <li>Stardog</li>
                <li>Virtuoso</li>
            </ul>
            </para>
            <h3>ASP.Net Integration</h3>
            <para>
            For those building ASP.Net based websites the <see cref="N:VDS.RDF.Web">Web</see> namespace is dedicated to providing classes for integrating RDF into ASP.Net applications.
            </para>
            <h3>Ontology API</h3>
            <para>
            There is also an <see cref="N:VDS.RDF.Ontology">Ontology</see> namespace which provides a more resource and ontology centric API for working with RDF than the standard Graph and Triple centric APIs
            </para>
            <h3>Configuration API</h3>
            <para>
            We provide a <see cref="N:VDS.RDF.Configuration">Configuration</see> API which provides for encoding configuration in RDF Graphs.  This configuration system is used extensively as part of the ASP.Net support as it allows for much more expressive and flexible configurations than were previously possible.  See the <a href="http://www.dotnetrdf.org/content.asp?pageID=Configuration%20API">documentation</a> on the main website for many detailed examples.  This is primarily intended as an easy way to help deploy configurations for ASP.Net applications though you can make use of the API to describe the configuration of various types of objects in other applications, for example we use it in our Store Manager utility to store connection details.
            </para>
            <h3>Notes</h3>
            <para>
            dotNetRDF 1.0.0 is now considered a stable release, this means it should be stable for production scenarios.  However it is open source software and despite our best efforts there may still be bugs.  Please help us improve this library by emailing us when you find a bug, you can use the <a href="mailto:dotnetrdf-bugs@lists.sourceforge.net">Bug Reports list</a> to report bugs, the <a href="mailto:dotnetrdf-support@lists.sourceforge.net">Support list</a> to ask questions and the <a href="mailto:dotnetrdf-develop@lists.sourceforge.net">Developer list</a> to request new features or discuss development plans (all these are SourceForge mailing lists which require subscription).
            </para>
            <h4>Alternative Builds</h4>
            <h5>Mono Build</h5>
            <para>
            There is no separate build for Mono since dotNetRDF can run directly under Mono.  Note that there may still be some features of .Net we use that Mono does not fully support, see the <a href="http://www.dotnetrdf.org/content.asp?pageID=Mono%20Issues">Mono Issues</a> page for more details.  We recommend Mono 2.10 or higher though the library should run on recent 2.6/2.8 releases.
            </para>
            <h5>Client Profile Build</h5>
            <para>
            The Client Profile build omits the reference to <see cref="!:System.Web">System.Web</see> so lacks the ASP.Net integration and some other features that rely on this dependency but is otherwise a fairly complete build of the library.
            </para>
            <h5>Silverlight/Windows Phone 7 Build</h5>
            <para>
            The Silverlight and Windows Phone 7 builds of dotNetRDF (<em>dotNetRDF.Silverlight.dll</em> and <em>dotNetRDF.WindowsPhone.dll</em>) are experimental builds that receive limited internal testing so please be aware that these are not as stable as the standard .Net builds.  These build runs on Silverlight 4/Windows Phone 7 and omits the following features since they can't be supported on these platforms:
            </para>
            <ul>
                <li>Most of the <see cref="N:VDS.RDF.Web">Web</see> namespaces</li>
                <li>Does not include parts of the <see cref="N:VDS.RDF.Storage">Storage</see> namespace that would require synchronous HTTP</li>
                <li>No String normalization support</li>
                <li>No <see cref="T:VDS.RDF.Parsing.UriLoader">UriLoader</see> caching support</li>
                <li>No multi-threaded support where <see cref="!:System.Threading.ReaderWriteLockSlim">ReaderWriterLockSlim</see> is used</li>
                <li>Various writers and parsers use streaming rather than DOM based XML parsing</li>
                <li>No support for XSL in TriX files</li>
                <li>Synchronous HTTP Request Features - For most of these there are asynchronous callback driven versions of these features available from the 0.5.0 release onwards</li>
            </ul>
            </summary>
        </member>
        <member name="T:VDS.RDF.Configuration.NamespaceDoc">
            <summary>
            <para>
            Namespace for Configuration Classes which are used for dynamic loading of Configuration serialized as RDF Graphs.
            </para>
            <para>
            This API which provides for encoding dotNetRDF centric configuration in RDF Graphs though it can be extended to serialize and deserialize arbitrary objects if desired.  This configuration API is used extensively with our ASP.Net support as it allows for highly expressive and flexible configurations.  See the <a href="http://www.dotnetrdf.org/content.asp?pageID=Configuration%20API">documentation</a> on the main website for many detailed examples.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Configuration.Permissions.NamespaceDoc">
            <summary>
            <para>
            Namespace for classes related to configuring Permissions
            </para>
            <para>
            <strong>Warning:</strong> The API here is experimental and may changed/be removed in future releases
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Nodes.NamespaceDoc">
            <summary>
            Namespace for specialised node implementations and the <see cref="T:VDS.RDF.Nodes.IValuedNode"/> interface, this is an extension of the <see cref="T:VDS.RDF.INode"/> interface that provides strongly typed access to the value of a node.
            <para>
            These implementations are primarily used internally in the SPARQL engine, however as these all derive from the standard <see cref="T:VDS.RDF.INode"/> implementations they can be used interchangeably with those if desired.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Ontology.NamespaceDoc">
            <summary>
            <para>
            The Ontology Namespace is based upon <a href="http://jena.sourceforge.net/ontology/">Jena's Ontology API</a>.  It allows for a more ontology-centric way of manipulating RDF graphs within the dotNetRDF API.
            </para>
            <para>
            The <see cref="T:VDS.RDF.Ontology.OntologyResource">OntologyResource</see> is the base class of resources and allows for the retrieval and manipulation of various common properties of a resource.  More specialised classes like <see cref="T:VDS.RDF.Ontology.OntologyClass">OntologyClass</see> and <see cref="T:VDS.RDF.Ontology.OntologyProperty">OntologyProperty</see> are used to work with classes and properties etc.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.NamespaceDoc">
            <summary>
            <para>
            Namespace for Parsing classes and variety of supporting Classes.
            </para>
            <para>
            Classes here are primarily implementations of <see cref="T:VDS.RDF.IRdfReader">IRdfReader</see> with some implementations of <see cref="T:VDS.RDF.IStoreReader">IStoreReader</see> and a few other specialised classes.
            </para>
            <para>
            Has child namespaces <see cref="N:VDS.RDF.Parsing.Events">Events</see> and <see cref="N:VDS.RDF.Parsing.Tokens">Tokens</see> for supporting Event and Token based Parsing.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Contexts.NamespaceDoc">
            <summary>
            <para>
            Namespace for Parser Context classes, these are classes that are used internally by parsers to store their state.  This allows parsers to be safely used in a multi-threaded scenario so the parsing of one Graph/Store cannot affect the parsing of another.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.NamespaceDoc">
            <summary>
            Namespace for Event classes which are used to support Event Based parsing of RDF syntaxes
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Handlers.NamespaceDoc">
            <summary>
            <para>
            Namespace for RDF and SPARQL Results Handlers
            </para>
            <para>
            Handlers are a powerful low level part of the parsers API, they allow you to parse RDF, RDF Datasets and SPARQL Results in such a way that you can take arbitrary actions with the data and choose to end parsing as soon as desired.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.NamespaceDoc">
            <summary>
            <para>
            Namespace for Token classes which are used to support Token Based parsing of RDF syntaxes
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Validation.NamespaceDoc">
            <summary>
            <para>
            Namespace for Validator classes that can be used to validate various forms of syntax
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.NamespaceDoc">
            <summary>
            <para>
            Namespace for Query Classes which provide querying capabilities on RDF.
            </para>
            <para>
            Query capabilities are centered around support for the SPARQL standard.  You can execute full SPARQL 1.1 queries over in-memory data or submit queries to remote SPARQL endpoints.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Aggregates.NamespaceDoc">
            <summary>
            <para>
            Namespace for Aggregate classes which implement Aggregate functions for SPARQL
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Aggregates.Leviathan.NamespaceDoc">
            <summary>
            Namespace for aggregates provided by the Leviathan function library
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Aggregates.Sparql.NamespaceDoc">
            <summary>
            Namespace for the built-in SPARQL aggregates
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Aggregates.XPath.NamespaceDoc">
            <summary>
            Namespace for aggregates provided by the XPath function library
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.NamespaceDoc">
            <summary>
            <para>
            Contains the classes which model the mapping of SPARQL queries into the SPARQL Algebra.  This namespace is a key component of the new <strong>Leviathan</strong> SPARQL engine introduced in the 0.2.x builds of dotNetRDF
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Construct.NamespaceDoc">
            <summary>
            <para>
            Namespace for classes used in executing CONSTRUCT queries
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Datasets.NamespaceDoc">
            <summary>
            <para>
            Namespace for classes used to define a Dataset over which SPARQL Queries and Updates evaluated using the Leviathan engine operate
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Describe.NamespaceDoc">
            <summary>
            <para>
            Namespace for classes which implement algorithms for executing DESCRIBE queries
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.NamespaceDoc">
            <summary>
            <para>
            Namespace containing all the classes related to the execution of expressions in SPARQL queries.  Any valid expression should be able to be modelled and executed using these clases.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Arithmetic.NamespaceDoc">
            <summary>
            Namespace containing expression classes pertaining to arithmetic operations
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Comparison.NamespaceDoc">
            <summary>
            Namespace containing expression classes pertaining to comparison operations
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Conditional.NamespaceDoc">
            <summary>
            Namespace containing expression classes pertaining to conditional operations
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.NamespaceDoc">
            <summary>
            <para>
            Namespace containing expression classes which model functions in SPARQL expressions
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Arq.NamespaceDoc">
            <summary>
            Namespace containing expression classes which provide the ARQ function library
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.NamespaceDoc">
            <summary>
            Namespace containing expression classes which provide the Leviathan function library
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Hash.NamespaceDoc">
            <summary>
            Namespace containing expression classes which provide the hash functions from the Leviathan function library
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.NamespaceDoc">
            <summary>
            Namespace containing expression classes which provide the numeric functions from the Leviathan function library
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.NamespaceDoc">
            <summary>
            Namespace containing expression classes which provide the trigonometric functions from the Leviathan function library
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.NamespaceDoc">
            <summary>
            Namespace containing expression classes which provide the SPARQL built-in functions
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.NamespaceDoc">
            <summary>
            Namespace containing expression classes which provide the SPARQL built-in functions which have boolean results
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.NamespaceDoc">
            <summary>
            Namespace containing expression classes which provide the SPARQL built-in functions which construct new terms
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.NamespaceDoc">
            <summary>
            Namespace containing expression classes which provide the SPARQL built-in functions pertaining to date times
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Hash.NamespaceDoc">
            <summary>
            Namespace containing expression classes which provide the SPARQL built-in functions pertaining to hash algorithms
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Numeric.NamespaceDoc">
            <summary>
            Namespace containing expression classes which provide the SPARQL built-in numeric functions
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Set.NamespaceDoc">
            <summary>
            Namespace containing expression classes which provide the SPARQL built-in functions pertaining to sets (IN and NOT IN)
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.String.NamespaceDoc">
            <summary>
            Namespace containing expression classes which provide the SPARQL built-in functions pertaining to string manipulation
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.NamespaceDoc">
            <summary>
            Namespace containing expression classes which provide functions from the XPath function library
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.Cast.NamespaceDoc">
            <summary>
            Namespace containing expression classes which provide cast functions from the XPath function library
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.NamespaceDoc">
            <summary>
            Namespace containing expression classes which provide date time functions from the XPath function library
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.NamespaceDoc">
            <summary>
            Namespace containing expression classes which provide numeric functions from the XPath function library
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.String.NamespaceDoc">
            <summary>
            Namespace containing expression classes which provide string functions from the XPath function library
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Primary.NamespaceDoc">
            <summary>
            Namespace containing expression classes representing primary constructs in SPARQL expression trees i.e. constants, modifiers and variables
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Filters.NamespaceDoc">
            <summary>
            <para>
            Namespace containing classes pertaining to the filtering of the results of SPARQL queries
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Grouping.NamespaceDoc">
            <summary>
            <para>
            Namespace containing classes used to apply GROUP BY clauses to SPARQL queries
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Inference.NamespaceDoc">
            <summary>
            <para>
            Namespace for Inference Classes which provide Inferencing capabilities on RDF - these features are currently experimental and may not work as expected.
            </para>
            <para>
            Classes which implement reasoning must implement the <see cref="T:VDS.RDF.Query.Inference.IInferenceEngine">IInferenceEngine</see> interface, these can then be attached to classes which implement the <see cref="T:VDS.RDF.IInferencingTripleStore">IInferencingTripleStore</see> interface or they can be used to apply inference to any <see cref="T:VDS.RDF.IGraph">IGraph</see> implementation with the inferred Triples optionally output to a separate Graph.
            </para>
            <para>
            OWL reasoning currently has extremely limited support, we provide a Pellet client in the <see cref="N:VDS.RDF.Query.Inference.Pellet">Pellet</see> namespace which can be used to connect to a Pellet Server but that currently only provides reasoning on external knowledge bases on the Pellet Server
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.NamespaceDoc">
            <summary>
            <para>
            Namespace which provides a client for interacting with a Pellet Server
            </para>
            <para>
            Due to Pellet Server being a relatively new product it is currently only possible to reason over external knowledge bases on a Pellet Server and not to use Pellet to reason over in-memory data.  As Pellet Server is updated in the future this client will be updated to take advantage of those updates and to eventually provide for in-memory reasoning.  You may also want to consider using the <see cref="T:VDS.RDF.Storage.StardogConnector"/> which is the triple store from the same people who developed Pellet and which integrates some Pellet capabilities.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.Services.NamespaceDoc">
            <summary>
            <para>
            Namespace which provides classes which represent the Services offered by a Pellet Server knowledge base
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Operators.NamespaceDoc">
            <summary>
            <para>
            Namespace which provides classes which represent the implementation of various operators in SPARQL.  This allows for some of the basic operators like + and - to be extended to allow functionality beyond the SPARQL specification such as date time arithmetic.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Operators.DateTime.NamespaceDoc">
            <summary>
            <para>
            Namespace which provides implementations of <see cref="T:VDS.RDF.Query.Operators.ISparqlOperator"/> which allow for embedding date time arithmetic into SPARQL queries
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Operators.Numeric.NamespaceDoc">
            <summary>
            <para>
            Namespace which provides implementations of <see cref="T:VDS.RDF.Query.Operators.ISparqlOperator"/> which provide the default numeric implementations of operators as required by the SPARQL specification
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Optimisation.NamespaceDoc">
            <summary>
            <para>
            Namespace containing classes that are used in the Optimisation of SPARQL Queries.  Includes the interfaces <see cref="T:VDS.RDF.Query.Optimisation.IQueryOptimiser">IQueryOptimiser</see> and <see cref="T:VDS.RDF.Query.Optimisation.IAlgebraOptimiser">IAlgebraOptimiser</see> which can be used to implement custom query optimisation. 
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Ordering.NamespaceDoc">
            <summary>
            <para>
            Namespace containing classes used to order the results of SPARQL queries
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Paths.NamespaceDoc">
            <summary>
            <para>
            Contains the classes which model property paths in SPARQL, they can be used to both represent and evaluate a property path as part of a SPARQL query.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Patterns.NamespaceDoc">
            <summary>
            Namespace for Pattern Classes that are used in the Graph and Triple matching process for executing SPARQL queries on <see cref="T:VDS.RDF.IInMemoryQueryableStore">IInMemoryQueryableStore</see> objects
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.PropertyFunctions.NamespaceDoc">
            <summary>
            Namespace which provide classes relating to the property function extension point of SPARQL
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.NamespaceDoc">
            <summary>
            <para>
            Namespace for ctorage classes which provide support for using arbitrary backing Stores
            </para>
            <para>
            Storage is managed via the <see cref="T:VDS.RDF.Storage.IStorageProvider">IStorageProvider</see> interface, see the <a href="http://www.dotnetrdf.org/content.asp?pageID=Triple%20Store%20Integration">Triple Store Integration</a> documentation on the main website for more detail.
            </para>
            <h3>Data Provider Libraries</h3>
            <para>
            From the 0.5.0 release onwards any triple store integration that requires additional dependencies are provided with their own library to reduce dependencies in the Core library and allow that functionality to be optional.  The following stores are currently provided in separate libraries:
            </para>
            <ul>
                <li>Virtuoso - Virtuoso support can be found in the <strong>dotNetRDF.Data.Virtuoso.dll</strong> library and requires one additional dependency.</li>
            </ul>
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.Management.NamespaceDoc">
            <summary>
            <para>
            Namespace for storage classes which provide support for managing servers that provide multiple backing Stores
            </para>
            <para>
            Servers are managed via the <see cref="T:VDS.RDF.Storage.Management.IStorageServer"/> interface, a server can provide lists of available stores, retrieve a reference to a store, create new stores and delete existing stores.  The exact capabilites may depend on the implementation and may be inspected via the <see cref="P:VDS.RDF.Storage.Management.IStorageServer.IOBehaviour"/> property.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.Management.Provisioning.NamespaceDoc">
            <summary>
            <para>
            Namespace for storage classes which provide support for creating new stores in conjunction with a <see cref="T:VDS.RDF.Storage.Management.IStorageServer"/>
            </para>
            <para>
            In order for an <see cref="T:VDS.RDF.Storage.Management.IStorageServer"/> to create a new store it requires an instance of the <see cref="T:VDS.RDF.Storage.Management.Provisioning.IStoreTemplate"/> interface from this namespace.  The basic interface provides only a Store ID, specific implementations may provide many more customizable properties to allow new stores to be created that take advantage of the capabilties of the server the store is being created on.  A <see cref="T:VDS.RDF.Storage.Management.IStorageServer"/> provides methods to generate the basic templates that it accepts and should be used in preference to creating any of the implementations directly.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.Management.Provisioning.Sesame.NamespaceDoc">
            <summary>
            <para>
            Namespace containing implementations of <see cref="T:VDS.RDF.Storage.Management.Provisioning.IStoreTemplate"/> which provide templates for creating new stores on Sesame servers
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.Management.Provisioning.Stardog.NamespaceDoc">
            <summary>
            <para>
            Namespace containing implementations of <see cref="T:VDS.RDF.Storage.Management.Provisioning.IStoreTemplate"/> which provide templates for creating new stores on Stardog servers
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Update.NamespaceDoc">
            <summary>
            <para>
            Namespace for performing updates on Triple Stores using SPARQL Update
            </para>
            <para>
            This is a new part of the API introduced in the 0.3.0 release and adds support for using SPARQL to update Triple Stores.  SPARQL Update is part of the new SPARQL 1.1 standard and provides syntax for inserting, modifying and deleting data as well as managing graphs in a store.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Update.Commands.NamespaceDoc">
            <summary>
            <para>
            Namespace containing classes which model SPARQL Update Commands.  These can be used both to represent SPARQL Updates and to execute them over in-memory stores.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Update.Protocol.NamespaceDoc">
            <summary>
            <para>
            Namespaces containing classes which implement the SPARQL Graph Store HTTP Protocol for RDF Graph Management
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Web.NamespaceDoc">
            <summary>
            <para>
            Namespace for Classes designed to aid the deployment of Linked Data, SPARQL Endpoints and other Semantic Web technologies as part of ASP.Net web applications.
            </para>
            <para>
            The ASP.Net support leverages the <see cref="N:VDS.RDF.Configuration">Configuration API</see> heavily and so only requires only 1 &lt;appSetting&gt; like so:
            <code>
            &lt;add key="dotNetRDFConfig" value="~/App_Data/config.ttl" /&gt;
            </code>
            This setting provides a pointer to an RDF configuration graph that uses the <a href="http://www.dotnetrdf.org/configuration#">Configuration Vocabulary</a> to express the configuration of HTTP Handlers for your ASP.Net application.  We also now provide a command line tool <a href="http://www.dotnetrdf.org/content.asp?pageID=rdfWedDeploy">rdfWebDeploy</a> which can be used to automate the testing and deployment of this configuration.  See documentation on the <a href="http://www.dotnetrdf.org/content.asp?pageID=Configuration%20API">Configuration API</a> for more detail.  Individual handler documentation gives basic examples of Handler configurations.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Web.Configuration.NamespaceDoc">
            <summary>
            <para>
            Namespace for Configuration classes which are used to load and store the configuration settings for HTTP Handlers provided as part of the <strong>Web</strong> namespace.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Web.Configuration.Protocol.NamespaceDoc">
            <summary>
            <para>
            Namespace for Configuration classes which are used to load and store the configuration settings for SPARQL Graph Store HTTP Protocol
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Web.Configuration.Query.NamespaceDoc">
            <summary>
            <para>
            Namespace for Configuration classes which are used to load and store the configuration settings for SPARQL Query handlers
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Web.Configuration.Resource.NamespaceDoc">
            <summary>
            <para>
            Namespace for Configuration classes which are used to load and store the configuration settings for handlers which serve resources such as Graphs
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Web.Configuration.Server.NamespaceDoc">
            <summary>
            <para>
            Namespace for Configuration classes which are used to load and store the configuration settings for SPARQL Servers
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Web.Configuration.Update.NamespaceDoc">
            <summary>
            <para>
            Namespace for Configuration classes which are used to load and store the configuration settings for SPARQL Update handlers
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.NamespaceDoc">
            <summary>
            <para>
            Namespace for Writing Classes which provide the means to Serialize RDF Graphs as concrete RDF syntaxes or graphical representations.
            </para>
            <para>
            Also contains classes that can be used to save Graphs and Triple Stores to arbitrary database backed storage using classes from the <see cref="N:VDS.RDF.Storage">Storage</see> namespace.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.Contexts.NamespaceDoc">
            <summary>
            <para>
            Namespace for Writer Context classes, these are classes that are used internally by writers to store their state.  This allows writers to be safely used in a multi-threaded scenario since the writing of one Graph/Store cannot affect the writing of another.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.Formatting.NamespaceDoc">
            <summary>
            <para>
            Namespace for Formatter Classes which can be used to format <see cref="T:VDS.RDF.Triple">Triples</see>, <see cref="T:VDS.RDF.INode">Nodes</see> and <see cref="T:System.Uri">URIs</see> among other types.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.Serialization.NamespaceDoc">
            <summary>
            <para>
            Namespace for classes related to .Net serialization integration in the library
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.NamespaceChanged">
            <summary>
            Delegate Type for the Events of the Namespace Mapper
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="uri">Namespace Uri</param>
        </member>
        <member name="T:VDS.RDF.NamespaceMapper">
            <summary>
            Class for representing Mappings between Prefixes and Namespace URIs
            </summary>
        </member>
        <member name="T:VDS.RDF.INamespaceMapper">
            <summary>
            Interface for Namespace Maps which provide mappings between Namespace Prefixes and Namespace URIs
            </summary>
        </member>
        <member name="M:VDS.RDF.INamespaceMapper.AddNamespace(System.String,System.Uri)">
            <summary>
            Adds a Namespace to the Namespace Map
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="uri">Namespace Uri</param>
        </member>
        <member name="M:VDS.RDF.INamespaceMapper.Clear">
            <summary>
            Clears the Namespace Map
            </summary>
        </member>
        <member name="M:VDS.RDF.INamespaceMapper.GetNamespaceUri(System.String)">
            <summary>
            Returns the Namespace URI associated with the given Prefix
            </summary>
            <param name="prefix">The Prefix to lookup the Namespace URI for</param>
            <returns>URI for the Namespace</returns>
        </member>
        <member name="M:VDS.RDF.INamespaceMapper.GetPrefix(System.Uri)">
            <summary>
            Returns the Prefix associated with the given Namespace URI
            </summary>
            <param name="uri">The Namespace URI to lookup the Prefix for</param>
            <returns>String prefix for the Namespace</returns>
        </member>
        <member name="M:VDS.RDF.INamespaceMapper.HasNamespace(System.String)">
            <summary>
            Method which checks whether a given Namespace Prefix is defined
            </summary>
            <param name="prefix">Prefix to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.INamespaceMapper.Import(VDS.RDF.INamespaceMapper)">
            <summary>
            Imports the contents of another Namespace Map into this Namespace Map
            </summary>
            <param name="nsmap">Namespace Map to import</param>
            <remarks>
            Prefixes in the imported Map which are already defined in this Map are ignored, this may change in future releases.
            </remarks>
        </member>
        <member name="M:VDS.RDF.INamespaceMapper.ReduceToQName(System.String,System.String@)">
            <summary>
            A Function which attempts to reduce a Uri to a QName
            </summary>
            <param name="uri">The Uri to attempt to reduce</param>
            <param name="qname">The value to output the QName to if possible</param>
            <returns></returns>
            <remarks>
            This function will return a Boolean indicated whether it succeeded in reducing the Uri to a QName.  If it did then the out parameter qname will contain the reduction, otherwise it will be the empty string.
            </remarks>
        </member>
        <member name="M:VDS.RDF.INamespaceMapper.RemoveNamespace(System.String)">
            <summary>
            Removes a Namespace from the Namespace Map
            </summary>
            <param name="prefix">Namespace Prefix of the Namespace to remove</param>
        </member>
        <member name="E:VDS.RDF.INamespaceMapper.NamespaceAdded">
            <summary>
            Event which is raised when a Namespace is Added
            </summary>
        </member>
        <member name="E:VDS.RDF.INamespaceMapper.NamespaceModified">
            <summary>
            Event which is raised when a Namespace is Modified
            </summary>
        </member>
        <member name="E:VDS.RDF.INamespaceMapper.NamespaceRemoved">
            <summary>
            Event which is raised when a Namespace is Removed
            </summary>
        </member>
        <member name="P:VDS.RDF.INamespaceMapper.Prefixes">
            <summary>
            Gets a Enumeratorion of all the Prefixes
            </summary>
        </member>
        <member name="F:VDS.RDF.NamespaceMapper.RDF">
            <summary>
            Constant Uri for the RDF Namespace
            </summary>
        </member>
        <member name="F:VDS.RDF.NamespaceMapper.RDFS">
            <summary>
            Constant Uri for the RDF Scheme Namespace
            </summary>
        </member>
        <member name="F:VDS.RDF.NamespaceMapper.XMLSCHEMA">
            <summary>
            Constant Uri for the XML Scheme Namespace
            </summary>
        </member>
        <member name="F:VDS.RDF.NamespaceMapper.OWL">
            <summary>
            Constant Uri for the OWL Namespace
            </summary>
        </member>
        <member name="F:VDS.RDF.NamespaceMapper._uris">
            <summary>
            Mapping of Prefixes to URIs
            </summary>
        </member>
        <member name="F:VDS.RDF.NamespaceMapper._prefixes">
            <summary>
            Mapping of URIs to Prefixes
            </summary>
        </member>
        <member name="M:VDS.RDF.NamespaceMapper.#ctor">
            <summary>
            Constructs a new Namespace Map
            </summary>
            <remarks>The Prefixes rdf, rdfs and xsd are automatically defined</remarks>
        </member>
        <member name="M:VDS.RDF.NamespaceMapper.#ctor(System.Boolean)">
            <summary>
            Constructs a new Namespace Map which is optionally empty
            </summary>
            <param name="empty">Whether the Namespace Map should be empty, if set to false the Prefixes rdf, rdfs and xsd are automatically defined</param>
        </member>
        <member name="M:VDS.RDF.NamespaceMapper.#ctor(VDS.RDF.INamespaceMapper)">
            <summary>
            Constructs a new Namespace Map which is based on an existing map
            </summary>
            <param name="nsmapper"></param>
        </member>
        <member name="M:VDS.RDF.NamespaceMapper.GetPrefix(System.Uri)">
            <summary>
            Returns the Prefix associated with the given Namespace URI
            </summary>
            <param name="uri">The Namespace URI to lookup the Prefix for</param>
            <returns>String prefix for the Namespace</returns>
        </member>
        <member name="M:VDS.RDF.NamespaceMapper.GetNamespaceUri(System.String)">
            <summary>
            Returns the Namespace URI associated with the given Prefix
            </summary>
            <param name="prefix">The Prefix to lookup the Namespace URI for</param>
            <returns>URI for the Namespace</returns>
        </member>
        <member name="M:VDS.RDF.NamespaceMapper.AddNamespace(System.String,System.Uri)">
            <summary>
            Adds a Namespace to the Namespace Map
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="uri">Namespace Uri</param>
        </member>
        <member name="M:VDS.RDF.NamespaceMapper.RemoveNamespace(System.String)">
            <summary>
            Removes a Namespace from the NamespaceMapper
            </summary>
            <param name="prefix">Namespace Prefix of the Namespace to remove</param>
        </member>
        <member name="M:VDS.RDF.NamespaceMapper.HasNamespace(System.String)">
            <summary>
            Method which checks whether a given Namespace Prefix is defined
            </summary>
            <param name="prefix">Prefix to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.NamespaceMapper.Clear">
            <summary>
            Clears the Namespace Map
            </summary>
        </member>
        <member name="M:VDS.RDF.NamespaceMapper.ReduceToQName(System.String,System.String@)">
            <summary>
            A Function which attempts to reduce a Uri to a QName
            </summary>
            <param name="uri">The Uri to attempt to reduce</param>
            <param name="qname">The value to output the QName to if possible</param>
            <returns></returns>
            <remarks>This function will return a Boolean indicated whether it succeeded in reducing the Uri to a QName.  If it did then the out parameter qname will contain the reduction, otherwise it will be the empty string.</remarks>
        </member>
        <member name="M:VDS.RDF.NamespaceMapper.Import(VDS.RDF.INamespaceMapper)">
            <summary>
            Imports the contents of another Namespace Map into this Namespace Map
            </summary>
            <param name="nsmap">Namespace Map to import</param>
            <remarks>
            Prefixes in the imported Map which are already defined in this Map are ignored, this may change in future releases.
            </remarks>
        </member>
        <member name="M:VDS.RDF.NamespaceMapper.OnNamespaceAdded(System.String,System.Uri)">
            <summary>
            Internal Helper for the NamespaceAdded Event which raises it only when a Handler is registered
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="uri">Namespace Uri</param>
        </member>
        <member name="M:VDS.RDF.NamespaceMapper.OnNamespaceModified(System.String,System.Uri)">
            <summary>
            Internal Helper for the NamespaceModified Event which raises it only when a Handler is registered
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="uri">Namespace Uri</param>
        </member>
        <member name="M:VDS.RDF.NamespaceMapper.OnNamespaceRemoved(System.String,System.Uri)">
            <summary>
            Internal Helper for the NamespaceRemoved Event which raises it only when a Handler is registered
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="uri">Namespace Uri</param>
        </member>
        <member name="M:VDS.RDF.NamespaceMapper.Dispose">
            <summary>
            Disposes of a Namespace Map
            </summary>
        </member>
        <member name="P:VDS.RDF.NamespaceMapper.Prefixes">
            <summary>
            Gets a Enumerator of all the Prefixes
            </summary>
        </member>
        <member name="E:VDS.RDF.NamespaceMapper.NamespaceAdded">
            <summary>
            Event which is raised when a Namespace is Added
            </summary>
        </member>
        <member name="E:VDS.RDF.NamespaceMapper.NamespaceModified">
            <summary>
            Event which is raised when a Namespace is Modified
            </summary>
        </member>
        <member name="E:VDS.RDF.NamespaceMapper.NamespaceRemoved">
            <summary>
            Event which is raised when a Namespace is Removed
            </summary>
        </member>
        <member name="T:VDS.RDF.QNameOutputMapper">
            <summary>
            Class for representing Mappings from URIs to QNames
            </summary>
            <remarks>
            Used primarily in outputting RDF syntax
            </remarks>
        </member>
        <member name="F:VDS.RDF.QNameOutputMapper._mapping">
            <summary>
            Mapping of URIs to QNames
            </summary>
        </member>
        <member name="F:VDS.RDF.QNameOutputMapper._nextNamespaceID">
            <summary>
            Next available Temporary Namespace ID
            </summary>
        </member>
        <member name="M:VDS.RDF.QNameOutputMapper.#ctor(VDS.RDF.INamespaceMapper)">
            <summary>
            Creates a new QName Output Mapper using the given Namespace Map
            </summary>
            <param name="nsmapper">Namespace Map</param>
        </member>
        <member name="M:VDS.RDF.QNameOutputMapper.#ctor">
            <summary>
            Creates a new QName Output Mapper which has an empty Namespace Map
            </summary>
        </member>
        <member name="M:VDS.RDF.QNameOutputMapper.ReduceToQName(System.String,System.String@)">
            <summary>
            A Function which attempts to reduce a Uri to a QName
            </summary>
            <param name="uri">The Uri to attempt to reduce</param>
            <param name="qname">The value to output the QName to if possible</param>
            <returns></returns>
            <remarks>This function will return a Boolean indicated whether it succeeded in reducing the Uri to a QName.  If it did then the out parameter qname will contain the reduction, otherwise it will be the empty string.</remarks>
        </member>
        <member name="M:VDS.RDF.QNameOutputMapper.ReduceToQName(System.String,System.String@,System.String@)">
            <summary>
            A Function which attempts to reduce a Uri to a QName and issues a Temporary Namespace if required
            </summary>
            <param name="uri">The Uri to attempt to reduce</param>
            <param name="qname">The value to output the QName to if possible</param>
            <param name="tempNamespace">The Temporary Namespace issued (if any)</param>
            <returns></returns>
            <remarks>
            <para>
            This function will always returns a possible QName for the URI if the format of the URI permits it.  It doesn't guarentee that the QName will be valid for the syntax it is being written to - it is up to implementers of writers to validate the QNames returned.
            </para>
            <para>
            Where necessary a Temporary Namespace will be issued and the <paramref name="tempNamespace">tempNamespace</paramref> parameter will be set to the prefix of the new temporary namespace
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.QNameOutputMapper.AddToCache(System.String,VDS.RDF.QNameMapping)">
            <summary>
            Adds a QName mapping to the cache
            </summary>
            <param name="uri">URI</param>
            <param name="mapping">Mapping</param>
        </member>
        <member name="M:VDS.RDF.QNameOutputMapper.GetNextTemporaryNamespacePrefix">
            <summary>
            Gets the next available Temporary Namespace ID
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.ThreadSafeQNameOutputMapper">
            <summary>
            Thread Safe version of the <see cref="T:VDS.RDF.QNameOutputMapper">QNameOutputMapper</see>
            </summary>
        </member>
        <member name="M:VDS.RDF.ThreadSafeQNameOutputMapper.#ctor(VDS.RDF.INamespaceMapper)">
            <summary>
            Creates a new Thread Safe QName Output Mapper
            </summary>
            <param name="nsmapper">Namespace Mapper</param>
        </member>
        <member name="M:VDS.RDF.ThreadSafeQNameOutputMapper.AddToCache(System.String,VDS.RDF.QNameMapping)">
            <summary>
            Adds a QName Mapping to the Cache in a Thread Safe way
            </summary>
            <param name="key">Key</param>
            <param name="value">Value</param>
        </member>
        <member name="M:VDS.RDF.ThreadSafeQNameOutputMapper.AddNamespace(System.String,System.Uri)">
            <summary>
            Adds a Namespace to the QName Output Mapper
            </summary>
            <param name="prefix">Prefix</param>
            <param name="uri">Namespace URI</param>
        </member>
        <member name="T:VDS.RDF.QNameMapping">
            <summary>
            Represents a mapping from a URI to a QName
            </summary>
        </member>
        <member name="M:VDS.RDF.QNameMapping.#ctor(System.String)">
            <summary>
            Creates a new QName Mapping
            </summary>
            <param name="u">URI</param>
        </member>
        <member name="M:VDS.RDF.QNameMapping.ToString">
            <summary>
            Gets the String representation of the URI
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.QNameMapping.Equals(System.Object)">
            <summary>
            Checks whether this is equal to another Object
            </summary>
            <param name="obj">Object to test against</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.QNameMapping.Uri">
            <summary>
            URI this is a mapping for
            </summary>
        </member>
        <member name="P:VDS.RDF.QNameMapping.QName">
            <summary>
            QName this URI maps to
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.NTriplesSyntax">
            <summary>
            Possible NTriples syntax modes
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.NTriplesSyntax.Original">
            <summary>
            The original NTriples syntax as specified in the original RDF specification <a href="http://www.w3.org/TR/2004/REC-rdf-testcases-20040210/">test cases</a> specification
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.NTriplesSyntax.Rdf11">
            <summary>
            Standardized NTriples as specified in the <a href="http://www.w3.org/TR/n-triples/">RDF 1.1 NTriples</a> specification
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.NTriplesParser">
            <summary>
            Parser for NTriples syntax
            </summary>
            <threadsafety instance="true">Designed to be Thread Safe - should be able to call Load from multiple threads on different Graphs without issue</threadsafety>
        </member>
        <member name="M:VDS.RDF.Parsing.NTriplesParser.#ctor">
            <summary>
            Creates a new instance of the parser
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.NTriplesParser.#ctor(VDS.RDF.Parsing.NTriplesSyntax)">
            <summary>
            Creates a new instance of the parser
            </summary>
            <param name="syntax">NTriples syntax to parse</param>
        </member>
        <member name="M:VDS.RDF.Parsing.NTriplesParser.#ctor(VDS.RDF.Parsing.Tokens.TokenQueueMode)">
            <summary>
            Creates a new instance of the parser using the given token queue mode
            </summary>
            <param name="qmode">Token Queue Mode</param>
        </member>
        <member name="M:VDS.RDF.Parsing.NTriplesParser.#ctor(VDS.RDF.Parsing.NTriplesSyntax,VDS.RDF.Parsing.Tokens.TokenQueueMode)">
            <summary>
            Creates a new instance of the parser using the given syntax and token queue mode
            </summary>
            
            <param name="qmode">Token Queue Mode</param>
            <param name="syntax">NTriples syntax to parse</param>
        </member>
        <member name="M:VDS.RDF.Parsing.NTriplesParser.Load(VDS.RDF.IGraph,System.IO.StreamReader)">
            <summary>
            Parses NTriples Syntax from the given Input Stream into Triples in the given Graph
            </summary>
            <param name="g">Graph to create Triples in</param>
            <param name="input">Arbitrary Input Stream to read input from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.NTriplesParser.Load(VDS.RDF.IGraph,System.IO.TextReader)">
            <summary>
            Parses NTriples Syntax from the given Input into Triples in the given Graph
            </summary>
            <param name="g">Graph to create Triples in</param>
            <param name="input">Arbitrary Input to read input from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.NTriplesParser.Load(VDS.RDF.IRdfHandler,System.IO.StreamReader)">
            <summary>
            Parses NTriples Syntax from the given Input Stream using a RDF Handler
            </summary>
            <param name="handler">RDF Handler to use</param>
            <param name="input">Input Stream to read input from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.NTriplesParser.Load(VDS.RDF.IRdfHandler,System.IO.TextReader)">
            <summary>
            Parses NTriples Syntax from the given Input using a RDF Handler
            </summary>
            <param name="handler">RDF Handler to use</param>
            <param name="input">Input to read input from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.NTriplesParser.TryParseUri(VDS.RDF.Parsing.Contexts.TokenisingParserContext,System.String)">
            <summary>
            Tries to parse a URI
            </summary>
            <param name="context">Context</param>
            <param name="uri">URI</param>
            <returns>URI Node if parsed successfully</returns>
        </member>
        <member name="M:VDS.RDF.Parsing.NTriplesParser.Error(System.String,VDS.RDF.Parsing.Tokens.IToken)">
            <summary>
            Helper method for raising informative standardised Parser Errors
            </summary>
            <param name="msg">The Error Message</param>
            <param name="t">The Token that is the cause of the Error</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.NTriplesParser.RaiseWarning(System.String)">
            <summary>
            Internal Helper method which raises the Warning event if an event handler is registered to it
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="M:VDS.RDF.Parsing.NTriplesParser.ToString">
            <summary>
            Gets the String representation of the Parser which is a description of the syntax it parses
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Parsing.NTriplesParser.TraceTokeniser">
            <summary>
            Controls whether Tokeniser progress will be traced by writing output to the Console
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.NTriplesParser.TraceParsing">
            <summary>
            Controls whether Parser progress will be traced by writing output to the Console
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.NTriplesParser.TokenQueueMode">
            <summary>
            Gets/Sets the token queue mode used
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.NTriplesParser.Syntax">
            <summary>
            Gets/Sets the desired NTriples syntax
            </summary>
        </member>
        <member name="E:VDS.RDF.Parsing.NTriplesParser.Warning">
            <summary>
            Event which is raised when there is a non-fatal issue with the NTriples being parsed
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.Notation3Tokeniser">
            <summary>
            A Class for Reading an Input Stream and generating Notation 3 Tokens from it
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Notation3Tokeniser.ValidQNamesPattern">
            <summary>
            Pattern for Valid QNames that use only the Latin Alphabet
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Notation3Tokeniser.ValidVarNamesPattern">
            <summary>
            Patter for Valid Variable Names
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.Notation3Tokeniser.#ctor(System.IO.StreamReader)">
            <summary>
            Creates a new Instance of the Tokeniser
            </summary>
            <param name="input">The Input Stream to generate Tokens from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.Notation3Tokeniser.#ctor(VDS.RDF.Parsing.ParsingTextReader)">
            <summary>
            Creates a new Instance of the Tokeniser
            </summary>
            <param name="input">The Input Stream to generate Tokens from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.Notation3Tokeniser.#ctor(System.IO.TextReader)">
            <summary>
            Creates a new Instance of the Tokeniser
            </summary>
            <param name="input">The Input to generate Tokens from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.Notation3Tokeniser.GetNextToken">
            <summary>
            Gets the next parseable Token from the Input or raises an Error
            </summary>
            <returns></returns>
            <exception cref="T:VDS.RDF.Parsing.RdfParseException">Occurs when a Token cannot be parsed</exception>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.Notation3Tokeniser.TryGetCommentToken">
            <summary>
            Internal Helper method which attempts to get a Comment Token
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.Notation3Tokeniser.IsRDFTermToken(System.Int32)">
            <summary>
            Determines whether a given Token represents an RDF Term or part thereof
            </summary>
            <param name="tokentype">Token Type to test</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.SparqlRemoteEndpoint">
            <summary>
            A Class for connecting to a remote SPARQL Endpoint and executing Queries against it
            </summary>
        </member>
        <member name="T:VDS.RDF.BaseEndpoint">
            <summary>
            Abstract Base class for HTTP endpoints
            </summary>
        </member>
        <member name="M:VDS.RDF.BaseEndpoint.#ctor">
            <summary>
            Creates a new Base Endpoint
            </summary>
        </member>
        <member name="M:VDS.RDF.BaseEndpoint.#ctor(System.Uri)">
            <summary>
            Creates a new Base Endpoint
            </summary>
            <param name="endpointUri">Endpoint URI</param>
        </member>
        <member name="M:VDS.RDF.BaseEndpoint.SetCredentials(System.String,System.String)">
            <summary>
            Sets the HTTP Digest authentication credentials to be used
            </summary>
            <param name="username">Username</param>
            <param name="password">Password</param>
        </member>
        <member name="M:VDS.RDF.BaseEndpoint.SetCredentials(System.String,System.String,System.String)">
            <summary>
            Sets the HTTP Digest authentication credentials to be used
            </summary>
            <param name="username">Username</param>
            <param name="password">Password</param>
            <param name="domain">Domain</param>
        </member>
        <member name="M:VDS.RDF.BaseEndpoint.ClearCredentials">
            <summary>
            Clears any in-use credentials so subsequent requests will not use HTTP authentication
            </summary>
        </member>
        <member name="M:VDS.RDF.BaseEndpoint.SerializeConfiguration(VDS.RDF.Configuration.ConfigurationSerializationContext)">
            <summary>
            Serializes the endpoints Credential and Proxy information
            </summary>
            <param name="context">Configuration Serialization Context</param>
        </member>
        <member name="M:VDS.RDF.BaseEndpoint.ApplyRequestOptions(System.Net.HttpWebRequest)">
            <summary>
            Applies generic request options (timeout, authorization and proxy server) to a request
            </summary>
            <param name="httpRequest">HTTP Request</param>
        </member>
        <member name="P:VDS.RDF.BaseEndpoint.Uri">
            <summary>
            Gets the Endpoints URI
            </summary>
        </member>
        <member name="P:VDS.RDF.BaseEndpoint.HttpMode">
            <summary>
            Gets/Sets the HTTP Mode used for requests
            </summary>
            <remarks>
            <para>
            Only GET and POST are permitted - implementations may override this property if they wish to support more methods
            </para>
            </remarks>
        </member>
        <member name="P:VDS.RDF.BaseEndpoint.Timeout">
            <summary>
            Gets/Sets the HTTP Timeouts used specified in milliseconds
            </summary>
            <remarks>
            <para>
            Defaults to 30 Seconds (i.e. the default value is 30,000)
            </para>
            <para>
            It is important to understand that this timeout only applies to the HTTP request portions of any operation performed and that the timeout may apply more than once if a POST operation is used since the timeout applies separately to obtaining the request stream to POST the request and obtaining the response stream.  Also the timeout does not in any way apply to subsequent work that may be carried out before the operation can return so if you need a hard timeout you should manage that yourself.
            </para>
            <para>
            When set to a zero/negative value then the standard .Net timeout of 100 seconds will apply, use <see cref="F:System.Int32.MaxValue"/> if you want the maximum possible timeout i.e. if you expect to launch extremely long running operations.
            </para>
            <para>
            Not supported under Silverlight, Windows Phone and Portable Class Library builds
            </para>
            </remarks>
        </member>
        <member name="P:VDS.RDF.BaseEndpoint.Credentials">
            <summary>
            Gets/Sets the HTTP authentication credentials to be used
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SparqlRemoteEndpoint.#ctor">
            <summary>
            Empty Constructor for use by derived classes
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SparqlRemoteEndpoint.#ctor(System.Uri)">
            <summary>
            Creates a new SPARQL Endpoint for the given Endpoint URI
            </summary>
            <param name="endpointUri">Remote Endpoint URI</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlRemoteEndpoint.#ctor(System.Uri,System.String)">
            <summary>
            Creates a new SPARQL Endpoint for the given Endpoint URI using the given Default Graph Uri
            </summary>
            <param name="endpointUri">Remote Endpoint URI</param>
            <param name="defaultGraphUri">Default Graph URI to use when Querying the Endpoint</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlRemoteEndpoint.#ctor(System.Uri,System.Uri)">
            <summary>
            Creates a new SPARQL Endpoint for the given Endpoint Uri using the given Default Graph Uri
            </summary>
            <param name="endpointUri">Remote Endpoint URI</param>
            <param name="defaultGraphUri">Default Graph URI to use when Querying the Endpoint</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlRemoteEndpoint.#ctor(System.Uri,System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a new SPARQL Endpoint for the given Endpoint URI using the given Default Graph URI
            </summary>
            <param name="endpointUri">Remote Endpoint URI</param>
            <param name="defaultGraphUri">Default Graph URI to use when Querying the Endpoint</param>
            <param name="namedGraphUris">Named Graph URIs to use when Querying the Endpoint</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlRemoteEndpoint.#ctor(System.Uri,System.Uri,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a new SPARQL Endpoint for the given Endpoint URI using the given Default Graph URI
            </summary>
            <param name="endpointUri">Remote Endpoint URI</param>
            <param name="defaultGraphUri">Default Graph URI to use when Querying the Endpoint</param>
            <param name="namedGraphUris">Named Graph URIs to use when Querying the Endpoint</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlRemoteEndpoint.#ctor(System.Uri,System.Uri,System.Collections.Generic.IEnumerable{System.Uri})">
            <summary>
            Creates a new SPARQL Endpoint for the given Endpoint URI using the given Default Graph URI
            </summary>
            <param name="endpointUri">Remote Endpoint URI</param>
            <param name="defaultGraphUri">Default Graph URI to use when Querying the Endpoint</param>
            <param name="namedGraphUris">Named Graph URIs to use when Querying the Endpoint</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlRemoteEndpoint.#ctor(System.Uri,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a new SPARQL Endpoint for the given Endpoint URI using the given Default Graph URI
            </summary>
            <param name="endpointUri">Remote Endpoint URI</param>
            <param name="defaultGraphUris">Default Graph URIs to use when Querying the Endpoint</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlRemoteEndpoint.#ctor(System.Uri,System.Collections.Generic.IEnumerable{System.Uri})">
            <summary>
            Creates a new SPARQL Endpoint for the given Endpoint URI using the given Default Graph URI
            </summary>
            <param name="endpointUri">Remote Endpoint URI</param>
            <param name="defaultGraphUris">Default Graph URIs to use when Querying the Endpoint</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlRemoteEndpoint.#ctor(System.Uri,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a new SPARQL Endpoint for the given Endpoint URI using the given Default Graph URI
            </summary>
            <param name="endpointUri">Remote Endpoint URI</param>
            <param name="defaultGraphUris">Default Graph URIs to use when Querying the Endpoint</param>
            <param name="namedGraphUris">Named Graph URIs to use when Querying the Endpoint</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlRemoteEndpoint.#ctor(System.Uri,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.Uri})">
            <summary>
            Creates a new SPARQL Endpoint for the given Endpoint URI using the given Default Graph URI
            </summary>
            <param name="endpointUri">Remote Endpoint URI</param>
            <param name="defaultGraphUris">Default Graph URIs to use when Querying the Endpoint</param>
            <param name="namedGraphUris">Named Graph URIs to use when Querying the Endpoint</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlRemoteEndpoint.#ctor(System.Uri,System.Collections.Generic.IEnumerable{System.Uri},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a new SPARQL Endpoint for the given Endpoint URI using the given Default Graph URI
            </summary>
            <param name="endpointUri">Remote Endpoint URI</param>
            <param name="defaultGraphUris">Default Graph URIs to use when Querying the Endpoint</param>
            <param name="namedGraphUris">Named Graph URIs to use when Querying the Endpoint</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlRemoteEndpoint.#ctor(System.Uri,System.Collections.Generic.IEnumerable{System.Uri},System.Collections.Generic.IEnumerable{System.Uri})">
            <summary>
            Creates a new SPARQL Endpoint for the given Endpoint URI using the given Default Graph URI
            </summary>
            <param name="endpointUri">Remote Endpoint URI</param>
            <param name="defaultGraphUris">Default Graph URIs to use when Querying the Endpoint</param>
            <param name="namedGraphUris">Named Graph URIs to use when Querying the Endpoint</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlRemoteEndpoint.QueryWithResultSet(System.String,VDS.RDF.SparqlResultsCallback,System.Object)">
            <summary>
            Makes a Query asynchronously where the expected Result is a <see cref="T:VDS.RDF.Query.SparqlResultSet">SparqlResultSet</see> i.e. SELECT and ASK Queries
            </summary>
            <param name="query">SPARQL Query String</param>
            <param name="callback">Callback to invoke when the query completes</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlRemoteEndpoint.QueryWithResultSet(VDS.RDF.ISparqlResultsHandler,System.String,VDS.RDF.QueryCallback,System.Object)">
            <summary>
            Makes a Query asynchronously where the expected Result is a <see cref="T:VDS.RDF.Query.SparqlResultSet">SparqlResultSet</see> i.e. SELECT and ASK Queries
            </summary>
            <param name="query">SPARQL Query String</param>
            <param name="handler">Results Handler</param>
            <param name="callback">Callback to invoke when the query completes</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlRemoteEndpoint.QueryWithResultGraph(System.String,VDS.RDF.GraphCallback,System.Object)">
            <summary>
            Makes a Query asynchronously where the expected Result is an RDF Graph ie. CONSTRUCT and DESCRIBE Queries
            </summary>
            <param name="query">SPARQL Query String</param>
            <param name="callback">Callback to invoke when the query completes</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlRemoteEndpoint.QueryWithResultGraph(VDS.RDF.IRdfHandler,System.String,VDS.RDF.QueryCallback,System.Object)">
            <summary>
            Makes a Query asynchronously where the expected Result is an RDF Graph ie. CONSTRUCT and DESCRIBE Queries
            </summary>
            <param name="query">SPARQL Query String</param>
            <param name="handler">RDF Handler</param>
            <param name="callback">Callback to invoke when the query completes</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlRemoteEndpoint.SerializeConfiguration(VDS.RDF.Configuration.ConfigurationSerializationContext)">
            <summary>
            Serializes the Endpoint's Configuration
            </summary>
            <param name="context">Configuration Serialization Context</param>
        </member>
        <member name="P:VDS.RDF.Query.SparqlRemoteEndpoint.DefaultGraphs">
            <summary>
            Gets the Default Graph URIs for Queries made to the SPARQL Endpoint
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlRemoteEndpoint.NamedGraphs">
            <summary>
            Gets the List of Named Graphs used in requests
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlRemoteEndpoint.ResultsAcceptHeader">
            <summary>
            Gets/Sets the Accept Header sent with ASK/SELECT queries
            </summary>
            <remarks>
            <para>
            Can be used to workaround buggy endpoints which don't like the broad Accept Header that dotNetRDF sends by default.  If not set or explicitly set to null the library uses the default header generated by <see cref="P:VDS.RDF.MimeTypesHelper.HttpSparqlAcceptHeader"/>
            </para>
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.SparqlRemoteEndpoint.RdfAcceptHeader">
            <summary>
            Gets/Sets the Accept Header sent with CONSTRUCT/DESCRIBE queries
            </summary>
            <remarks>
            <para>
            Can be used to workaround buggy endpoints which don't like the broad Accept Header that dotNetRDF sends by default.  If not set or explicitly set to null the library uses the default header generated by <see cref="P:VDS.RDF.MimeTypesHelper.HttpAcceptHeader"/>
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.SparqlResultsType">
            <summary>
            Represents the type of the SPARQL Results Set
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlResultsType.Boolean">
            <summary>
            The Result Set represents a Boolean Result
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlResultsType.VariableBindings">
            <summary>
            The Result Set represents a set of Variable Bindings
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlResultsType.Unknown">
            <summary>
            The Result Set represents an unknown result i.e. it has yet to be filled with Results
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.SparqlResultSet">
            <summary>
            Class for representing Sparql Result Sets
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlResultSet._results">
            <summary>
            Lists of Sparql Results
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlResultSet._variables">
            <summary>
            Lists of Variables in the Result Set
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlResultSet._result">
            <summary>
            Boolean Result
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResultSet.#ctor">
            <summary>
            Creates an Empty Sparql Result Set
            </summary>
            <remarks>Useful where you need a possible guarentee of returning an result set even if it proves to be empty and also necessary for the implementation of Result Set Parsers.</remarks>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResultSet.#ctor(System.Boolean)">
            <summary>
            Creates a Sparql Result Set for the Results of an ASK Query with the given Result value
            </summary>
            <param name="result"></param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResultSet.#ctor(System.Collections.Generic.IEnumerable{VDS.RDF.Query.SparqlResult})">
            <summary>
            Creates a Sparql Result Set for the collection of results
            </summary>
            <param name="results">Results</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResultSet.#ctor(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Creates a SPARQL Result Set for the Results of a Query with the Leviathan Engine
            </summary>
            <param name="context">SPARQL Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResultSet.Trim">
            <summary>
            Trims the Result Set to remove unbound variables from results
            </summary>
            <remarks>
            <strong>Note: </strong> This does not remove empty results this only removes unbound variables from individual results
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResultSet.AddVariable(System.String)">
            <summary>
            Adds a Variable to the Result Set
            </summary>
            <param name="var">Variable Name</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResultSet.AddResult(VDS.RDF.Query.SparqlResult)">
            <summary>
            Adds a Result to the Result Set
            </summary>
            <param name="result">Result</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResultSet.SetResult(System.Boolean)">
            <summary>
            Sets the Boolean Result for the Result Set
            </summary>
            <param name="result">Boolean Result</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResultSet.GetEnumerator">
            <summary>
            Gets an Enumerator for the Results List
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResultSet.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets an Enumerator for the Results List
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResultSet.Equals(System.Object)">
            <summary>
            Determines whether two Result Sets are equal
            </summary>
            <param name="obj"></param>
            <returns></returns>
            <remarks>
            Experimental and not yet complete
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResultSet.ToTripleCollection(VDS.RDF.IGraph)">
            <summary>
            Converts a Result Set into a Triple Collection
            </summary>
            <param name="g">Graph to generate the Nodes in</param>
            <returns></returns>
            <remarks>
            Assumes the Result Set contains three variables ?s, ?p and ?o to use as the Subject, Predicate and Object respectively.  Only Results for which all three variables have bound values will generate Triples
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResultSet.ToTripleCollection(VDS.RDF.IGraph,System.String,System.String,System.String)">
            <summary>
            Converts a Result Set into a Triple Collection
            </summary>
            <param name="g">Graph to generate the Nodes in</param>
            <param name="subjVar">Variable whose value should be used for Subjects of Triples</param>
            <param name="predVar">Variable whose value should be used for Predicates of Triples</param>
            <param name="objVar">Variable whose value should be used for Object of Triples</param>
            <returns></returns>
            <remarks>
            Only Results for which all three variables have bound values will generate Triples
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.SparqlResultSet.Dispose">
            <summary>
            Disposes of a Result Set
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlResultSet.ResultsType">
            <summary>
            Gets the Type of the Results Set
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlResultSet.Result">
            <summary>
            Gets the Result of an ASK Query
            </summary>
            <remarks>Result Set is deemed to refer to an ASK query if the Variables list is empty since an ASK Query result has an empty &lt;head&gt;.  It is always true for any other Query type where one/more variables were requested even if the Result Set is empty.</remarks>
        </member>
        <member name="P:VDS.RDF.Query.SparqlResultSet.Count">
            <summary>
            Gets the number of Results in the Result Set
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlResultSet.IsEmpty">
            <summary>
            Gets whether the Result Set is empty and can have Results loaded into it
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.SparqlResultSet.Results">
            <summary>
            Gets the List of Results
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlResultSet.Item(System.Int32)">
            <summary>
            Index directly into the Results
            </summary>
            <param name="index">Index of the Result you wish to retrieve</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.SparqlResultSet.Variables">
            <summary>
            Gets the Variables used in the Result Set
            </summary>
            <remarks>
            As of 1.0 where possible dotNetRDF tries to preserve the ordering of variables however this may not be possible depending on where the result set originates from or how it is populated
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.SparqlSpecsHelper">
            <summary>
            Class containing Helper information and methods pertaining to the Sparql Query Language for RDF
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlNamespace">
            <summary>
            Namespace Uri for SPARQL Namespace
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlRdfResultsNamespace">
            <summary>
            Namespace Uri for the RDF serialization of a SPARQL Result Set
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordBase">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordPrefix">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordSelect">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordConstruct">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordDescribe">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordAsk">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordOrder">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordBy">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordOrderBy">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordLimit">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordOffset">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordDistinct">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordReduced">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordFrom">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordNamed">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordFromNamed">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordWhere">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordGraph">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordOptional">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordUnion">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordFilter">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordStr">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordLang">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordLangMatches">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordDataType">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordBound">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordSameTerm">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordIsUri">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordIsIri">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordIsLiteral">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordIsBlank">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordRegex">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordTrue">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordFalse">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordAsc">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordDesc">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordCount">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordSum">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordAvg">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordMin">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordMax">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordGroupConcat">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordSample">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordNMin">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordNMax">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordMedian">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordMode">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordAs">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordGroupBy">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordGroup">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordHaving">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordExists">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordNot">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordNotExists">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordUnsaid">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordLet">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordBind">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordSeparator">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordLength">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordStrLang">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordStrDt">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordIri">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordUri">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordBNode">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordIn">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordNotIn">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordCoalesce">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordIf">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordInsert">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordDelete">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordClear">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordLoad">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordData">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordInto">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordSilent">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordCreate">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordDrop">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordWith">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordUsing">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordDefault">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordAll">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordMinus">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordService">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordBindings">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordValues">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordUndef">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordIsNumeric">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordStrLen">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordSubStr">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordUCase">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordLCase">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordStrStarts">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordStrEnds">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordStrBefore">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordStrAfter">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordReplace">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordContains">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordEncodeForUri">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordConcat">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordAbs">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordRound">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordCeil">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordFloor">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordRand">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordNow">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordYear">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordMonth">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordDay">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordHours">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordMinutes">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordSeconds">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordTimezone">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordTz">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordMD5">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordSha1">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordSha256">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordSha384">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordSha512">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordAny">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordNone">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordAdd">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordCopy">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordMove">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordTo">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordUUID">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordStrUUID">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlKeywordCall">
            <summary>
            Keywords in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.NonQueryKeywords">
            <summary>
            Set of SPARQL Keywords that are Non-Query Keywords
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.FunctionKeywords">
            <summary>
            Set of SPARQL Keywords that are Function Keywords
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.AggregateKeywords">
            <summary>
            Set of SPARQL Keywords that are Aggregate Keywords
            </summary>
            <remarks>
            Unlike <see cref="F:VDS.RDF.Query.SparqlSpecsHelper.AggregateFunctionKeywords">AggregateFunctionKeywords[]</see> this includes keywords related to aggregates (like DISTINCT) and those for Leviathan extension aggregates which are not standard SPARQL 1.1 syntax
            </remarks>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.AggregateFunctionKeywords">
            <summary>
            Set of SPARQL Keywords that are built in SPARQL Aggregate Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.IntegerDataTypes">
            <summary>
            Set of XML Schema Data Types which are derived from Integer and can be treated as Integers by SPARQL
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SupportedCastFunctions">
            <summary>
            Set of IRIs for supported Cast Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlQuery10Keywords">
            <summary>
            Set of Keywords for SPARQL Query 1.0
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlQuery11Keywords">
            <summary>
            Set of additional Keywords for SPARQL Query 1.1
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.UpdateKeywords">
            <summary>
            Set of SPARQL Keywords that are Update Keywords
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlUpdate11Keywords">
            <summary>
            Set of Keywords for SPARQL Update 1.1
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlInteger">
            <summary>
            Regular Expression Pattern for Valid Integers in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlDecimal">
            <summary>
            Regular Expression Pattern for Valid Decimals in Sparql
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.SparqlSpecsHelper.SparqlDouble">
            <summary>
            Regular Expression Pattern for Valid Doubles in Sparql
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.IsQueryKeyword(System.String)">
            <summary>
            Checks whether a given Keyword is a SPARQL Query Keyword
            </summary>
            <param name="keyword">Keyword to check</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.IsNonQueryKeyword(System.String)">
            <summary>
            Checks whether a given Keyword is a SPARQL Non-Query Keyword
            </summary>
            <param name="keyword">Keyword to check</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.IsFunctionKeyword(System.String)">
            <summary>
            Checks whether a given Keyword is a SPARQL Function Verb
            </summary>
            <param name="keyword">Keyword to check</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.IsFunctionKeyword11(System.String)">
            <summary>
            Checks whether a given Keyword is a SPARQL 1.1 Function Verb
            </summary>
            <param name="keyword">Keyword to check</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.IsAggregateKeyword(System.String)">
            <summary>
            Checks whether a given Keyword is a SPARQL Aggregate Keyword (includes keywords related to aggregates like DISTINCT, AS and Leviathan extension aggregate keywords)
            </summary>
            <param name="keyword">Keyword to check</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.IsAggregateFunctionKeyword(System.String)">
            <summary>
            Checks whether a given Keyword is a SPARQL Aggregate Function Keyword (only keywords for the SPARQL built-in aggregate functions)
            </summary>
            <param name="keyword">Keyword to check</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.IsUpdateKeyword(System.String)">
            <summary>
            Checks whether a given Keyword is a SPARQL Update Keyword
            </summary>
            <param name="keyword"></param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.IsValidQName(System.String,VDS.RDF.Parsing.SparqlQuerySyntax)">
            <summary>
            Checks whether a given QName is valid in Sparql
            </summary>
            <param name="value">QName to check</param>
            <param name="syntax">SPARQL Syntax</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.IsValidVarName(System.String)">
            <summary>
            Checks whether a given Variable Name is valid in Sparql
            </summary>
            <param name="value">Variable Name to check</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.IsValidPrefix(System.String)">
            <summary>
            Gets whether a given prefix declaration is valid in SPARQL
            </summary>
            <param name="value">Prefix declaration</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.IsValidBNode(System.String)">
            <summary>
            Gets whether a given BNode ID is valid
            </summary>
            <param name="value">Value</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.IsPNCharsBase(System.Char)">
            <summary>
            Checks whether a given Character matches the PN_CHARS_BASE rule from the Sparql Specification
            </summary>
            <param name="c">Character to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.IsPNCharsU(System.Char)">
            <summary>
            Checks whether a given Character matches the PN_CHARS_U rule from the SPARQL Specification
            </summary>
            <param name="c">Character to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.IsPNChars(System.Char)">
            <summary>
            Checks whether a given Character matches the PN_CHARS rule from the SPARQL Specification
            </summary>
            <param name="c">Character to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.IsPNLocal(System.Char[],VDS.RDF.Parsing.SparqlQuerySyntax)">
            <summary>
            Checks whether a given String matches the PN_LOCAL rule from the Sparql Specification
            </summary>
            <param name="cs">String as character array</param>
            <param name="syntax">SPARQL Syntax</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.IsPNPrefix(System.Char[])">
            <summary>
            Checks whether a given String matches the PN_PREFIX rule from the SPARQL Specification
            </summary>
            <param name="cs">String as character array</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.IsPLX(System.Char[],System.Int32,System.Int32@)">
            <summary>
            Checks whether a given String matches the PLX rule from the SPARQL Specification
            </summary>
            <param name="cs">String as character array</param>
            <param name="startIndex">Start Index</param>
            <param name="endIndex">Resulting End Index</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.IsHex(System.Char)">
            <summary>
            Gets whether a character is a Hex character
            </summary>
            <param name="c">Character</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.UnescapeQName(System.String)">
            <summary>
            Unescapes local name escapes from QNames
            </summary>
            <param name="value">Value to unescape</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.IsValidNumericLiteral(System.String)">
            <summary>
            Checks whether the given value is a valid Numeric Literal in Sparql
            </summary>
            <param name="value">Value to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.IsInteger(System.String)">
            <summary>
            Checks whether the given value is a valid Integer Literal in Sparql
            </summary>
            <param name="value">Value to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.IsDecimal(System.String)">
            <summary>
            Checks whether the given value is a valid Decimal Literal in Sparql
            </summary>
            <param name="value">Value to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.IsFloat(System.String)">
            <summary>
            Checks whether the given value is a valid Float Literal in Sparql
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.IsDouble(System.String)">
            <summary>
            Checks whether the given value is a valid Double Literal in Sparql
            </summary>
            <param name="value">Value to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.GetNumericTypeFromDataTypeUri(System.Uri)">
            <summary>
            Determines the Sparql Numeric Type for a Literal based on its Data Type Uri
            </summary>
            <param name="dtUri">Data Type Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.GetNumericTypeFromDataTypeUri(System.String)">
            <summary>
            Determines the Sparql Numeric Type for a Literal based on its Data Type Uri
            </summary>
            <param name="dtUri">Data Type Uri as a String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.EffectiveBooleanValue(VDS.RDF.INode)">
            <summary>
            Calculates the Effective Boolean Value of a given Node according to the Sparql specification
            </summary>
            <param name="n">Node to computer EBV for</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.IsSelectQuery(VDS.RDF.Query.SparqlQueryType)">
            <summary>
            Checks whether the Query is a SELECT Query
            </summary>
            <param name="type">Query Type</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.Equality(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Implements Node Equality with SPARQL Semantics
            </summary>
            <param name="x">Node</param>
            <param name="y">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.Inequality(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Implements Node Inequality with SPARQL Semantics
            </summary>
            <param name="x">Node</param>
            <param name="y">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.NumericEquality(VDS.RDF.INode,VDS.RDF.INode,VDS.RDF.Query.Expressions.SparqlNumericType)">
            <summary>
            Implements Numeric Equality with SPARQL Semantics
            </summary>
            <param name="x">Node</param>
            <param name="y">Node</param>
            <param name="type">SPARQL Numeric Tyoe</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.DateTimeEquality(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Implements Date Time Equality with SPARQL Semantics
            </summary>
            <param name="x">Node</param>
            <param name="y">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.DateEquality(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Implements Date Equality with SPARQL Semantics
            </summary>
            <param name="x">Node</param>
            <param name="y">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.TimeSpanEquality(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Implements Time Span Equality with SPARQL Semantics
            </summary>
            <param name="x">Node</param>
            <param name="y">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.ToDecimal(VDS.RDF.ILiteralNode)">
            <summary>
            Converts a Literal Node to a Decimal
            </summary>
            <param name="n">Literal Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.ToDouble(VDS.RDF.ILiteralNode)">
            <summary>
            Converts a Literal Node to a Double
            </summary>
            <param name="n">Literal Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.ToFloat(VDS.RDF.ILiteralNode)">
            <summary>
            Converts a Literal Node to a Float
            </summary>
            <param name="n">Literal Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.ToInteger(VDS.RDF.ILiteralNode)">
            <summary>
            Converts a Literal Node to an Integer
            </summary>
            <param name="n">Literal Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.ToDateTime(VDS.RDF.ILiteralNode)">
            <summary>
            Converts a Literal Node to a Date Time
            </summary>
            <param name="n">Literal Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.ToDateTimeOffset(VDS.RDF.ILiteralNode)">
            <summary>
            Converts a Literal Node to a Date Time Offset
            </summary>
            <param name="n">Literal Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlSpecsHelper.ToTimeSpan(VDS.RDF.ILiteralNode)">
            <summary>
            Converts a Literal Node to a Time Span
            </summary>
            <param name="n">Literal Node</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.SparqlSpecsHelper.Formatter">
            <summary>
            Gets a SPARQL Formatter to use in formatting Queries as Strings
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.SparqlHtmlWriter">
            <summary>
            Class for saving SPARQL Result Sets to a HTML Table format (this is not a standardised format)
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.BaseHtmlWriter">
            <summary>
            Abstract Base Class for HTML Writers which provides basic implementation of the IHtmlWriter interface
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.BaseHtmlWriter.Stylesheet">
            <summary>
            Gets/Sets a path to a Stylesheet which is used to format the Graph output
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.BaseHtmlWriter.CssClassUri">
            <summary>
            Gets/Sets the CSS class used for the anchor tags used to display the URIs of URI Nodes
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.BaseHtmlWriter.CssClassBlankNode">
            <summary>
            Gets/Sets the CSS class used for the span tags used to display Blank Node IDs
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.BaseHtmlWriter.CssClassLiteral">
            <summary>
            Gets/Sets the CSS class used for the span tags used to display Literals
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.BaseHtmlWriter.CssClassDatatype">
            <summary>
            Gets/Sets the CSS class used for the anchor tags used to display Literal datatypes
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.BaseHtmlWriter.CssClassLangSpec">
            <summary>
            Gets/Sets the CSS class used for the span tags used to display Literal language specifiers
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.BaseHtmlWriter.CssClassBox">
            <summary>
            Gets/Sets the CSS class used for div tags used to group chunks of markup into a box
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.BaseHtmlWriter.UriPrefix">
            <summary>
            Gets/Sets the Prefix applied to href attributes
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.SparqlHtmlWriter.Save(VDS.RDF.Query.SparqlResultSet,System.IO.TextWriter)">
            <summary>
            Saves the Result Set to the given Stream as a HTML Table
            </summary>
            <param name="results">Result Set to save</param>
            <param name="output">Stream to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.SparqlHtmlWriter.GenerateOutput(VDS.RDF.Query.SparqlResultSet,System.IO.TextWriter)">
            <summary>
            Internal method which generates the HTML Output for the Sparql Results
            </summary>
            <param name="results"></param>
            <param name="output"></param>
        </member>
        <member name="M:VDS.RDF.Writing.SparqlHtmlWriter.RaiseWarning(System.String)">
            <summary>
            Helper Method which raises the Warning event when a non-fatal issue with the SPARQL Results being written is detected
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="M:VDS.RDF.Writing.SparqlHtmlWriter.ToString">
            <summary>
            Gets the String representation of the writer which is a description of the syntax it produces
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Writing.SparqlHtmlWriter.DefaultNamespaces">
            <summary>
            Gets/Sets the Default Namespaces used to pretty print URIs in the output
            </summary>
        </member>
        <member name="E:VDS.RDF.Writing.SparqlHtmlWriter.Warning">
            <summary>
            Event raised when a non-fatal issue with the SPARQL Results being written is detected
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.SparqlJsonWriter">
            <summary>
            Class for saving Sparql Result Sets to the SPARQL Results JSON Format
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.SparqlJsonWriter.Save(VDS.RDF.Query.SparqlResultSet,System.IO.TextWriter)">
            <summary>
            Saves the Result Set to the given Stream in the SPARQL Results JSON Format
            </summary>
            <param name="results">Result Set to save</param>
            <param name="output">Stream to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.SparqlJsonWriter.GenerateOutput(VDS.RDF.Query.SparqlResultSet,System.IO.TextWriter)">
            <summary>
            Internal method which generates the SPARQL Query Results JSON output
            </summary>
            <param name="results">Result Set to save</param>
            <param name="output">Stream to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.SparqlJsonWriter.RaiseWarning(System.String)">
            <summary>
            Helper Method which raises the Warning event when a non-fatal issue with the SPARQL Results being written is detected
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="M:VDS.RDF.Writing.SparqlJsonWriter.ToString">
            <summary>
            Gets the String representation of the writer which is a description of the syntax it produces
            </summary>
            <returns></returns>
        </member>
        <member name="E:VDS.RDF.Writing.SparqlJsonWriter.Warning">
            <summary>
            Event raised when a non-fatal issue with the SPARQL Results being written is detected
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.SparqlXmlWriter">
            <summary>
            Class for saving Sparql Result Sets to the Sparql Results XML Format
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.SparqlXmlWriter.Save(VDS.RDF.Query.SparqlResultSet,System.IO.TextWriter)">
            <summary>
            Saves the Result Set to the given Stream in the Sparql Results XML Format
            </summary>
            <param name="results"></param>
            <param name="output"></param>
        </member>
        <member name="M:VDS.RDF.Writing.SparqlXmlWriter.GenerateOutput(VDS.RDF.Query.SparqlResultSet,System.Xml.XmlWriter)">
            <summary>
            Method which generates the Sparql Query Results XML Format serialization of the Result Set
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.SparqlXmlWriter.RaiseWarning(System.String)">
            <summary>
            Helper Method which raises the Warning event when a non-fatal issue with the SPARQL Results being written is detected
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="M:VDS.RDF.Writing.SparqlXmlWriter.ToString">
            <summary>
            Gets the String representation of the writer which is a description of the syntax it produces
            </summary>
            <returns></returns>
        </member>
        <member name="E:VDS.RDF.Writing.SparqlXmlWriter.Warning">
            <summary>
            Event raised when a non-fatal issue with the SPARQL Results being written is detected
            </summary>
        </member>
        <member name="T:VDS.RDF.TripleStore">
            <summary>
            Class for representing Triple Stores which are collections of RDF Graphs
            </summary>
        </member>
        <member name="F:VDS.RDF.TripleStore._reasoners">
            <summary>
            List of Reasoners that are applied to Graphs as they are added to the Triple Store
            </summary>
        </member>
        <member name="F:VDS.RDF.TripleStore._storeInferencesExternally">
            <summary>
            Controls whether inferred information is stored in a special Graph or in the original Graph
            </summary>
        </member>
        <member name="F:VDS.RDF.TripleStore._inferenceGraphUri">
            <summary>
            Graph Uri for the special Graph used to store inferred information
            </summary>
        </member>
        <member name="M:VDS.RDF.TripleStore.#ctor">
            <summary>
            Creates a new Triple Store using a new empty Graph collection
            </summary>
        </member>
        <member name="M:VDS.RDF.TripleStore.#ctor(VDS.RDF.BaseGraphCollection)">
            <summary>
            Creates a new Triple Store using the given Graph collection which may be non-empty
            </summary>
            <param name="graphCollection">Graph Collection</param>
        </member>
        <member name="M:VDS.RDF.TripleStore.Contains(VDS.RDF.Triple)">
            <summary>
            Returns whether the Store contains the given Triple within the Query Triples
            </summary>
            <param name="t">Triple to search for</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriples(System.Uri)">
            <summary>
            Selects all Triples which have a Uri Node with the given Uri from all the Query Triples
            </summary>
            <param name="uri">Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriples(VDS.RDF.INode)">
            <summary>
            Selects all Triples which contain the given Node from all Graphs in the Triple Store
            </summary>
            <param name="n">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriplesWithObject(System.Uri)">
            <summary>
            Selects all Triples where the Object is a Uri Node with the given Uri from all Graphs in the Triple Store
            </summary>
            <param name="u">Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriplesWithObject(VDS.RDF.INode)">
            <summary>
            Selects all Triples where the Object is a given Node from all Graphs in the Triple Store
            </summary>
            <param name="n">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriplesWithPredicate(VDS.RDF.INode)">
            <summary>
            Selects all Triples where the Predicate is a given Node from all Graphs in the Triple Store
            </summary>
            <param name="n">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriplesWithPredicate(System.Uri)">
            <summary>
            Selects all Triples where the Predicate is a Uri Node with the given Uri from all Graphs in the Triple Store
            </summary>
            <param name="u">Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriplesWithSubject(VDS.RDF.INode)">
            <summary>
            Selects all Triples where the Subject is a given Node from all Graphs in the Triple Store
            </summary>
            <param name="n">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriplesWithSubject(System.Uri)">
            <summary>
            Selects all Triples where the Subject is a Uri Node with the given Uri from all Graphs in the Triple Store
            </summary>
            <param name="u">Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriplesWithSubjectPredicate(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Selects all the Triples with the given Subject-Predicate pair from all the Query Triples
            </summary>
            <param name="subj">Subject</param>
            <param name="pred">Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriplesWithPredicateObject(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Selects all the Triples with the given Predicate-Object pair from all the Query Triples
            </summary>
            <param name="pred">Predicate</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriplesWithSubjectObject(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Selects all the Triples with the given Subject-Object pair from all the Query Triples
            </summary>
            <param name="subj">Subject</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriples(System.Collections.Generic.List{System.Uri},System.Uri)">
            <summary>
            Selects all Triples which have a Uri Node with the given Uri from a Subset of Graphs in the Triple Store
            </summary>
            <param name="graphUris">List of the Graph URIs of Graphs you want to select over</param>
            <param name="uri">Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriples(System.Collections.Generic.List{System.Uri},VDS.RDF.INode)">
            <summary>
            Selects all Triples which contain the given Node from a Subset of Graphs in the Triple Store
            </summary>
            <param name="graphUris">List of the Graph URIs of Graphs you want to select over</param>
            <param name="n">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriplesWithObject(System.Collections.Generic.List{System.Uri},System.Uri)">
            <summary>
            Selects all Triples where the Object is a Uri Node with the given Uri from a Subset of Graphs in the Triple Store
            </summary>
            <param name="graphUris">List of the Graph URIs of Graphs you want to select over</param>
            <param name="u">Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriplesWithObject(System.Collections.Generic.List{System.Uri},VDS.RDF.INode)">
            <summary>
            Selects all Triples where the Object is a given Node from a Subset of Graphs in the Triple Store
            </summary>
            <param name="graphUris">List of the Graph URIs of Graphs you want to select over</param>
            <param name="n">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriplesWithPredicate(System.Collections.Generic.List{System.Uri},VDS.RDF.INode)">
            <summary>
            Selects all Triples where the Predicate is a given Node from a Subset of Graphs in the Triple Store
            </summary>
            <param name="graphUris">List of the Graph URIs of Graphs you want to select over</param>
            <param name="n">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriplesWithPredicate(System.Collections.Generic.List{System.Uri},System.Uri)">
            <summary>
            Selects all Triples where the Predicate is a Uri Node with the given Uri from a Subset of Graphs in the Triple Store
            </summary>
            <param name="graphUris">List of the Graph URIs of Graphs you want to select over</param>
            <param name="u">Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriplesWithSubject(System.Collections.Generic.List{System.Uri},VDS.RDF.INode)">
            <summary>
            Selects all Triples where the Subject is a given Node from a Subset of Graphs in the Triple Store
            </summary>
            <param name="graphUris">List of the Graph URIs of Graphs you want to select over</param>
            <param name="n">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.GetTriplesWithSubject(System.Collections.Generic.List{System.Uri},System.Uri)">
            <summary>
            Selects all Triples where the Subject is a Uri Node with the given Uri from a Subset of Graphs in the Triple Store
            </summary>
            <param name="graphUris">List of the Graph URIs of Graphs you want to select over</param>
            <param name="u">Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleStore.ExecuteQuery(System.String)">
            <summary>
            Executes a SPARQL Query on the Triple Store
            </summary>
            <param name="query">SPARQL Query as unparsed String</param>
            <returns></returns>
            <remarks>
            <para>
            This method of making queries often leads to no results because of misconceptions about what data is being queries.  dotNetRDF's SPARQL engine only queries the default unnamed graph of the triple store (the graph added with a null URI) by default unless your query uses FROM clauses to change the default graph or you use GRAPH clauses to access named graphs in the store.  Therefore a common mistake is to add a single graph to the store and then query the store which typically results in no results because usually the added graph is named and so is not queried.
            </para>
            <para>
            We recommend using a <see cref="T:VDS.RDF.Query.ISparqlQueryProcessor"/> instead for making queries over in-memory data since using our standard implementation (<see cref="T:VDS.RDF.Query.LeviathanQueryProcessor"/>) affords you much more explicit control over which graphs are queried.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.TripleStore.ExecuteQuery(VDS.RDF.Query.SparqlQuery)">
            <summary>
            Executes a SPARQL Query on the Triple Store
            </summary>
            <param name="query">SPARQL Query as a <see cref="T:VDS.RDF.Query.SparqlQuery">SparqlQuery</see> instance</param>
            <returns></returns>
            <remarks>
            <para>
            This method of making queries often leads to no results because of misconceptions about what data is being queries.  dotNetRDF's SPARQL engine only queries the default unnamed graph of the triple store (the graph added with a null URI) by default unless your query uses FROM clauses to change the default graph or you use GRAPH clauses to access named graphs in the store.  Therefore a common mistake is to add a single graph to the store and then query the store which typically results in no results because usually the added graph is named and so is not queried.
            </para>
            <para>
            We recommend using a <see cref="T:VDS.RDF.Query.ISparqlQueryProcessor"/> instead for making queries over in-memory data since using our standard implementation (<see cref="T:VDS.RDF.Query.LeviathanQueryProcessor"/>) affords you much more explicit control over which graphs are queried.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.TripleStore.ExecuteQuery(VDS.RDF.IRdfHandler,VDS.RDF.ISparqlResultsHandler,System.String)">
            <summary>
            Executes a SPARQL Query on the Triple Store processing the results with an appropriate handler from those provided
            </summary>
            <param name="rdfHandler">RDF Handler</param>
            <param name="resultsHandler">Results Handler</param>
            <param name="query">SPARQL Query as unparsed String</param>
            <remarks>
            <para>
            This method of making queries often leads to no results because of misconceptions about what data is being queries.  dotNetRDF's SPARQL engine only queries the default unnamed graph of the triple store (the graph added with a null URI) by default unless your query uses FROM clauses to change the default graph or you use GRAPH clauses to access named graphs in the store.  Therefore a common mistake is to add a single graph to the store and then query the store which typically results in no results because usually the added graph is named and so is not queried.
            </para>
            <para>
            We recommend using a <see cref="T:VDS.RDF.Query.ISparqlQueryProcessor"/> instead for making queries over in-memory data since using our standard implementation (<see cref="T:VDS.RDF.Query.LeviathanQueryProcessor"/>) affords you much more explicit control over which graphs are queried.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.TripleStore.ExecuteQuery(VDS.RDF.IRdfHandler,VDS.RDF.ISparqlResultsHandler,VDS.RDF.Query.SparqlQuery)">
            <summary>
            Executes a SPARQL Query on the Triple Store processing the results with an appropriate handler from those provided
            </summary>
            <param name="rdfHandler">RDF Handler</param>
            <param name="resultsHandler">Results Handler</param>
            <param name="query">SPARQL Query as unparsed String</param>
            <remarks>
            <para>
            This method of making queries often leads to no results because of misconceptions about what data is being queries.  dotNetRDF's SPARQL engine only queries the default unnamed graph of the triple store (the graph added with a null URI) by default unless your query uses FROM clauses to change the default graph or you use GRAPH clauses to access named graphs in the store.  Therefore a common mistake is to add a single graph to the store and then query the store which typically results in no results because usually the added graph is named and so is not queried.
            </para>
            <para>
            We recommend using a <see cref="T:VDS.RDF.Query.ISparqlQueryProcessor"/> instead for making queries over in-memory data since using our standard implementation (<see cref="T:VDS.RDF.Query.LeviathanQueryProcessor"/>) affords you much more explicit control over which graphs are queried.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.TripleStore.ApplyInference(VDS.RDF.IGraph)">
            <summary>
            Applies Inference to the given Graph
            </summary>
            <param name="g">Graph to apply inference to</param>
        </member>
        <member name="M:VDS.RDF.TripleStore.AddInferenceEngine(VDS.RDF.Query.Inference.IInferenceEngine)">
            <summary>
            Adds an Inference Engine to the Triple Store
            </summary>
            <param name="reasoner">Reasoner to add</param>
        </member>
        <member name="M:VDS.RDF.TripleStore.RemoveInferenceEngine(VDS.RDF.Query.Inference.IInferenceEngine)">
            <summary>
            Removes an Inference Engine from the Triple Store
            </summary>
            <param name="reasoner">Reasoner to remove</param>
        </member>
        <member name="M:VDS.RDF.TripleStore.ClearInferenceEngines">
            <summary>
            Clears all Inference Engines from the Triple Store
            </summary>
        </member>
        <member name="M:VDS.RDF.TripleStore.Dispose">
            <summary>
            Disposes of a Triple Store
            </summary>
        </member>
        <member name="M:VDS.RDF.TripleStore.ExecuteUpdate(System.String)">
            <summary>
            Executes an Update against the Triple Store
            </summary>
            <param name="update">SPARQL Update Command(s)</param>
            <remarks>
            As per the SPARQL 1.1 Update specification the command string may be a sequence of commands
            </remarks>
        </member>
        <member name="M:VDS.RDF.TripleStore.ExecuteUpdate(VDS.RDF.Update.SparqlUpdateCommand)">
            <summary>
            Executes a single Update Command against the Triple Store
            </summary>
            <param name="update">SPARQL Update Command</param>
        </member>
        <member name="M:VDS.RDF.TripleStore.ExecuteUpdate(VDS.RDF.Update.SparqlUpdateCommandSet)">
            <summary>
            Executes a set of Update Commands against the Triple Store
            </summary>
            <param name="updates">SPARQL Update Command Set</param>
        </member>
        <member name="M:VDS.RDF.TripleStore.OnGraphAdded(System.Object,VDS.RDF.GraphEventArgs)">
            <summary>
            Event Handler for the <see cref="E:VDS.RDF.BaseGraphCollection.GraphAdded">Graph Added</see> event of the underlying Graph Collection which calls the normal event processing of the parent class <see cref="T:VDS.RDF.BaseTripleStore">BaseTripleStore</see> and then applies Inference to the newly added Graph
            </summary>
            <param name="sender">Sender</param>
            <param name="args">Graph Event Arguments</param>
        </member>
        <member name="T:VDS.RDF.ThreadSafeTripleStore">
            <summary>
            A thread safe variant of <see cref="T:VDS.RDF.TripleStore"/>, simply a <see cref="T:VDS.RDF.TripleStore"/> instance with a <see cref="T:VDS.RDF.ThreadSafeGraphCollection"/> decorator around it's underlying <see cref="T:VDS.RDF.BaseGraphCollection"/>
            </summary>
        </member>
        <member name="M:VDS.RDF.ThreadSafeTripleStore.#ctor">
            <summary>
            Creates a new Thread Safe triple store
            </summary>
        </member>
        <member name="M:VDS.RDF.ThreadSafeTripleStore.#ctor(VDS.RDF.ThreadSafeGraphCollection)">
            <summary>
            Creates a new Thread safe triple store using the given Thread safe graph collection
            </summary>
            <param name="collection">Collection</param>
        </member>
        <member name="M:VDS.RDF.ThreadSafeTripleStore.#ctor(VDS.RDF.BaseGraphCollection)">
            <summary>
            Creates a new Thread safe triple store using a thread safe decorator around the given graph collection
            </summary>
            <param name="collection">Collection</param>
        </member>
        <member name="T:VDS.RDF.Writing.StringWriter">
            <summary>
            Static Helper class for the writing of RDF Graphs and SPARQL Result Sets to Strings rather than Streams/Files
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.StringWriter.Write(VDS.RDF.IGraph,VDS.RDF.IRdfWriter)">
            <summary>
            Writes the Graph to a String and returns the output in your chosen concrete RDF Syntax
            </summary>
            <param name="g">Graph to save</param>
            <param name="writer">Writer to use to generate the concrete RDF Syntax</param>
            <returns></returns>
            <remarks>
            Since the API allows for any <see cref="T:System.IO.TextWriter">TextWriter</see> to be passed to the <see cref="M:VDS.RDF.IRdfWriter.Save(VDS.RDF.IGraph,System.IO.TextWriter)">Save()</see> method of a <see cref="T:VDS.RDF.IRdfWriter">IRdfWriter</see> you can just pass in a <see cref="T:VDS.RDF.Writing.StringWriter">StringWriter</see> to the Save() method to get the output as a String.  This method simply provides a wrapper to doing just that.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Writing.StringWriter.Write(VDS.RDF.ITripleStore,VDS.RDF.IStoreWriter)">
            <summary>
            Writes the given Triple Store to a String and returns the output in your chosen concrete RDF dataset syntax
            </summary>
            <param name="store">Triple Store</param>
            <param name="writer">Writer to use to generate conrete RDF Syntax</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.StringWriter.Write(VDS.RDF.Query.SparqlResultSet,VDS.RDF.ISparqlResultsWriter)">
            <summary>
            Writes the SPARQL Result Set to a String and returns the Output in your chosen format
            </summary>
            <param name="results">SPARQL Result Set</param>
            <param name="writer">Writer to use to generate the SPARQL Results output</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Writing.TriGWriter">
            <summary>
            Class for writing a Triple Store in named Graph TriG syntax to a file/stream
            </summary>
            <remarks>
            <para>
            For efficiency the TriG Writer splits it's writing over several threads (currently 4), these threads share a reference to a Context object which gives Global writing context eg. the target <see cref="T:System.IO.TextWriter">TextWriter</see> being written to.  Each thread generates temporary local writing contexts as it goes along, each of these is scoped to writing a specific Graph.  Graphs are written to a <see cref="T:VDS.RDF.Writing.StringWriter">StringWriter</see> so the output for each Graph is built completely and then written in one go to the <see cref="T:System.IO.TextWriter">TextWriter</see> specified as the target of the writing in the global context.
            </para>
            </remarks>
            <threadsafety instance="true">Designed to be Thread Safe - should be able to call <see cref="M:VDS.RDF.Writing.TriGWriter.Save(VDS.RDF.ITripleStore,System.IO.TextWriter)">Save()</see> from several threads with no issue.  See Remarks for potential performance impact of this.</threadsafety>
        </member>
        <member name="M:VDS.RDF.Writing.TriGWriter.Save(VDS.RDF.ITripleStore,System.IO.TextWriter)">
            <summary>
            Saves a Store in TriG (Turtle with Named Graphs) format
            </summary>
            <param name="store">Store to save</param>
            <param name="writer">Writer to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.TriGWriter.GenerateGraphOutput(VDS.RDF.Writing.Contexts.TriGWriterContext,VDS.RDF.Writing.Contexts.TurtleWriterContext)">
            <summary>
            Generates the Output for a Graph as a String in TriG syntax
            </summary>
            <param name="globalContext">Context for writing the Store</param>
            <param name="context">Context for writing the Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.TriGWriter.GenerateTripleOutput(VDS.RDF.Writing.Contexts.TriGWriterContext,VDS.RDF.Writing.Contexts.TurtleWriterContext)">
            <summary>
            Generates the Output for a Triple as a String in Turtle syntax
            </summary>
            <param name="globalContext">Context for writing the Store</param>
            <param name="context">Context for writing the Graph</param>
        </member>
        <member name="M:VDS.RDF.Writing.TriGWriter.GenerateNodeOutput(VDS.RDF.Writing.Contexts.TriGWriterContext,VDS.RDF.Writing.Contexts.TurtleWriterContext,VDS.RDF.INode,VDS.RDF.Writing.TripleSegment)">
            <summary>
            Generates Output for Nodes in Turtle syntax
            </summary>
            <param name="globalContext">Context for writing the Store</param>
            <param name="context">Context for writing the Graph</param>
            <param name="n">Node to generate output for</param>
            <param name="segment">Segment of the Triple being written</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.TriGWriter.SaveGraphs(VDS.RDF.Writing.Contexts.TriGWriterContext)">
            <summary>
            Thread Worker method which writes Graphs to the output
            </summary>
            <param name="globalContext">Context for writing the Store</param>
        </member>
        <member name="M:VDS.RDF.Writing.TriGWriter.RaiseWarning(System.String)">
            <summary>
            Internal Helper method which raises the Warning event only if there is an Event Handler registered
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="M:VDS.RDF.Writing.TriGWriter.ToString">
            <summary>
            Gets the String representation of the writer which is a description of the syntax it produces
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Writing.TriGWriter.HighSpeedModePermitted">
            <summary>
            Gets/Sets whether High Speed Write Mode is permitted
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.TriGWriter.PrettyPrintMode">
            <summary>
            Gets/Sets whether Pretty Printing is used
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.TriGWriter.CompressionLevel">
            <summary>
            Gets/Sets the Compression Level for the writer
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.TriGWriter.N3CompatabilityMode">
            <summary>
            Gets/Sets whether N3 Compatability Mode is used, in this mode an = is written after Graph Names so an N3 parser can read the TriG file correctly
            </summary>
            <remarks>
            Defaults to <strong>false</strong> from the 0.4.1 release onwards
            </remarks>
        </member>
        <member name="P:VDS.RDF.Writing.TriGWriter.UseMultiThreadedWriting">
            <summary>
            Gets/Sets whether multi-threaded writing will be used to generate output faster
            </summary>
        </member>
        <member name="E:VDS.RDF.Writing.TriGWriter.Warning">
            <summary>
            Event which is raised when there is an issue with the Graphs being serialized that doesn't prevent serialization but the user should be aware of
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.TriGWriter.SaveGraphsDelegate">
            <summary>
            Delegate for the SaveGraphs method
            </summary>
            <param name="globalContext">Context for writing the Store</param>
        </member>
        <member name="T:VDS.RDF.Writing.NTriplesWriter">
            <summary>
            Class for generating RDF in NTriples Concrete Syntax
            </summary>
            <threadsafety instance="true">Designed to be Thread Safe - should be able to call the Save() method from multiple threads on different Graphs without issue</threadsafety>
        </member>
        <member name="M:VDS.RDF.Writing.NTriplesWriter.#ctor(VDS.RDF.Parsing.NTriplesSyntax)">
            <summary>
            Creates a new writer
            </summary>
            <param name="syntax">NTriples Syntax Mode</param>
        </member>
        <member name="M:VDS.RDF.Writing.NTriplesWriter.#ctor">
            <summary>
            Creates a new writer
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.NTriplesWriter.Save(VDS.RDF.IGraph,System.IO.TextWriter)">
            <summary>
            Saves the Graph in NTriples Syntax to the given stream
            </summary>
            <param name="g">Graph to save</param>
            <param name="output">Stream to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.NTriplesWriter.TripleToNTriples(VDS.RDF.Writing.Contexts.NTriplesWriterContext,VDS.RDF.Triple)">
            <summary>
            Converts a Triple into relevant NTriples Syntax
            </summary>
            <param name="context">Writer Context</param>
            <param name="t">Triple to convert</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.NTriplesWriter.NodeToNTriples(VDS.RDF.Writing.Contexts.NTriplesWriterContext,VDS.RDF.INode,VDS.RDF.Writing.TripleSegment)">
            <summary>
            Converts a Node into relevant NTriples Syntax
            </summary>
            <param name="context">Writer Context</param>
            <param name="n">Node to convert</param>
            <param name="segment">Segment of the Triple being written</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.NTriplesWriter.RaiseWarning(System.String)">
            <summary>
            Internal Helper method which raises the Warning event only if there is an Event Handler registered
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="M:VDS.RDF.Writing.NTriplesWriter.ToString">
            <summary>
            Gets the String representation of the writer which is a description of the syntax it produces
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Writing.NTriplesWriter.SortTriples">
            <summary>
            Gets/Sets whether Triples are sorted before being Output
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.NTriplesWriter.TripleFormatterType">
            <summary>
            Gets the type of the Triple Formatter used by this writer
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.NTriplesWriter.Syntax">
            <summary>
            Gets/Sets the NTriples syntax mode
            </summary>
        </member>
        <member name="E:VDS.RDF.Writing.NTriplesWriter.Warning">
            <summary>
            Event which is raised when there is an issue with the Graph being serialized that doesn't prevent serialization but the user should be aware of
            </summary>
        </member>
        <member name="T:VDS.RDF.Tools">
            <summary>
            Tools class which contains a number of utility methods which are declared as static methods
            </summary>
        </member>
        <member name="M:VDS.RDF.Tools.IsValidBaseUri(System.Uri)">
            <summary>
            Checks whether a Uri is valid as a Base Uri for resolving Relative URIs against
            </summary>
            <param name="baseUri">Base Uri to test</param>
            <returns>True if the Base Uri can be used to resolve Relative URIs against</returns>
            <remarks>A Base Uri is valid if it is an absolute Uri and not using the mailto: scheme</remarks>
        </member>
        <member name="M:VDS.RDF.Tools.FixMalformedUriStrings(System.String)">
            <summary>
            Checks whether a URI Reference appears malformed and if so fixes it
            </summary>
            <param name="uriref">URI Reference</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Tools.StripUriFragment(System.Uri)">
            <summary>
            Returns a URI with any Fragment ID removed from it
            </summary>
            <param name="u">URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Tools.ResolveUri(System.String,System.String)">
            <summary>
            Generic Helper Function which Resolves Uri References against a Base Uri
            </summary>
            <param name="uriref">Uri Reference to resolve</param>
            <param name="baseUri">Base Uri to resolve against</param>
            <returns>Resolved Uri as a String</returns>
            <exception cref="T:VDS.RDF.Parsing.RdfParseException">RDF Parse Exception if the Uri cannot be resolved for a know reason</exception>
            <exception cref="!:UriFormatException">Uri Format Exception if one/both of the URIs is malformed</exception>
        </member>
        <member name="M:VDS.RDF.Tools.ResolveUri(System.Uri,System.Uri)">
            <summary>
            Generic Helper Function which Resolves Uri References against a Base Uri
            </summary>
            <param name="uriref">Uri Reference to resolve</param>
            <param name="baseUri">Base Uri to resolve against</param>
            <returns>Resolved Uri as a String</returns>
            <exception cref="!:UriFormatException">Uri Format Exception if one/both of the URIs is malformed</exception>
        </member>
        <member name="M:VDS.RDF.Tools.ResolveQName(System.String,VDS.RDF.INamespaceMapper,System.Uri)">
            <summary>
            Resolves a QName into a Uri using the Namespace Mapper and Base Uri provided
            </summary>
            <param name="qname">QName to resolve</param>
            <param name="nsmap">Namespace Map to resolve against</param>
            <param name="baseUri">Base Uri to resolve against</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Tools.ResolveQName(System.String,VDS.RDF.INamespaceMapper,System.Uri,System.Boolean)">
            <summary>
            Resolves a QName into a Uri using the Namespace Mapper and Base Uri provided
            </summary>
            <param name="qname">QName to resolve</param>
            <param name="nsmap">Namespace Map to resolve against</param>
            <param name="baseUri">Base Uri to resolve against</param>
            <param name="allowDefaultPrefixFallback">Whether when the default prefix is used but not defined it can fallback to Base URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Tools.ResolveUriOrQName(VDS.RDF.Parsing.Tokens.IToken,VDS.RDF.INamespaceMapper,System.Uri)">
            <summary>
            Resolves a QName/Uri into a Uri using the Namespace Mapper and Base Uri provided
            </summary>
            <param name="t">QName/Uri to resolve</param>
            <param name="nsmap">Namespace Map to resolve against</param>
            <param name="baseUri">Base Uri to resolve against</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Tools.CopyNode(VDS.RDF.INode,VDS.RDF.IGraph,System.Boolean)">
            <summary>
            Copies a Node so it can be used in another Graph since by default Triples cannot contain Nodes from more than one Graph
            </summary>
            <param name="original">Node to Copy</param>
            <param name="target">Graph to Copy into</param>
            <param name="keepOriginalGraphUri">Indicates whether the Copy should preserve the Graph Uri of the Node being copied</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Tools.CopyNode(VDS.RDF.INode,VDS.RDF.IGraph)">
            <summary>
            Copies a Node so it can be used in another Graph since by default Triples cannot contain Nodes from more than one Graph
            </summary>
            <param name="original">Node to Copy</param>
            <param name="target">Graph to Copy into</param>
            <returns></returns>
            <remarks>
            <para>
            <strong>Warning:</strong> Copying Blank Nodes may lead to unforseen circumstances since no remapping of IDs between Graphs is done
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Tools.CopyNode(VDS.RDF.INode,VDS.RDF.INodeFactory)">
            <summary>
            Copies a Node using another Node Factory
            </summary>
            <param name="original">Node to copy</param>
            <param name="target">Factory to copy into</param>
            <returns></returns>
            <remarks>
            <para>
            <strong>Warning:</strong> Copying Blank Nodes may lead to unforseen circumstances since no remapping of IDs between Factories is done
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Tools.CopyTriple(VDS.RDF.Triple,VDS.RDF.IGraph)">
            <summary>
            Copies a Triple from one Graph to another
            </summary>
            <param name="t">Triple to copy</param>
            <param name="target">Graph to copy to</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Tools.CopyTriple(VDS.RDF.Triple,VDS.RDF.IGraph,System.Boolean)">
            <summary>
            Copies a Triple from one Graph to another
            </summary>
            <param name="t">Triple to copy</param>
            <param name="target">Graph to copy to</param>
            <param name="keepOriginalGraphUri">Indicates whether the Copy should preserve the Graph Uri of the Nodes being copied</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Tools.CombineHashCodes(System.Object,System.Object)">
            <summary>
            Does a quick and simple combination of the Hash Codes of two Objects
            </summary>
            <param name="x">First Object</param>
            <param name="y">Second Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Tools.HttpDebugRequest(System.Net.HttpWebRequest)">
            <summary>
            Prints Debugging Output to the Console Standard Out for a HTTP Web Request
            </summary>
            <param name="httpRequest">HTTP Web Request</param>
            <remarks><strong>Only available in Debug builds</strong></remarks>
        </member>
        <member name="M:VDS.RDF.Tools.HttpDebugResponse(System.Net.HttpWebResponse)">
            <summary>
            Prints Debugging Output to the Console Standard Out for a HTTP Web Response
            </summary>
            <param name="httpResponse">HTTP Web Response</param>
            <remarks><strong>Only available in Debug builds</strong></remarks>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.TurtleTokeniser">
            <summary>
            A Class for Reading an Input Stream and generating Turtle Tokens from it
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TurtleTokeniser.#ctor(System.IO.StreamReader)">
            <summary>
            Creates a new Turtle Tokeniser
            </summary>
            <param name="input">The Input Stream to generate Tokens from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TurtleTokeniser.#ctor(VDS.RDF.Parsing.ParsingTextReader)">
            <summary>
            Creates a new Turtle Tokeniser
            </summary>
            <param name="input">The Input Stream to generate Tokens from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TurtleTokeniser.#ctor(System.IO.TextReader)">
            <summary>
            Creates a new Turtle Tokeniser
            </summary>
            <param name="input">Input to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TurtleTokeniser.#ctor(System.IO.StreamReader,VDS.RDF.Parsing.TurtleSyntax)">
            <summary>
            Creates a new Turtle Tokeniser
            </summary>
            <param name="input">The Input Stream to generate Tokens from</param>
            <param name="syntax">Turtle Syntax</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TurtleTokeniser.#ctor(VDS.RDF.Parsing.ParsingTextReader,VDS.RDF.Parsing.TurtleSyntax)">
            <summary>
            Creates a new Turtle Tokeniser
            </summary>
            <param name="input">The Input Stream to generate Tokens from</param>
            <param name="syntax">Turtle Syntax</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TurtleTokeniser.#ctor(System.IO.TextReader,VDS.RDF.Parsing.TurtleSyntax)">
            <summary>
            Creates a new Turtle Tokeniser
            </summary>
            <param name="input">Input to read from</param>
            <param name="syntax">Turtle Syntax</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TurtleTokeniser.GetNextToken">
            <summary>
            Gets the next parseable Token from the Input or raises an Error
            </summary>
            <returns></returns>
            <exception cref="T:VDS.RDF.Parsing.RdfParseException">Occurs when a Token cannot be parsed</exception>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TurtleTokeniser.TryGetDirectiveToken">
            <summary>
            Internal Helper method which attempts to get a Directive Token
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TurtleTokeniser.TryGetPrefixToken">
            <summary>
            Internal Helper method which attempts to get a Prefix Token
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TurtleTokeniser.TryGetQNameToken">
            <summary>
            Internal Helper method which attempts to get a QName Token
            </summary>
            <returns></returns>
            <remarks>In fact this function may return a number of Tokens depending on the characters it finds.  It may find a QName, Plain Literal, Blank Node QName (with ID) or Keyword.  QName &amp; Keyword Validation is carried out by this function</remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TurtleTokeniser.TryGetLanguageSpecToken">
            <summary>
            Internal Helper method which attempts to get a Language Specifier Token
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TurtleTokeniser.TryGetDataTypeToken">
            <summary>
            Internal Helper method which attempts to get a Date Type Token
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TurtleTokeniser.TryGetCommentToken">
            <summary>
            Internal Helper method which attempts to get a Comment Token
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.BOFToken">
            <summary>
            Token which represents the Start of the Input
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BOFToken.#ctor">
            <summary>
            Creates a new Beginning of File Token
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.EOFToken">
            <summary>
            Token which represents the End of the Input
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.EOFToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new End of File Token
            </summary>
            <param name="line">Line at which the File Ends</param>
            <param name="pos">Column as which the File Ends</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.EOLToken">
            <summary>
            Token which represents the End of a Line
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.EOLToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new End of Line Token
            </summary>
            <param name="line">Line</param>
            <param name="pos">Column at which the line ends</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.ATToken">
            <summary>
            Token which represents the @ Character
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.ATToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new @ Token
            </summary>
            <param name="line">Line at which the @ occurs</param>
            <param name="pos">Column at which the @ occurs</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.DotToken">
            <summary>
            Token which represents the . Character
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.DotToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new . Token
            </summary>
            <param name="line">Line at which the . occurs</param>
            <param name="pos">Column at which the . occurs</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.SemicolonToken">
            <summary>
            Token which represents the ; Character
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.SemicolonToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new ; Token
            </summary>
            <param name="line">Line at which the ; occurs</param>
            <param name="pos">Column at which the ; occurs</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.CommaToken">
            <summary>
            Token which represents the , Character
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.CommaToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new , Token
            </summary>
            <param name="line">Line at which the , occurs</param>
            <param name="pos">Column at which the , occurs</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.TabToken">
            <summary>
            Tokens which represents the tab character
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TabToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new Tab Token
            </summary>
            <param name="line">Line at which the tab occurs</param>
            <param name="pos">Column at which the tab occurs</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.HashToken">
            <summary>
            Token which represents the # Character
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.HashToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new # Token
            </summary>
            <param name="line">Line at which the # occurs</param>
            <param name="pos">Column at which the # occurs</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.UnderscoreToken">
            <summary>
            Token which repreents the _ Character
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.UnderscoreToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new _ Token
            </summary>
            <param name="line">Line at which the _ occurs</param>
            <param name="pos">Column at which the _ occurs</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.HatHatToken">
            <summary>
            Token which represents the ^^ sequence used for Data Type specification in some RDF Syntaxes
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.HatHatToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new ^^Token
            </summary>
            <param name="line">Line at which the ^^ occurs</param>
            <param name="pos">Column at which the ^^ occurs</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.HatToken">
            <summary>
            Token which represents the ^ Character used for Reverse Path Traversal in somme RDF Syntaxes
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.HatToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new ^ Token
            </summary>
            <param name="line">Line at which the ^ occurs</param>
            <param name="pos">Column at which the ^ occurs</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.ExclamationToken">
            <summary>
            Token which represents the ! Character used for Forward Path Traversal in some RDF Syntaxes
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.ExclamationToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new ! Token
            </summary>
            <param name="line">Line at which the ! occurs</param>
            <param name="pos">Column at which the ! occurs</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.CommentToken">
            <summary>
            Token which represents Comments
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.CommentToken.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new Comment Token
            </summary>
            <param name="value">The Comment</param>
            <param name="line">Line on which the Comment occurs</param>
            <param name="start">Column at which the Comment starts</param>
            <param name="end">Column at which the Comment ends</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.LeftSquareBracketToken">
            <summary>
            Token which represents the [ Character
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.LeftSquareBracketToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new [ Token
            </summary>
            <param name="line">Line at which the [ occurs</param>
            <param name="pos">Column at which the [ occurs</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.RightSquareBracketToken">
            <summary>
            Token which represents the ] Character
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.RightSquareBracketToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new ] Token
            </summary>
            <param name="line">Line at which the ] occurs</param>
            <param name="pos">Column at which the ] occurs</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.LeftBracketToken">
            <summary>
            Token which represents the ( Character
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.LeftBracketToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new ( Token
            </summary>
            <param name="line">Line at which the ( occurs</param>
            <param name="pos">Column at which the ( occurs</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.RightBracketToken">
            <summary>
            Token which represents the ) Character
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.RightBracketToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new ) Token
            </summary>
            <param name="line">Line at which the ) occurs</param>
            <param name="pos">Column at which the ) occurs</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.LeftCurlyBracketToken">
            <summary>
            Token which represents the { Character
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.LeftCurlyBracketToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new { Token
            </summary>
            <param name="line">Line at which the { occurs</param>
            <param name="pos">Column at which the { occurs</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.RightCurlyBracketToken">
            <summary>
            Token which represents the } Character
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.RightCurlyBracketToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new } Token
            </summary>
            <param name="line">Line at which the } occurs</param>
            <param name="pos">Column at which the } occurs</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.AssignmentToken">
            <summary>
            Token which reprsents the := Assignment Operator
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.AssignmentToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new := Token
            </summary>
            <param name="line">Line on which the := occurs</param>
            <param name="post">Position at which the := occurs</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.QuestionToken">
            <summary>
            Token which represents the ? Character
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.QuestionToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new ? Token
            </summary>
            <param name="line">Line at which the ? occurs</param>
            <param name="pos">Column at which the ? occurs</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.BitwiseOrToken">
            <summary>
            Token which represents the | Character
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BitwiseOrToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new | Token
            </summary>
            <param name="line">Line at which the | occurs</param>
            <param name="pos">Column at which the | occurs</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.PrefixDirectiveToken">
            <summary>
            Token which represents a Prefix Directive
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.PrefixDirectiveToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new Prefix Direction Token
            </summary>
            <param name="line">Line at which the Prefix Directive occurs</param>
            <param name="pos">Column at which the Prefix Directive occurs</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.PrefixToken">
            <summary>
            Token which represents the Prefix specified after a Prefix Directive
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.PrefixToken.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new Prefix Token
            </summary>
            <param name="value">Prefix</param>
            <param name="line">Line at which the Prefix occurs</param>
            <param name="start">Column at which the Prefix starts</param>
            <param name="end">Column at which the Prefix ends</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.BaseDirectiveToken">
            <summary>
            Token which represents a Base Directive
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BaseDirectiveToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new Base Directive Token
            </summary>
            <param name="line">Line at which the Base Directive occurs</param>
            <param name="pos">Column at which the Base Directive occurs</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.KeywordDirectiveToken">
            <summary>
            Token which represents a Keyword Directive
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.KeywordDirectiveToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new Keyword Directive Token
            </summary>
            <param name="line">Line at which the Keyword Directive occurs</param>
            <param name="pos">Column at which the Keyword Directive occurs</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.ForAllQuantifierToken">
            <summary>
            Token which represents a For All Quantifier
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.ForAllQuantifierToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new For All Quantifier Token
            </summary>
            <param name="line">Line at which the For All Quantifier occurs</param>
            <param name="pos">Column at which the For All Quantifier occurs</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.ForSomeQuantifierToken">
            <summary>
            Token which represents a For Some Quantifier
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.ForSomeQuantifierToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new For Some Quantifier Token
            </summary>
            <param name="line">Line at which the For Some Quantifier occurs</param>
            <param name="pos">Column at which the For Some Quantifier occurs</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.UriToken">
            <summary>
            Token which represents URIs
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.UriToken.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new Uri Token
            </summary>
            <param name="value">Value of the Uri including the &lt; &gt; deliminators</param>
            <param name="line">Line the Uri occurs on</param>
            <param name="start">Column the Uri starts at</param>
            <param name="end">Column the Uri ends at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.QNameToken">
            <summary>
            Token which represents QNames
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.QNameToken.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new QName Token
            </summary>
            <param name="value">QName</param>
            <param name="line">Line the QName occurs on</param>
            <param name="start">Column the QName starts at</param>
            <param name="end">Column the QName ends at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.PlainLiteralToken">
            <summary>
            Token which represents Plain (Unquoted) Literals
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.PlainLiteralToken.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new Plain Literal Token
            </summary>
            <param name="value">Literal Value</param>
            <param name="line">Line the Literal occurs on</param>
            <param name="start">Column the Literal starts at</param>
            <param name="end">Column the Literal ends at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.LiteralToken">
            <summary>
            Token which represents Literals
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.LiteralToken.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new Literal Token
            </summary>
            <param name="value">Literal Value including the Quote deliminators</param>
            <param name="line">Line the Literal occurs on</param>
            <param name="start">Column the Literal starts at</param>
            <param name="end">Column the Literal ends at</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.LiteralToken.#ctor(System.String,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new Literal Token
            </summary>
            <param name="value">Literal Value including the Quote deliminators</param>
            <param name="startLine">Line the Literal starts on</param>
            <param name="endLine">Line the Literal ends on</param>
            <param name="start">Column the Literal starts at</param>
            <param name="end">Column the Literal ends at</param>
            <remarks>
            Most syntaxes use different deliminators for multiline literals and will usually use a <see cref="T:VDS.RDF.Parsing.Tokens.LongLiteralToken">LongLiteralToken</see> instead but some formats like CSV only use quotes for multiline literals and use no delimitors for single line literals
            </remarks>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.LongLiteralToken">
            <summary>
            Token which represents Long Literals (allows multi-line values)
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.LongLiteralToken.#ctor(System.String,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new Long Literal Token
            </summary>
            <param name="value">Literal Value including the Triple Quote deliminators</param>
            <param name="startLine">Line the Long Literal starts on</param>
            <param name="endLine">Line the Long Literal ends on</param>
            <param name="start">Column the Literal starts at</param>
            <param name="end">Column the Literal ends at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.LanguageSpecifierToken">
            <summary>
            Token which represents the Language Specifier for a Literal
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.LanguageSpecifierToken.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new Language Specifier Token
            </summary>
            <param name="value">Language Specifier</param>
            <param name="line">Line the Literal occurs on</param>
            <param name="start">Column the Literal starts at</param>
            <param name="end">Column the Literal ends at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.DataTypeToken">
            <summary>
            Token which represents the Data Type for a Literal
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.DataTypeToken.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new DataType Token
            </summary>
            <param name="value">DataType Uri including the &lt; &gt; deliminators or a QName</param>
            <param name="line">Line the DataType occurs on</param>
            <param name="start">Column the DataType starts at</param>
            <param name="end">Column the DataType ends at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.LiteralWithLanguageSpecifierToken">
            <summary>
            Token which represents Literals with Language Specifiers
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.LiteralWithLanguageSpecifierToken.#ctor(VDS.RDF.Parsing.Tokens.IToken,VDS.RDF.Parsing.Tokens.LanguageSpecifierToken)">
            <summary>
            Creates a new Literal with Language Specifier Token
            </summary>
            <param name="lit">Literal Token</param>
            <param name="lang">Language Specifier Token</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.LiteralWithLanguageSpecifierToken.Language">
            <summary>
            The Language Specifier for this Literal
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.LiteralWithDataTypeToken">
            <summary>
            Token which represents Literals with Data Types
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.LiteralWithDataTypeToken.#ctor(VDS.RDF.Parsing.Tokens.IToken,VDS.RDF.Parsing.Tokens.DataTypeToken)">
            <summary>
            Creates a new Literal with DataType Token
            </summary>
            <param name="lit">Literal Token</param>
            <param name="dt">DataType Token</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.LiteralWithDataTypeToken.DataType">
            <summary>
            The Data Type Uri/QName for this Literal
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.GraphLiteralToken">
            <summary>
            Token which represents Graph Literals
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.GraphLiteralToken.#ctor(System.String,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new Graph Literal Token
            </summary>
            <param name="value">Value of the Graph Literal</param>
            <param name="startLine">Line the Graph Literal starts on</param>
            <param name="endLine">Line the Graph Literal ends on</param>
            <param name="startPos">Column the Graph Literal starts at</param>
            <param name="endPos">Column the Graph Literal ends at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.BlankNodeToken">
            <summary>
            Token which represents anonymous Blank Nodes
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BlankNodeToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new Anonymous Blank Node Token
            </summary>
            <param name="line">Line the Blank Node occurs on</param>
            <param name="pos">Column the Blank Node occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.BlankNodeWithIDToken">
            <summary>
            Token which represents named Blank Nodes
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BlankNodeWithIDToken.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new Blank Node Token
            </summary>
            <param name="value">ID of the Blank Node</param>
            <param name="line">Line the Blank Node occurs on</param>
            <param name="start">Column the Blank Node starts at</param>
            <param name="end">Column the Blank Node ends at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.BlankNodeCollectionToken">
            <summary>
            Token which represents Blank Node Collections
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BlankNodeCollectionToken.#ctor(System.Collections.Generic.Stack{VDS.RDF.Parsing.Tokens.IToken},System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new Blank Node Collection Token
            </summary>
            <param name="contents">Contents of the Blank Node Collection</param>
            <param name="startline">Line the Collection starts on</param>
            <param name="endline">Line the Collection ends on</param>
            <param name="start">Column the Collection starts at</param>
            <param name="end">Column the Collection ends at</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.BlankNodeCollectionToken.Collection">
            <summary>
            The Tokens contained in the Blank Node Collection
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.KeywordAToken">
            <summary>
            Token representing the 'a' Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.KeywordAToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new 'a' Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Column the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.KeywordIsToken">
            <summary>
            Token representing the 'is' Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.KeywordIsToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new 'is' Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Column the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.KeywordOfToken">
            <summary>
            Token representing the 'of' Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.KeywordOfToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new 'of' Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Column the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.ImpliesToken">
            <summary>
            Token representing the '=>' implies Syntax
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.ImpliesToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new '=>' Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Column the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.ImpliedByToken">
            <summary>
            Token representing the '>=' implied by Syntax
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.ImpliedByToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new '&lt;=' Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Column the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.EqualityToken">
            <summary>
            Token representing the '=' equality Syntax
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.EqualityToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new '=' Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Column the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.CustomKeywordToken">
            <summary>
            Token representing the use of a Custom Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.CustomKeywordToken.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new Custom Keyword Token
            </summary>
            <param name="value">Custom Keyword</param>
            <param name="line">Line the Keyword occurs on</param>
            <param name="start">Column the Keyword starts at</param>
            <param name="end">Column the Keyword ends at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.CustomKeywordDefinitionToken">
            <summary>
            Token representing the definition of a Custom Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.CustomKeywordDefinitionToken.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new Custom Keyword Definition Token
            </summary>
            <param name="value">Custom Keyword Definition</param>
            <param name="line">Line the Keyword occurs on</param>
            <param name="start">Column the Keyword starts at</param>
            <param name="end">Column the Keyword ends at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.VariableToken">
            <summary>
            Token representing Variables
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.VariableToken.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new Variable Token
            </summary>
            <param name="value">Variable</param>
            <param name="line">Line the Variable occurs on</param>
            <param name="start">Column the Variable starts at</param>
            <param name="end">Column the Variable ends at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.UnicodeSpecsHelper">
            <summary>
            Helper Class which defines some Test Functions for testing the Unicode Category of Characters
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.UnicodeSpecsHelper.HighSurrogateStart">
            <summary>
            Start of high surrogate range
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.UnicodeSpecsHelper.HighSurrogateEnd">
            <summary>
            End of high surrogate range
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.UnicodeSpecsHelper.LowSurrogateStart">
            <summary>
            Start of low surrogate range
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.UnicodeSpecsHelper.LowSurrogateEnd">
            <summary>
            End of low surrogate range
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.UnicodeSpecsHelper.IsLetter(System.Char)">
            <summary>
            Checks whether a given Character is considered a Letter
            </summary>
            <param name="c">Character to Test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.UnicodeSpecsHelper.IsLetterOrDigit(System.Char)">
            <summary>
            Checks whether a given Character is considered a Letter or Digit
            </summary>
            <param name="c">Character to Test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.UnicodeSpecsHelper.IsLetterModifier(System.Char)">
            <summary>
            Checks whether a given Character is considered a Letter Modifier
            </summary>
            <param name="c">Character to Test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.UnicodeSpecsHelper.IsDigit(System.Char)">
            <summary>
            Checks whether a given Character is considered a Digit
            </summary>
            <param name="c">Character to Test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.UnicodeSpecsHelper.IsHighSurrogate(System.Char)">
            <summary>
            Indicates whether the specified <see cref="T:System.Char"/> object is a high surrogate.
            </summary>
            
            <returns>
            true if the numeric value of the <paramref name="c"/> parameter ranges from U+D800 through U+DBFF; otherwise, false.
            </returns>
            <param name="c">The Unicode character to evaluate. </param><filterpriority>1</filterpriority>
        </member>
        <member name="M:VDS.RDF.Parsing.UnicodeSpecsHelper.IsLowSurrogate(System.Char)">
            <summary>
            Indicates whether the specified <see cref="T:System.Char"/> object is a low surrogate.
            </summary>
            
            <returns>
            true if the numeric value of the <paramref name="c"/> parameter ranges from U+DC00 through U+DFFF; otherwise, false.
            </returns>
            <param name="c">The character to evaluate. </param><filterpriority>1</filterpriority>
        </member>
        <member name="M:VDS.RDF.Parsing.UnicodeSpecsHelper.ConvertToUtf32(System.Char,System.Char)">
            <summary>
            Converts the value of a UTF-16 encoded surrogate pair into a Unicode code point.
            </summary>
            
            <returns>
            The 21-bit Unicode code point represented by the <paramref name="highSurrogate"/> and <paramref name="lowSurrogate"/> parameters.
            </returns>
            <param name="highSurrogate">A high surrogate code point (that is, a code point ranging from U+D800 through U+DBFF). </param>
            <param name="lowSurrogate">A low surrogate code point (that is, a code point ranging from U+DC00 through U+DFFF). </param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="highSurrogate"/> is not in the range U+D800 through U+DBFF, or <paramref name="lowSurrogate"/> is not in the range U+DC00 through U+DFFF. </exception>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:VDS.RDF.Parsing.UnicodeSpecsHelper.ConvertToChar(System.String)">
            <summary>
            Converts a Hex Escape into the relevant Unicode Character
            </summary>
            <param name="hex">Hex code</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.UnicodeSpecsHelper.ConvertToChars(System.String)">
            <summary>
            Converts a Hex Escape into the relevant UTF-16 codepoints
            </summary>
            <param name="hex"></param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Parsing.UriLoader">
            <summary>
            Static Helper Class for dereferencing URIs and attempting to parse the results of a HTTP GET request to the URI into RDF
            </summary>
            <remarks>
            <h3>Caching</h3>
            <para>
            As of the 0.2.2 release the loader has support for caching retrieved data locally built into it (for Graphs only), caching is done using ETags where the remote server provides them or just by a user-defineable 'freshness' criteria (i.e. number of hours retrieved resources should be cached for).  By default this caching happens in the system temporary directory which means it is non-persistent i.e. if you run your application using dotNetRDF it may cache stuff during the session but once the application is closed the operating system may freely delete the cached data.  If you wish to have a persistent cache then you can use the <see cref="!:UriLoader.CacheDirectory">CacheDirectory</see> property to set your own cache directory.  Even when you set your own cache directory dotNetRDF will delete obsolete data from it over time though this will only happen when a new request invalidates previously cached data.
            </para>
            <para>
            If you wish to completely control the Cache you can implement your own <see cref="!:IUriLoaderCache">IUriLoaderCache</see> implementation and use it by setting the <see cref="!:UriLoader.Cache">Cache</see> property
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.UriLoader.RaiseWarning(System.String)">
            <summary>
            Raises warning messages
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="M:VDS.RDF.Parsing.UriLoader.RaiseStoreWarning(System.String)">
            <summary>
            Raises store warning messages
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="M:VDS.RDF.Parsing.UriLoader.Load(VDS.RDF.IGraph,System.Uri,VDS.RDF.IRdfReader,VDS.RDF.GraphCallback,System.Object)">
            <summary>
            Attempts to load a RDF Graph from a URI asynchronously
            </summary>
            <param name="g">Graph to assert triple in</param>
            <param name="u">URI to load from</param>
            <param name="parser">Parser to use</param>
            <param name="callback">Callback to invoke when the operation completes</param>
            <param name="state">State to pass to the callback</param>
            <remarks>
            <para>
            Uses the supplied parser to attempt parsing regardless of the actual Content Type returned
            </para>
            <para>
            In the event that the URI is a File URI the <see cref="!:FileLoader">FileLoader</see> will be used instead. If the URI is a Data URI then the <see cref="T:VDS.RDF.Parsing.DataUriLoader">DataUriLoader</see> will be used instead.
            </para>
            <para>
            <strong>Note:</strong> UriLoader will assign the Graph the source URI as it's Base URI unless the Graph already has a Base URI or is non-empty prior to attempting parsing.  Note that any Base URI specified in the RDF contained in the file will override this initial Base URI.  In some cases this may lead to invalid RDF being accepted and generating strange relative URIs, if you encounter this either set a Base URI prior to calling this method or create an instance of the relevant parser and invoke it directly.
            </para>
            <para>
            If the loading completes normally the callback will be invoked normally, if an error occurs it will be invoked and passed an instance of <see cref="T:VDS.RDF.AsyncError"/> as the state which contains details of the error and the original state.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.UriLoader.Load(VDS.RDF.IGraph,System.Uri,VDS.RDF.GraphCallback,System.Object)">
            <summary>
            Attempts to load a RDF Graph from a URI asynchronously
            </summary>
            <param name="g">Graph to assert triple in</param>
            <param name="u">URI to load from</param>
            <param name="callback">Callback to invoke when the operation completes</param>
            <param name="state">State to pass to the callback</param>
            <remarks>
            <para>
            Will attempt to autodetect the format of the RDF based on the Content-Type header of the HTTP response
            </para>
            <para>
            In the event that the URI is a File URI the <see cref="!:FileLoader">FileLoader</see> will be used instead. If the URI is a Data URI then the <see cref="T:VDS.RDF.Parsing.DataUriLoader">DataUriLoader</see> will be used instead.
            </para>
            <para>
            <strong>Note:</strong> UriLoader will assign the Graph the source URI as it's Base URI unless the Graph already has a Base URI or is non-empty prior to attempting parsing.  Note that any Base URI specified in the RDF contained in the file will override this initial Base URI.  In some cases this may lead to invalid RDF being accepted and generating strange relative URIs, if you encounter this either set a Base URI prior to calling this method or create an instance of the relevant parser and invoke it directly.
            </para>
            <para>
            If the loading completes normally the callback will be invoked normally, if an error occurs it will be invoked and passed an instance of <see cref="T:VDS.RDF.AsyncError"/> as the state which contains details of the error and the original state.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.UriLoader.Load(VDS.RDF.IRdfHandler,System.Uri,VDS.RDF.IRdfReader,VDS.RDF.RdfHandlerCallback,System.Object)">
            <summary>
            Attempts to load a RDF Graph from a URI asynchronously using an RDF Handler
            </summary>
            <param name="handler">RDF Handler to use</param>
            <param name="u">URI to load from</param>
            <param name="parser">Parser to use</param>
            <param name="callback">Callback to invoke when the operation completes</param>
            <param name="state">State to pass to the callback</param>
            <remarks>
            <para>
            Uses the supplied parser to attempt parsing regardless of the actual Content Type returned
            </para>
            <para>
            In the event that the URI is a File URI the <see cref="!:FileLoader">FileLoader</see> will be used instead
            </para>
            <para>
            If the URI is a Data URI then the <see cref="T:VDS.RDF.Parsing.DataUriLoader">DataUriLoader</see> will be used instead.
            </para>
            <para>
            If the loading completes normally the callback will be invoked normally, if an error occurs it will be invoked and passed an instance of <see cref="T:VDS.RDF.AsyncError"/> as the state which contains details of the error and the original state.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.UriLoader.Load(VDS.RDF.IRdfHandler,System.Uri,VDS.RDF.RdfHandlerCallback,System.Object)">
            <summary>
            Attempts to load a RDF Graph from a URI asynchronously using an RDF Handler
            </summary>
            <param name="handler">RDF Handler to use</param>
            <param name="u">URI to load from</param>
            <param name="callback">Callback to invoke when the operation completes</param>
            <param name="state">State to pass to the callback</param>
            <remarks>
            <para>
            Attempts to autodetect the RDF format based on the Content-Type header of the HTTP response
            </para>
            <para>
            If the loading completes normally the callback will be invoked normally, if an error occurs it will be invoked and passed an instance of <see cref="T:VDS.RDF.AsyncError"/> as the state which contains details of the error and the original state.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.UriLoader.Load(VDS.RDF.ITripleStore,System.Uri,VDS.RDF.IStoreReader,VDS.RDF.TripleStoreCallback,System.Object)">
            <summary>
            Attempts to load a RDF dataset asynchronously from the given URI into the given Triple Store
            </summary>
            <param name="store">Triple Store to load into</param>
            <param name="u">URI to attempt to get a RDF dataset from</param>
            <param name="parser">Parser to use to parse the RDF dataset</param>
            <param name="callback">Callback to invoke when the operation completes</param>
            <param name="state">State to pass to the callback</param>
            <remarks>
            <para>
            If the <paramref name="parser"/> parameter is set to null then this method attempts to select the relevant Store Parser based on the Content Type header returned in the HTTP Response.
            </para>
            <para>
            If you know ahead of time the Content Type you can explicitly pass in the parser to use.
            </para>
            <para>
            If the loading completes normally the callback will be invoked normally, if an error occurs it will be invoked and passed an instance of <see cref="T:VDS.RDF.AsyncError"/> as the state which contains details of the error and the original state.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.UriLoader.Load(VDS.RDF.ITripleStore,System.Uri,VDS.RDF.TripleStoreCallback,System.Object)">
            <summary>
            Attempts to load a RDF dataset asynchronously from the given URI into the given Triple Store
            </summary>
            <param name="store">Triple Store to load into</param>
            <param name="u">URI to attempt to get a RDF dataset from</param>
            <param name="callback">Callback to invoke when the operation completes</param>
            <param name="state">State to pass to the callback</param>
            <remarks>
            <para>
            Attempts to select the relevant Store Parser based on the Content Type header returned in the HTTP Response.
            </para>
            <para>
            If the loading completes normally the callback will be invoked normally, if an error occurs it will be invoked and passed an instance of <see cref="T:VDS.RDF.AsyncError"/> as the state which contains details of the error and the original state.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.UriLoader.Load(VDS.RDF.IRdfHandler,System.Uri,VDS.RDF.IStoreReader,VDS.RDF.RdfHandlerCallback,System.Object)">
            <summary>
            Attempts to load a RDF dataset asynchronously from the given URI using a RDF Handler
            </summary>
            <param name="handler">RDF Handler to use</param>
            <param name="u">URI to attempt to get a RDF dataset from</param>
            <param name="parser">Parser to use to parse the RDF dataset</param>
            <param name="callback">Callback to invoke when the operation completes</param>
            <param name="state">State to pass to the callback</param>
            <remarks>
            <para>
            If the <paramref name="parser"/> parameter is set to null then this method attempts to select the relevant Store Parser based on the Content Type header returned in the HTTP Response.
            </para>
            <para>
            If you know ahead of time the Content Type you can explicitly pass in the parser to use.
            </para>
            <para>
            If the loading completes normally the callback will be invoked normally, if an error occurs it will be invoked and passed an instance of <see cref="T:VDS.RDF.AsyncError"/> as the state which contains details of the error and the original state.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.UriLoader.LoadDataset(VDS.RDF.IRdfHandler,System.Uri,VDS.RDF.RdfHandlerCallback,System.Object)">
            <summary>
            Attempts to load a RDF dataset asynchronously from the given URI using a RDF Handler
            </summary>
            <param name="handler">RDF Handler to use</param>
            <param name="u">URI to attempt to get a RDF dataset from</param>
            <param name="callback">Callback to invoke when the operation completes</param>
            <param name="state">State to pass to the callback</param>
            <remarks>
            <para>
            Attempts to select the relevant Store Parser based on the Content Type header returned in the HTTP Response.
            </para>
            <para>
            If the loading completes normally the callback will be invoked normally, if an error occurs it will be invoked and passed an instance of <see cref="T:VDS.RDF.AsyncError"/> as the state which contains details of the error and the original state.
            </para>
            </remarks>
        </member>
        <member name="P:VDS.RDF.Parsing.UriLoader.UserAgent">
            <summary>
            Gets/Sets an optional User Agent string that will be appended to HTTP Requests
            </summary>
        </member>
        <member name="E:VDS.RDF.Parsing.UriLoader.Warning">
            <summary>
            Event which is raised when a parser that is invoked by the UriLoader notices a non-fatal issue with the RDF syntax
            </summary>
        </member>
        <member name="E:VDS.RDF.Parsing.UriLoader.StoreWarning">
            <summary>
            Event which is raised when a store parser that is invoked by the UriLoader notices a non-fatal issue with the RDF dataset syntax
            </summary>
        </member>
        <member name="T:VDS.RDF.BaseUriNode">
            <summary>
            Abstract Base Class for URI Nodes
            </summary>
        </member>
        <member name="M:VDS.RDF.BaseUriNode.#ctor(VDS.RDF.IGraph,System.Uri)">
            <summary>
            Internal Only Constructor for URI Nodes
            </summary>
            <param name="g">Graph this Node is in</param>
            <param name="uri">URI</param>
        </member>
        <member name="M:VDS.RDF.BaseUriNode.#ctor(VDS.RDF.IGraph,System.String)">
            <summary>
            Internal Only Constructor for URI Nodes
            </summary>
            <param name="g">Graph this Node is in</param>
            <param name="qname">QName for the Node</param>
            <remarks>
            This Constructor tries to resolve the QName using the NamespaceMapper and Base Uri of the Graph it is in.  Exceptions may occur if we cannot resolve the QName correctly.
            </remarks>
        </member>
        <member name="M:VDS.RDF.BaseUriNode.#ctor(System.Uri)">
            <summary>
            Internal Only Constructor for URI Nodes
            </summary>
            <param name="uri">URI</param>
        </member>
        <member name="M:VDS.RDF.BaseUriNode.#ctor">
            <summary>
            Deserialization Only Constructor
            </summary>
        </member>
        <member name="M:VDS.RDF.BaseUriNode.Equals(System.Object)">
            <summary>
            Implementation of Equality for Uri Nodes
            </summary>
            <param name="obj">Object to compare with</param>
            <returns></returns>
            <remarks>
            URI Nodes are considered equal if the string form of their URIs match using Ordinal string comparison
            </remarks>
        </member>
        <member name="M:VDS.RDF.BaseUriNode.Equals(VDS.RDF.INode)">
            <summary>
            Implementation of Equality for Uri Nodes
            </summary>
            <param name="other">Object to compare with</param>
            <returns></returns>
            <remarks>
            URI Nodes are considered equal if the string form of their URIs match using Ordinal string comparison
            </remarks>
        </member>
        <member name="M:VDS.RDF.BaseUriNode.Equals(VDS.RDF.IBlankNode)">
            <summary>
            Determines whether this Node is equal to a Blank Node (should always be false)
            </summary>
            <param name="other">Blank Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseUriNode.Equals(VDS.RDF.IGraphLiteralNode)">
            <summary>
            Determines whether this Node is equal to a Graph Literal Node (should always be false)
            </summary>
            <param name="other">Graph Literal Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseUriNode.Equals(VDS.RDF.ILiteralNode)">
            <summary>
            Determines whether this Node is equal to a Literal Node (should always be false)
            </summary>
            <param name="other">Literal Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseUriNode.Equals(VDS.RDF.IUriNode)">
            <summary>
            Determines whether this Node is equal to a URI Node
            </summary>
            <param name="other">URI Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseUriNode.Equals(VDS.RDF.IVariableNode)">
            <summary>
            Determines whether this Node is equal to a Variable Node (should always be false)
            </summary>
            <param name="other">Variable Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseUriNode.Equals(VDS.RDF.BaseUriNode)">
            <summary>
            Determines whether this Node is equal to a URI Node
            </summary>
            <param name="other">URI Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseUriNode.ToString">
            <summary>
            Gets a String representation of a Uri as a plain text Uri
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseUriNode.CompareTo(VDS.RDF.INode)">
            <summary>
            Implementation of Compare To for Uri Nodes
            </summary>
            <param name="other">Node to Compare To</param>
            <returns></returns>
            <remarks>
            Uri Nodes are greater than Blank Nodes and Nulls, they are less than Literal Nodes and Graph Literal Nodes.
            <br /><br />
            Uri Nodes are ordered based upon lexical ordering of the string value of their URIs
            </remarks>
        </member>
        <member name="M:VDS.RDF.BaseUriNode.CompareTo(VDS.RDF.IBlankNode)">
            <summary>
            Returns an Integer indicating the Ordering of this Node compared to another Node
            </summary>
            <param name="other">Node to test against</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseUriNode.CompareTo(VDS.RDF.IGraphLiteralNode)">
            <summary>
            Returns an Integer indicating the Ordering of this Node compared to another Node
            </summary>
            <param name="other">Node to test against</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseUriNode.CompareTo(VDS.RDF.ILiteralNode)">
            <summary>
            Returns an Integer indicating the Ordering of this Node compared to another Node
            </summary>
            <param name="other">Node to test against</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseUriNode.CompareTo(VDS.RDF.IVariableNode)">
            <summary>
            Returns an Integer indicating the Ordering of this Node compared to another Node
            </summary>
            <param name="other">Node to test against</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseUriNode.CompareTo(VDS.RDF.IUriNode)">
            <summary>
            Returns an Integer indicating the Ordering of this Node compared to another Node
            </summary>
            <param name="other">Node to test against</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseUriNode.CompareTo(VDS.RDF.BaseUriNode)">
            <summary>
            Returns an Integer indicating the Ordering of this Node compared to another Node
            </summary>
            <param name="other">Node to test against</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseUriNode.AsString">
            <summary>
            Gets the value of the node as a string
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseUriNode.AsInteger">
            <summary>
            Throws an error as URIs cannot be cast to numerics
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseUriNode.AsDecimal">
            <summary>
            Throws an error as URIs cannot be cast to numerics
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseUriNode.AsFloat">
            <summary>
            Throws an error as URIs cannot be cast to numerics
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseUriNode.AsDouble">
            <summary>
            Throws an error as URIs cannot be cast to numerics
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseUriNode.AsBoolean">
            <summary>
            Throws an error as URIs cannot be cast to a boolean
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseUriNode.AsDateTime">
            <summary>
            Throws an error as URIs cannot be cast to a date time
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseUriNode.AsDateTimeOffset">
            <summary>
            Throws an error as URIs cannot be cast to a date time
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseUriNode.AsTimeSpan">
            <summary>
            Throws an error as URIs cannot be cast to a time span
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.BaseUriNode.Uri">
            <summary>
            Gets the Uri for this Node
            </summary>
        </member>
        <member name="P:VDS.RDF.BaseUriNode.EffectiveType">
            <summary>
            Gets the URI of the datatype this valued node represents as a String
            </summary>
        </member>
        <member name="P:VDS.RDF.BaseUriNode.NumericType">
            <summary>
            Gets the numeric type of the expression
            </summary>
        </member>
        <member name="T:VDS.RDF.UriNode">
            <summary>
            Class for representing URI Nodes
            </summary>
        </member>
        <member name="M:VDS.RDF.UriNode.#ctor(VDS.RDF.IGraph,System.Uri)">
            <summary>
            Internal Only Constructor for URI Nodes
            </summary>
            <param name="g">Graph this Node is in</param>
            <param name="uri">URI for the Node</param>
        </member>
        <member name="M:VDS.RDF.UriNode.#ctor(VDS.RDF.IGraph,System.String)">
            <summary>
            Internal Only Constructor for URI Nodes
            </summary>
            <param name="g">Graph this Node is in</param>
            <param name="qname">QName for the Node</param>
            <remarks>
            This Constructor tries to resolve the QName using the NamespaceMapper and Base Uri of the Graph it is in.  Exceptions may occur if we cannot resolve the QName correctly.
            </remarks>
        </member>
        <member name="M:VDS.RDF.UriNode.#ctor">
            <summary>
            Deserilization Only Constructor
            </summary>
        </member>
        <member name="M:VDS.RDF.UriNode.CompareTo(VDS.RDF.UriNode)">
            <summary>
            Implementation of Compare To for URI Nodes
            </summary>
            <param name="other">URI Node to Compare To</param>
            <returns></returns>
            <remarks>
            Simply invokes the more general implementation of this method
            </remarks>
        </member>
        <member name="M:VDS.RDF.UriNode.Equals(VDS.RDF.UriNode)">
            <summary>
            Determines whether this Node is equal to a URI Node
            </summary>
            <param name="other">URI Node</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Triple">
            <summary>
            Class for representing RDF Triples in memory
            </summary>
        </member>
        <member name="M:VDS.RDF.Triple.#ctor(VDS.RDF.INode,VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Constructs a Triple from Nodes that belong to the same Graph/Node Factory
            </summary>
            <param name="subj">Subject of the Triple</param>
            <param name="pred">Predicate of the Triple</param>
            <param name="obj">Object of the Triple</param>
            <remarks>Will throw an RdfException if the Nodes don't belong to the same Graph/Node Factory</remarks>
            <exception cref="T:VDS.RDF.RdfException">Thrown if the Nodes aren't all from the same Graph/Node Factory</exception>
        </member>
        <member name="M:VDS.RDF.Triple.#ctor(VDS.RDF.INode,VDS.RDF.INode,VDS.RDF.INode,VDS.RDF.IGraph)">
            <summary>
            Constructs a Triple from Nodes that belong to the same Graph/Node Factory and associates this Triple with the given Graph (doesn't assert the Triple)
            </summary>
            <param name="subj">Subject</param>
            <param name="pred">Predicate</param>
            <param name="obj">Object</param>
            <param name="g">Graph</param>
            <remarks>Will throw an RdfException if the Nodes don't belong to the same Graph/Node Factory</remarks>
            <exception cref="T:VDS.RDF.RdfException">Thrown if the Nodes aren't all from the same Graph/Node Factory</exception>
        </member>
        <member name="M:VDS.RDF.Triple.#ctor(VDS.RDF.INode,VDS.RDF.INode,VDS.RDF.INode,VDS.RDF.ITripleContext)">
            <summary>
            Constructs a Triple from Nodes that belong to the same Graph/Node Factory with some Context
            </summary>
            <param name="subj">Subject of the Triple</param>
            <param name="pred">Predicate of the Triple</param>
            <param name="obj">Object of the Triple</param>
            <param name="context">Context Information for the Triple</param>
            <remarks>Will throw an RdfException if the Nodes don't belong to the same Graph/Node Factory</remarks>
            <exception cref="T:VDS.RDF.RdfException">Thrown if the Nodes aren't all from the same Graph/Node Factory</exception>
        </member>
        <member name="M:VDS.RDF.Triple.#ctor(VDS.RDF.INode,VDS.RDF.INode,VDS.RDF.INode,System.Uri)">
            <summary>
            Creates a Triple and associates it with the given Graph URI permanently (though not with a specific Graph as such)
            </summary>
            <param name="subj">Subject of the Triple</param>
            <param name="pred">Predicate of the Triple</param>
            <param name="obj">Object of the Triple</param>
            <param name="graphUri">Graph URI</param>
            <remarks>Will throw an RdfException if the Nodes don't belong to the same Graph/Node Factory</remarks>
            <exception cref="T:VDS.RDF.RdfException">Thrown if the Nodes aren't all from the same Graph/Node Factory</exception>
        </member>
        <member name="M:VDS.RDF.Triple.#ctor(VDS.RDF.INode,VDS.RDF.INode,VDS.RDF.INode,VDS.RDF.ITripleContext,System.Uri)">
            <summary>
            Constructs a Triple from Nodes that belong to the same Graph/Node Factory with some Context
            </summary>
            <param name="subj">Subject of the Triple</param>
            <param name="pred">Predicate of the Triple</param>
            <param name="obj">Object of the Triple</param>
            <param name="context">Context Information for the Triple</param>
            <param name="graphUri">Graph URI</param>
            <remarks>Will throw an RdfException if the Nodes don't belong to the same Graph/Node Factory</remarks>
            <exception cref="T:VDS.RDF.RdfException">Thrown if the Nodes aren't all from the same Graph/Node Factory</exception>
        </member>
        <member name="M:VDS.RDF.Triple.Involves(VDS.RDF.INode)">
            <summary>
            Checks whether the Triple involves a given Node
            </summary>
            <param name="n">The Node to test upon</param>
            <returns>True if the Triple contains the given Node</returns>
        </member>
        <member name="M:VDS.RDF.Triple.Involves(System.Uri)">
            <summary>
            Checks whether the Triple involves a given Uri
            </summary>
            <param name="uri">The Uri to test upon</param>
            <returns>True if the Triple has a UriNode with the given Uri</returns>
        </member>
        <member name="M:VDS.RDF.Triple.HasSubject(VDS.RDF.INode)">
            <summary>
            Indicates whether the Triple has the given Node as the Subject
            </summary>
            <param name="n">Node to test upon</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Triple.HasPredicate(VDS.RDF.INode)">
            <summary>
            Indicates whether the Triple has the given Node as the Predicate
            </summary>
            <param name="n">Node to test upon</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Triple.HasObject(VDS.RDF.INode)">
            <summary>
            Indicates whether the Triple has the given Node as the Object
            </summary>
            <param name="n">Node to test upon</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Triple.Equals(System.Object)">
            <summary>
            Implementation of Equality for Triples
            </summary>
            <param name="obj">Object to compare with</param>
            <returns></returns>
            <remarks>
            Triples are considered equal on the basis of two things:
            <ol>
            <li>The Hash Codes of the Triples are identical</li>
            <li>The logical conjunction (AND) of the equality of the Subject, Predicate and Object is true.  Each pair of Nodes must either be Equal using Node Equality or are both Blank Nodes and have identical Node IDs (i.e. are indistinguishable for equality purposes on a single Triple level)</li>
            </ol>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Triple.GetHashCode">
            <summary>
            Implementation of Hash Codes for Triples
            </summary>
            <returns></returns>
            <remarks>
            <para>
            Returns the Hash Code of the Triple which is calculated as the Hash Code of the String formed by concatenating the Hash Codes of its constituent Nodes.  This Hash Code is precomputed in the Constructor of a Triple since it will be used a lot (in Triple Equality calculation, Triple Collections etc)
            </para>
            <para>
            Since Hash Codes are based on a String representation there is no guarantee of uniqueness though the same Triple will always give the same Hash Code (on a given Platform - see the MSDN Documentation for <see cref="M:System.String.GetHashCode">string.GetHashCode()</see> for further details)
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Triple.ToString">
            <summary>
            Gets a String representation of a Triple in the form 'Subject , Predicate , Object'
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Triple.ToString(System.Boolean)">
            <summary>
            Gets a String representation of a Triple in the form 'Subject , Predicate , Object' with optional compression of URIs to QNames
            </summary>
            <param name="compress">Controls whether URIs will be compressed to QNames in the String representation</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Triple.ToString(VDS.RDF.Writing.Formatting.ITripleFormatter)">
            <summary>
            Gets the String representation of a Triple using the given Triple Formatter
            </summary>
            <param name="formatter">Formatter</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Triple.CompareTo(VDS.RDF.Triple)">
            <summary>
            Implementation of CompareTo for Triples which allows Triples to be sorted
            </summary>
            <param name="other">Triple to compare to</param>
            <returns></returns>
            <remarks>Triples are Ordered by Subjects, Predicates and then Objects.  Triples are only partially orderable since the CompareTo methods on Nodes only define a partial ordering over Nodes</remarks>
        </member>
        <member name="P:VDS.RDF.Triple.Subject">
            <summary>
            Gets the Subject of the Triple
            </summary>
        </member>
        <member name="P:VDS.RDF.Triple.Predicate">
            <summary>
            Gets the Predicate of the Triple
            </summary>
        </member>
        <member name="P:VDS.RDF.Triple.Object">
            <summary>
            Gets the Object of the Triple
            </summary>
        </member>
        <member name="P:VDS.RDF.Triple.Graph">
            <summary>
            Gets the Graph this Triple was created for
            </summary>
            <remarks>This is not necessarily the actual Graph this Triple is asserted in since this property is set from the Subject of the Triple when it is created and it is possible to create a Triple without asserting it into an actual Graph or to then assert it into a different Graph.</remarks>
        </member>
        <member name="P:VDS.RDF.Triple.GraphUri">
            <summary>
            Gets the Uri of the Graph this Triple was created for
            </summary>
            <remarks>This is not necessarily the actual Graph Uri of the Graph this Triple is asserted in since this property is set from the Subject of the Triple when it is created and it is possible to create a Triple without asserting it into an actual Graph or to then assert it into a different Graph.</remarks>
        </member>
        <member name="P:VDS.RDF.Triple.Context">
            <summary>
            Gets the Context Information for this Triple
            </summary>
            <remarks>
            Context may be null where no Context for the Triple has been defined
            </remarks>
        </member>
        <member name="P:VDS.RDF.Triple.Nodes">
            <summary>
            Gets an enumeration of the Nodes in the Triple
            </summary>
            <remarks>
            Returned as subject, predicate, object
            </remarks>
        </member>
        <member name="P:VDS.RDF.Triple.IsGroundTriple">
            <summary>
            Gets whether the Triple is a Ground Triple
            </summary>
            <remarks>
            <para>
            A <strong>Ground Triple</strong> is any Triple considered to state a single fixed fact.  In practise this means that the Triple does not contain any Blank Nodes.
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.TripleCollection">
            <summary>
            Basic Triple Collection which is not indexed
            </summary>
        </member>
        <member name="F:VDS.RDF.TripleCollection._triples">
            <summary>
            Underlying Storage of the Triple Collection
            </summary>
        </member>
        <member name="M:VDS.RDF.TripleCollection.#ctor">
            <summary>
            Creates a new Triple Collection
            </summary>
        </member>
        <member name="M:VDS.RDF.TripleCollection.Contains(VDS.RDF.Triple)">
            <summary>
            Determines whether a given Triple is in the Triple Collection
            </summary>
            <param name="t">The Triple to test</param>
            <returns>True if the Triple already exists in the Triple Collection</returns>
        </member>
        <member name="M:VDS.RDF.TripleCollection.Add(VDS.RDF.Triple)">
            <summary>
            Adds a Triple to the Collection
            </summary>
            <param name="t">Triple to add</param>
        </member>
        <member name="M:VDS.RDF.TripleCollection.Delete(VDS.RDF.Triple)">
            <summary>
            Deletes a Triple from the Colleciton
            </summary>
            <param name="t">Triple to remove</param>
            <remarks>Deleting something that doesn't exist has no effect and gives no error</remarks>
        </member>
        <member name="M:VDS.RDF.TripleCollection.GetEnumerator">
            <summary>
            Gets the Enumerator for the Collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets the Enumerator for the Collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleCollection.Dispose">
            <summary>
            Disposes of a Triple Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.TripleCollection.Count">
            <summary>
            Gets the Number of Triples in the Triple Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.TripleCollection.Item(VDS.RDF.Triple)">
            <summary>
            Gets the given Triple
            </summary>
            <param name="t">Triple to retrieve</param>
            <returns></returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if the given Triple does not exist in the Triple Collection</exception>
        </member>
        <member name="P:VDS.RDF.TripleCollection.SubjectNodes">
            <summary>
            Gets all the Nodes which are Subjects of Triples in the Triple Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.TripleCollection.PredicateNodes">
            <summary>
            Gets all the Nodes which are Predicates of Triples in the Triple Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.TripleCollection.ObjectNodes">
            <summary>
            Gets all the Nodes which are Objects of Triples in the Triple Collectio
            </summary>
        </member>
        <member name="T:VDS.RDF.ThreadSafeTripleCollection">
            <summary>
            Thread Safe decorator for triple collections
            </summary>
            <remarks>
            Depending on the platform this either uses <see cref="!:ReaderWriterLockSlim"/> to provide MRSW concurrency or it uses <see cref="T:System.Threading.Monitor"/> to provide exclusive access concurrency, either way usage is thread safe
            </remarks>
            <threadsafety instance="true">This decorator provides thread safe access to any underlying triple collection</threadsafety>
        </member>
        <member name="M:VDS.RDF.ThreadSafeTripleCollection.#ctor">
            <summary>
            Creates a new thread safe triple collection which wraps a new instance of the default unindexed <see cref="T:VDS.RDF.TripleCollection"/>
            </summary>
        </member>
        <member name="M:VDS.RDF.ThreadSafeTripleCollection.#ctor(VDS.RDF.BaseTripleCollection)">
            <summary>
            Creates a new thread safe triple collection which wraps the provided triple collection
            </summary>
            <param name="tripleCollection">Triple Collection</param>
        </member>
        <member name="M:VDS.RDF.ThreadSafeTripleCollection.EnterWriteLock">
            <summary>
            Enters the write lock
            </summary>
        </member>
        <member name="M:VDS.RDF.ThreadSafeTripleCollection.ExitWriteLock">
            <summary>
            Exists the write lock
            </summary>
        </member>
        <member name="M:VDS.RDF.ThreadSafeTripleCollection.EnterReadLock">
            <summary>
            Enters the read lock
            </summary>
        </member>
        <member name="M:VDS.RDF.ThreadSafeTripleCollection.ExitReadLock">
            <summary>
            Exists the read lock
            </summary>
        </member>
        <member name="M:VDS.RDF.ThreadSafeTripleCollection.Add(VDS.RDF.Triple)">
            <summary>
            Adds a Triple to the Collection
            </summary>
            <param name="t">Triple to add</param>
        </member>
        <member name="M:VDS.RDF.ThreadSafeTripleCollection.Contains(VDS.RDF.Triple)">
            <summary>
            Determines whether a given Triple is in the Triple Collection
            </summary>
            <param name="t">The Triple to test</param>
            <returns>True if the Triple already exists in the Triple Collection</returns>
        </member>
        <member name="M:VDS.RDF.ThreadSafeTripleCollection.Delete(VDS.RDF.Triple)">
            <summary>
            Deletes a Triple from the Collection
            </summary>
            <param name="t">Triple to remove</param>
            <remarks>Deleting something that doesn't exist has no effect and gives no error</remarks>
        </member>
        <member name="M:VDS.RDF.ThreadSafeTripleCollection.GetEnumerator">
            <summary>
            Gets the Enumerator for the Collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.ThreadSafeTripleCollection.WithObject(VDS.RDF.INode)">
            <summary>
            Gets all triples with the given Object
            </summary>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.ThreadSafeTripleCollection.WithPredicate(VDS.RDF.INode)">
            <summary>
            Gets all triples with the given predicate
            </summary>
            <param name="pred">Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.ThreadSafeTripleCollection.WithPredicateObject(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets all triples with the given predicate object
            </summary>
            <param name="pred">Predicate</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.ThreadSafeTripleCollection.WithSubject(VDS.RDF.INode)">
            <summary>
            Gets all the triples with the given subject
            </summary>
            <param name="subj">Subject</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.ThreadSafeTripleCollection.WithSubjectObject(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets all the triples with the given subject and object
            </summary>
            <param name="subj">Subject</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.ThreadSafeTripleCollection.WithSubjectPredicate(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets all triples with the given subject and predicate
            </summary>
            <param name="subj">Subject</param>
            <param name="pred">Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.ThreadSafeTripleCollection.Dispose">
            <summary>
            Disposes of a Triple Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.ThreadSafeTripleCollection.Count">
            <summary>
            Gets the Number of Triples in the Triple Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.ThreadSafeTripleCollection.Item(VDS.RDF.Triple)">
            <summary>
            Gets the original instance of a specific Triple from the Triple Collection
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.ThreadSafeTripleCollection.ObjectNodes">
            <summary>
            Gets all the Nodes which are Objects of Triples in the Triple Collectio
            </summary>
        </member>
        <member name="P:VDS.RDF.ThreadSafeTripleCollection.PredicateNodes">
            <summary>
            Gets all the Nodes which are Predicates of Triples in the Triple Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.ThreadSafeTripleCollection.SubjectNodes">
            <summary>
            Gets all the Nodes which are Subjects of Triples in the Triple Collection
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.RdfXml.RdfXmlEvent">
            <summary>
            Static Class which defines the Event Types for RDF/XML Events
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Events.RdfXml.RdfXmlEvent.Root">
            <summary>
            Constants for Event Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Events.RdfXml.RdfXmlEvent.Clear">
            <summary>
            Constants for Event Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Events.RdfXml.RdfXmlEvent.Element">
            <summary>
            Constants for Event Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Events.RdfXml.RdfXmlEvent.EndElement">
            <summary>
            Constants for Event Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Events.RdfXml.RdfXmlEvent.Attribute">
            <summary>
            Constants for Event Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Events.RdfXml.RdfXmlEvent.NamespaceAttribute">
            <summary>
            Constants for Event Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Events.RdfXml.RdfXmlEvent.LanguageAttribute">
            <summary>
            Constants for Event Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Events.RdfXml.RdfXmlEvent.ParseTypeAttribute">
            <summary>
            Constants for Event Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Events.RdfXml.RdfXmlEvent.XmlBaseAttribute">
            <summary>
            Constants for Event Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Events.RdfXml.RdfXmlEvent.Text">
            <summary>
            Constants for Event Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Events.RdfXml.RdfXmlEvent.UriReference">
            <summary>
            Constants for Event Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Events.RdfXml.RdfXmlEvent.QName">
            <summary>
            Constants for Event Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Events.RdfXml.RdfXmlEvent.BlankNodeID">
            <summary>
            Constants for Event Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Events.RdfXml.RdfXmlEvent.Literal">
            <summary>
            Constants for Event Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Events.RdfXml.RdfXmlEvent.TypedLiteral">
            <summary>
            Constants for Event Types
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.RdfXml.RootEvent">
            <summary>
            Event representing the Root Node of the Document
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.RdfXml.RootEvent.#ctor(System.String,System.String,VDS.RDF.Parsing.PositionInfo)">
            <summary>
            Creates a new Root Event
            </summary>
            <param name="baseUri">Base Uri of the Document</param>
            <param name="sourceXml">Source XML of the Document</param>
            <param name="pos">Position Info</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.RdfXml.RootEvent.#ctor(System.String,System.String)">
            <summary>
            Creates a new Root Event
            </summary>
            <param name="baseUri">Base Uri of the Document</param>
            <param name="sourceXml">Source XML of the Document</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.RdfXml.RootEvent.DocumentElement">
            <summary>
            Gets/Sets the ElementEvent that represents the actual DocumentElement
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.RdfXml.RootEvent.Children">
            <summary>
            Gets all the Child ElementEvents of the Document Root
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.RdfXml.RootEvent.BaseUri">
            <summary>
            Gets the Base Uri of the Node
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.RdfXml.RootEvent.Language">
            <summary>
            Gets the Language of the Node
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.RdfXml.ElementEvent">
            <summary>
            Event representing a Node from the XML Document
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.RdfXml.ElementEvent.#ctor(System.String,System.String,System.String,VDS.RDF.Parsing.PositionInfo)">
            <summary>
            Creates a new Element Event
            </summary>
            <param name="qname">QName of the XML Node</param>
            <param name="baseUri">Base Uri of the XML Node</param>
            <param name="sourceXml">Source XML of the XML Node</param>
            <param name="pos">Position Info</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.RdfXml.ElementEvent.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new Element Event
            </summary>
            <param name="qname">QName of the XML Node</param>
            <param name="baseUri">Base Uri of the XML Node</param>
            <param name="sourceXml">Source XML of the XML Node</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.RdfXml.ElementEvent.#ctor(System.String,System.String,System.String,System.String,VDS.RDF.Parsing.PositionInfo)">
            <summary>
            Creates new Element Event
            </summary>
            <param name="localname">Local Name of the XML Node</param>
            <param name="ns">Namespace Prefix of the XML Node</param>
            <param name="baseUri">Base Uri of the XML Node</param>
            <param name="sourceXml">Source XML of the XML Node</param>
            <param name="pos">Position Info</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.RdfXml.ElementEvent.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Creates new Element Event
            </summary>
            <param name="localname">Local Name of the XML Node</param>
            <param name="ns">Namespace Prefix of the XML Node</param>
            <param name="baseUri">Base Uri of the XML Node</param>
            <param name="sourceXml">Source XML of the XML Node</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.RdfXml.ElementEvent.SetUri(VDS.RDF.Parsing.Events.RdfXml.UriReferenceEvent)">
            <summary>
            Method which sets the Uri for this Element Event
            </summary>
            <param name="u">Uri Reference to set Uri from</param>
            <remarks>This can only be used on Elements which are rdf:li and thus need expanding into actual list elements according to List Expansion rules.  Attempting to set the Uri on any other Element Event will cause an Error message.</remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.RdfXml.ElementEvent.ToString">
            <summary>
            Gets the String representation of the Event
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.RdfXml.ElementEvent.LocalName">
            <summary>
            Gets the Local Name of this Element Event
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.RdfXml.ElementEvent.Namespace">
            <summary>
            Gets the Namespace of this Element Event
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.RdfXml.ElementEvent.QName">
            <summary>
            Gets the QName of this Element Event
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.RdfXml.ElementEvent.Children">
            <summary>
            Gets the Child Element Events 
            </summary>
            <remarks>These correspond to the Child Nodes of the XML Node</remarks>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.RdfXml.ElementEvent.BaseUri">
            <summary>
            Gets/Sets the Base Uri of the XML Node
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.RdfXml.ElementEvent.Attributes">
            <summary>
            Gets the Attribute Events
            </summary>
            <remarks>These correspond to the Attributes of the XML Node (with some exceptions as defined in the RDF/XML specification)</remarks>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.RdfXml.ElementEvent.NamespaceAttributes">
            <summary>
            Gets the Namespace Attribute Events
            </summary>
            <remarks>
            These correspond to all the Namespace Attributes of the XML Node
            </remarks>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.RdfXml.ElementEvent.ListCounter">
            <summary>
            Gets/Sets the List Counter
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.RdfXml.ElementEvent.Language">
            <summary>
            Gets/Sets the Language of this Event
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.RdfXml.ElementEvent.Subject">
            <summary>
            Gets/Sets the Subject Event of this Event
            </summary>
            <remarks>Will be assigned according to the Parsing rules during the Parsing process and later used to generate a Subject Node</remarks>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.RdfXml.ElementEvent.SubjectNode">
            <summary>
            Gets/Sets the Subject Node of this Event
            </summary>
            <remarks>Will be created from the Subject at some point during the Parsing process</remarks>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.RdfXml.ElementEvent.ParseType">
            <summary>
            Gets/Sets the Parse Type for this Event
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.RdfXml.EndElementEvent">
            <summary>
            An Event for representing the End of Elements
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.RdfXml.EndElementEvent.#ctor(VDS.RDF.Parsing.PositionInfo)">
            <summary>
            Creates a new EndElementEvent
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.RdfXml.EndElementEvent.#ctor">
            <summary>
            Creates a new EndElementEvent
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.RdfXml.AttributeEvent">
            <summary>
            An Event for representing Attributes of XML Node
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.RdfXml.AttributeEvent.#ctor(System.String,System.String,System.String,VDS.RDF.Parsing.PositionInfo)">
            <summary>
            Creates a new Attribute Event from an XML Attribute
            </summary>
            <param name="qname">QName of the Attribute</param>
            <param name="value">Value of the Attribute</param>
            <param name="sourceXml">Source XML of the Attribute</param>
            <param name="pos">Position Info</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.RdfXml.AttributeEvent.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new Attribute Event from an XML Attribute
            </summary>
            <param name="qname">QName of the Attribute</param>
            <param name="value">Value of the Attribute</param>
            <param name="sourceXml">Source XML of the Attribute</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.RdfXml.AttributeEvent.#ctor(System.String,System.String,System.String,System.String,VDS.RDF.Parsing.PositionInfo)">
            <summary>
            Creates a new Attribute Event from an XML Attribute
            </summary>
            <param name="localname">Local Name of the Attribute</param>
            <param name="ns">Namespace Prefix of the Attribute</param>
            <param name="value">Value of the Attribute</param>
            <param name="sourceXml">Source XML of the Attribute</param>
            <param name="pos">Position Info</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.RdfXml.AttributeEvent.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Creates a new Attribute Event from an XML Attribute
            </summary>
            <param name="localname">Local Name of the Attribute</param>
            <param name="ns">Namespace Prefix of the Attribute</param>
            <param name="value">Value of the Attribute</param>
            <param name="sourceXml">Source XML of the Attribute</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.RdfXml.AttributeEvent.LocalName">
            <summary>
            Gets the Local Name of the Attribute
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.RdfXml.AttributeEvent.Namespace">
            <summary>
            Gets the Namespace Prefix of the Attribute
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.RdfXml.AttributeEvent.QName">
            <summary>
            Gets the QName of the Attribute
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.RdfXml.AttributeEvent.Value">
            <summary>
            Gets the Value of the Attribute
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.RdfXml.NamespaceAttributeEvent">
            <summary>
            An Event for representing Namespace Attributes of an XML Node
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.RdfXml.NamespaceAttributeEvent.#ctor(System.String,System.String,System.String,VDS.RDF.Parsing.PositionInfo)">
            <summary>
            Creates a new Namespace Attribute Event
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="uri">Namespace Uri</param>
            <param name="sourceXml">Source XML</param>
            <param name="pos">Position Info</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.RdfXml.NamespaceAttributeEvent.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new Namespace Attribute Event
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="uri">Namespace Uri</param>
            <param name="sourceXml">Source XML</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.RdfXml.NamespaceAttributeEvent.Prefix">
            <summary>
            Gets the Namespace Prefix
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.RdfXml.NamespaceAttributeEvent.Uri">
            <summary>
            Gets the Namespace Uri
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.RdfXml.LanguageAttributeEvent">
            <summary>
            An Event for representing Language Attributes of an XML Node
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.RdfXml.LanguageAttributeEvent.#ctor(System.String,System.String,VDS.RDF.Parsing.PositionInfo)">
            <summary>
            Creates a new Language Attribute Event
            </summary>
            <param name="lang">Language</param>
            <param name="sourceXml">Source XML</param>
            <param name="pos">Position Info</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.RdfXml.LanguageAttributeEvent.#ctor(System.String,System.String)">
            <summary>
            Creates a new Language Attribute Event
            </summary>
            <param name="lang">Language</param>
            <param name="sourceXml">Source XML</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.RdfXml.LanguageAttributeEvent.Language">
            <summary>
            Gets the Language
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.RdfXml.ParseTypeAttributeEvent">
            <summary>
            An Event for representing rdf:parseType Attributes of an XML Node
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.RdfXml.ParseTypeAttributeEvent.#ctor(VDS.RDF.Parsing.RdfXmlParseType,System.String,VDS.RDF.Parsing.PositionInfo)">
            <summary>
            Creates a new Parse Type Attribute Event
            </summary>
            <param name="type">Parse Type</param>
            <param name="sourceXml">Source XML</param>
            <param name="pos">Position Info</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.RdfXml.ParseTypeAttributeEvent.#ctor(VDS.RDF.Parsing.RdfXmlParseType,System.String)">
            <summary>
            Creates a new Parse Type Attribute Event
            </summary>
            <param name="type">Parse Type</param>
            <param name="sourceXml">Source XML</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.RdfXml.ParseTypeAttributeEvent.ParseType">
            <summary>
            Gets the Parse Type
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.RdfXml.XmlBaseAttributeEvent">
            <summary>
            An Event for representing xml:base attributes of XML Nodes
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.RdfXml.XmlBaseAttributeEvent.#ctor(System.String,System.String,VDS.RDF.Parsing.PositionInfo)">
            <summary>
            Creates a new XML Base Attribute
            </summary>
            <param name="baseUri">Base URI</param>
            <param name="sourceXml">Source XML</param>
            <param name="pos">Position Info</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.RdfXml.XmlBaseAttributeEvent.#ctor(System.String,System.String)">
            <summary>
            Creates a new XML Base Attribute
            </summary>
            <param name="baseUri">Base URI</param>
            <param name="sourceXml">Source XML</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.RdfXml.XmlBaseAttributeEvent.BaseUri">
            <summary>
            Gets the Base URI
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.RdfXml.TextEvent">
            <summary>
            Event for representing plain text content (XML Text Nodes)
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.RdfXml.TextEvent.#ctor(System.String,System.String,VDS.RDF.Parsing.PositionInfo)">
            <summary>
            Creates a new Text Node
            </summary>
            <param name="value">Textual Content of the XML Text Node</param>
            <param name="sourceXml">Source XML of the Node</param>
            <param name="pos">Position Info</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.RdfXml.TextEvent.#ctor(System.String,System.String)">
            <summary>
            Creates a new Text Node
            </summary>
            <param name="value">Textual Content of the XML Text Node</param>
            <param name="sourceXml">Source XML of the Node</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.RdfXml.TextEvent.ToString">
            <summary>
            Gets the String representation of the Event
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.RdfXml.TextEvent.Value">
            <summary>
            Gets the Textual Content of the Event
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.RdfXml.UriReferenceEvent">
            <summary>
            Event for representing URIRefs
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.RdfXml.UriReferenceEvent.#ctor(System.String,System.String,VDS.RDF.Parsing.PositionInfo)">
            <summary>
            Creates a new URIRef Event from a URIRef in an XML Attribute value or similar
            </summary>
            <param name="identifier">URIRef</param>
            <param name="sourceXml">Source XML of the URIRef</param>
            <param name="pos">Position Info</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.RdfXml.UriReferenceEvent.#ctor(System.String,System.String)">
            <summary>
            Creates a new URIRef Event from a URIRef in an XML Attribute value or similar
            </summary>
            <param name="identifier">URIRef</param>
            <param name="sourceXml">Source XML of the URIRef</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.RdfXml.UriReferenceEvent.Identifier">
            <summary>
            Gets the URIRef
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.RdfXml.QNameEvent">
            <summary>
            Event for representing QNames
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.RdfXml.QNameEvent.#ctor(System.String,System.String,VDS.RDF.Parsing.PositionInfo)">
            <summary>
            Creates a new QName Event
            </summary>
            <param name="qname">QName</param>
            <param name="sourceXml">Source XML of the QName</param>
            <param name="pos">Position Info</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.RdfXml.QNameEvent.#ctor(System.String,System.String)">
            <summary>
            Creates a new QName Event
            </summary>
            <param name="qname">QName</param>
            <param name="sourceXml">Source XML of the QName</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.RdfXml.QNameEvent.QName">
            <summary>
            Gets the QName
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.RdfXml.BlankNodeIDEvent">
            <summary>
            Event for representing the need for a Blank Node
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.RdfXml.BlankNodeIDEvent.#ctor(System.String,System.String,VDS.RDF.Parsing.PositionInfo)">
            <summary>
            Creates a new Blank Node ID Event for a named Blank Node
            </summary>
            <param name="identifier">Node ID for the Blank Node</param>
            <param name="sourceXml">Source XML</param>
            <param name="pos">Position Info</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.RdfXml.BlankNodeIDEvent.#ctor(System.String,System.String)">
            <summary>
            Creates a new Blank Node ID Event for a named Blank Node
            </summary>
            <param name="identifier">Node ID for the Blank Node</param>
            <param name="sourceXml">Source XML</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.RdfXml.BlankNodeIDEvent.#ctor(System.String,VDS.RDF.Parsing.PositionInfo)">
            <summary>
            Creates a new Blank Node ID Event for an anonymous Blank Node
            </summary>
            <param name="sourceXml">Source XML</param>
            <param name="pos">Position Info</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.RdfXml.BlankNodeIDEvent.#ctor(System.String)">
            <summary>
            Creates a new Blank Node ID Event for an anonymous Blank Node
            </summary>
            <param name="sourceXml">Source XML</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.RdfXml.BlankNodeIDEvent.Identifier">
            <summary>
            Gets the Blank Node ID (if any)
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.RdfXml.PlainLiteralEvent">
            <summary>
            An Event for representing Plain Literals
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.RdfXml.PlainLiteralEvent.#ctor(System.String,System.String,System.String,VDS.RDF.Parsing.PositionInfo)">
            <summary>
            Creates a new Plain Literal Event
            </summary>
            <param name="value">Value of the Literal</param>
            <param name="language">Language Specifier of the Literal</param>
            <param name="sourceXml">Source XML of the Event</param>
            <param name="pos">Position Info</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.RdfXml.PlainLiteralEvent.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new Plain Literal Event
            </summary>
            <param name="value">Value of the Literal</param>
            <param name="language">Language Specifier of the Literal</param>
            <param name="sourceXml">Source XML of the Event</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.RdfXml.PlainLiteralEvent.Value">
            <summary>
            Gets the Value of the Plain Literal
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.RdfXml.PlainLiteralEvent.Language">
            <summary>
            Gets the Langugage Specifier of the Plain Literal
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.RdfXml.TypedLiteralEvent">
            <summary>
            An Event for representing Typed Literals
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.RdfXml.TypedLiteralEvent.#ctor(System.String,System.String,System.String,VDS.RDF.Parsing.PositionInfo)">
            <summary>
            Creates a new Typed Literal Event
            </summary>
            <param name="value">Value of the Literal</param>
            <param name="datatype">DataType Uri of the Literal</param>
            <param name="sourceXml">Source XML of the Event</param>
            <param name="pos">Position Info</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.RdfXml.TypedLiteralEvent.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new Typed Literal Event
            </summary>
            <param name="value">Value of the Literal</param>
            <param name="datatype">DataType Uri of the Literal</param>
            <param name="sourceXml">Source XML of the Event</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.RdfXml.TypedLiteralEvent.ToString">
            <summary>
            Gets the String representation of the Event
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.RdfXml.TypedLiteralEvent.Value">
            <summary>
            Gets the Value of the Typed Literal
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.RdfXml.TypedLiteralEvent.DataType">
            <summary>
            Gets the DataType of the Typed Literal
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.RdfXml.ClearQueueEvent">
            <summary>
            An Event for representing that the Event Queue should be cleared of previously queued events
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.RdfXml.ClearQueueEvent.#ctor">
            <summary>
            Creates a new Clear Queue Event
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.RdfXmlParseType">
            <summary>
            Possible RDF/XML Parse Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.RdfXmlParseType.None">
            <summary>
            No specific Parse Type is specified (Default Parsing Rules will be used)
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.RdfXmlParseType.Literal">
            <summary>
            Literal Parse Type
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.RdfXmlParseType.Resource">
            <summary>
            Resource Parse Type
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.RdfXmlParseType.Collection">
            <summary>
            Collection Parse Type
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.RdfXmlParseType.Other">
            <summary>
            Other Parse Type
            </summary>
            <remarks>This is never used since any other Parse Type encountered is assumed to be Literal as per the RDF/XML Specification</remarks>
        </member>
        <member name="T:VDS.RDF.Parsing.RdfXmlParserMode">
            <summary>
            Possible RDF/XML Parser Modes
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.RdfXmlParserMode.Streaming">
            <summary>
            Uses Streaming Based parsing (default)
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.RdfXmlParser">
            <summary>
            Parser for RDF/XML syntax
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.#ctor">
            <summary>
            Creates a new RDF/XML Parser
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.#ctor(VDS.RDF.Parsing.RdfXmlParserMode)">
            <summary>
            Creates a new RDF/XML Parser which uses the given parsing mode
            </summary>
            <param name="mode">RDF/XML Parse Mode</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.Load(VDS.RDF.IGraph,System.IO.StreamReader)">
            <summary>
            Reads RDF/XML syntax from some Stream into the given Graph
            </summary>
            <param name="g">Graph to create Triples in</param>
            <param name="input">Input Stream</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.Load(VDS.RDF.IGraph,System.IO.TextReader)">
            <summary>
            Reads RDF/XML syntax from some Input into the given Graph
            </summary>
            <param name="g">Graph to create Triples in</param>
            <param name="input">Input to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.Load(VDS.RDF.IRdfHandler,System.IO.StreamReader)">
            <summary>
            Reads RDF/XML syntax from some Stream using a RDF Handler
            </summary>
            <param name="handler">RDF Handler to use</param>
            <param name="input">Input Stream</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.Load(VDS.RDF.IRdfHandler,System.IO.TextReader)">
            <summary>
            Reads RDF/XML syntax from some Input using a RDF Handler
            </summary>
            <param name="handler">RDF Handler to use</param>
            <param name="input">Input to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.RaiseWarning(System.String)">
            <summary>
            Helper Method for raising the <see cref="E:VDS.RDF.Parsing.RdfXmlParser.Warning">Warning</see> event
            </summary>
            <param name="warning">Warning Message</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.Parse(VDS.RDF.Parsing.Contexts.RdfXmlParserContext)">
            <summary>
            Function which does the actual Parsing by invoking the various steps of the Parser
            </summary>
            <param name="context">Parser Context</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.ProcessEventQueue(VDS.RDF.Parsing.Contexts.RdfXmlParserContext)">
            <summary>
            Starts the Parsing of the flattened Event Tree by calling the appropriate Grammar Production based on the type of the First Event in the Queue
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.GrammarProductionDoc(VDS.RDF.Parsing.Contexts.RdfXmlParserContext,VDS.RDF.Parsing.Events.RdfXml.RootEvent)">
            <summary>
            Implementation of the RDF/XML Grammar Production 'doc'
            </summary>
            <param name="context">Parser Context</param>
            <param name="root">Root Event to start applying Productions from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.GrammarProductionRDF(VDS.RDF.Parsing.Contexts.RdfXmlParserContext,VDS.RDF.Parsing.Events.RdfXml.ElementEvent)">
            <summary>
            Implementation of the RDF/XML Grammar Production 'RDF'
            </summary>
            <param name="context">Parser Context</param>
            <param name="element">RDF Element to apply Production to</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.GrammarProductionNodeElementList(VDS.RDF.Parsing.Contexts.RdfXmlParserContext,VDS.RDF.Parsing.Events.IEventQueue{VDS.RDF.Parsing.Events.IRdfXmlEvent})">
            <summary>
            Implementation of the RDF/XML Grammar Production 'nodeElementList'
            </summary>
            <param name="context">Parser Context</param>
            <param name="eventlist">Queue of Events to apply the Production to</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.GrammarProductionNodeElement(VDS.RDF.Parsing.Contexts.RdfXmlParserContext,VDS.RDF.Parsing.Events.IEventQueue{VDS.RDF.Parsing.Events.IRdfXmlEvent})">
            <summary>
            Implementation of the RDF/XML Grammar Production 'nodeElement'
            </summary>
            <param name="context">Parser Context</param>
            <param name="eventlist">Queue of Events that make up the Node Element and its Children to apply the Production to</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.GrammarProductionPropertyElementList(VDS.RDF.Parsing.Contexts.RdfXmlParserContext,VDS.RDF.Parsing.Events.IEventQueue{VDS.RDF.Parsing.Events.IRdfXmlEvent},VDS.RDF.Parsing.Events.IRdfXmlEvent)">
            <summary>
            Implementation of the RDF/XML Grammar Production 'propertyEltList'
            </summary>
            <param name="context">Parser Context</param>
            <param name="eventlist">Queue of Events to apply the Production to</param>
            <param name="parent">Parent Event (ie. Node) of the Property Elements</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.GrammarProductionPropertyElement(VDS.RDF.Parsing.Contexts.RdfXmlParserContext,VDS.RDF.Parsing.Events.IEventQueue{VDS.RDF.Parsing.Events.IRdfXmlEvent},VDS.RDF.Parsing.Events.IRdfXmlEvent)">
            <summary>
            Implementation of the RDF/XML Grammar Production 'propertyElt'
            </summary>
            <param name="context">Parser Context</param>
            <param name="eventlist">Queue of Events that make up the Property Element and its Children</param>
            <param name="parent">Parent Event (ie. Node) of the Property Element</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.GrammarProductionResourcePropertyElement(VDS.RDF.Parsing.Contexts.RdfXmlParserContext,VDS.RDF.Parsing.Events.IEventQueue{VDS.RDF.Parsing.Events.IRdfXmlEvent},VDS.RDF.Parsing.Events.IRdfXmlEvent)">
            <summary>
            Implementation of the RDF/XML Grammar Production 'resourcePropertyElt'
            </summary>
            <param name="context">Parser Context</param>
            <param name="eventlist">Queue of Events that make up the Resource Property Element and its Children</param>
            <param name="parent">Parent Event (ie. Node) of the Property Element</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.GrammarProductionLiteralPropertyElement(VDS.RDF.Parsing.Contexts.RdfXmlParserContext,VDS.RDF.Parsing.Events.IEventQueue{VDS.RDF.Parsing.Events.IRdfXmlEvent},VDS.RDF.Parsing.Events.IRdfXmlEvent)">
            <summary>
            Implementation of the RDF/XML Grammar Production 'literalPropertyElt'
            </summary>
            <param name="context">Parser Context</param>
            <param name="eventlist">Queue of Events that make up the Literal Property Element and its Children</param>
            <param name="parent">Parent Event (ie. Node) of the Property Element</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.GrammarProductionParseTypeLiteralPropertyElement(VDS.RDF.Parsing.Contexts.RdfXmlParserContext,VDS.RDF.Parsing.Events.IEventQueue{VDS.RDF.Parsing.Events.IRdfXmlEvent},VDS.RDF.Parsing.Events.IRdfXmlEvent)">
            <summary>
            Implementation of the RDF/XML Grammar Production 'parseTypeLiteralPropertyElt'
            </summary>
            <param name="context">Parser Context</param>
            <param name="eventlist">Queue of Events that make up the Literal Parse Type Property Element and its Children</param>
            <param name="parent">Parent Event (ie. Node) of the Property Element</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.GrammarProductionParseTypeResourcePropertyElement(VDS.RDF.Parsing.Contexts.RdfXmlParserContext,VDS.RDF.Parsing.Events.IEventQueue{VDS.RDF.Parsing.Events.IRdfXmlEvent},VDS.RDF.Parsing.Events.IRdfXmlEvent)">
            <summary>
            Implementation of the RDF/XML Grammar Production 'parseTypeResourcePropertyElt'
            </summary>
            <param name="context">Parser Context</param>
            <param name="eventlist">Queue of Events that make up the Resource Parse Type Property Element and its Children</param>
            <param name="parent">Parent Event (ie. Node) of the Property Element</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.GrammarProductionParseTypeCollectionPropertyElement(VDS.RDF.Parsing.Contexts.RdfXmlParserContext,VDS.RDF.Parsing.Events.IEventQueue{VDS.RDF.Parsing.Events.IRdfXmlEvent},VDS.RDF.Parsing.Events.IRdfXmlEvent)">
            <summary>
            Implementation of the RDF/XML Grammar Production 'parseTypeCollectionPropertyElt'
            </summary>
            <param name="context">Parser Context</param>
            <param name="eventlist">Queue of Events that make up the Collection Parse Type Property Element and its Children</param>
            <param name="parent">Parent Event (ie. Node) of the Property Element</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.GrammarProductionEmptyPropertyElement(VDS.RDF.Parsing.Contexts.RdfXmlParserContext,VDS.RDF.Parsing.Events.RdfXml.ElementEvent,VDS.RDF.Parsing.Events.IRdfXmlEvent)">
            <summary>
            Implementation of the RDF/XML Grammar Production 'emptyPropertyElt'
            </summary>
            <param name="context">Parser Context</param>
            <param name="element">Element Event for the Empty Property Element</param>
            <param name="parent">Parent Event (ie. Node) of the Property Element</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.ApplyNamespaces(VDS.RDF.Parsing.Contexts.RdfXmlParserContext,VDS.RDF.Parsing.Events.RdfXml.ElementEvent)">
            <summary>
            Applies the Namespace Attributes of an Element Event to the Namespace Map
            </summary>
            <param name="context">Parser Context</param>
            <param name="evt">Element Event</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.Resolve(VDS.RDF.Parsing.Contexts.RdfXmlParserContext,VDS.RDF.Parsing.Events.RdfXml.UriReferenceEvent,System.String)">
            <summary>
            Resolves a Uri Reference into a Uri Node against a given Base Uri
            </summary>
            <param name="context">Parser Context</param>
            <param name="uriref">Uri Reference to Resolve</param>
            <param name="baseUri">Base Uri to Resolve against</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.Reify(VDS.RDF.Parsing.Contexts.RdfXmlParserContext,VDS.RDF.IUriNode,VDS.RDF.INode,VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Reifies a Triple
            </summary>
            <param name="context">Parser Context</param>
            <param name="uriref">Uri Reference for the Reified Triple</param>
            <param name="subj">Subject of the Triple</param>
            <param name="pred">Predicate of the Triple</param>
            <param name="obj">Object of the Triple</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.QueueJump(VDS.RDF.Parsing.Events.IEventQueue{VDS.RDF.Parsing.Events.IRdfXmlEvent},VDS.RDF.Parsing.Events.IRdfXmlEvent)">
            <summary>
            Helper function which inserts an Element back on the front of a Queue
            </summary>
            <param name="eventlist">Queue to insert onto the Front of</param>
            <param name="evt">Event to put on the front of the Queue</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.ListExpand(VDS.RDF.Parsing.Events.IRdfXmlEvent)">
            <summary>
            Applies List Expansion to the given Event
            </summary>
            <param name="evt">Element to apply List Expansion to</param>
            <returns>Uri Reference for the List Item</returns>
            <remarks>List Expansion only works on Element Events</remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.ValidateID(VDS.RDF.Parsing.Contexts.RdfXmlParserContext,System.String,VDS.RDF.INode)">
            <summary>
            Validates that an ID is correctly formed and has only been used once in the context of a given Subject
            </summary>
            <param name="context">Parser Context</param>
            <param name="id">ID to Validate</param>
            <param name="subj">Subject that the ID pertains to</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.ProductionTrace(System.String)">
            <summary>
            Tracing function used when Parse Tracing is enabled
            </summary>
            <param name="production">Production</param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.ProductionTrace(System.String,VDS.RDF.Parsing.Events.RdfXml.ElementEvent)">
            <summary>
            Tracing function used when Parse Tracing is enabled
            </summary>
            <param name="production">Production</param>
            <param name="evt"></param>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlParser.ToString">
            <summary>
            Gets the String representation of the Parser which is a description of the syntax it parses
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Parsing.RdfXmlParser.TraceParsing">
            <summary>
            Controls whether Parser progress will be traced by writing output to the Console
            </summary>
        </member>
        <member name="E:VDS.RDF.Parsing.RdfXmlParser.Warning">
            <summary>
            Event which Readers can raise when they notice syntax that is ambigious/deprecated etc which can still be parsed
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.XmlSpecsHelper">
            <summary>
            Static Helper Class which contains a set of Functions which model Name and Character validations as laid
            out in the W3C XML and XML Namespaces specification
            </summary>
            <remarks>
            These are needed in the XML/RDF Parser
            
            Also contains the Date Time format string used to format .Net's DateTime type into a String whose format conforms to the XML Schema Datatypes specification
            
            
            </remarks>
            <seealso>http://www.w3.org/TR/REC-xml/</seealso>
            <seealso>http://www.w3.org/TR/REC-xml-names/</seealso>
            <seealso>http://www.w3.org/TR/xmlschema-2/</seealso>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.NamespaceXml">
            <summary>
            Namespace for XML
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.NamespaceXmlNamespaces">
            <summary>
            Namespace for XML Namespaces
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.NamespaceXmlSchema">
            <summary>
            Namespace for XML Schema
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDateTimeFormat">
            <summary>
            Date Time Formatting string which meets the specified format for xsd:dateTime
            </summary>
            <remarks>
            Use with the <see cref="M:System.DateTime.ToString">DateTime.ToString()</see> method to format a DateTime into appropriate string format
            </remarks>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDateTimeFormatImprecise">
            <summary>
            Date Time Formatting string which meets the specified format for xsd:dateTime, this formatting string is imprecise in the sense that it does not preserve the fractional seconds.
            </summary>
            <remarks>
            Use with the <see cref="M:System.DateTime.ToString">DateTime.ToString()</see> method to format a DateTime into appropriate string format
            </remarks>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDateFormat">
            <summary>
            Date Time Formatting string which meets the specified format for xsd:date
            </summary>
            <remarks>
            Use with the <see cref="M:System.DateTime.ToString">DateTime.ToString()</see> method to format a DateTime into appropriate string format
            </remarks>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaTimeFormat">
            <summary>
            Date Time Formatting string which meets the the specified format for xsd:time
            </summary>
            <remarks>
            Use with the <see cref="M:System.DateTime.ToString">DateTime.ToString()</see> method to format a DateTime into appropriate string format
            </remarks>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaTimeFormatImprecise">
            <summary>
            Date Time Formatting string which meets the the specified format for xsd:time, this formatting string is imprecise in the sense that it does not preserve the fractional seconds.
            </summary>
            <remarks>
            Use with the <see cref="M:System.DateTime.ToString">DateTime.ToString()</see> method to format a DateTime into appropriate string format
            </remarks>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypeAnyUri">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypeBase64Binary">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypeBoolean">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypeByte">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypeDate">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypeDateTime">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypeDayTimeDuration">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypeDuration">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypeDecimal">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypeDouble">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypeFloat">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypeHexBinary">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypeInt">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypeInteger">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypeLong">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypeNegativeInteger">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypeNonNegativeInteger">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypeNonPositiveInteger">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypePositiveInteger">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypeShort">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypeTime">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypeString">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypeUnsignedByte">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypeUnsignedInt">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypeUnsignedLong">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.XmlSchemaDataTypeUnsignedShort">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.XmlSpecsHelper.SupportedTypes">
            <summary>
            Array of Constants for Data Types that are supported by the Literal Node CompareTo method
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.XmlSpecsHelper.IsName(System.String)">
            <summary>
            Returns whether a String is a Name as defined by the W3C XML Specification
            </summary>
            <param name="name">String to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.XmlSpecsHelper.IsNCName(System.String)">
            <summary>
            Returns whether a String is a NCName as defined by the W3C XML Namespaces Specification
            </summary>
            <param name="name">String to test</param>
            <returns></returns>
            <see>http://www.w3.org/TR/REC-xml-names/#NT-NCName</see>
        </member>
        <member name="M:VDS.RDF.Parsing.XmlSpecsHelper.IsNameChar(System.Char)">
            <summary>
            Returns whether a Character is a NameChar as defined by the W3C XML Specification
            </summary>
            <param name="c">Character to Test</param>
            <returns></returns>
            <see>http://www.w3.org/TR/REC-xml/#NT-NameChar</see>
        </member>
        <member name="M:VDS.RDF.Parsing.XmlSpecsHelper.IsNameStartChar(System.Char)">
            <summary>
            Returns whether a Character is a NameChar as defined by the W3C XML Specification
            </summary>
            <param name="c">Character to test</param>
            <returns></returns>
            <see>http://www.w3.org/TR/REC-xml/#NT-NameChar</see>
        </member>
        <member name="M:VDS.RDF.Parsing.XmlSpecsHelper.IsSupportedType(System.String)">
            <summary>
            Returns whether the given Type refers to one of the types supported by the <see cref="T:VDS.RDF.LiteralNode">LiteralNode</see> CompareTo method
            </summary>
            <param name="type">Data Type Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.XmlSpecsHelper.IsSupportedType(System.Uri)">
            <summary>
            Returns whether the given Type refers to one of the types supported by the <see cref="T:VDS.RDF.LiteralNode">LiteralNode</see> CompareTo method
            </summary>
            <param name="type">Data Type Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.XmlSpecsHelper.GetSupportedDataType(VDS.RDF.INode)">
            <summary>
            Gets the Data Type Uri of the given Node if it has a supported type
            </summary>
            <param name="n">Node</param>
            <returns></returns>
            <remarks>
            <para>
            Only <see cref="T:VDS.RDF.ILiteralNode">ILiteralNode</see>'s can have a Data Type
            </para>
            <para>
            The function only returns the Data Type Uri (as a String) if the Data Type of the Literal is one of the supported Data Types
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.XmlSpecsHelper.GetCompatibleSupportedDataType(VDS.RDF.INode,VDS.RDF.INode,System.Boolean)">
            <summary>
            Gets the Compatible Supported Data Type assuming the two Nodes are Literals with support types and that those types are compatible
            </summary>
            <param name="x">A Node</param>
            <param name="y">A Node</param>
            <param name="widen">Whether the compatible type should be the wider type</param>
            <returns></returns>
            <remarks>
            <para>
            Currently this is only immplemented sufficiently for the types it needs to know are compatible for implementing SPARQL equality and ordering semantics
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.XmlSpecsHelper.GetCompatibleSupportedDataType(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets the Compatible Supported Data Type assuming the two Nodes are Literals with support types and that those types are compatible
            </summary>
            <param name="x">A Node</param>
            <param name="y">A Node</param>
            <returns></returns>
            <remarks>
            <para>
            Currently this is only immplemented sufficiently for the types it needs to know are compatible for implementing SPARQL equality and ordering semantics
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.XmlSpecsHelper.GetCompatibleSupportedDataType(System.String,System.String)">
            <summary>
            Gets the Compatible Supported Data Type for the two Data Types
            </summary>
            <param name="type1">A Data Type</param>
            <param name="type2">A Data Type</param>
            <returns></returns>
            <remarks>
            <para>
            Currently this is only immplemented sufficiently for the types it needs to know are compatible for implementing SPARQL equality and ordering semantics
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.XmlSpecsHelper.GetCompatibleSupportedDataType(System.String,System.String,System.Boolean)">
            <summary>
            Gets the Compatible Supported Data Type for the two Data Types
            </summary>
            <param name="type1">A Data Type</param>
            <param name="type2">A Data Type</param>
            <param name="widen">Whether the compatible type should be the wider type</param>
            <returns></returns>
            <remarks>
            <para>
            Currently this is only immplemented sufficiently for the types it needs to know are compatible for implementing SPARQL equality and ordering semantics
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Writing.UriRefType">
            <summary>
            Possible URI Reference Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.UriRefType.QName">
            <summary>
            Must be a QName
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.UriRefType.QNameOrUri">
            <summary>
            May be a QName or a URI
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.UriRefType.UriRef">
            <summary>
            URI Reference
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.UriRefType.Uri">
            <summary>
            URI
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.WriterCompressionLevel">
            <summary>
            Class containing constants for possible Compression Levels
            </summary>
            <remarks>These are intended as guidance only, Writer implementations are free to interpret these levels as they desire or to ignore them entirely and use their own levels</remarks>
        </member>
        <member name="F:VDS.RDF.Writing.WriterCompressionLevel.None">
            <summary>
            No Compression should be used (-1)
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.WriterCompressionLevel.Minimal">
            <summary>
            Minimal Compression should be used (0)
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.WriterCompressionLevel.Default">
            <summary>
            Default Compression should be used (1)
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.WriterCompressionLevel.Medium">
            <summary>
            Medium Compression should be used (3)
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.WriterCompressionLevel.More">
            <summary>
            More Compression should be used (5)
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.WriterCompressionLevel.High">
            <summary>
            High Compression should be used (10)
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.WriterErrorMessages">
            <summary>
            Class containing constants for standardised Writer Error Messages
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.WriterErrorMessages.GraphLiteralsUnserializableError">
            <summary>
            Error message produced when a User attempts to serialize a Graph containing Graph Literals
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.WriterErrorMessages.UnknownNodeTypeUnserializableError">
            <summary>
            Error message produced when a User attempts to serialize a Graph containing Unknown Node Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.WriterErrorMessages.LiteralSubjectsUnserializableError">
            <summary>
            Error message produced when a User attempts to serialize a Graph containing Triples with Literal Subjects
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.WriterErrorMessages.LiteralPredicatesUnserializableError">
            <summary>
            Error message produced when a User attempts to serialize a Graph containing Triples with Literal Predicates
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.WriterErrorMessages.GraphLiteralPredicatesUnserializableError">
            <summary>
            Error message produced when a User attempts to serialized a Graph containing Triples with Graph Literal Predicates
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.WriterErrorMessages.BlankPredicatesUnserializableError">
            <summary>
            Error message produced when a User attempts to serialize a Graph containing Triples with Blank Node Predicates
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.WriterErrorMessages.UnreducablePropertyURIUnserializable">
            <summary>
            Error message produced when a User attempts to serialize a Graph containing URIs which cannot be reduced to a URIRef or QName as required by the serialization
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.WriterErrorMessages.MalformedCollectionWithMultipleFirsts">
            <summary>
            Error message produced when a User attempts to serialize a Graph containing collections where a collection item has more than one rdf:first triple
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.WriterErrorMessages.ThreadedOutputError">
            <summary>
            Error messages produced when errors occur in a multi-threaded writing process
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.WriterErrorMessages.VariableNodesUnserializableError">
            <summary>
            Error message produced when a User attempts to serialize a Variable Node in a format which does not support it
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.WriterErrorMessages.GraphLiteralsUnserializable(System.String)">
            <summary>
            Gets an Error message indicating that Graph Literals are not serializable with the appropriate RDF format name inserted in the error
            </summary>
            <param name="format">RDF format (syntax)</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.WriterErrorMessages.UnknownNodeTypeUnserializable(System.String)">
            <summary>
            Gets an Error message indicating that Unknown Node Types are not serializable with the appropriate RDF format name inserted in the error
            </summary>
            <param name="format">RDF format (syntax)</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.WriterErrorMessages.VariableNodesUnserializable(System.String)">
            <summary>
            Gets an Error message indicating that Variable Nodes are not serializable with the appropriate RDF format name inserted in the error
            </summary>
            <param name="format">RDF format (syntax)</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.WriterErrorMessages.LiteralSubjectsUnserializable(System.String)">
            <summary>
            Gets an Error message indicating that Literal Subjects are not serializable with the appropriate RDF format name inserted in the error
            </summary>
            <param name="format">RDF format (syntax)</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.WriterErrorMessages.LiteralPredicatesUnserializable(System.String)">
            <summary>
            Gets an Error message indicating that Literal Predicates are not serializable with the appropriate RDF format name inserted in the error
            </summary>
            <param name="format">RDF format (syntax)</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.WriterErrorMessages.GraphLiteralPredicatesUnserializable(System.String)">
            <summary>
            Gets an Error message indicating that Graph Literal Predicates are not serializable with the appropriate RDF format name inserted in the error
            </summary>
            <param name="format">RDF format (syntax)</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.WriterErrorMessages.BlankPredicatesUnserializable(System.String)">
            <summary>
            Gets an Error message indicating that Blank Node Predicates are not serializable with the appropriate RDF format name inserted in the error
            </summary>
            <param name="format">RDF format (syntax)</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.WriterErrorMessages.ThreadedOutputFailure(System.String)">
            <summary>
            Gets an Error message indicating that a multi-threading writer process failed
            </summary>
            <param name="format">RDF format (syntax)</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Writing.TripleSegment">
            <summary>
            Indicates which Segment of a Triple Node Output is being generated for
            </summary>
            <remarks>
            Used by Writers and Formatters to ensure restrictions on which Nodes can appear where in the syntax are enforced
            </remarks>
        </member>
        <member name="F:VDS.RDF.Writing.TripleSegment.Subject">
            <summary>
            Subject of the Triple
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.TripleSegment.Predicate">
            <summary>
            Predicate of the Triple
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.TripleSegment.Object">
            <summary>
            Object of the Triple
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.CollectionSearchMode">
            <summary>
            Controls what type of collections
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.CollectionSearchMode.All">
            <summary>
            Find all collections
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.CollectionSearchMode.ExplicitOnly">
            <summary>
            Find explicit collections only (those specified with Blank Node syntax)
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.CollectionSearchMode.ImplicitOnly">
            <summary>
            Find implicit collections only (those using rdf:first and rdf:rest)
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.OutputRdfCollection">
            <summary>
            Class used to store Collections as part of the writing process for Compressing Writers
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.OutputRdfCollection.#ctor(System.Boolean)">
            <summary>
            Creates a new Instance of a Collection
            </summary>
            <param name="explicitCollection">Whether the collection is explicit (specified using square bracket notation) or implicit (specified using normal parentheses)</param>
        </member>
        <member name="P:VDS.RDF.Writing.OutputRdfCollection.IsExplicit">
            <summary>
            Gets whether this is an Explicit collection (specified using square bracket notation)
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.OutputRdfCollection.HasBeenWritten">
            <summary>
            Gets/Sets whether the Collection has been written
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.OutputRdfCollection.Triples">
            <summary>
            Gets the Triples that make up the Collection
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.NodeFormat">
            <summary>
            Possible Output Formats for Nodes
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.NodeFormat.NTriples">
            <summary>
            Format for NTriples
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.NodeFormat.Turtle">
            <summary>
            Format for Turtle
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.NodeFormat.Notation3">
            <summary>
            Format for Notation 3
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.NodeFormat.UncompressedTurtle">
            <summary>
            Format for Uncompressed Turtle
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.NodeFormat.UncompressedNotation3">
            <summary>
            Format for Uncompressed Notation 3
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.WriterHelper">
            <summary>
            Helper methods for writers
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.WriterHelper.IsValidBlankNodeID(System.String)">
            <summary>
            Determines whether a Blank Node ID is valid as-is when serialised in NTriple like syntaxes (Turtle/N3/SPARQL)
            </summary>
            <param name="id">ID to test</param>
            <returns></returns>
            <remarks>If false is returned then the writer will alter the ID in some way</remarks>
        </member>
        <member name="M:VDS.RDF.Writing.WriterHelper.IsValidStrictBlankNodeID(System.String)">
            <summary>
            Determines whether a Blank Node ID is valid as-is when serialised as NTriples
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.WriterHelper.IsDefaultGraph(System.Uri)">
            <summary>
            Determines whether a given Uri refers to one of the Default Graph URIs assigned to the default Graph when parsing from some RDF dataset syntax
            </summary>
            <param name="u">Uri to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.WriterHelper.FindCollections(VDS.RDF.IGraph,VDS.RDF.BaseTripleCollection)">
            <summary>
            Helper method which finds Collections expressed in the Graph which can be compressed into concise collection syntax constructs in some RDF syntaxes
            </summary>
            <param name="g">Graph to find collections in</param>
            <param name="triplesDone">Triple Collection in which Triples that have been output are to be listed</param>
        </member>
        <member name="M:VDS.RDF.Writing.WriterHelper.FindCollections(VDS.RDF.Writing.Contexts.ICollectionCompressingWriterContext,VDS.RDF.Writing.CollectionSearchMode)">
            <summary>
            Helper method which finds Collections expressed in the Graph which can be compressed into concise collection syntax constructs in some RDF syntaxes
            </summary>
            <param name="context">Writer Context</param>
            <param name="mode">Collection Search Mode</param>
        </member>
        <member name="M:VDS.RDF.Writing.WriterHelper.FindCollections(VDS.RDF.Writing.Contexts.ICollectionCompressingWriterContext)">
            <summary>
            Helper method which finds Collections expressed in the Graph which can be compressed into concise collection syntax constructs in some RDF syntaxes
            </summary>
            <param name="context">Writer Context</param>
        </member>
        <member name="M:VDS.RDF.Writing.WriterHelper.EncodeForXml(System.String)">
            <summary>
            Encodes values for use in XML
            </summary>
            <param name="value">Value to encode</param>
            <returns>
            The value with any ampersands escaped to &amp;
            </returns>
        </member>
        <member name="T:VDS.RDF.SparqlResultsCallback">
            <summary>
            Callback for methods that return a <see cref="T:VDS.RDF.Query.SparqlResultSet">SparqlResultSet</see> asynchronously
            </summary>
            <param name="results">SPARQL Results</param>
            <param name="state">State</param>
            <remarks>
            In the event of an error you will be passed an instance of <see cref="T:VDS.RDF.AsyncError"/> which will contain the error and the original state information you passed into the method that took this callback
            </remarks>
        </member>
        <member name="T:VDS.RDF.GraphCallback">
            <summary>
            Callback for methods that return a <see cref="T:VDS.RDF.IGraph">IGraph</see> asynchronously
            </summary>
            <param name="g">Graph</param>
            <param name="state">State</param>
            <remarks>
            In the event of an error you will be passed an instance of <see cref="T:VDS.RDF.AsyncError"/> which will contain the error and the original state information you passed into the method that took this callback
            </remarks>
        </member>
        <member name="T:VDS.RDF.TripleStoreCallback">
            <summary>
            Callback for methods that return a <see cref="T:VDS.RDF.ITripleStore">ITripleStore</see> asynchronously
            </summary>
            <param name="store">Triple Store</param>
            <param name="state">State</param>
            <remarks>
            In the event of an error you will be passed an instance of <see cref="T:VDS.RDF.AsyncError"/> which will contain the error and the original state information you passed into the method that took this callback
            </remarks>
        </member>
        <member name="T:VDS.RDF.RdfHandlerCallback">
            <summary>
            Callbacks for methods that process the resulting triples with an RDF Handler asynchronously
            </summary>
            <param name="handler">RDF Handler</param>
            <param name="state">State</param>
            <remarks>
            In the event of an error you will be passed an instance of <see cref="T:VDS.RDF.AsyncError"/> which will contain the error and the original state information you passed into the method that took this callback
            </remarks>
        </member>
        <member name="T:VDS.RDF.SparqlResultsHandlerCallback">
            <summary>
            Callbacks for methods that process the results with an SPARQL Results Handler asynchronously
            </summary>
            <param name="handler">SPARQL Results Handler</param>
            <param name="state">State</param>
            <remarks>
            In the event of an error you will be passed an instance of <see cref="T:VDS.RDF.AsyncError"/> which will contain the error and the original state information you passed into the method that took this callback
            </remarks>
        </member>
        <member name="T:VDS.RDF.QueryCallback">
            <summary>
            Callbacks for methods that may process the results with either an RDF or a SPARQL Results Handler
            </summary>
            <param name="rdfHandler">RDF Handler</param>
            <param name="resultsHandler">SPARQL Results Handler</param>
            <param name="state">State</param>
            <remarks>
            In the event of an error you will be passed an instance of <see cref="T:VDS.RDF.AsyncError"/> which will contain the error and the original state information you passed into the method that took this callback
            </remarks>
        </member>
        <member name="T:VDS.RDF.UpdateCallback">
            <summary>
            Callbacks for methods that perform SPARQL Updates
            </summary>
            <param name="state">State</param>
            <remarks>
            In the event of an error you will be passed an instance of <see cref="T:VDS.RDF.AsyncError"/> which will contain the error and the original state information you passed into the method that took this callback
            </remarks>
        </member>
        <member name="T:VDS.RDF.NamespaceCallback">
            <summary>
            Callback for methods that return a Namespace Map
            </summary>
            <param name="nsmap">Namespace Map</param>
            <param name="state">State</param>
            <remarks>
            In the event of an error you will be passed an instance of <see cref="T:VDS.RDF.AsyncError"/> which will contain the error and the original state information you passed into the method that took this callback
            </remarks>
        </member>
        <member name="T:VDS.RDF.NodeListCallback">
            <summary>
            Callbacks for methods that return a list of nodes
            </summary>
            <param name="nodes">Node List</param>
            <param name="state">State</param>
            <remarks>
            In the event of an error you will be passed an instance of <see cref="T:VDS.RDF.AsyncError"/> which will contain the error and the original state information you passed into the method that took this callback
            </remarks>
        </member>
        <member name="T:VDS.RDF.AsyncError">
            <summary>
            Marker that will be passed to your callback in the event that an async error occurs, provides access to the error and any state that you passed in originally
            </summary>
        </member>
        <member name="M:VDS.RDF.AsyncError.#ctor(System.Exception,System.Object)">
            <summary>
            Creates new async error
            </summary>
            <param name="ex">Exception</param>
            <param name="state">State</param>
        </member>
        <member name="P:VDS.RDF.AsyncError.Error">
            <summary>
            Gets the error that occurred
            </summary>
        </member>
        <member name="P:VDS.RDF.AsyncError.State">
            <summary>
            Gets the original state that was passed in to the async call
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.PelletServerReadyCallback">
            <summary>
            Callback that occurs when the connection to a Pellet Server instance is ready for use
            </summary>
            <param name="server">Pellet Server</param>
            <param name="state">State</param>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.PelletConsistencyCallback">
            <summary>
            Callback for Pellet Constistency Service
            </summary>
            <param name="isConsistent">Whether the Knowledge Base is consistent</param>
            <param name="state">State</param>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.PelletSearchServiceCallback">
            <summary>
            Callback for Pellet Search Service
            </summary>
            <param name="results">Pellet Search Results</param>
            <param name="state">State</param>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.PelletClusterServiceCallback">
            <summary>
            Callback for Pellet Cluster Service
            </summary>
            <param name="clusters">Clusters</param>
            <param name="state">State</param>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.PelletSimilarityServiceCallback">
            <summary>
            Callback for Pellet Similarity Service
            </summary>
            <param name="results">Similarity Results</param>
            <param name="state">State</param>
        </member>
        <member name="T:VDS.RDF.Configuration.CachedObjectKey">
            <summary>
            Key for Objects that are cached by the Configuration Loader
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.CachedObjectKey.#ctor(VDS.RDF.INode,VDS.RDF.IGraph)">
            <summary>
            Creates a new Cached Object Key
            </summary>
            <param name="objNode">Object Node</param>
            <param name="g">Configuration Graph</param>
        </member>
        <member name="M:VDS.RDF.Configuration.CachedObjectKey.GetHashCode">
            <summary>
            Gets the Hash Code for the Key
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.CachedObjectKey.Equals(System.Object)">
            <summary>
            Gets whether this Key is equal to the given Object
            </summary>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.CachedObjectKey.Equals(VDS.RDF.Configuration.CachedObjectKey)">
            <summary>
            Gets whether this Key is equal to the given Key
            </summary>
            <param name="other">Key</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Configuration.ConfigurationSerializationContext">
            <summary>
            Context Class for writing serializing Configuration information
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationSerializationContext._g">
            <summary>
            Configuration Graph being written to
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationSerializationContext.#ctor">
            <summary>
            Creates a new Serialization Context
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationSerializationContext.#ctor(VDS.RDF.IGraph)">
            <summary>
            Creates a new Serialization Context
            </summary>
            <param name="g">Base Configuration Graph</param>
        </member>
        <member name="P:VDS.RDF.Configuration.ConfigurationSerializationContext.Graph">
            <summary>
            Gets the Graph to which Configuration information should be written
            </summary>
        </member>
        <member name="P:VDS.RDF.Configuration.ConfigurationSerializationContext.NextSubject">
            <summary>
            Gets/Sets the next subject to be used
            </summary>
            <remarks>
            <para>
            Always returns a Blank Node if none is currently explicitly specified
            </para>
            <para>
            Used to link objects together when you want some subsidiary object to serialize it's configuration and link that to the configuration you are currently serializing
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Configuration.CredentialsFactory">
            <summary>
            Factory class for producing Network Credentials
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.CredentialsFactory.TryLoadObject(VDS.RDF.IGraph,VDS.RDF.INode,System.Type,System.Object@)">
            <summary>
            Tries to load a Network Credential based on information from the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="targetType">Target Type</param>
            <param name="obj">Output Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.CredentialsFactory.CanLoadObject(System.Type)">
            <summary>
            Gets whether this Factory can load objects of the given Type
            </summary>
            <param name="t">Type</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Configuration.GraphFactory">
            <summary>
            Factory class for producing Graphs from Configuration Graphs
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.GraphFactory.TryLoadObject(VDS.RDF.IGraph,VDS.RDF.INode,System.Type,System.Object@)">
            <summary>
            Tries to load a Graph based on information from the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="targetType">Target Type</param>
            <param name="obj">Output Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.GraphFactory.CanLoadObject(System.Type)">
            <summary>
            Gets whether this Factory can load objects of the given Type
            </summary>
            <param name="t">Type</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Configuration.StoreFactory">
            <summary>
            Factory class for producing Triple Stores from Configuration Graphs
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.StoreFactory.TryLoadObject(VDS.RDF.IGraph,VDS.RDF.INode,System.Type,System.Object@)">
            <summary>
            Tries to load a Triple Store based on information from the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="targetType">Target Type</param>
            <param name="obj">Output Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.StoreFactory.CanLoadObject(System.Type)">
            <summary>
            Gets whether this Factory can load objects of the given Type
            </summary>
            <param name="t">Type</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Configuration.DatasetFactory">
            <summary>
            An Object Factory for creating SPARQL Datasets
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.DatasetFactory.TryLoadObject(VDS.RDF.IGraph,VDS.RDF.INode,System.Type,System.Object@)">
            <summary>
            Tries to load a SPARQL Dataset based on information from the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="targetType">Target Type</param>
            <param name="obj">Output Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.DatasetFactory.CanLoadObject(System.Type)">
            <summary>
            Gets whether this Factory can load objects of the given Type
            </summary>
            <param name="t">Type</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Configuration.SparqlEndpointFactory">
            <summary>
            Factory class for producing SPARQL Endpoints from Configuration Graphs
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.SparqlEndpointFactory.TryLoadObject(VDS.RDF.IGraph,VDS.RDF.INode,System.Type,System.Object@)">
            <summary>
            Tries to load a SPARQL Endpoint based on information from the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="targetType">Target Type</param>
            <param name="obj">Output Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.SparqlEndpointFactory.CanLoadObject(System.Type)">
            <summary>
            Gets whether this Factory can load objects of the given Type
            </summary>
            <param name="t">Type</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Configuration.ExpressionFactoryFactory">
            <summary>
            Factory class for producing Custom SPARQL Expression Factories from Configuration Graphs
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.ExpressionFactoryFactory.TryLoadObject(VDS.RDF.IGraph,VDS.RDF.INode,System.Type,System.Object@)">
            <summary>
            Tries to load a SPARQL Custom Expression Factory based on information from the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="targetType">Target Type</param>
            <param name="obj">Output Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.ExpressionFactoryFactory.CanLoadObject(System.Type)">
            <summary>
            Gets whether this Factory can load objects of the given Type
            </summary>
            <param name="t">Type</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Configuration.OptimiserFactory">
            <summary>
            An Object Factory that can generate SPARQL Query and Algebra Optimisers
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.OptimiserFactory.TryLoadObject(VDS.RDF.IGraph,VDS.RDF.INode,System.Type,System.Object@)">
            <summary>
            Tries to load a SPARQL Query/Algebra Optimiser based on information from the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="targetType">Target Type</param>
            <param name="obj">Output Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.OptimiserFactory.CanLoadObject(System.Type)">
            <summary>
            Gets whether this Factory can load objects of the given Type
            </summary>
            <param name="t">Type</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Configuration.ParserFactory">
            <summary>
            Object Factory used by the Configuration API to load parsers from configuration graphs
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.ParserFactory.TryLoadObject(VDS.RDF.IGraph,VDS.RDF.INode,System.Type,System.Object@)">
            <summary>
            Tries to load a Parser based on information from the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="targetType">Target Type</param>
            <param name="obj">Output Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.ParserFactory.CanLoadObject(System.Type)">
            <summary>
            Gets whether this Factory can load objects of the given Type
            </summary>
            <param name="t">Type</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Configuration.WriterFactory">
            <summary>
            Object Factory used by the Configuration API to load writers from configuration graphs
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.WriterFactory.TryLoadObject(VDS.RDF.IGraph,VDS.RDF.INode,System.Type,System.Object@)">
            <summary>
            Tries to load a Writer based on information from the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="targetType">Target Type</param>
            <param name="obj">Output Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.WriterFactory.CanLoadObject(System.Type)">
            <summary>
            Gets whether this Factory can load objects of the given Type
            </summary>
            <param name="t">Type</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Configuration.PermissionFactory">
            <summary>
            Factory class for producing Permissions from Configuration Graphs
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.PermissionFactory.TryLoadObject(VDS.RDF.IGraph,VDS.RDF.INode,System.Type,System.Object@)">
            <summary>
            Tries to load a Permission based on information from the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="targetType">Target Type</param>
            <param name="obj">Output Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.PermissionFactory.CanLoadObject(System.Type)">
            <summary>
            Gets whether this Factory can load objects of the given Type
            </summary>
            <param name="t">Type</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Configuration.UserGroupFactory">
            <summary>
            Factory class for producing User Groups from Configuration Graphs
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.UserGroupFactory.TryLoadObject(VDS.RDF.IGraph,VDS.RDF.INode,System.Type,System.Object@)">
            <summary>
            Tries to load a User Group based on information from the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="targetType">Target Type</param>
            <param name="obj">Output Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.UserGroupFactory.CanLoadObject(System.Type)">
            <summary>
            Gets whether this Factory can load objects of the given Type
            </summary>
            <param name="t">Type</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Configuration.Permissions.PermissionModel">
            <summary>
            Possible permission models
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.Permissions.PermissionModel.DenyAllow">
            <summary>
            If the action appears in the deny list it is denied unless it is in the allow list, otherwise it is allowed
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.Permissions.PermissionModel.AllowDeny">
            <summary>
            If the action appears in the allow list it is allowed unless it is in the deny list, otherwise it is denied
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.Permissions.PermissionModel.AllowAny">
            <summary>
            All actions are allowed
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.Permissions.PermissionModel.DenyAny">
            <summary>
            All actions are denied
            </summary>
        </member>
        <member name="T:VDS.RDF.Configuration.Permissions.IPermission">
            <summary>
            Interface for Permission
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.Permissions.IPermission.IsPermissionFor(System.String)">
            <summary>
            Gets whether the Permission is for a specific action
            </summary>
            <param name="action">Action</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Configuration.Permissions.Permission">
            <summary>
            Represents a action that can be allowed/denied
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.Permissions.Permission.#ctor(System.String)">
            <summary>
            Creates a new Permission for the given Action
            </summary>
            <param name="action">Action</param>
        </member>
        <member name="M:VDS.RDF.Configuration.Permissions.Permission.IsPermissionFor(System.String)">
            <summary>
            Gets whether the Permission is for the given action
            </summary>
            <param name="action">Action</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Configuration.Permissions.PermissionSet">
            <summary>
            Represents a set of Permissions that can be allowed/denied
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.Permissions.PermissionSet.#ctor(System.String)">
            <summary>
            Creates a new Permissions Set
            </summary>
            <param name="action">Action</param>
        </member>
        <member name="M:VDS.RDF.Configuration.Permissions.PermissionSet.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a new Permissions Set
            </summary>
            <param name="actions">Actions</param>
        </member>
        <member name="M:VDS.RDF.Configuration.Permissions.PermissionSet.IsPermissionFor(System.String)">
            <summary>
            Gets whether the Permission is for the given action
            </summary>
            <param name="action">Action</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Configuration.Permissions.UserGroup">
            <summary>
            Represents a Group of Users and the permissions they have to perform actions
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.Permissions.UserGroup.#ctor">
            <summary>
            Creates a new User Group
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.Permissions.UserGroup.#ctor(System.Boolean)">
            <summary>
            Creates a new User Group which may allow guests
            </summary>
            <param name="allowGuest">Are guests allowed?</param>
            <remarks>
            If guests are allowed then this Groups permissions apply to unauthenticated users
            </remarks>
        </member>
        <member name="M:VDS.RDF.Configuration.Permissions.UserGroup.AddUser(System.Net.NetworkCredential)">
            <summary>
            Adds a User to the Group
            </summary>
            <param name="credentials">User Credentials</param>
        </member>
        <member name="M:VDS.RDF.Configuration.Permissions.UserGroup.AddAllowedAction(VDS.RDF.Configuration.Permissions.IPermission)">
            <summary>
            Adds an allow action permission to the Group
            </summary>
            <param name="permission">Permission</param>
        </member>
        <member name="M:VDS.RDF.Configuration.Permissions.UserGroup.AddDeniedAction(VDS.RDF.Configuration.Permissions.IPermission)">
            <summary>
            Adds a deny action permission to the Group
            </summary>
            <param name="permission">Permission</param>
        </member>
        <member name="M:VDS.RDF.Configuration.Permissions.UserGroup.HasMember(System.String)">
            <summary>
            Returns whether the Group has a member with the given username
            </summary>
            <param name="username">Username</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.Permissions.UserGroup.HasMember(System.String,System.String)">
            <summary>
            Returns whether the Group has a member with the given credentials
            </summary>
            <param name="username">Username</param>
            <param name="password">Password</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.Permissions.UserGroup.IsActionPermitted(System.String)">
            <summary>
            Gets whether the Group permits the action
            </summary>
            <param name="action">Action</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Configuration.Permissions.UserGroup.AllowGuests">
            <summary>
            Gets/Sets whether Guests are allowed
            </summary>
        </member>
        <member name="P:VDS.RDF.Configuration.Permissions.UserGroup.PermissionModel">
            <summary>
            Gets/Sets the in-use Permission Model
            </summary>
        </member>
        <member name="T:VDS.RDF.Configuration.QueryProcessorFactory">
            <summary>
            Factory class for producing SPARQL Query Processors from Configuration Graphs
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.QueryProcessorFactory.TryLoadObject(VDS.RDF.IGraph,VDS.RDF.INode,System.Type,System.Object@)">
            <summary>
            Tries to load a SPARQL Query Processor based on information from the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="targetType">Target Type</param>
            <param name="obj">Output Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.QueryProcessorFactory.CanLoadObject(System.Type)">
            <summary>
            Gets whether this Factory can load objects of the given Type
            </summary>
            <param name="t">Type</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Configuration.UpdateProcessorFactory">
            <summary>
            Factory class for producing SPARQL Update Processors from Configuration Graphs
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.UpdateProcessorFactory.TryLoadObject(VDS.RDF.IGraph,VDS.RDF.INode,System.Type,System.Object@)">
            <summary>
            Tries to load a SPARQL Update based on information from the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="targetType">Target Type</param>
            <param name="obj">Output Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.UpdateProcessorFactory.CanLoadObject(System.Type)">
            <summary>
            Gets whether this Factory can load objects of the given Type
            </summary>
            <param name="t">Type</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Configuration.ObjectFactoryFactory">
            <summary>
            Factory class for producing <see cref="T:VDS.RDF.Configuration.IObjectFactory">IObjectFactory</see> instances from Configuration Graphs
            </summary>
            <remarks>
            <para>
            This essentially reflexive implementation allows for defining additional <see cref="T:VDS.RDF.Configuration.IObjectFactory">IObjectFactory</see> instances that can load custom/user defined types based on user definable Configuration.  If your Configuration Graphs contain custom object factory definitions then you should call <see cref="M:VDS.RDF.Configuration.ConfigurationLoader.AutoConfigureObjectFactories(VDS.RDF.IGraph)">ConfigurationLoader.AutoConfigureObjectFactories()</see> before attempting to load any Configuration.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Configuration.ObjectFactoryFactory.TryLoadObject(VDS.RDF.IGraph,VDS.RDF.INode,System.Type,System.Object@)">
            <summary>
            Tries to load an Object Factory based on information from the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="targetType">Target Type</param>
            <param name="obj">Output Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.ObjectFactoryFactory.CanLoadObject(System.Type)">
            <summary>
            Gets whether this Factory can load objects of the given Type
            </summary>
            <param name="t">Type</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Configuration.ReasonerFactory">
            <summary>
            Factory class for producing Reasoners from Configuration Graphs
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.ReasonerFactory.TryLoadObject(VDS.RDF.IGraph,VDS.RDF.INode,System.Type,System.Object@)">
            <summary>
            Tries to load a Reasoner based on information from the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="targetType">Target Type</param>
            <param name="obj">Output Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.ReasonerFactory.CanLoadObject(System.Type)">
            <summary>
            Gets whether this Factory can load objects of the given Type
            </summary>
            <param name="t">Type</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.BlankNodeMapper">
            <summary>
            Mapper class which creates Blank Node IDs and ensures that auto-assigned and user specified IDs don't collide
            </summary>
        </member>
        <member name="M:VDS.RDF.BlankNodeMapper.#ctor">
            <summary>
            Creates a new Blank Node Mapper
            </summary>
        </member>
        <member name="M:VDS.RDF.BlankNodeMapper.#ctor(System.String)">
            <summary>
            Creates a new Blank Node Mapper that uses a custom Prefix
            </summary>
            <param name="prefix">Prefix</param>
        </member>
        <member name="M:VDS.RDF.BlankNodeMapper.GetNextID">
            <summary>
            Gets the next available auto-assigned Blank Node ID
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BlankNodeMapper.CheckID(System.String@)">
            <summary>
            Checks that an ID can be used as a Blank Node ID remapping it to another ID if necessary
            </summary>
            <param name="id">ID to be checked</param>
            <remarks>
            If the ID is not known it is added to the ID maps.  If the ID is known but is user-assigned then this can be used fine.  If the ID is known and was auto-assigned then it has to be remapped to a different ID.
            </remarks>
        </member>
        <member name="T:VDS.RDF.BlankNodeOutputMapper">
            <summary>
            Mapper class which remaps Blank Node IDs which aren't valid as-is in a given serialization to a new ID
            </summary>
            <remarks>
            This also has to take care of the fact that it's possible that these remapped IDs then collide with existing valid IDs in which case these also have to be remapped
            </remarks>
        </member>
        <member name="M:VDS.RDF.BlankNodeOutputMapper.#ctor(System.Func{System.String,System.Boolean})">
            <summary>
            Creates a new Blank Node ID mapper
            </summary>
            <param name="validator">Function which determines whether IDs are valid or not</param>
        </member>
        <member name="M:VDS.RDF.BlankNodeOutputMapper.GetOutputID(System.String)">
            <summary>
            Takes a ID, validates it and returns either the ID or an appropriate remapped ID
            </summary>
            <param name="id">ID to map</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BlankNodeOutputMapper.GetNextID">
            <summary>
            Internal Helper function which generates the new IDs
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.BlankNodeIDAssigment">
            <summary>
            Records Blank Node assigments
            </summary>
        </member>
        <member name="M:VDS.RDF.BlankNodeIDAssigment.#ctor(System.String,System.Boolean)">
            <summary>
            Creates a new Blank Node ID Assigment Record
            </summary>
            <param name="id">ID to assign</param>
            <param name="auto">Was the ID auto-assigned</param>
        </member>
        <member name="M:VDS.RDF.BlankNodeIDAssigment.Equals(System.Object)">
            <summary>
            Returns whether a given Object is equal to this Blank Node ID assignment
            </summary>
            <param name="obj">Object to test</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.BlankNodeIDAssigment.ID">
            <summary>
            Assigned ID
            </summary>
        </member>
        <member name="P:VDS.RDF.BlankNodeIDAssigment.AutoAssigned">
            <summary>
            Whether the ID is auto-assigned
            </summary>
        </member>
        <member name="T:VDS.RDF.EqualityHelper">
            <summary>
            Static Helper class containing standard implementations of Equality between various Node types
            </summary>
        </member>
        <member name="M:VDS.RDF.EqualityHelper.AreUrisEqual(System.Uri,System.Uri)">
            <summary>
            Determines whether two URIs are equal
            </summary>
            <param name="a">First URI</param>
            <param name="b">Second URI</param>
            <returns></returns>
            <remarks>
            Unlike the Equals method provided by the <see cref="T:System.Uri">Uri</see> class by default this takes into account Fragment IDs which are essential for checking URI equality in RDF
            </remarks>
        </member>
        <member name="M:VDS.RDF.EqualityHelper.AreUrisEqual(VDS.RDF.IUriNode,VDS.RDF.IUriNode)">
            <summary>
            Determines whether two URIs are equal
            </summary>
            <param name="a">First URI Node</param>
            <param name="b">Second URI Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.EqualityHelper.AreLiteralsEqual(VDS.RDF.ILiteralNode,VDS.RDF.ILiteralNode)">
            <summary>
            Determines whether two Literals are equal
            </summary>
            <param name="a">First Literal</param>
            <param name="b">Second Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.EqualityHelper.AreBlankNodesEqual(VDS.RDF.IBlankNode,VDS.RDF.IBlankNode)">
            <summary>
            Determines whether two Blank Nodes are equal
            </summary>
            <param name="a">First Blank Node</param>
            <param name="b">Second Blank Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.EqualityHelper.AreGraphLiteralsEqual(VDS.RDF.IGraphLiteralNode,VDS.RDF.IGraphLiteralNode)">
            <summary>
            Determines whether two Graph Literals are equal
            </summary>
            <param name="a">First Blank Node</param>
            <param name="b">Second Blank Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.EqualityHelper.AreVariablesEqual(VDS.RDF.IVariableNode,VDS.RDF.IVariableNode)">
            <summary>
            Determines whether two Variable Nodes are equal
            </summary>
            <param name="a">First Variable Node</param>
            <param name="b">Second Variable Node</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.ComparisonHelper">
            <summary>
            Static Helper class containing standard implementations of Comparison between various Node types
            </summary>
        </member>
        <member name="M:VDS.RDF.ComparisonHelper.CompareUris(System.Uri,System.Uri)">
            <summary>
            Compares two URIs
            </summary>
            <param name="a">First URI</param>
            <param name="b">Second URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.ComparisonHelper.CompareUris(VDS.RDF.IUriNode,VDS.RDF.IUriNode)">
            <summary>
            Compares two URI Nodes
            </summary>
            <param name="a">First URI Node</param>
            <param name="b">Second URI Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.ComparisonHelper.CompareLiterals(VDS.RDF.ILiteralNode,VDS.RDF.ILiteralNode)">
            <summary>
            Compares two Literal Nodes using global default comparison options where applicable
            </summary>
            <param name="a">First Literal Node</param>
            <param name="b">Second Literal Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.ComparisonHelper.CompareLiterals(VDS.RDF.ILiteralNode,VDS.RDF.ILiteralNode,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
            <summary>
            Compares two Literal Nodes
            </summary>
            <param name="a">First Literal Node</param>
            <param name="b">Second Literal Node</param>
            <param name="culture">Culture to use for lexical string comparisons where more natural comparisons are not possible/applicable</param>
            <param name="comparisonOptions">String Comparison options used for lexical string comparisons where more natural comparisons are not possible/applicable</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.ComparisonHelper.CompareBlankNodes(VDS.RDF.IBlankNode,VDS.RDF.IBlankNode)">
            <summary>
            Compares two Blank Nodes
            </summary>
            <param name="a">First Blank Node</param>
            <param name="b">Second Blank Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.ComparisonHelper.CompareGraphLiterals(VDS.RDF.IGraphLiteralNode,VDS.RDF.IGraphLiteralNode)">
            <summary>
            Compares two Graph Literals
            </summary>
            <param name="a">First Graph Literal</param>
            <param name="b">Second Graph Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.ComparisonHelper.CompareVariables(VDS.RDF.IVariableNode,VDS.RDF.IVariableNode)">
            <summary>
            Compares two Variable Nodes
            </summary>
            <param name="a">First Variable Node</param>
            <param name="b">Second Variable Node</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.UriComparer">
            <summary>
            Equality comparer that compares URIs
            </summary>
        </member>
        <member name="M:VDS.RDF.UriComparer.Compare(System.Uri,System.Uri)">
            <summary>
            Compares two URIs
            </summary>
            <param name="x">URI</param>
            <param name="y">URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.UriComparer.Equals(System.Uri,System.Uri)">
            <summary>
            Determines whether two URIs are equal
            </summary>
            <param name="x">URI</param>
            <param name="y">URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.UriComparer.GetHashCode(System.Uri)">
            <summary>
            Gets the Hash Code for a URI
            </summary>
            <param name="obj">URI</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.GraphDiff">
            <summary>
            Implementation of a Graph Difference algorithm for RDF Graphs
            </summary>
            <remarks>
            <para>
            This algorithm is broadly based upon the methodology fror computing differences in RDF Graphs described in the <a href="http://www.springerlink.com/index/lq65211003774313.pdf">RDFSync</a> paper by Tummarello et al.  This is an implementation purely of a difference algorithm and not the synchronisation aspects described in their paper.  Main difference between their algorithm and mine is that mine does not make the input Graphs lean as it is concerned with showing the raw differences between the Graphs and does not concern itself with whether the differences may be semantically irrelevant.
            </para>
            <para>
            To understand this consider the following Graphs:
            </para>
            <h2>Graph A</h2>
            <code>
            _:autos1 rdfs:label "Rob" .
            </code>
            <h2>Graph B</h2>
            <code>
            _:autos1 rdfs:label "Rob" .
            _:autos2 rdfs:label "Rob" .
            </code>
            <para>
            Given these Graphs computing the Graph Difference between A and B would report an Added MSG (Minimal Spanning Graph) when in fact the 2nd Graph is non-lean and could be reduced to the same as the 1st Graph
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.GraphDiff.Difference(VDS.RDF.IGraph,VDS.RDF.IGraph)">
            <summary>
            Calculates the Difference between the two Graphs i.e. the changes required to get from the 1st Graph to the 2nd Graph
            </summary>
            <param name="a">First Graph</param>
            <param name="b">Second Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphDiff.ComputeMSGs(VDS.RDF.IGraph,VDS.RDF.HashSet{VDS.RDF.Triple},System.Collections.Generic.List{VDS.RDF.IGraph})">
            <summary>
            Computes MSGs for a Graph
            </summary>
            <param name="g">Graph</param>
            <param name="unassigned">Triples that need assigning to MSGs</param>
            <param name="msgs">MSGs list to populate</param>
        </member>
        <member name="T:VDS.RDF.GraphDiffReport">
            <summary>
            Represents the Differences between 2 Graphs
            </summary>
            <remarks>
            <para>
            The Diff represents the Difference between the 2 Graphs at the time the Difference was calculated - if the Graphs subsequently change then the Diff must be recalculated
            </para>
            </remarks>
        </member>
        <member name="P:VDS.RDF.GraphDiffReport.AreEqual">
            <summary>
            Gets whether the Graphs were equal at the time the Diff was calculated
            </summary>
        </member>
        <member name="P:VDS.RDF.GraphDiffReport.AreDifferentSizes">
            <summary>
            Gets whether the Graphs are different sizes, different sized graphs are by definition non-equal
            </summary>
        </member>
        <member name="P:VDS.RDF.GraphDiffReport.Mapping">
            <summary>
            Provides the mapping from Blank Nodes in 1 Graph to Blank Nodes in another
            </summary>
            <remarks>
            <para>
            In the case of Equal Graphs this will be a complete mapping, if the Graphs are different then it will be an empty/partial mapping depending on whether Blank Nodes can be mapped from one Graph to another or not
            </para>
            </remarks>
        </member>
        <member name="P:VDS.RDF.GraphDiffReport.AddedTriples">
            <summary>
            Gets the Ground Triples (i.e. no Blank Nodes) that must be added to the 1st Graph to get the 2nd Graph
            </summary>
        </member>
        <member name="P:VDS.RDF.GraphDiffReport.RemovedTriples">
            <summary>
            Gets the Ground Triples (i.e. no Blank Nodes) that must be removed from the 1st Graph to get the 2nd Graph
            </summary>
        </member>
        <member name="P:VDS.RDF.GraphDiffReport.AddedMSGs">
            <summary>
            Gets the MSGs (Minimal Spanning Graphs i.e. sets of Triples sharing common Blank Nodes) that must be added to the 1st Graph to get the 2nd Graph
            </summary>
        </member>
        <member name="P:VDS.RDF.GraphDiffReport.RemovedMSGs">
            <summary>
            Gets the MSGs (Minimal Spanning Graphs i.e. sets of Triples sharing common Blank Nodes) that must be added to the 1st Graph to get the 2nd Graph
            </summary>
        </member>
        <member name="T:VDS.RDF.GraphSizeComparer">
            <summary>
            A Comparer for Graphs which compares based on number of Triples
            </summary>
            <remarks>
            Used internally in computing Graph Differences but made a public Graph as it may occasionally come in useful
            </remarks>
        </member>
        <member name="M:VDS.RDF.GraphSizeComparer.Compare(VDS.RDF.IGraph,VDS.RDF.IGraph)">
            <summary>
            Compares Graphs based on their number of Triples
            </summary>
            <param name="x">Graph</param>
            <param name="y">Graph</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.MimeTypeDefinition">
            <summary>
            Represents the definition of a MIME Type including mappings to relevant readers and writers
            </summary>
        </member>
        <member name="M:VDS.RDF.MimeTypeDefinition.#ctor(System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a new MIME Type Definition
            </summary>
            <param name="syntaxName">Syntax Name for the Syntax which has this MIME Type definition</param>
            <param name="mimeTypes">MIME Types</param>
            <param name="fileExtensions">File Extensions</param>
        </member>
        <member name="M:VDS.RDF.MimeTypeDefinition.#ctor(System.String,System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a new MIME Type Definition
            </summary>
            <param name="syntaxName">Syntax Name for the Syntax which has this MIME Type definition</param>
            <param name="formatUri">Format URI as defined by the <a href="http://www.w3.org/ns/formats/">W3C</a></param>
            <param name="mimeTypes">MIME Types</param>
            <param name="fileExtensions">File Extensions</param>
        </member>
        <member name="M:VDS.RDF.MimeTypeDefinition.#ctor(System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Type,System.Type,System.Type,System.Type,System.Type,System.Type)">
            <summary>
            Creates a new MIME Type Definition
            </summary>
            <param name="syntaxName">Syntax Name for the Syntax which has this MIME Type definition</param>
            <param name="mimeTypes">MIME Types</param>
            <param name="fileExtensions">File Extensions</param>
            <param name="rdfParserType">Type to use to parse RDF (or null if not applicable)</param>
            <param name="rdfDatasetParserType">Type to use to parse RDF Datasets (or null if not applicable)</param>
            <param name="sparqlResultsParserType">Type to use to parse SPARQL Results (or null if not applicable)</param>
            <param name="rdfWriterType">Type to use to writer RDF (or null if not applicable)</param>
            <param name="rdfDatasetWriterType">Type to use to write RDF Datasets (or null if not applicable)</param>
            <param name="sparqlResultsWriterType">Type to use to write SPARQL Results (or null if not applicable)</param>
        </member>
        <member name="M:VDS.RDF.MimeTypeDefinition.#ctor(System.String,System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Type,System.Type,System.Type,System.Type,System.Type,System.Type)">
            <summary>
            Creates a new MIME Type Definition
            </summary>
            <param name="syntaxName">Syntax Name for the Syntax which has this MIME Type definition</param>
            <param name="formatUri">Format URI as defined by the <a href="http://www.w3.org/ns/formats/">W3C</a></param>
            <param name="mimeTypes">MIME Types</param>
            <param name="fileExtensions">File Extensions</param>
            <param name="rdfParserType">Type to use to parse RDF (or null if not applicable)</param>
            <param name="rdfDatasetParserType">Type to use to parse RDF Datasets (or null if not applicable)</param>
            <param name="sparqlResultsParserType">Type to use to parse SPARQL Results (or null if not applicable)</param>
            <param name="rdfWriterType">Type to use to writer RDF (or null if not applicable)</param>
            <param name="rdfDatasetWriterType">Type to use to write RDF Datasets (or null if not applicable)</param>
            <param name="sparqlResultsWriterType">Type to use to write SPARQL Results (or null if not applicable)</param>
        </member>
        <member name="M:VDS.RDF.MimeTypeDefinition.CheckValidMimeType(System.String)">
            <summary>
            Checks that MIME Types are valid
            </summary>
            <param name="type">Type</param>
        </member>
        <member name="M:VDS.RDF.MimeTypeDefinition.AddMimeType(System.String)">
            <summary>
            Adds a MIME Type to this definition
            </summary>
            <param name="type">MIME Type</param>
        </member>
        <member name="M:VDS.RDF.MimeTypeDefinition.SupportsMimeType(System.String)">
            <summary>
            Determines whether the Definition supports a particular MIME type
            </summary>
            <param name="mimeType">MIME Type</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypeDefinition.SupportsMimeType(VDS.RDF.MimeTypeSelector)">
            <summary>
            Determines whether the definition supports the MIME type specified by the selector
            </summary>
            <param name="selector">MIME Type selector</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypeDefinition.AddFileExtension(System.String)">
            <summary>
            Adds a File Extension for this Syntax
            </summary>
            <param name="ext">File Extension</param>
        </member>
        <member name="M:VDS.RDF.MimeTypeDefinition.SupportsFileExtension(System.String)">
            <summary>
            Determines whether the Definition supports a particular File Extension
            </summary>
            <param name="ext">File Extension</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypeDefinition.EnsureInterface(System.String,System.Type,System.Type)">
            <summary>
            Ensures that a given Type implements a required Interface
            </summary>
            <param name="property">Property to which we are assigning</param>
            <param name="t">Type</param>
            <param name="interfaceType">Required Interface Type</param>
        </member>
        <member name="M:VDS.RDF.MimeTypeDefinition.GetRdfParser">
            <summary>
            Gets an instance of a RDF parser
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypeDefinition.GetRdfWriter">
            <summary>
            Gets an instance of a RDF writer
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypeDefinition.GetRdfDatasetParser">
            <summary>
            Gets an instance of a RDF Dataset parser
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypeDefinition.GetRdfDatasetWriter">
            <summary>
            Gets an instance of a RDF Dataset writer
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypeDefinition.GetSparqlResultsParser">
            <summary>
            Gets an instance of a SPARQL Results parser
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypeDefinition.GetSparqlResultsWriter">
            <summary>
            Gets an instance of a SPARQL Results writer
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypeDefinition.CanParseObject``1">
            <summary>
            Gets whether a particular Type of Object can be parsed
            </summary>
            <typeparam name="T">Object Type</typeparam>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypeDefinition.GetObjectParserType``1">
            <summary>
            Gets an Object Parser for the given Type
            </summary>
            <typeparam name="T">Object Type</typeparam>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypeDefinition.SetObjectParserType``1(System.Type)">
            <summary>
            Sets an Object Parser for the given Type
            </summary>
            <typeparam name="T">Object Type</typeparam>
            <param name="parserType">Parser Type</param>
        </member>
        <member name="M:VDS.RDF.MimeTypeDefinition.GetObjectParser``1">
            <summary>
            Gets an Object Parser for the given Type
            </summary>
            <typeparam name="T">Object Type</typeparam>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.MimeTypeDefinition.SyntaxName">
            <summary>
            Gets the name of the Syntax to which this MIME Type Definition relates
            </summary>
        </member>
        <member name="P:VDS.RDF.MimeTypeDefinition.FormatUri">
            <summary>
            Gets the Format URI as defined by the <a href="http://www.w3.org/ns/formats/">W3C</a> (where applicable)
            </summary>
        </member>
        <member name="P:VDS.RDF.MimeTypeDefinition.Encoding">
            <summary>
            Gets the Encoding that should be used for reading and writing this Syntax
            </summary>
        </member>
        <member name="P:VDS.RDF.MimeTypeDefinition.MimeTypes">
            <summary>
            Gets the MIME Types defined
            </summary>
        </member>
        <member name="P:VDS.RDF.MimeTypeDefinition.CanonicalMimeType">
            <summary>
            Gets the Canonical MIME Type that should be used
            </summary>
        </member>
        <member name="P:VDS.RDF.MimeTypeDefinition.FileExtensions">
            <summary>
            Gets the File Extensions associated with this Syntax
            </summary>
        </member>
        <member name="P:VDS.RDF.MimeTypeDefinition.HasFileExtensions">
            <summary>
            Gets whether any file extensions are associated with this syntax
            </summary>
        </member>
        <member name="P:VDS.RDF.MimeTypeDefinition.CanonicalFileExtension">
            <summary>
            Gets/Sets the Canonical File Extension for this Syntax
            </summary>
        </member>
        <member name="P:VDS.RDF.MimeTypeDefinition.RdfParserType">
            <summary>
            Gets/Sets the Type to use to parse RDF (or null if not applicable)
            </summary>
        </member>
        <member name="P:VDS.RDF.MimeTypeDefinition.RdfDatasetParserType">
            <summary>
            Gets/Sets the Type to use to parse RDF Datasets (or null if not applicable)
            </summary>
        </member>
        <member name="P:VDS.RDF.MimeTypeDefinition.SparqlResultsParserType">
            <summary>
            Gets/Sets the Type to use to parse SPARQL Results (or null if not applicable)
            </summary>
        </member>
        <member name="P:VDS.RDF.MimeTypeDefinition.RdfWriterType">
            <summary>
            Gets/Sets the Type to use to writer RDF (or null if not applicable)
            </summary>
        </member>
        <member name="P:VDS.RDF.MimeTypeDefinition.RdfDatasetWriterType">
            <summary>
            Gets/Sets the Type to use to writer RDF Dataets (or null if not applicable)
            </summary>
        </member>
        <member name="P:VDS.RDF.MimeTypeDefinition.SparqlResultsWriterType">
            <summary>
            Gets/Sets the Type to use to write SPARQL Results (or null if not applicable)
            </summary>
        </member>
        <member name="P:VDS.RDF.MimeTypeDefinition.CanParseRdf">
            <summary>
            Gets whether this definition can instantiate a Parser that can parse RDF
            </summary>
        </member>
        <member name="P:VDS.RDF.MimeTypeDefinition.CanParseRdfDatasets">
            <summary>
            Gets whether this definition can instantiate a Parser that can parse RDF Datasets
            </summary>
        </member>
        <member name="P:VDS.RDF.MimeTypeDefinition.CanParseSparqlResults">
            <summary>
            Gets whether this definition can instantiate a Parser that can parse SPARQL Results
            </summary>
        </member>
        <member name="P:VDS.RDF.MimeTypeDefinition.CanWriteRdf">
            <summary>
            Gets whether the definition provides a RDF Writer
            </summary>
        </member>
        <member name="P:VDS.RDF.MimeTypeDefinition.CanWriteRdfDatasets">
            <summary>
            Gets whether the Definition provides a RDF Dataset Writer
            </summary>
        </member>
        <member name="P:VDS.RDF.MimeTypeDefinition.CanWriteSparqlResults">
            <summary>
            Gets whether the Definition provides a SPARQL Results Writer
            </summary>
        </member>
        <member name="P:VDS.RDF.MimeTypeDefinition.ObjectParserTypes">
            <summary>
            Gets the registered Object Parser Types
            </summary>
        </member>
        <member name="T:VDS.RDF.MimeTypeSelector">
            <summary>
            Selector used in selecting which MIME type to use
            </summary>
        </member>
        <member name="M:VDS.RDF.MimeTypeSelector.Create(System.String,System.Int32)">
            <summary>
            Creates a MIME Type selector
            </summary>
            <param name="contentType">MIME Type</param>
            <param name="order">Order the selector appears in the input</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypeSelector.CreateSelectors(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates an enumeration of MIME type selectors
            </summary>
            <param name="ctypes">MIME Types</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypeSelector.#ctor(System.String,System.String,System.Double,System.Int32)">
            <summary>
            Creates a new MIME Type Selector
            </summary>
            <param name="type">MIME Type to match</param>
            <param name="charset">Charset</param>
            <param name="quality">Quality (in range 0.0-1.0)</param>
            <param name="order">Order of appearance (used as precendence tiebreaker where necessary)</param>
        </member>
        <member name="M:VDS.RDF.MimeTypeSelector.CompareTo(VDS.RDF.MimeTypeSelector)">
            <summary>
            Sorts the selector in precedence order according to the content negotiation rules from the relevant RFCs
            </summary>
            <param name="other">Selector to compare against</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.MimeTypeSelector.ToString">
            <summary>
            Gets the string representation of the selector as it would appear in an Accept header
            </summary>
            <returns></returns>
            <remarks>
            Unless this is an invalid selector this will always be a valid selector that could be appended to a MIME type header
            </remarks>
        </member>
        <member name="P:VDS.RDF.MimeTypeSelector.Type">
            <summary>
            Gets the selected type
            </summary>
            <returns>A type string of the form <strong>type/subtype</strong> assuming the type if valid</returns>
        </member>
        <member name="P:VDS.RDF.MimeTypeSelector.RangeType">
            <summary>
            Gets the range type if this is a range selector
            </summary>
            <returns>A type string of the form <strong>type/</strong> if this is a range selector, otherwise null</returns>
        </member>
        <member name="P:VDS.RDF.MimeTypeSelector.Charset">
            <summary>
            Gets the Charset for the selector (may be null if none specified)
            </summary>
        </member>
        <member name="P:VDS.RDF.MimeTypeSelector.Quality">
            <summary>
            Gets the quality for the selector (range of 0.0-1.0)
            </summary>
        </member>
        <member name="P:VDS.RDF.MimeTypeSelector.Order">
            <summary>
            Gets the order of apperance for the selector (used as precedence tiebreaker where necessary)
            </summary>
        </member>
        <member name="P:VDS.RDF.MimeTypeSelector.IsAny">
            <summary>
            Gets whether the selector if for a */* pattern i.e. accept any
            </summary>
        </member>
        <member name="P:VDS.RDF.MimeTypeSelector.IsRange">
            <summary>
            Gets whether the selector is for a type/* pattern i.e. accept any sub-type of the given type
            </summary>
        </member>
        <member name="P:VDS.RDF.MimeTypeSelector.IsInvalid">
            <summary>
            Gets whether the selector is invalid
            </summary>
        </member>
        <member name="P:VDS.RDF.MimeTypeSelector.IsSpecific">
            <summary>
            Gets whether the selector is for a specific MIME type e.g. type/sub-type
            </summary>
        </member>
        <member name="T:VDS.RDF.GraphPersistenceWrapper">
            <summary>
            The Graph Persistence Wrapper is a wrapper around another Graph that can be used to batch persistence actions with the ability to Flush/Discard changes as desired.
            </summary>
            <remarks>
            <para>
            When disposed any outstanding changes are always flushed so if you make changes which you don't want to persist be sure to call the <see cref="M:VDS.RDF.GraphPersistenceWrapper.Discard">Discard()</see> method before disposing of the Graph
            </para>
            <para>
            Implementors who wish to make persistent graphs should extend this class and override the <see cref="P:VDS.RDF.GraphPersistenceWrapper.SupportsTriplePersistence">SupportsTriplePersistence</see> property and the <see cref="M:VDS.RDF.GraphPersistenceWrapper.PersistInsertedTriples(System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">PersistInsertedTriples()</see>, <see cref="M:VDS.RDF.GraphPersistenceWrapper.PersistDeletedTriples(System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">PersistDeletedTriples()</see> and <see cref="M:VDS.RDF.GraphPersistenceWrapper.PersistGraph">PersistGraph()</see> methods.  If you return true for the property then the <see cref="M:VDS.RDF.GraphPersistenceWrapper.PersistInsertedTriples(System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">PersistInsertedTriples()</see> and <see cref="M:VDS.RDF.GraphPersistenceWrapper.PersistDeletedTriples(System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">PersistDeletedTriples()</see> methods will be invoked to do persistence on batches of Triples.  If your persistence mechanism requires persisting the entire graph at once return false for the property and override the <see cref="M:VDS.RDF.GraphPersistenceWrapper.PersistGraph">PersistGraph()</see> method appropriately.
            </para>
            <h3>Warning</h3>
            <para>
            Note that the wrapper does not automatically dispose of the wrapped graph when the wrapper is Dispose, this is by design since disposing of the wrapped Graph can have unintended consequences
            </para>
            </remarks>
        </member>
        <member name="F:VDS.RDF.GraphPersistenceWrapper._g">
            <summary>
            Underlying Graph this is a wrapper around
            </summary>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.#ctor">
            <summary>
            Creates a new Graph Persistence Wrapper around a new Graph
            </summary>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.#ctor(System.Boolean)">
            <summary>
            Creates a new Graph Persistence Wrapper around a new Graph with the given always queue setting
            </summary>
            <param name="alwaysQueueActions">Whether to always queue actions</param>
            <remarks>
            The <paramref name="alwaysQueueActions">alwaysQueueActions</paramref> setting when enabled will cause the wrapper to queue Asserts and Retracts for persistence regardless of whether the relevant Triples already exist (i.e. normally if a Triple exists is cannot be asserted again and if it doesn't exist it cannot be retracted).  This is useful for creating derived wrappers which operate in write-only mode i.e. append mode for an existing graph that may be too large to reasonably load into memory
            </remarks>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.#ctor(VDS.RDF.IGraph)">
            <summary>
            Creates a new Graph Persistence Wrapper around the given Graph
            </summary>
            <param name="g">Graph</param>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.#ctor(VDS.RDF.IGraph,System.Boolean)">
            <summary>
            Creates a new Graph Persistence Wrapper around the given Graph with the given always queue setting
            </summary>
            <param name="g">Graph</param>
            <param name="alwaysQueueActions">Whether to always queue actions</param>
            <remarks>
            The <paramref name="alwaysQueueActions">alwaysQueueActions</paramref> setting when enabled will cause the wrapper to queue Asserts and Retracts for persistence regardless of whether the relevant Triples already exist (i.e. normally if a Triple exists is cannot be asserted again and if it doesn't exist it cannot be retracted).  This is useful for creating derived wrappers which operate in write-only mode i.e. append mode for an existing graph that may be too large to reasonably load into memory
            </remarks>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.Finalize">
            <summary>
            Destructor for the wrapper to ensure that <see cref="M:VDS.RDF.GraphPersistenceWrapper.Dispose">Dispose()</see> is called and thus that persistence happens
            </summary>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.Assert(VDS.RDF.Triple)">
            <summary>
            Asserts a Triple in the Graph
            </summary>
            <param name="t">Triple</param>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.Assert(System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Asserts Triples in the Graph
            </summary>
            <param name="ts">Triples</param>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.Retract(VDS.RDF.Triple)">
            <summary>
            Retracts a Triple from the Graph
            </summary>
            <param name="t">Triple</param>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.Retract(System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Retracts Triples from the Graph
            </summary>
            <param name="ts">Triples</param>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.Clear">
            <summary>
            Clears the Graph
            </summary>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.CreateBlankNode(System.String)">
            <summary>
            Creates a new Blank Node with the given Node ID
            </summary>
            <param name="nodeId">Node ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.CreateBlankNode">
            <summary>
            Creates a new Blank Node
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.GetNextBlankNodeID">
            <summary>
            Gets the next available Blank Node ID
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.CreateGraphLiteralNode(VDS.RDF.IGraph)">
            <summary>
            Creates a new Graph Literal Node with the given sub-graph
            </summary>
            <param name="subgraph">Sub-graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.CreateGraphLiteralNode">
            <summary>
            Creates a new Graph Literal Node
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.CreateLiteralNode(System.String)">
            <summary>
            Creates a new Literal Node
            </summary>
            <param name="literal">Value</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.CreateLiteralNode(System.String,System.Uri)">
            <summary>
            Creates a new Literal Node with the given Datatype
            </summary>
            <param name="literal">Value</param>
            <param name="datatype">Datatype URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.CreateLiteralNode(System.String,System.String)">
            <summary>
            Creates a new Literal Node with the given Language
            </summary>
            <param name="literal">Value</param>
            <param name="langspec">Language</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.CreateUriNode">
            <summary>
            Creates a new URI Node that references the Graphs Base URI
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.CreateUriNode(System.String)">
            <summary>
            Creates a new URI Node from a QName
            </summary>
            <param name="qname">QName</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.CreateUriNode(System.Uri)">
            <summary>
            Creates a new URI Node
            </summary>
            <param name="uri">URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.CreateVariableNode(System.String)">
            <summary>
            Creates a new Variable Node
            </summary>
            <param name="varname">Variable Name</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.GetBlankNode(System.String)">
            <summary>
            Attempts to get the Blank Node with the given ID
            </summary>
            <param name="nodeId">Node ID</param>
            <returns>The Node if it exists or null</returns>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.GetLiteralNode(System.String,System.String)">
            <summary>
            Attempts to get the Literal Node with the given Value and Language
            </summary>
            <param name="literal">Value</param>
            <param name="langspec">Language</param>
            <returns>The Node if it exists or null</returns>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.GetLiteralNode(System.String)">
            <summary>
            Attempts to get the Literal Node with the given Value
            </summary>
            <param name="literal">Value</param>
            <returns>The Node if it exists or null</returns>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.GetLiteralNode(System.String,System.Uri)">
            <summary>
            Attempts to get the Literal Node with the given Value and Datatype
            </summary>
            <param name="literal">Value</param>
            <param name="datatype">Datatype URI</param>
            <returns>The Node if it exists or null otherwise</returns>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.GetTriples(System.Uri)">
            <summary>
            Gets all the Triples involving the given URI
            </summary>
            <param name="uri">The URI to find Triples involving</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.GetTriples(VDS.RDF.INode)">
            <summary>
            Gets all the Triples involving the given Node
            </summary>
            <param name="n">The Node to find Triples involving</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.GetTriplesWithObject(System.Uri)">
            <summary>
            Gets all the Triples with the given URI as the Object
            </summary>
            <param name="u">The URI to find Triples with it as the Object</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.GetTriplesWithObject(VDS.RDF.INode)">
            <summary>
            Gets all the Triples with the given Node as the Object
            </summary>
            <param name="n">The Node to find Triples with it as the Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.GetTriplesWithPredicate(VDS.RDF.INode)">
            <summary>
            Gets all the Triples with the given Node as the Predicate
            </summary>
            <param name="n">The Node to find Triples with it as the Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.GetTriplesWithPredicate(System.Uri)">
            <summary>
            Gets all the Triples with the given Uri as the Predicate
            </summary>
            <param name="u">The Uri to find Triples with it as the Predicate</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.GetTriplesWithSubject(VDS.RDF.INode)">
            <summary>
            Gets all the Triples with the given Node as the Subject
            </summary>
            <param name="n">The Node to find Triples with it as the Subject</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.GetTriplesWithSubject(System.Uri)">
            <summary>
            Gets all the Triples with the given Uri as the Subject
            </summary>
            <param name="u">The Uri to find Triples with it as the Subject</param>
            <returns>Zero/More Triples</returns>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.GetTriplesWithSubjectPredicate(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Selects all Triples with the given Subject and Predicate
            </summary>
            <param name="subj">Subject</param>
            <param name="pred">Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.GetTriplesWithSubjectObject(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Selects all Triples with the given Subject and Object
            </summary>
            <param name="subj">Subject</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.GetTriplesWithPredicateObject(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Selects all Triples with the given Predicate and Object
            </summary>
            <param name="pred">Predicate</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.GetUriNode(System.String)">
            <summary>
            Returns the UriNode with the given QName if it exists
            </summary>
            <param name="qname">The QName of the Node to select</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.GetUriNode(System.Uri)">
            <summary>
            Returns the UriNode with the given Uri if it exists
            </summary>
            <param name="uri">The Uri of the Node to select</param>
            <returns>Either the UriNode Or null if no Node with the given Uri exists</returns>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.ContainsTriple(VDS.RDF.Triple)">
            <summary>
            Gets whether a given Triple exists in this Graph
            </summary>
            <param name="t">Triple to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.Merge(VDS.RDF.IGraph)">
            <summary>
            Merges another Graph into the current Graph
            </summary>
            <param name="g">Graph to Merge into this Graph</param>
            <remarks>The Graph on which you invoke this method will preserve its Blank Node IDs while the Blank Nodes from the Graph being merged in will be given new IDs as required in the scope of this Graph.</remarks>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.Merge(VDS.RDF.IGraph,System.Boolean)">
            <summary>
            Merges another Graph into the current Graph
            </summary>
            <param name="g">Graph to Merge into this Graph</param>
            <param name="keepOriginalGraphUri">Indicates that the Merge should preserve the Graph URIs of Nodes so they refer to the Graph they originated in</param>
            <remarks>
            <para>
            The Graph on which you invoke this method will preserve its Blank Node IDs while the Blank Nodes from the Graph being merged in will be given new IDs as required in the scope of this Graph.
            </para>
            <para>
            The Graph will raise the <see cref="E:VDS.RDF.GraphPersistenceWrapper.MergeRequested">MergeRequested</see> event before the Merge operation which gives any event handlers the oppurtunity to cancel this event.  When the Merge operation is completed the <see cref="E:VDS.RDF.GraphPersistenceWrapper.Merged">Merged</see> event is raised
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.Equals(System.Object)">
            <summary>
            Determines whether a Graph is equal to another Object
            </summary>
            <param name="obj">Object to test</param>
            <returns></returns>
            <remarks>
            <para>
            A Graph can only be equal to another Object which is an <see cref="T:VDS.RDF.IGraph">IGraph</see>
            </para>
            <para>
            Graph Equality is determined by a somewhat complex algorithm which is explained in the remarks of the other overload for Equals
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.Equals(VDS.RDF.IGraph,System.Collections.Generic.Dictionary{VDS.RDF.INode,VDS.RDF.INode}@)">
            <summary>
            Determines whether this Graph is equal to the given Graph
            </summary>
            <param name="g">Graph to test for equality</param>
            <param name="mapping">Mapping of Blank Nodes iff the Graphs are equal and contain some Blank Nodes</param>
            <returns></returns>
            <remarks>
            <para>
            The algorithm used to determine Graph equality is based in part on a Iterative Vertex Classification Algorithm described in a Technical Report from HP by Jeremy J Carroll - <a href="http://www.hpl.hp.com/techreports/2001/HPL-2001-293.html">Matching RDF Graphs</a>
            </para>
            <para>
            Graph Equality is determined according to the following algorithm:
            </para>
            <ol>
            <li>If the given Graph is null Graphs are not equal</li>
            <li>If the given Graph is this Graph (as determined by Reference Equality) then Graphs are equal</li>
            <li>If the Graphs have a different number of Triples they are not equal</li>
            <li>Declare a list of Triples which are the Triples of the given Graph called <em>OtherTriples</em></li>
            <li>Declare two dictionaries of Nodes to Integers which are called <em>LocalClassification</em> and <em>OtherClassification</em></li>
            <li>For Each Triple in this Graph
                <ol>
                <li>If it is a Ground Triple and cannot be found and removed from <em>OtherTriples</em> then Graphs are not equal since the Triple does not exist in both Graphs</li>
                <li>If it contains Blank Nodes track the number of usages of this Blank Node in <em>LocalClassification</em></li>
                </ol>
            </li> 
            <li>If there are any Triples remaining in <em>OtherTriples</em> which are Ground Triples then Graphs are not equal since this Graph does not contain them</li>
            <li>If all the Triples from both Graphs were Ground Triples and there were no Blank Nodes then the Graphs are equal</li>
            <li>Iterate over the remaining Triples in <em>OtherTriples</em> and populate the <em>OtherClassification</em></li>
            <li>If the count of the two classifications is different the Graphs are not equal since there are differing numbers of Blank Nodes in the Graph</li>
            <li>Now build two additional dictionaries of Integers to Integers which are called <em>LocalDegreeClassification</em> and <em>OtherDegreeClassification</em>.  Iterate over <em>LocalClassification</em> and <em>OtherClassification</em> such that the corresponding degree classifications contain a mapping of the number of Blank Nodes with a given degree</li>
            <li>If the count of the two degree classifications is different the Graphs are not equal since there are not the same range of Blank Node degrees in both Graphs</li>
            <li>For All classifications in <em>LocalDegreeClassification</em> there must be a matching classification in <em>OtherDegreeClassification</em> else the Graphs are not equal</li>
            <li>Then build a possible mapping using the following rules:
                <ol>
                <li>Any Blank Node used only once should be mapped to an equivalent Blank Node in the other Graph.  If this is not possible then the Graphs are not equal</li>
                <li>Any Blank Node with a unique degree should be mapped to an equivalent Blank Node in the other Graph.  If this is not possible then the Graphs are not equal</li>
                <li>Keep a copy of the mapping up to this point as a Base Mapping for use as a fallback in later steps</li>
                <li>Build up lists of dependent pairs of Blank Nodes for both Graphs</li>
                <li>Use these lists to determine if there are any independent nodes not yet mapped.  These should be mapped to equivalent Blank Nodes in the other Graph, if this is not possible the Graphs are not equal</li>
                <li>Use the Dependencies and existing mappings to generate a possible mapping</li>
                <li>If a Complete Possible Mapping (there is a Mapping for each Blank Node from this Graph to the Other Graph) then test this mapping.  If it succeeds then the Graphs are equal</li>
                <li>Otherwise we now fallback to the Base Mapping and use it as a basis for Brute Forcing the possible solution space and testing every possibility until either a mapping works or we find the Graphs to be non-equal</li>
                </ol>
            </li>
            </ol>
            </remarks>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.IsSubGraphOf(VDS.RDF.IGraph)">
            <summary>
            Checks whether this Graph is a sub-graph of the given Graph
            </summary>
            <param name="g">Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.IsSubGraphOf(VDS.RDF.IGraph,System.Collections.Generic.Dictionary{VDS.RDF.INode,VDS.RDF.INode}@)">
            <summary>
            Checks whether this Graph is a sub-graph of the given Graph
            </summary>
            <param name="g">Graph</param>
            <param name="mapping">Mapping of Blank Nodes</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.HasSubGraph(VDS.RDF.IGraph)">
            <summary>
            Checks whether this Graph has the given Graph as a sub-graph
            </summary>
            <param name="g">Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.HasSubGraph(VDS.RDF.IGraph,System.Collections.Generic.Dictionary{VDS.RDF.INode,VDS.RDF.INode}@)">
            <summary>
            Checks whether this Graph has the given Graph as a sub-graph
            </summary>
            <param name="g">Graph</param>
            <param name="mapping">Mapping of Blank Nodes</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.Difference(VDS.RDF.IGraph)">
            <summary>
            Computes the Difference between this Graph the given Graph
            </summary>
            <param name="g">Graph</param>
            <returns></returns>
            <remarks>
            <para>
            Produces a report which shows the changes that must be made to this Graph to produce the given Graph
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.ResolveQName(System.String)">
            <summary>
            Helper function for Resolving QNames to URIs
            </summary>
            <param name="qname">QName to resolve to a Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.OnTripleAsserted(System.Object,VDS.RDF.TripleEventArgs)">
            <summary>
            Event Handler which handles the <see cref="E:VDS.RDF.BaseTripleCollection.TripleAdded">Triple Added</see> event from the underlying Triple Collection by raising the Graph's <see cref="E:VDS.RDF.GraphPersistenceWrapper.TripleAsserted">TripleAsserted</see> event
            </summary>
            <param name="sender">Sender</param>
            <param name="args">Triple Event Arguments</param>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.RaiseTripleAsserted(VDS.RDF.TripleEventArgs)">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.GraphPersistenceWrapper.TripleAsserted">Triple Asserted</see> event manually
            </summary>
            <param name="args">Triple Event Arguments</param>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.RaiseTripleAsserted(VDS.RDF.Triple)">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.GraphPersistenceWrapper.TripleAsserted">Triple Asserted</see> event manually
            </summary>
            <param name="t">Triple</param>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.OnTripleRetracted(System.Object,VDS.RDF.TripleEventArgs)">
            <summary>
            Event Handler which handles the <see cref="E:VDS.RDF.BaseTripleCollection.TripleRemoved">Triple Removed</see> event from the underlying Triple Collection by raising the Graph's <see cref="E:VDS.RDF.GraphPersistenceWrapper.TripleRetracted">Triple Retracted</see> event
            </summary>
            <param name="sender">Sender</param>
            <param name="args">Triple Event Arguments</param>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.RaiseTripleRetracted(VDS.RDF.TripleEventArgs)">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.GraphPersistenceWrapper.TripleRetracted">Triple Retracted</see> event manually
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.RaiseTripleRetracted(VDS.RDF.Triple)">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.GraphPersistenceWrapper.TripleRetracted">Triple Retracted</see> event manually
            </summary>
            <param name="t">Triple</param>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.RaiseGraphChanged(VDS.RDF.TripleEventArgs)">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.GraphPersistenceWrapper.Changed">Changed</see> event
            </summary>
            <param name="args">Triple Event Arguments</param>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.RaiseGraphChanged">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.GraphPersistenceWrapper.Changed">Changed</see> event
            </summary>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.RaiseClearRequested">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.GraphPersistenceWrapper.ClearRequested">Clear Requested</see> event and returning whether any of the Event Handlers cancelled the operation
            </summary>
            <returns>True if the operation can continue, false if it should be aborted</returns>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.RaiseCleared">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.GraphPersistenceWrapper.Cleared">Cleared</see> event
            </summary>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.RaiseMergeRequested">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.GraphPersistenceWrapper.MergeRequested">Merge Requested</see> event and returning whether any of the Event Handlers cancelled the operation
            </summary>
            <returns>True if the operation can continue, false if it should be aborted</returns>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.RaiseMerged">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.GraphPersistenceWrapper.Merged">Merged</see> event
            </summary>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.AttachEventHandlers(VDS.RDF.BaseTripleCollection)">
            <summary>
            Helper method for attaching the necessary event Handlers to a Triple Collection
            </summary>
            <param name="tripleCollection">Triple Collection</param>
            <remarks>
            May be useful if you replace the Triple Collection after instantiation e.g. as done in <see cref="T:VDS.RDF.Query.SparqlView">SparqlView</see>'s
            </remarks>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.DetachEventHandlers(VDS.RDF.BaseTripleCollection)">
            <summary>
            Helper method for detaching the necessary event Handlers from a Triple Collection
            </summary>
            <param name="tripleCollection">Triple Collection</param>
            <remarks>
            May be useful if you replace the Triple Collection after instantiation e.g. as done in <see cref="T:VDS.RDF.Query.SparqlView">SparqlView</see>'s
            </remarks>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.Flush">
            <summary>
            Flushes all changes which have yet to be persisted to the underlying storage
            </summary>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.Discard">
            <summary>
            Discards all changes which have yet to be persisted so that they are not persisted to the underlying storage
            </summary>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.PersistInsertedTriples(System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Persists inserted Triples to the underlying Storage
            </summary>
            <param name="ts">Triples</param>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.PersistDeletedTriples(System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Persists deleted Triples to the underlying Storage
            </summary>
            <param name="ts"></param>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.PersistGraph">
            <summary>
            Persists the entire Graph to the underlying Storage
            </summary>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.Dispose">
            <summary>
            Disposes of the persistence wrapper and in doing so persists any changes to the underlying storage
            </summary>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceWrapper.Dispose(System.Boolean)">
            <summary>
            Disposes of the persistence wrapper and in doing so persists any changes to the underlying storage
            </summary>
            <param name="disposing">Whether the method was called from Dispose() or the destructor</param>
        </member>
        <member name="P:VDS.RDF.GraphPersistenceWrapper.BaseUri">
            <summary>
            Gets/Sets the Base URI of the Graph
            </summary>
        </member>
        <member name="P:VDS.RDF.GraphPersistenceWrapper.IsEmpty">
            <summary>
            Gets whether the Graph is empty
            </summary>
        </member>
        <member name="P:VDS.RDF.GraphPersistenceWrapper.NamespaceMap">
            <summary>
            Gets the Namespace Map for the Graph
            </summary>
        </member>
        <member name="P:VDS.RDF.GraphPersistenceWrapper.Nodes">
            <summary>
            Gets the Nodes of the Graph
            </summary>
        </member>
        <member name="P:VDS.RDF.GraphPersistenceWrapper.Triples">
            <summary>
            Gets the Triple Collection for the Graph
            </summary>
        </member>
        <member name="E:VDS.RDF.GraphPersistenceWrapper.TripleAsserted">
            <summary>
            Event which is raised when a Triple is asserted in the Graph
            </summary>
        </member>
        <member name="E:VDS.RDF.GraphPersistenceWrapper.TripleRetracted">
            <summary>
            Event which is raised when a Triple is retracted from the Graph
            </summary>
        </member>
        <member name="E:VDS.RDF.GraphPersistenceWrapper.Changed">
            <summary>
            Event which is raised when the Graph contents change
            </summary>
        </member>
        <member name="E:VDS.RDF.GraphPersistenceWrapper.ClearRequested">
            <summary>
            Event which is raised just before the Graph is cleared of its contents
            </summary>
        </member>
        <member name="E:VDS.RDF.GraphPersistenceWrapper.Cleared">
            <summary>
            Event which is raised after the Graph is cleared of its contents
            </summary>
        </member>
        <member name="E:VDS.RDF.GraphPersistenceWrapper.MergeRequested">
            <summary>
            Event which is raised when a Merge operation is requested on the Graph
            </summary>
        </member>
        <member name="E:VDS.RDF.GraphPersistenceWrapper.Merged">
            <summary>
            Event which is raised when a Merge operation is completed on the Graph
            </summary>
        </member>
        <member name="P:VDS.RDF.GraphPersistenceWrapper.SupportsTriplePersistence">
            <summary>
            Used to indicate whether the persistence mechansim can persist batches of Triples
            </summary>
            <remarks>
            <para>
            If <strong>true</strong> then the <see cref="M:VDS.RDF.GraphPersistenceWrapper.PersistInsertedTriples(System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">PersistInsertedTriples()</see> and <see cref="M:VDS.RDF.GraphPersistenceWrapper.PersistDeletedTriples(System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">PersistDeletedTriples()</see> methods are used to persist changes when the <see cref="M:VDS.RDF.GraphPersistenceWrapper.Flush">Flush()</see> method is called.  If <strong>false</strong> then the <see cref="M:VDS.RDF.GraphPersistenceWrapper.PersistGraph">PersistGraph()</see> method will be invoked instead.
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.StoreGraphPersistenceWrapper">
            <summary>
            The Store Graph Persistence Wrapper is a wrapper around another Graph that will be persisted to an underlying store via a provided <see cref="T:VDS.RDF.Storage.IStorageProvider">IStorageProvider</see> implementation
            </summary>
        </member>
        <member name="M:VDS.RDF.StoreGraphPersistenceWrapper.#ctor(VDS.RDF.Storage.IStorageProvider,VDS.RDF.IGraph,System.Uri,System.Boolean)">
            <summary>
            Creates a new Store Graph Persistence Wrapper
            </summary>
            <param name="manager">Generic IO Manager</param>
            <param name="g">Graph to wrap</param>
            <param name="graphUri">Graph URI (the URI the Graph will be persisted as)</param>
            <param name="writeOnly">Whether to operate in write-only mode</param>
            <remarks>
            <para>
            <strong>Note:</strong> In order to operate in write-only mode the <see cref="T:VDS.RDF.Storage.IStorageProvider">IStorageProvider</see> must support triple level updates indicated by it returning true to its <see cref="!:IStorageProvider.UpdateSupported">UpdateSupported</see> property and the Graph to be wrapped must be an empty Graph
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.StoreGraphPersistenceWrapper.#ctor(VDS.RDF.Storage.IStorageProvider,VDS.RDF.IGraph,System.Boolean)">
            <summary>
            Creates a new Store Graph Persistence Wrapper
            </summary>
            <param name="manager">Generic IO Manager</param>
            <param name="g">Graph to wrap</param>
            <param name="writeOnly">Whether to operate in write-only mode</param>
            <remarks>
            <para>
            <strong>Note:</strong> In order to operate in write-only mode the <see cref="T:VDS.RDF.Storage.IStorageProvider">IStorageProvider</see> must support triple level updates indicated by it returning true to its <see cref="!:IStorageProvider.UpdateSupported">UpdateSupported</see> property and the Graph to be wrapped must be an empty Graph
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.StoreGraphPersistenceWrapper.#ctor(VDS.RDF.Storage.IStorageProvider,VDS.RDF.IGraph)">
            <summary>
            Creates a new Store Graph Persistence Wrapper
            </summary>
            <param name="manager">Generic IO Manager</param>
            <param name="g">Graph to wrap</param>
        </member>
        <member name="M:VDS.RDF.StoreGraphPersistenceWrapper.#ctor(VDS.RDF.Storage.IStorageProvider,System.Uri,System.Boolean)">
            <summary>
            Creates a new Store Graph Persistence Wrapper around a new empty Graph
            </summary>
            <param name="manager">Generic IO Manager</param>
            <param name="graphUri">Graph URI (the URI the Graph will be persisted as)</param>
            <param name="writeOnly">Whether to operate in write-only mode</param>
            <remarks>
            <para>
            <strong>Note:</strong> In order to operate in write-only mode the <see cref="T:VDS.RDF.Storage.IStorageProvider">IStorageProvider</see> must support triple level updates indicated by it returning true to its <see cref="!:IStorageProvider.UpdateSupported">UpdateSupported</see> property
            </para>
            <para>
            When not operating in write-only mode the existing Graph will be loaded from the underlying store
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.StoreGraphPersistenceWrapper.#ctor(VDS.RDF.Storage.IStorageProvider,System.Uri)">
            <summary>
            Creates a new Store Graph Persistence Wrapper around a new empty Graph
            </summary>
            <param name="manager">Generic IO Manager</param>
            <param name="graphUri">Graph URI (the URI the Graph will be persisted as)</param>
        </member>
        <member name="M:VDS.RDF.StoreGraphPersistenceWrapper.PersistDeletedTriples(System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Persists the deleted Triples to the in-use <see cref="T:VDS.RDF.Storage.IStorageProvider">IStorageProvider</see>
            </summary>
            <param name="ts">Triples</param>
        </member>
        <member name="M:VDS.RDF.StoreGraphPersistenceWrapper.PersistInsertedTriples(System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Persists the inserted Triples to the in-use <see cref="T:VDS.RDF.Storage.IStorageProvider">IStorageProvider</see>
            </summary>
            <param name="ts">Triples</param>
        </member>
        <member name="M:VDS.RDF.StoreGraphPersistenceWrapper.PersistGraph">
            <summary>
            Persists the entire Graph to the in-use <see cref="T:VDS.RDF.Storage.IStorageProvider">IStorageProvider</see>
            </summary>
        </member>
        <member name="P:VDS.RDF.StoreGraphPersistenceWrapper.SupportsTriplePersistence">
            <summary>
            Gets whether the in-use <see cref="T:VDS.RDF.Storage.IStorageProvider">IStorageProvider</see> supports triple level updates
            </summary>
        </member>
        <member name="T:VDS.RDF.NestedNamespaceMapper">
            <summary>
            A Namespace Mapper which has an explicit notion of Nesting
            </summary>
        </member>
        <member name="M:VDS.RDF.NestedNamespaceMapper.#ctor">
            <summary>
            Constructs a new Namespace Map
            </summary>
            <remarks>The Prefixes rdf, rdfs and xsd are automatically defined</remarks>
        </member>
        <member name="M:VDS.RDF.NestedNamespaceMapper.#ctor(System.Boolean)">
            <summary>
            Constructs a new Namespace Map which is optionally empty
            </summary>
            <param name="empty">Whether the Namespace Map should be empty, if set to false the Prefixes rdf, rdfs and xsd are automatically defined</param>
        </member>
        <member name="M:VDS.RDF.NestedNamespaceMapper.AddNamespace(System.String,System.Uri)">
            <summary>
            Adds a Namespace at the Current Nesting Level
            </summary>
            <param name="prefix">Prefix</param>
            <param name="uri">Namespace URI</param>
        </member>
        <member name="M:VDS.RDF.NestedNamespaceMapper.Clear">
            <summary>
            Clears the Namespace Map
            </summary>
        </member>
        <member name="M:VDS.RDF.NestedNamespaceMapper.GetNamespaceUri(System.String)">
            <summary>
            Gets the Namespace URI for the given Prefix at the current Nesting Level
            </summary>
            <param name="prefix">Prefix</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.NestedNamespaceMapper.GetPrefix(System.Uri)">
            <summary>
            Gets the Namespace Prefix for the given URI at the current Nesting Level
            </summary>
            <param name="uri">Namespace URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.NestedNamespaceMapper.GetNestingLevel(System.String)">
            <summary>
            Gets the Nesting Level at which the given Namespace is definition is defined
            </summary>
            <param name="prefix">Prefix</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.NestedNamespaceMapper.HasNamespace(System.String)">
            <summary>
            Gets whether the given Namespace exists
            </summary>
            <param name="prefix">Prefix</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.NestedNamespaceMapper.Import(VDS.RDF.INamespaceMapper)">
            <summary>
            Imports another Namespace Map into this one
            </summary>
            <param name="nsmap">Namespace Map</param>
        </member>
        <member name="M:VDS.RDF.NestedNamespaceMapper.IncrementNesting">
            <summary>
            Increments the Nesting Level
            </summary>
        </member>
        <member name="M:VDS.RDF.NestedNamespaceMapper.DecrementNesting">
            <summary>
            Decrements the Nesting Level
            </summary>
            <remarks>
            When the Nesting Level is decremented any Namespaces defined at a greater Nesting Level are now out of scope and so are removed from the Mapper
            </remarks>
        </member>
        <member name="M:VDS.RDF.NestedNamespaceMapper.RaiseNamespaceAdded(System.String,System.Uri)">
            <summary>
            Internal Helper for the NamespaceAdded Event which raises it only when a Handler is registered
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="uri">Namespace Uri</param>
        </member>
        <member name="M:VDS.RDF.NestedNamespaceMapper.RaiseNamespaceModified(System.String,System.Uri)">
            <summary>
            Internal Helper for the NamespaceModified Event which raises it only when a Handler is registered
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="uri">Namespace Uri</param>
        </member>
        <member name="M:VDS.RDF.NestedNamespaceMapper.OnNamespaceRemoved(System.String,System.Uri)">
            <summary>
            Internal Helper for the NamespaceRemoved Event which raises it only when a Handler is registered
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="uri">Namespace Uri</param>
        </member>
        <member name="M:VDS.RDF.NestedNamespaceMapper.ReduceToQName(System.String,System.String@)">
            <summary>
            Tries to reduce a URI to a QName using this Namespace Map
            </summary>
            <param name="uri">URI</param>
            <param name="qname">Resulting QName</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.NestedNamespaceMapper.RemoveNamespace(System.String)">
            <summary>
            Removes a Namespace provided that Namespace is defined on the current Nesting Level
            </summary>
            <param name="prefix">Prefix</param>
        </member>
        <member name="M:VDS.RDF.NestedNamespaceMapper.Dispose">
            <summary>
            Disposes of the Namespace Map
            </summary>
        </member>
        <member name="P:VDS.RDF.NestedNamespaceMapper.NestingLevel">
            <summary>
            Gets the current Nesting Level
            </summary>
        </member>
        <member name="E:VDS.RDF.NestedNamespaceMapper.NamespaceAdded">
            <summary>
            Event which occurs when a Namespace is added
            </summary>
        </member>
        <member name="E:VDS.RDF.NestedNamespaceMapper.NamespaceModified">
            <summary>
            Event which occurs when a Namespace is modified
            </summary>
        </member>
        <member name="E:VDS.RDF.NestedNamespaceMapper.NamespaceRemoved">
            <summary>
            Event which occurs when a Namespace is removed
            </summary>
        </member>
        <member name="P:VDS.RDF.NestedNamespaceMapper.Prefixes">
            <summary>
            Gets the Namespace Prefixes
            </summary>
        </member>
        <member name="T:VDS.RDF.NestedMapping">
            <summary>
            Class used to hold Nested Namespace definition information
            </summary>
        </member>
        <member name="M:VDS.RDF.NestedMapping.#ctor(System.String,System.Uri,System.Int32)">
            <summary>
            Creates a new Nested Mapping
            </summary>
            <param name="prefix">Prefix</param>
            <param name="uri">Namespace URI</param>
            <param name="level">Nesting Level</param>
        </member>
        <member name="M:VDS.RDF.NestedMapping.#ctor(System.String,System.Uri)">
            <summary>
            Creates a new Nested Mapping
            </summary>
            <param name="prefix">Prefix</param>
            <param name="uri">Namespace URI</param>
        </member>
        <member name="P:VDS.RDF.NestedMapping.Level">
            <summary>
            Gets the Nesting Level
            </summary>
        </member>
        <member name="P:VDS.RDF.NestedMapping.Prefix">
            <summary>
            Gets the Namespace Prefix
            </summary>
        </member>
        <member name="P:VDS.RDF.NestedMapping.Uri">
            <summary>
            Gets the Namespace URI
            </summary>
        </member>
        <member name="T:VDS.RDF.GraphFactory">
            <summary>
            A Graph Factory provides access to consistent Graph References so that Nodes and Triples can be instantiated in the correct Graphs
            </summary>
            <remarks>
            <para>
            Primarily designed for internal use in some of our code but may prove useful to other users hence is a public class.  Internally this is just a wrapper around a <see cref="T:VDS.RDF.TripleStore">TripleStore</see> instance.
            </para>
            <para>
            The main usage for this class is scenarios where consistent graph references matter such as returning node references from out of memory datasets (like SQL backed ones) particularly with regards to blank nodes since blank node equality is predicated upon Graph reference.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.GraphFactory.GetGraph(System.Uri)">
            <summary>
            Gets a Graph Reference for the given Graph URI
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
            <remarks>
            Synonym for the index access method i.e. factory[graphUri]
            </remarks>
        </member>
        <member name="M:VDS.RDF.GraphFactory.TryGetGraph(System.Uri,System.Boolean@)">
            <summary>
            Gets a Graph Reference for the given Graph URI and indicates whether this was a new Graph reference
            </summary>
            <param name="graphUri">Graph URI</param>
            <param name="created">Indicates whether the returned reference was newly created</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphFactory.Reset">
            <summary>
            Resets the Factory so any Graphs with contents are emptied
            </summary>
        </member>
        <member name="P:VDS.RDF.GraphFactory.Item(System.Uri)">
            <summary>
            Gets a Graph Reference for the given Graph URI
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.MockNodeFactory">
            <summary>
            A private implementation of a Node Factory which returns mock constants regardless of the inputs
            </summary>
            <remarks>
            <para>
            Intended for usage in scenarios where the user of the factory does not care about the values returned, for example it is used internally in the <see cref="T:VDS.RDF.Parsing.Handlers.CountHandler">CountHandler</see> to speed up processing
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.TriplePersistenceAction">
            <summary>
            Represents a Triple that is queued for persistence (either insertion/deletion)
            </summary>
        </member>
        <member name="M:VDS.RDF.TriplePersistenceAction.#ctor(VDS.RDF.Triple,System.Boolean)">
            <summary>
            Creates a new Triple Persistence Action (an insertion/deletion)
            </summary>
            <param name="t">Triple to persist</param>
            <param name="toDelete">Whether the Triple is to be deleted</param>
        </member>
        <member name="M:VDS.RDF.TriplePersistenceAction.#ctor(VDS.RDF.Triple)">
            <summary>
            Creates a new Triple Persistence Action (an insertion)
            </summary>
            <param name="t">Triple to persist</param>
        </member>
        <member name="P:VDS.RDF.TriplePersistenceAction.Triple">
            <summary>
            Gets the Triple to persist
            </summary>
        </member>
        <member name="P:VDS.RDF.TriplePersistenceAction.IsDelete">
            <summary>
            Gets whether the action is a Delete Action
            </summary>
        </member>
        <member name="T:VDS.RDF.GraphPersistenceActionType">
            <summary>
            Possible Types of Graph Persistence Actions
            </summary>
        </member>
        <member name="F:VDS.RDF.GraphPersistenceActionType.Added">
            <summary>
            Graph was Added
            </summary>
        </member>
        <member name="F:VDS.RDF.GraphPersistenceActionType.Deleted">
            <summary>
            Graph was Deleted
            </summary>
        </member>
        <member name="F:VDS.RDF.GraphPersistenceActionType.Modified">
            <summary>
            Graph was Modified
            </summary>
        </member>
        <member name="T:VDS.RDF.GraphPersistenceAction">
            <summary>
            Represents a Graph that is queued for persistence (added/modified/removed)
            </summary>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceAction.#ctor(VDS.RDF.IGraph,VDS.RDF.GraphPersistenceActionType)">
            <summary>
            Creates a new Graph Persistence action
            </summary>
            <param name="g">Graph</param>
            <param name="action">Action Type</param>
        </member>
        <member name="M:VDS.RDF.GraphPersistenceAction.#ctor(VDS.RDF.ITransactionalGraph,VDS.RDF.GraphPersistenceActionType)">
            <summary>
            Creates a new Graph Persistence action
            </summary>
            <param name="g">Graph</param>
            <param name="action">Action Type</param>
        </member>
        <member name="P:VDS.RDF.GraphPersistenceAction.Graph">
            <summary>
            Gets the Graph to be persisted
            </summary>
        </member>
        <member name="P:VDS.RDF.GraphPersistenceAction.Action">
            <summary>
            Gets the Action Type
            </summary>
        </member>
        <member name="T:VDS.RDF.TripleStorePersistenceAction">
            <summary>
            Represents an action on a Triple Store that is queued for persistence
            </summary>
        </member>
        <member name="M:VDS.RDF.TripleStorePersistenceAction.#ctor(VDS.RDF.GraphPersistenceAction)">
            <summary>
            Creates a new persistence action that pertains to a Graph
            </summary>
            <param name="graphAction">Graph Action</param>
        </member>
        <member name="M:VDS.RDF.TripleStorePersistenceAction.#ctor(VDS.RDF.TriplePersistenceAction)">
            <summary>
            Creates a new persistence action that pertains to a Triple
            </summary>
            <param name="tripleAction">Triple Action</param>
        </member>
        <member name="P:VDS.RDF.TripleStorePersistenceAction.IsGraphAction">
            <summary>
            Gets whether this action pertains to a Graph
            </summary>
        </member>
        <member name="P:VDS.RDF.TripleStorePersistenceAction.IsTripleAction">
            <summary>
            Gets whether this action peratins to a Triple
            </summary>
        </member>
        <member name="P:VDS.RDF.TripleStorePersistenceAction.GraphAction">
            <summary>
            Gets the Graph Action (if any)
            </summary>
        </member>
        <member name="P:VDS.RDF.TripleStorePersistenceAction.TripleAction">
            <summary>
            Gets the Triple Action (if any)
            </summary>
        </member>
        <member name="T:VDS.RDF.PersistentTripleStore">
            <summary>
            Represents an in-memory view of a triple store provided by an <see cref="T:VDS.RDF.Storage.IStorageProvider">IStorageProvider</see> instance where changes to the in-memory view get reflected in the persisted view.
            </summary>
            <remarks>
            <h3>Persistence Behaviour</h3>
            <para>
            <strong>Note:</strong> This is a transactional implementation - this means that changes made are not persisted until you either call <see cref="M:VDS.RDF.PersistentTripleStore.Flush">Flush()</see> or you dispose of the instance.  Alternatively you may invoke the <see cref="M:VDS.RDF.PersistentTripleStore.Discard">Discard()</see> method to throw away changes made to the in-memory state.
            </para>
            <para>
            The actual level of persistence provided will vary according to the <see cref="T:VDS.RDF.Storage.IStorageProvider">IStorageProvider</see> instance you use.  For example if the <see cref="M:VDS.RDF.Storage.IStorageProvider.DeleteGraph(System.Uri)">DeleteGraph()</see> method is not supported then Graph removals won't persist in the underlying store.  Similarily an instance which is read-only will allow you to pull out existing graphs from the store but won't persist any changes.
            </para>
            <para>
            The Contains() method of the underlying <see cref="T:VDS.RDF.BaseGraphCollection">BaseGraphCollection</see> has been overridden so that invoking Contains causes the Graph from the underlying store to be loaded if it exists, this means that operations like <see cref="M:VDS.RDF.BaseTripleStore.HasGraph(System.Uri)">HasGraph()</see> may be slower than expected or cause applications to stop while they wait to load data from the store.
            </para>
            <h3>SPARQL Query Behaviour</h3>
            <para>
            The exact SPARQL Query behaviour will depend on the capabilities of the underlying <see cref="T:VDS.RDF.Storage.IStorageProvider">IStorageProvider</see> instance.  If it also implements the <see cref="T:VDS.RDF.Storage.IQueryableStorage">IQueryableStorage</see> interface then its own SPARQL implementation will be used, note that if you try and make a SPARQL query but the in-memory view has not been synced (via a <see cref="M:VDS.RDF.PersistentTripleStore.Flush">Flush()</see> or <see cref="M:VDS.RDF.PersistentTripleStore.Discard">Discard()</see> call) prior to the query then an <see cref="T:VDS.RDF.Query.RdfQueryException">RdfQueryException</see> will be thrown.  If you want to make the query regardless you can do so by invoking the query method on the underlying store directly by accessing it via the <see cref="P:VDS.RDF.PersistentTripleStore.UnderlyingStore">UnderlyingStore</see> property.
            </para>
            <para>
            If the underlying store does not support SPARQL itself then SPARQL queries cannot be applied and a <see cref="T:System.NotSupportedException">NotSupportedException</see> will be thrown.
            </para>
            <h3>SPARQL Update Behaviour</h3>
            <para>
            Similarly to SPARQL Query support the SPARQL Update behaviour depends on whether the underlying <see cref="T:VDS.RDF.Storage.IStorageProvider">IStorageProvider</see> instance also implements the <see cref="T:VDS.RDF.Storage.IUpdateableStorage">IUpdateableStorage</see> interface.  If it does then its own SPARQL implementation is used, otherwise a <see cref="T:VDS.RDF.Update.GenericUpdateProcessor">GenericUpdateProcessor</see> will be used to approximate the SPARQL Update.
            </para>
            <para>
            Please be aware that as with SPARQL Query if the in-memory view is not synced with the underlying store a <see cref="T:VDS.RDF.Update.SparqlUpdateException">SparqlUpdateException</see> will be thrown.
            </para>
            <h3>Other Notes</h3>
            <para>
            It is possible for the in-memory view of the triple store to get out of sync with the underlying store if that store is being modified by other processes or other code not utilising the <see cref="T:VDS.RDF.PersistentTripleStore">PersistentTripleStore</see> instance that you have created.  Currently there is no means to resync the in-memory view with the underlying view so you should be careful of using this class in scenarios where your underlying store may be modified.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.PersistentTripleStore.#ctor(VDS.RDF.Storage.IStorageProvider)">
            <summary>
            Creates a new in-memory view of some underlying store represented by the <see cref="T:VDS.RDF.Storage.IStorageProvider">IStorageProvider</see> instance
            </summary>
            <param name="manager">IO Manager</param>
            <remarks>
            Please see the remarks for this class for notes on exact behaviour of this class
            </remarks>
        </member>
        <member name="M:VDS.RDF.PersistentTripleStore.Finalize">
            <summary>
            Finalizer which ensures that the instance is properly disposed of thereby persisting any outstanding changes to the underlying store
            </summary>
            <remarks>
            If you do not wish to persist your changes you must call <see cref="M:VDS.RDF.PersistentTripleStore.Discard">Discard()</see> prior to disposing of this instance or allowing it to go out of scope such that the finalizer gets called
            </remarks>
        </member>
        <member name="M:VDS.RDF.PersistentTripleStore.Dispose">
            <summary>
            Disposes of the Triple Store flushing any outstanding changes to the underlying store
            </summary>
            <remarks>
            If you do not want to persist changes you have please ensure you call <see cref="M:VDS.RDF.PersistentTripleStore.Discard">Discard()</see> prior to disposing of the instance
            </remarks>
        </member>
        <member name="M:VDS.RDF.PersistentTripleStore.Flush">
            <summary>
            Flushes any outstanding changes to the underlying store
            </summary>
        </member>
        <member name="M:VDS.RDF.PersistentTripleStore.Discard">
            <summary>
            Discards any outstanding changes returning the in-memory view of the store to the state it was in after the last Flush/Discard operation
            </summary>
        </member>
        <member name="M:VDS.RDF.PersistentTripleStore.ExecuteQuery(System.String)">
            <summary>
            Executes a SPARQL Query on the Triple Store
            </summary>
            <param name="query">Sparql Query as unparsed String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.PersistentTripleStore.ExecuteQuery(VDS.RDF.IRdfHandler,VDS.RDF.ISparqlResultsHandler,System.String)">
            <summary>
            Executes a SPARQL Query on the Triple Store processing the results using an appropriate handler from those provided
            </summary>
            <param name="rdfHandler">RDF Handler</param>
            <param name="resultsHandler">Results Handler</param>
            <param name="query">SPARQL Query as unparsed String</param>
        </member>
        <member name="M:VDS.RDF.PersistentTripleStore.ExecuteUpdate(System.String)">
            <summary>
            Executes an Update against the Triple Store
            </summary>
            <param name="update">SPARQL Update Command(s)</param>
            <remarks>
            As per the SPARQL 1.1 Update specification the command string may be a sequence of commands
            </remarks>
        </member>
        <member name="M:VDS.RDF.PersistentTripleStore.ExecuteUpdate(VDS.RDF.Update.SparqlUpdateCommand)">
            <summary>
            Executes a single Update Command against the Triple Store
            </summary>
            <param name="update">SPARQL Update Command</param>
        </member>
        <member name="M:VDS.RDF.PersistentTripleStore.ExecuteUpdate(VDS.RDF.Update.SparqlUpdateCommandSet)">
            <summary>
            Executes a set of Update Commands against the Triple Store
            </summary>
            <param name="updates">SPARQL Update Command Set</param>
        </member>
        <member name="P:VDS.RDF.PersistentTripleStore.UnderlyingStore">
            <summary>
            Gets the underlying store
            </summary>
        </member>
        <member name="T:VDS.RDF.PersistentGraphCollection">
            <summary>
            Internal implementation of a Graph Collection for use by the <see cref="T:VDS.RDF.PersistentTripleStore">PersistentTripleStore</see>
            </summary>
        </member>
        <member name="T:VDS.RDF.SubGraphMatcher">
            <summary>
            Implements a Sub-Graph Isomorphism Algorithm
            </summary>
        </member>
        <member name="M:VDS.RDF.SubGraphMatcher.IsSubGraph(VDS.RDF.IGraph,VDS.RDF.IGraph)">
            <summary>
            Checks to see whether a given Graph is a sub-graph of the other Graph
            </summary>
            <param name="subgraph">Sub-Graph</param>
            <param name="parent">Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.SubGraphMatcher.TryRulesBasedMapping(VDS.RDF.IGraph,VDS.RDF.IGraph,System.Collections.Generic.Dictionary{VDS.RDF.INode,System.Int32},System.Collections.Generic.Dictionary{VDS.RDF.INode,System.Int32},System.Collections.Generic.Dictionary{System.Int32,System.Int32},System.Collections.Generic.Dictionary{System.Int32,System.Int32})">
            <summary>
            Uses a series of Rules to attempt to generate a mapping without the need for brute force guessing
            </summary>
            <param name="subgraph">1st Graph</param>
            <param name="parent">2nd Graph</param>
            <param name="subNodes">1st Graph Node classification</param>
            <param name="parentNodes">2nd Graph Node classification</param>
            <param name="subDegrees">1st Graph Degree classification</param>
            <param name="parentDegrees">2nd Graph Degree classification</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.SubGraphMatcher.TryBruteForceMapping(VDS.RDF.IGraph,VDS.RDF.IGraph,System.Collections.Generic.Dictionary{VDS.RDF.INode,System.Int32},System.Collections.Generic.Dictionary{VDS.RDF.INode,System.Int32},System.Collections.Generic.List{VDS.RDF.MappingPair},System.Collections.Generic.List{VDS.RDF.MappingPair})">
            <summary>
            Generates and Tests all possibilities in a brute force manner
            </summary>
            <param name="subgraph">1st Graph</param>
            <param name="parent">2nd Graph</param>
            <param name="subNodes">1st Graph Node classification</param>
            <param name="parentNodes">2nd Graph Node classification</param>
            <param name="subDependencies">Dependencies in the 1st Graph</param>
            <param name="parentDependencies">Dependencies in the 2nd Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.SubGraphMatcher.GenerateMappings(System.Collections.Generic.Dictionary{VDS.RDF.INode,System.Collections.Generic.List{VDS.RDF.INode}},System.Collections.Generic.List{VDS.RDF.MappingPair},System.Collections.Generic.List{VDS.RDF.MappingPair},VDS.RDF.IGraph)">
            <summary>
            Helper method for brute forcing the possible mappings
            </summary>
            <param name="possibleMappings">Possible Mappings</param>
            <param name="subDependencies">Dependencies in the 1st Graph</param>
            <param name="parentDependencies">Dependencies in the 2nd Graph</param>
            <param name="target">Target Graph (2nd Graph)</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.SubGraphMatcher.Mapping">
            <summary>
            Gets the Blank Node mapping if one could be found
            </summary>
        </member>
        <member name="T:VDS.RDF.GraphMatcher">
            <summary>
            Implements a Graph Isomorphism Algorithm
            </summary>
            <remarks>
            <para>
            The algorithm used to determine Graph equality is based in part on a Iterative Vertex Classification Algorithm described in a Technical Report from HP by Jeremy J Carroll - <a href="http://www.hpl.hp.com/techreports/2001/HPL-2001-293.html">Matching RDF Graphs</a> but has been expanded upon significantly to use a variety of techniques.
            </para>
            <para>
            Graph Equality is determined according to the following algorithm, we refer to the first graph as the <em>Source Graph</em> and the second graph as the <em>Target Graph</em>:
            </para>
            <ol>
            <li>If both graphs are null they are considered equal</li>
            <li>If only one of the given graph is null then they are not equal</li>
            <li>If the given graphs are reference equal then they are equal</li>
            <li>If the given graphs have a different number of Triples they are not equal</li>
            <li>Declare a list of triples which are the triples of the second graph called <em>TargetTriples</em></li>
            <li>Declare two dictionaries of Nodes to Integers which are called <em>SourceClassification</em> and <em>TargetClassification</em></li>
            <li>For Each Triple in the Source Graph
                <ol>
                <li>If it is a ground triple and cannot be found and removed from <em>TargetTriples</em> then graphs are not equal since the triple does not exist in both graphs</li>
                <li>If it contains blank nodes track the number of usages of this blank node in <em>SourceClassification</em></li>
                </ol>
            </li> 
            <li>If there are any triples remaining in <em>TargetTriples</em> which are ground triples then graphs are not equal since the Source Graph does not contain them</li>
            <li>If all the triples from both graphs were ground triples (i.e. there were no blank nodes) then the graphs are equal</li>
            <li>Iterate over the remaining triples in <em>TargetTriples</em> and populate the <em>TargetClassification</em></li>
            <li>If the count of the two classifications is different the graphs are not equal since there are differing numbers of blank nodes in the Graph</li>
            <li>Now build two additional dictionaries of Integers to Integers which are called <em>SourceDegreeClassification</em> and <em>TargetDegreeClassification</em>.  Iterate over <em>SourceClassification</em> and <em>TargetClassification</em> such that the corresponding degree classifications contain a mapping of the number of blank nodes with a given degree</li>
            <li>If the count of the two degree classifications is different the graphs are not equal since there are not the same range of blank node degrees in both graphs</li>
            <li>For All classifications in <em>SourceDegreeClassification</em> there must be a matching classification in <em>TargetDegreeClassification</em> else the graphs are not equal</li>
            <li>Then build a possible mapping using the following rules:
                <ol>
                <li>Any blank bode used only once (single-use) in the Source Graph should be mapped to an equivalent blank bode in the Target Graph.  If this is not possible then the graphs are not equal</li>
                <li>Any blank node with a unique degree in the Source Graph should be mapped to an equivalent blank node in the Target Graph.  If this is not possible then the graphs are not equal</li>
                <li>Any blank node used with unique constants (two other ground terms in a triple) in the Source Graph should be mapped to an equivalent blank bode in the Target Graph.  If this is not possible then the graphs are not equal.</li>
                <li>Build up lists of dependent pairs of blank Nodes for both graphs</li>
                <li>Use these lists to determine if there are any independent nodes not yet mapped in the Source Graph.  These should be mapped to equivalent blank nodes in the Target Graph, if this is not possible the graphs are not equal</li>
                <li><strong>Important:</strong> Keep a copy of the mapping up to this point as a <em>Base Mapping</em> for use as a fallback in later steps</li>
                <li>Use the dependency information and existing mappings to generate a possible mapping</li>
                <li>If a complete possible mapping (there is a mapping for each blank node from the Source Graph to the Target Graph) then test this mapping.  If it succeeds then the graphs are equal</li>
                </ol>
            </li>
            <li>If we don't yet have a mapping take a divide and conquer approach:
                <ol>
                <li>Take the not yet mapped blank nodes for each graph and sub-divide them into their isolated sub-graphs</li>
                <li>If there are at least 2 isolated sub-graphs proceed to divide and conquer</li>
                <li>For Each Isolated Sub-Graph from the Source Graph
                    <ol>
                    <li>Consider each possible isolated sub-graph of the same size from the target graph, if there are none then graphs are not equal.  If there is a single possible equal isolated sub-graph add the mappings for all involved blank nodes.</li>
                    </ol>
                </li>
                <li>If we now have a complete possible mapping (there is a mapping for each blank node from the Source Graph to the Target Graph) then test the mapping.  Return success/failure depending on whether the mapping is valid.</li>
                <li><strong>Important:</strong> Keep a copy of the mapping up to this point as a <em>Base Mapping</em> for use as a base for the brute force step</li>
                </ol> 
            </li>
            <li>If we still don't have a complete mapping we now fallback to the <em>Base Mapping</em> and use it as a basis for brute forcing the possible solution space and testing every possibility until either a mapping works or we find the graphs to be non-equal</li>
            </ol>
            </remarks>
        </member>
        <member name="M:VDS.RDF.GraphMatcher.Equals(VDS.RDF.IGraph,VDS.RDF.IGraph)">
            <summary>
            Compares two Graphs for equality
            </summary>
            <param name="g">Graph</param>
            <param name="h">Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphMatcher.TryRulesBasedMapping(VDS.RDF.IGraph,VDS.RDF.IGraph,System.Collections.Generic.Dictionary{VDS.RDF.INode,System.Int32},System.Collections.Generic.Dictionary{VDS.RDF.INode,System.Int32},System.Collections.Generic.Dictionary{System.Int32,System.Int32},System.Collections.Generic.Dictionary{System.Int32,System.Int32})">
            <summary>
            Uses a series of Rules to attempt to generate a mapping without the need for brute force guessing
            </summary>
            <param name="g">1st Graph</param>
            <param name="h">2nd Graph</param>
            <param name="gNodes">1st Graph Node classification</param>
            <param name="hNodes">2nd Graph Node classification</param>
            <param name="gDegrees">1st Graph Degree classification</param>
            <param name="hDegrees">2nd Graph Degree classification</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphMatcher.TryDivideAndConquerMapping(VDS.RDF.IGraph,VDS.RDF.IGraph,System.Collections.Generic.Dictionary{VDS.RDF.INode,System.Int32},System.Collections.Generic.Dictionary{VDS.RDF.INode,System.Int32},System.Collections.Generic.List{VDS.RDF.MappingPair},System.Collections.Generic.List{VDS.RDF.MappingPair})">
            <summary>
            Uses a divide and conquer based approach to generate a mapping without the need for brute force guessing
            </summary>
            <param name="g">1st Graph</param>
            <param name="h">2nd Graph</param>
            <param name="gNodes">1st Graph Node classification</param>
            <param name="hNodes">2nd Graph Node classification</param>
            <param name="sourceDependencies">Dependencies in the 1st Graph</param>
            <param name="targetDependencies">Dependencies in the 2nd Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphMatcher.TryBruteForceMapping(VDS.RDF.IGraph,VDS.RDF.IGraph,System.Collections.Generic.Dictionary{VDS.RDF.INode,System.Int32},System.Collections.Generic.Dictionary{VDS.RDF.INode,System.Int32},System.Collections.Generic.List{VDS.RDF.MappingPair},System.Collections.Generic.List{VDS.RDF.MappingPair})">
            <summary>
            Generates and Tests all possibilities in a brute force manner
            </summary>
            <param name="g">1st Graph</param>
            <param name="h">2nd Graph</param>
            <param name="gNodes">1st Graph Node classification</param>
            <param name="hNodes">2nd Graph Node classification</param>
            <param name="sourceDependencies">Dependencies in the 1st Graph</param>
            <param name="targetDependencies">Dependencies in the 2nd Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphMatcher.GenerateMappings(System.Collections.Generic.Dictionary{VDS.RDF.INode,VDS.RDF.INode},System.Collections.Generic.Dictionary{VDS.RDF.INode,System.Collections.Generic.List{VDS.RDF.INode}})">
            <summary>
            Helper method for brute forcing the possible mappings
            </summary>
            <param name="baseMapping">Base Mapping</param>
            <param name="possibleMappings">Possible Mappings</param>
            <returns></returns>
            <remarks>
            The base mapping at the time of the initial call shoudl contain known good mappings
            </remarks>
        </member>
        <member name="M:VDS.RDF.GraphMatcher.GenerateMappingsInternal(System.Collections.Generic.Dictionary{VDS.RDF.INode,VDS.RDF.INode},System.Collections.Generic.Dictionary{VDS.RDF.INode,System.Collections.Generic.List{VDS.RDF.INode}},VDS.RDF.INode)">
            <summary>
            Helper method for brute forcing the possible mappings
            </summary>
            <param name="baseMapping">Base Mapping</param>
            <param name="possibleMappings">Possible Mappings</param>
            <param name="x">Node to consider for mapping</param>
            <returns></returns>
            <remarks>
            The base mapping contains known good mappings
            </remarks>
        </member>
        <member name="P:VDS.RDF.GraphMatcher.Mapping">
            <summary>
            Gets the Blank Node Mapping found between the Graphs (if one was found)
            </summary>
        </member>
        <member name="T:VDS.RDF.MappingPair">
            <summary>
            Represents a Pair of Nodes that occur in the same Triple
            </summary>
        </member>
        <member name="T:VDS.RDF.QueryableGraph">
            <summary>
            Class for representing Graphs which can be directly queried using SPARQL
            </summary>
        </member>
        <member name="M:VDS.RDF.QueryableGraph.#ctor">
            <summary>
            Creates a new Queryable Graph
            </summary>
        </member>
        <member name="M:VDS.RDF.QueryableGraph.ExecuteQuery(System.String)">
            <summary>
            Executes a SPARQL Query on the Graph
            </summary>
            <param name="sparqlQuery">SPARQL Query</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.QueryableGraph.ExecuteQuery(VDS.RDF.IRdfHandler,VDS.RDF.ISparqlResultsHandler,System.String)">
            <summary>
            Executes a SPARQL Query on the Graph handling the results with the given handlers
            </summary>
            <param name="rdfHandler">RDF Handler</param>
            <param name="resultsHandler">SPARQL Results Handler</param>
            <param name="sparqlQuery">SPARQL Query</param>
        </member>
        <member name="M:VDS.RDF.QueryableGraph.ExecuteQuery(VDS.RDF.Query.SparqlQuery)">
            <summary>
            Executes a SPARQL Query on the Graph
            </summary>
            <param name="query">SPARQL Query</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.QueryableGraph.ExecuteQuery(VDS.RDF.IRdfHandler,VDS.RDF.ISparqlResultsHandler,VDS.RDF.Query.SparqlQuery)">
            <summary>
            Executes a SPARQL Query on the Graph handling the results with the given handlers
            </summary>
            <param name="rdfHandler">RDF Handler</param>
            <param name="resultsHandler">SPARQL Results Handler</param>
            <param name="query">SPARQL Query</param>
        </member>
        <member name="T:VDS.RDF.FastVirtualNodeComparer">
            <summary>
            A Node Comparer which does faster comparisons since it only does lexical comparisons for literals rather than value comparisons,
            and it compares virtual nodes on their VirtualID where possible.
            </summary>
        </member>
        <member name="M:VDS.RDF.FastVirtualNodeComparer.Compare(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Compares two Nodes
            </summary>
            <param name="x">Node</param>
            <param name="y">Node</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.FastNodeComparer">
            <summary>
            A Node Comparer which does faster comparisons since it only does lexical comparisons for literals rather than value comparisons
            </summary>
        </member>
        <member name="M:VDS.RDF.FastNodeComparer.Compare(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Compares two Nodes
            </summary>
            <param name="x">Node</param>
            <param name="y">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleEqualityComparer.Equals(VDS.RDF.Triple,VDS.RDF.Triple)">
            <summary>
            Returns whether two Triples are equal
            </summary>
            <param name="x">Triple</param>
            <param name="y">Triple</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.TripleEqualityComparer.GetHashCode(VDS.RDF.Triple)">
            <summary>
            Returns a predictable HashCode for the triple based on its components'
            </summary>
            <param name="x">Triple</param>
            <param name="y">Triple</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.BaseTripleComparer">
            <summary>
            Abstract base class for Triple Comparers which provide for comparisons using different node comparers
            </summary>
        </member>
        <member name="F:VDS.RDF.BaseTripleComparer._nodeComparer">
            <summary>
            Node Comparer
            </summary>
        </member>
        <member name="M:VDS.RDF.BaseTripleComparer.#ctor">
            <summary>
            Creates a new Triple Comparer
            </summary>
        </member>
        <member name="M:VDS.RDF.BaseTripleComparer.#ctor(System.Collections.Generic.IComparer{VDS.RDF.INode})">
            <summary>
            Creates a new Triple Comparer
            </summary>
            <param name="nodeComparer">Node Comparer to use</param>
        </member>
        <member name="M:VDS.RDF.BaseTripleComparer.Compare(VDS.RDF.Triple,VDS.RDF.Triple)">
            <summary>
            Compares two Triples
            </summary>
            <param name="x">Triple</param>
            <param name="y">Triple</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.FullTripleComparer">
            <summary>
            Triple comparer which compares on subjects, then predicates and finally objects
            </summary>
        </member>
        <member name="M:VDS.RDF.FullTripleComparer.#ctor">
            <summary>
            Creates a new Full Triple comparer
            </summary>
        </member>
        <member name="M:VDS.RDF.FullTripleComparer.#ctor(System.Collections.Generic.IComparer{VDS.RDF.INode})">
            <summary>
            Creates a new Full Triple comparer that uses a specific Node comparer
            </summary>
            <param name="nodeComparer">Node comparer</param>
        </member>
        <member name="M:VDS.RDF.FullTripleComparer.Compare(VDS.RDF.Triple,VDS.RDF.Triple)">
            <summary>
            Compares two Triples
            </summary>
            <param name="x">Triple</param>
            <param name="y">Triple</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.SubjectComparer">
            <summary>
            Triple comparer which compares only on subjects
            </summary>
        </member>
        <member name="M:VDS.RDF.SubjectComparer.#ctor">
            <summary>
            Creates a new Subject comparer
            </summary>
        </member>
        <member name="M:VDS.RDF.SubjectComparer.#ctor(System.Collections.Generic.IComparer{VDS.RDF.INode})">
            <summary>
            Creates a new Subject comparer using the provided Node comparer
            </summary>
            <param name="nodeComparer">Node comparer</param>
        </member>
        <member name="M:VDS.RDF.SubjectComparer.Compare(VDS.RDF.Triple,VDS.RDF.Triple)">
            <summary>
            Compares two Triples
            </summary>
            <param name="x">Triple</param>
            <param name="y">Triple</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.PredicateComparer">
            <summary>
            Triple comparer which compares only on predicates
            </summary>
        </member>
        <member name="M:VDS.RDF.PredicateComparer.#ctor">
            <summary>
            Creates a new Predicate comparer
            </summary>
        </member>
        <member name="M:VDS.RDF.PredicateComparer.#ctor(System.Collections.Generic.IComparer{VDS.RDF.INode})">
            <summary>
            Creates a new Predicate comparer using the provided Node comparer
            </summary>
            <param name="nodeComparer">Node Comparer</param>
        </member>
        <member name="M:VDS.RDF.PredicateComparer.Compare(VDS.RDF.Triple,VDS.RDF.Triple)">
            <summary>
            Compares two Triples
            </summary>
            <param name="x">Triple</param>
            <param name="y">Triple</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.ObjectComparer">
            <summary>
            Triple comparer which compares only on objects
            </summary>
        </member>
        <member name="M:VDS.RDF.ObjectComparer.#ctor">
            <summary>
            Creates a new Object comparer
            </summary>
        </member>
        <member name="M:VDS.RDF.ObjectComparer.#ctor(System.Collections.Generic.IComparer{VDS.RDF.INode})">
            <summary>
            Creates a new Object comparer using the provided Node comparer
            </summary>
            <param name="nodeComparer">Node comparer</param>
        </member>
        <member name="M:VDS.RDF.ObjectComparer.Compare(VDS.RDF.Triple,VDS.RDF.Triple)">
            <summary>
            Compares two Triples
            </summary>
            <param name="x">Triple</param>
            <param name="y">Triple</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.SubjectPredicateComparer">
            <summary>
            Triple comparer which compares on subjects and then predicates
            </summary>
        </member>
        <member name="M:VDS.RDF.SubjectPredicateComparer.#ctor">
            <summary>
            Creates a new Subject Predicate comparer
            </summary>
        </member>
        <member name="M:VDS.RDF.SubjectPredicateComparer.#ctor(System.Collections.Generic.IComparer{VDS.RDF.INode})">
            <summary>
            Creates a new Subject Predicate comparer using the provided Node comparer
            </summary>
            <param name="nodeComparer">Node Comparer</param>
        </member>
        <member name="M:VDS.RDF.SubjectPredicateComparer.Compare(VDS.RDF.Triple,VDS.RDF.Triple)">
            <summary>
            Compares two Triples
            </summary>
            <param name="x">Triple</param>
            <param name="y">Triple</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.SubjectObjectComparer">
            <summary>
            Triple comparer which compares on subjects and then objects
            </summary>
        </member>
        <member name="M:VDS.RDF.SubjectObjectComparer.#ctor">
            <summary>
            Creates a new Subject Object comparer
            </summary>
        </member>
        <member name="M:VDS.RDF.SubjectObjectComparer.#ctor(System.Collections.Generic.IComparer{VDS.RDF.INode})">
            <summary>
            Creates a new Subject Object comparer using the provided Node comparer
            </summary>
            <param name="nodeComparer">Node comparer</param>
        </member>
        <member name="M:VDS.RDF.SubjectObjectComparer.Compare(VDS.RDF.Triple,VDS.RDF.Triple)">
            <summary>
            Compares two Triples
            </summary>
            <param name="x">Triple</param>
            <param name="y">Triple</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.PredicateObjectComparer">
            <summary>
            Triple comparer which compares on predicates and then objects
            </summary>
        </member>
        <member name="M:VDS.RDF.PredicateObjectComparer.#ctor">
            <summary>
            Creates a new Predicate Object comparer
            </summary>
        </member>
        <member name="M:VDS.RDF.PredicateObjectComparer.#ctor(System.Collections.Generic.IComparer{VDS.RDF.INode})">
            <summary>
            Creates a new Predicate Object comparer using the provided Node comparer
            </summary>
            <param name="nodeComparer">Node comparer</param>
        </member>
        <member name="M:VDS.RDF.PredicateObjectComparer.Compare(VDS.RDF.Triple,VDS.RDF.Triple)">
            <summary>
            Compares two Triples
            </summary>
            <param name="x">Triple</param>
            <param name="y">Triple</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.ObjectSubjectComparer">
            <summary>
            Triple comparer which compares on objects and then subjects
            </summary>
        </member>
        <member name="M:VDS.RDF.ObjectSubjectComparer.#ctor">
            <summary>
            Creates a new Object Subject comparer
            </summary>
        </member>
        <member name="M:VDS.RDF.ObjectSubjectComparer.#ctor(System.Collections.Generic.IComparer{VDS.RDF.INode})">
            <summary>
            Creates a new Object Subject comparer using the provided Node comparer
            </summary>
        </member>
        <member name="M:VDS.RDF.ObjectSubjectComparer.Compare(VDS.RDF.Triple,VDS.RDF.Triple)">
            <summary>
            Compares two Triples
            </summary>
            <param name="x">Triple</param>
            <param name="y">Triple</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.UnionTripleCollection">
            <summary>
            Represents a union of multiple Triple Collections
            </summary>
            <remarks>
            <para>
            The union consists of a <em>Base</em> collection which is the collection that Triples can actually be added to and deleted from and any number of additional collections which are read-only as far as the union is concerned (this does not mean they cannot be altered elsewhere by other code)
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.UnionTripleCollection.#ctor(VDS.RDF.BaseTripleCollection,VDS.RDF.BaseTripleCollection)">
            <summary>
            Creates a new Union Triple Collection which is a union of two collections
            </summary>
            <param name="baseTriples">Base Triple Collection</param>
            <param name="additionalTriples">Additional Triple Collection</param>
        </member>
        <member name="M:VDS.RDF.UnionTripleCollection.#ctor(VDS.RDF.BaseTripleCollection,System.Collections.Generic.IEnumerable{VDS.RDF.BaseTripleCollection})">
            <summary>
            Creates a new Union Triple Collection which is a union of any number of collections
            </summary>
            <param name="baseTriples">Base Triple Collection</param>
            <param name="additionalTriples">Additional Triple Collection(s)</param>
        </member>
        <member name="M:VDS.RDF.UnionTripleCollection.Add(VDS.RDF.Triple)">
            <summary>
            Adds a Triple to the base collection
            </summary>
            <param name="t">Triple to add</param>
        </member>
        <member name="M:VDS.RDF.UnionTripleCollection.Contains(VDS.RDF.Triple)">
            <summary>
            Checks whether the union contains this Triple in any of the collections it comprises
            </summary>
            <param name="t">Triple to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.UnionTripleCollection.Delete(VDS.RDF.Triple)">
            <summary>
            Deletes a Triple from the base collection
            </summary>
            <param name="t">Triple to delete</param>
        </member>
        <member name="M:VDS.RDF.UnionTripleCollection.Dispose">
            <summary>
            Disposes of the collection
            </summary>
            <remarks>
            This does nothing since we don't know where and how the collections we are the union of are being used and therefore to dispose of them could have unwanted/unexpected results
            </remarks>
        </member>
        <member name="M:VDS.RDF.UnionTripleCollection.GetEnumerator">
            <summary>
            Gets the enumeration of Triples in the union
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.UnionTripleCollection.Count">
            <summary>
            Gets the count of Triples in this union
            </summary>
            <remarks>
            The Count is the total number of Triples, this may be different from the number of distinct triples
            </remarks>
        </member>
        <member name="P:VDS.RDF.UnionTripleCollection.Item(VDS.RDF.Triple)">
            <summary>
            Retrieves a Triple from the union
            </summary>
            <param name="t">Triple to retrieve</param>
            <returns></returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if the Triple is not contained in any of the collections this union comprises</exception>
        </member>
        <member name="P:VDS.RDF.UnionTripleCollection.ObjectNodes">
            <summary>
            Gets the enumeration of distinct objects of Triples
            </summary>
        </member>
        <member name="P:VDS.RDF.UnionTripleCollection.PredicateNodes">
            <summary>
            Gets the enumeration of distinct predicates of Triples
            </summary>
        </member>
        <member name="P:VDS.RDF.UnionTripleCollection.SubjectNodes">
            <summary>
            Gets the enumeration of distinct subjects of Triples
            </summary>
        </member>
        <member name="T:VDS.RDF.UnionGraph">
            <summary>
            A Graph which represents the Union of several Graphs
            </summary>
            <remarks>
            <para>
            The Union is entirely virtual, the Graphs and their Triples are not actually physically merged together
            </para>
            <para>
            All Assert and Retract operations are directed only to the Default Graph while a Clear() operation will clear all Graphs in the Union
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.UnionGraph.#ctor(VDS.RDF.IGraph,System.Collections.Generic.IEnumerable{VDS.RDF.IGraph})">
            <summary>
            Creates a new Union Graph which is the Union of all the given Graphs with a specific Default Graph
            </summary>
            <param name="defaultGraph">Default Graph of the Union</param>
            <param name="graphs">Other Graphs in the Union</param>
        </member>
        <member name="M:VDS.RDF.UnionGraph.Assert(System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Asserts some Triples in the Graph
            </summary>
            <param name="ts">Triples</param>
            <remarks>
            Assert and Retract operations are directed to the Default Graph of the Union.  We have to override the method to do this as although the <see cref="T:VDS.RDF.UnionTripleCollection">UnionTripleCollection</see> will direct asserts/retracts to Triple Collection of the default Graph we cannot guarantee that the Graph will be able to carry out any assertion/retraction logic (e.g. persistence) it might have implemented if the Assert/Retract bypasses the Assert/Retract method of the Default Graph
            </remarks>
        </member>
        <member name="M:VDS.RDF.UnionGraph.Assert(VDS.RDF.Triple)">
            <summary>
            Asserts s Triple in the Graph
            </summary>
            <param name="t">Triple</param>
            <remarks>
            Assert and Retract operations are directed to the Default Graph of the Union.  We have to override the method to do this as although the <see cref="T:VDS.RDF.UnionTripleCollection">UnionTripleCollection</see> will direct asserts/retracts to Triple Collection of the default Graph we cannot guarantee that the Graph will be able to carry out any assertion/retraction logic (e.g. persistence) it might have implemented if the Assert/Retract bypasses the Assert/Retract method of the Default Graph
            </remarks>
        </member>
        <member name="M:VDS.RDF.UnionGraph.Retract(System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Retracts some Triples from the Graph
            </summary>
            <param name="ts">Triples</param>
            <remarks>
            Assert and Retract operations are directed to the Default Graph of the Union.  We have to override the method to do this as although the <see cref="T:VDS.RDF.UnionTripleCollection">UnionTripleCollection</see> will direct asserts/retracts to Triple Collection of the default Graph we cannot guarantee that the Graph will be able to carry out any assertion/retraction logic (e.g. persistence) it might have implemented if the Assert/Retract bypasses the Assert/Retract method of the Default Graph
            </remarks>
        </member>
        <member name="M:VDS.RDF.UnionGraph.Retract(VDS.RDF.Triple)">
            <summary>
            Retracts a Triple from the Graph
            </summary>
            <param name="t">Triple</param>
            <remarks>
            Assert and Retract operations are directed to the Default Graph of the Union.  We have to override the method to do this as although the <see cref="T:VDS.RDF.UnionTripleCollection">UnionTripleCollection</see> will direct asserts/retracts to Triple Collection of the default Graph we cannot guarantee that the Graph will be able to carry out any assertion/retraction logic (e.g. persistence) it might have implemented if the Assert/Retract bypasses the Assert/Retract method of the Default Graph
            </remarks>
        </member>
        <member name="M:VDS.RDF.UnionGraph.Clear">
            <summary>
            Clears all the Graphs in the Union
            </summary>
        </member>
        <member name="P:VDS.RDF.UnionGraph.Nodes">
            <summary>
            Gets the Nodes of the Graph
            </summary>
        </member>
        <member name="T:VDS.RDF.UriFactory">
            <summary>
            A static helper class for interning URIs to reduce memory usage
            </summary>
        </member>
        <member name="M:VDS.RDF.UriFactory.Create(System.String)">
            <summary>
            Creates a URI interning it if interning is enabled via the <see cref="P:VDS.RDF.Options.InternUris">Options.InternUris</see>
            </summary>
            <param name="uri">String URI</param>
            <returns></returns>
            <remarks>
            When URI interning is disabled this is equivalent to just invoking the constructor of the <see cref="T:System.Uri">Uri</see> class
            </remarks>
        </member>
        <member name="M:VDS.RDF.UriFactory.Clear">
            <summary>
            Clears all interned URIs
            </summary>
        </member>
        <member name="T:VDS.RDF.BaseVariableNode">
            <summary>
            Abstract Base Class for Variable Nodes
            </summary>
        </member>
        <member name="M:VDS.RDF.BaseVariableNode.#ctor(VDS.RDF.IGraph,System.String)">
            <summary>
            Creates a new Variable Node
            </summary>
            <param name="g">Graph</param>
            <param name="varname">Variable Name</param>
        </member>
        <member name="M:VDS.RDF.BaseVariableNode.#ctor">
            <summary>
            Deserialization Only Constructor
            </summary>
        </member>
        <member name="M:VDS.RDF.BaseVariableNode.Equals(VDS.RDF.INode)">
            <summary>
            Gets whether this Node is equal to some other Node
            </summary>
            <param name="other">Node to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseVariableNode.Equals(VDS.RDF.IBlankNode)">
            <summary>
            Determines whether this Node is equal to a Blank Node (should always be false)
            </summary>
            <param name="other">Blank Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseVariableNode.Equals(VDS.RDF.IGraphLiteralNode)">
            <summary>
            Determines whether this Node is equal to a Graph Literal Node (should always be false)
            </summary>
            <param name="other">Graph Literal Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseVariableNode.Equals(VDS.RDF.ILiteralNode)">
            <summary>
            Determines whether this Node is equal to a Literal Node (should always be false)
            </summary>
            <param name="other">Literal Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseVariableNode.Equals(VDS.RDF.IUriNode)">
            <summary>
            Determines whether this Node is equal to a URI Node (should always be false)
            </summary>
            <param name="other">URI Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseVariableNode.Equals(VDS.RDF.IVariableNode)">
            <summary>
            Determines whether this Node is equal to a Variable Node
            </summary>
            <param name="other">Variable Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseVariableNode.Equals(VDS.RDF.BaseVariableNode)">
            <summary>
            Determines whether this Node is equal to a Variable Node
            </summary>
            <param name="other">Variable Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseVariableNode.Equals(System.Object)">
            <summary>
            Gets whether this Node is equal to some Object
            </summary>
            <param name="obj">Object to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseVariableNode.ToString">
            <summary>
            Gets the String representation of this Node
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseVariableNode.CompareTo(VDS.RDF.INode)">
            <summary>
            Compares this Node to another Node
            </summary>
            <param name="other">Node to compare with</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseVariableNode.CompareTo(VDS.RDF.IBlankNode)">
            <summary>
            Returns an Integer indicating the Ordering of this Node compared to another Node
            </summary>
            <param name="other">Node to test against</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseVariableNode.CompareTo(VDS.RDF.IGraphLiteralNode)">
            <summary>
            Returns an Integer indicating the Ordering of this Node compared to another Node
            </summary>
            <param name="other">Node to test against</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseVariableNode.CompareTo(VDS.RDF.ILiteralNode)">
            <summary>
            Returns an Integer indicating the Ordering of this Node compared to another Node
            </summary>
            <param name="other">Node to test against</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseVariableNode.CompareTo(VDS.RDF.IUriNode)">
            <summary>
            Returns an Integer indicating the Ordering of this Node compared to another Node
            </summary>
            <param name="other">Node to test against</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseVariableNode.CompareTo(VDS.RDF.IVariableNode)">
            <summary>
            Returns an Integer indicating the Ordering of this Node compared to another Node
            </summary>
            <param name="other">Node to test against</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseVariableNode.CompareTo(VDS.RDF.BaseVariableNode)">
            <summary>
            Returns an Integer indicating the Ordering of this Node compared to another Node
            </summary>
            <param name="other">Node to test against</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseVariableNode.AsString">
            <summary>
            Throws an error as variables cannot be converted to types
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseVariableNode.AsInteger">
            <summary>
            Throws an error as variables cannot be converted to types
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseVariableNode.AsDecimal">
            <summary>
            Throws an error as variables cannot be converted to types
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseVariableNode.AsFloat">
            <summary>
            Throws an error as variables cannot be converted to types
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseVariableNode.AsDouble">
            <summary>
            Throws an error as variables cannot be converted to types
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseVariableNode.AsBoolean">
            <summary>
            Throws an error as variables cannot be converted to types
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseVariableNode.AsDateTime">
            <summary>
            Throws an error as variables cannot be converted to types
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseVariableNode.AsDateTimeOffset">
            <summary>
            Throws an error as variables cannot be converted to types
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.BaseVariableNode.AsTimeSpan">
            <summary>
            Throws an error as variables cannot be cast to a time span
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.BaseVariableNode.VariableName">
            <summary>
            Gets the Variable Name
            </summary>
        </member>
        <member name="P:VDS.RDF.BaseVariableNode.EffectiveType">
            <summary>
            Gets the URI of the datatype this valued node represents as a String
            </summary>
        </member>
        <member name="P:VDS.RDF.BaseVariableNode.NumericType">
            <summary>
            Gets the numeric type of the expression
            </summary>
        </member>
        <member name="T:VDS.RDF.VariableNode">
            <summary>
            Class representing Variable Nodes (only used for N3)
            </summary>
        </member>
        <member name="M:VDS.RDF.VariableNode.#ctor(VDS.RDF.IGraph,System.String)">
            <summary>
            Creates a new Variable Node
            </summary>
            <param name="g">Graph</param>
            <param name="varname">Variable Name</param>
        </member>
        <member name="M:VDS.RDF.VariableNode.#ctor">
            <summary>
            Deserialization Only Constructor
            </summary>
        </member>
        <member name="M:VDS.RDF.VariableNode.CompareTo(VDS.RDF.VariableNode)">
            <summary>
            Compares this Node to another Variable Node
            </summary>
            <param name="other">Variable Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.VariableNode.Equals(VDS.RDF.VariableNode)">
            <summary>
            Determines whether this Node is equal to a Variable Node
            </summary>
            <param name="other">Variable Node</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.VariableContextType">
            <summary>
            Possible Variable Context Types
            </summary>
        </member>
        <member name="F:VDS.RDF.VariableContextType.None">
            <summary>
            There is currently no variable context
            </summary>
        </member>
        <member name="F:VDS.RDF.VariableContextType.Existential">
            <summary>
            Existential Variable Context
            </summary>
        </member>
        <member name="F:VDS.RDF.VariableContextType.Universal">
            <summary>
            Universal Variable Context
            </summary>
        </member>
        <member name="T:VDS.RDF.VariableContext">
            <summary>
            Represents the Variable Context for Triples
            </summary>
        </member>
        <member name="M:VDS.RDF.VariableContext.#ctor(VDS.RDF.VariableContextType)">
            <summary>
            Creates a new Variable Context
            </summary>
            <param name="type">Context Type</param>
        </member>
        <member name="M:VDS.RDF.VariableContext.AddVariable(VDS.RDF.INode)">
            <summary>
            Adds a Variable to this Context
            </summary>
            <param name="var">Variable</param>
        </member>
        <member name="M:VDS.RDF.VariableContext.IsVariable(VDS.RDF.INode)">
            <summary>
            Gets whether a given Variable exists in this Context
            </summary>
            <param name="var">Variable Node</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.VariableContext.Type">
            <summary>
            Gets the Context Type
            </summary>
        </member>
        <member name="P:VDS.RDF.VariableContext.Variables">
            <summary>
            Gets the Variables in this Context
            </summary>
        </member>
        <member name="P:VDS.RDF.VariableContext.InnerContext">
            <summary>
            Gets/Sets the Inner Context
            </summary>
            <remarks>
            When you set the Inner Context this sets the Inner Context of the most nested inner context, you can remove all nested contexts by setting this to null
            </remarks>
        </member>
        <member name="T:VDS.RDF.RdfReaderWarning">
            <summary>
            Delegate Type for Warning Messages raised by RDF Readers
            </summary>
            <param name="warning">Warning Message</param>
        </member>
        <member name="T:VDS.RDF.RdfWriterWarning">
            <summary>
            Delegate Type for Warning Messages raised by RDF Writers
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="T:VDS.RDF.StoreWriterWarning">
            <summary>
            Delegate Type for Warning Events raised by RDF Dataset Writers
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="T:VDS.RDF.StoreReaderWarning">
            <summary>
            Delegate Type for Warning Events raised by RDF Dataset Readers
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="T:VDS.RDF.SparqlWarning">
            <summary>
            Delegate Type for Warning Events raised by SPARQL Readers and Writers for Queries, Updates and Results
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="T:VDS.RDF.TripleEventHandler">
            <summary>
            Delegate Type for Triple events raised by Graphs
            </summary>
            <param name="sender">Originator of the Event</param>
            <param name="args">Triple Event Arguments</param>
        </member>
        <member name="T:VDS.RDF.GraphEventHandler">
            <summary>
            Delegate Type for Graph events raised by Graphs
            </summary>
            <param name="sender">Originator of the Event</param>
            <param name="args">Graph Event Arguments</param>
        </member>
        <member name="T:VDS.RDF.CancellableGraphEventHandler">
            <summary>
            Delegate Type for Graph events raised by Graphs where event handlers may set a Cancel flag to cancel the subsequent operation
            </summary>
            <param name="sender">Originator of the Event</param>
            <param name="args">Graph Event Arguments</param>
        </member>
        <member name="T:VDS.RDF.TripleStoreEventHandler">
            <summary>
            Delegate Type for Triple Store events raised by Triple Stores
            </summary>
            <param name="sender">Originator of the event</param>
            <param name="args">Triple Store Event Arguments</param>
        </member>
        <member name="T:VDS.RDF.TripleEventArgs">
            <summary>
            Event Arguments for Events regarding the assertion and retraction of Triples
            </summary>
        </member>
        <member name="M:VDS.RDF.TripleEventArgs.#ctor(VDS.RDF.Triple,VDS.RDF.IGraph)">
            <summary>
            Creates a new set of Triple Event Arguments for the given Triple
            </summary>
            <param name="t">Triple</param>
            <param name="g">Graph the Triple Event occurred in</param>
        </member>
        <member name="M:VDS.RDF.TripleEventArgs.#ctor(VDS.RDF.Triple,VDS.RDF.IGraph,System.Boolean)">
            <summary>
            Creates a new set of Triple Event Arguments for the given Triple
            </summary>
            <param name="t">Triple</param>
            <param name="g">Graph the Triple Event occurred in</param>
            <param name="asserted">Was the Triple Asserted (if not then it was Retracted)</param>
        </member>
        <member name="P:VDS.RDF.TripleEventArgs.Triple">
            <summary>
            Gets the Triple
            </summary>
        </member>
        <member name="P:VDS.RDF.TripleEventArgs.Graph">
            <summary>
            Gets the Graph the Triple belongs to (may be null)
            </summary>
        </member>
        <member name="P:VDS.RDF.TripleEventArgs.GraphUri">
            <summary>
            Gets the URI of the Graph the Triple belongs to (may be null)
            </summary>
        </member>
        <member name="P:VDS.RDF.TripleEventArgs.WasAsserted">
            <summary>
            Gets whether the Triple was asserted
            </summary>
        </member>
        <member name="P:VDS.RDF.TripleEventArgs.WasRetracted">
            <summary>
            Gets whether the Triple was retracted
            </summary>
        </member>
        <member name="T:VDS.RDF.GraphEventArgs">
            <summary>
            Event Arguments for Events regarding Graphs
            </summary>
        </member>
        <member name="M:VDS.RDF.GraphEventArgs.#ctor(VDS.RDF.IGraph)">
            <summary>
            Creates a new set of Graph Event Arguments
            </summary>
            <param name="g">Graph</param>
        </member>
        <member name="M:VDS.RDF.GraphEventArgs.#ctor(VDS.RDF.IGraph,VDS.RDF.TripleEventArgs)">
            <summary>
            Creates a new set of Graph Event Arguments
            </summary>
            <param name="g">Graph</param>
            <param name="args">Triple Event Arguments</param>
        </member>
        <member name="P:VDS.RDF.GraphEventArgs.Graph">
            <summary>
            Gets the Graph
            </summary>
        </member>
        <member name="P:VDS.RDF.GraphEventArgs.TripleEvent">
            <summary>
            Gets the Triple Event Arguments (if any)
            </summary>
        </member>
        <member name="T:VDS.RDF.CancellableGraphEventArgs">
            <summary>
            Event Arguments for Events regarding Graphs which may be cancelled
            </summary>
        </member>
        <member name="M:VDS.RDF.CancellableGraphEventArgs.#ctor(VDS.RDF.IGraph)">
            <summary>
            Creates a new set of Cancellable Graph Event Arguments
            </summary>
            <param name="g">Graph</param>
        </member>
        <member name="M:VDS.RDF.CancellableGraphEventArgs.#ctor(VDS.RDF.IGraph,VDS.RDF.TripleEventArgs)">
            <summary>
            Creates a new set of Cancellable Graph Event Arguments
            </summary>
            <param name="g">Graph</param>
            <param name="args">Triple Event Arguments</param>
        </member>
        <member name="P:VDS.RDF.CancellableGraphEventArgs.Cancel">
            <summary>
            Gets/Sets whether the Event should be cancelled
            </summary>
        </member>
        <member name="T:VDS.RDF.TripleStoreEventArgs">
            <summary>
            Event Arguments for Events regarding Graphs
            </summary>
        </member>
        <member name="M:VDS.RDF.TripleStoreEventArgs.#ctor(VDS.RDF.ITripleStore)">
            <summary>
            Creates a new set of Triple Store Event Arguments
            </summary>
            <param name="store">Triple Store</param>
        </member>
        <member name="M:VDS.RDF.TripleStoreEventArgs.#ctor(VDS.RDF.ITripleStore,VDS.RDF.GraphEventArgs)">
            <summary>
            Creates a new set of Triple Store Event Arguments
            </summary>
            <param name="store">Triple Store</param>
            <param name="args">Graph Event Arguments</param>
        </member>
        <member name="M:VDS.RDF.TripleStoreEventArgs.#ctor(VDS.RDF.ITripleStore,VDS.RDF.IGraph)">
            <summary>
            Creates a new set of Triple Store Event Arguments
            </summary>
            <param name="store">Triple Store</param>
            <param name="g">Graph</param>
        </member>
        <member name="P:VDS.RDF.TripleStoreEventArgs.TripleStore">
            <summary>
            Gets the Triple Store
            </summary>
        </member>
        <member name="P:VDS.RDF.TripleStoreEventArgs.GraphEvent">
            <summary>
            Gets the Graph Event Arguments (if any)
            </summary>
        </member>
        <member name="T:VDS.RDF.TripleIndexType">
            <summary>
            Possible Triple Index types
            </summary>
            <remarks>
            <para>
            Index types are given Integer values with the lowest being the least useful index and the highest being most useful index.  Non-Index based Patterns are given arbitrary high values since these will typically never be used as these items are usually inserted into a Graph Pattern after the ordering step
            </para>
            <para>
            When used to sort Patterns as part of query optimisation the patterns are partially ordered on the usefullness of their index since more useful indexes are considered more likely to return fewer results which will help restrict the query space earlier in the execution process.
            </para>
            </remarks>
        </member>
        <member name="F:VDS.RDF.TripleIndexType.NoVariables">
            <summary>
            No Index should be used as the Pattern does not use Variables
            </summary>
        </member>
        <member name="F:VDS.RDF.TripleIndexType.None">
            <summary>
            No Index should be used as the Pattern is three Variables
            </summary>
        </member>
        <member name="F:VDS.RDF.TripleIndexType.Subject">
            <summary>
            Subject Index should be used
            </summary>
        </member>
        <member name="F:VDS.RDF.TripleIndexType.Predicate">
            <summary>
            Predicate Index should be used
            </summary>
        </member>
        <member name="F:VDS.RDF.TripleIndexType.Object">
            <summary>
            Object Index should be used
            </summary>
        </member>
        <member name="F:VDS.RDF.TripleIndexType.SubjectPredicate">
            <summary>
            Subject-Predicate Index should be used
            </summary>
        </member>
        <member name="F:VDS.RDF.TripleIndexType.PredicateObject">
            <summary>
            Predicate-Object Index should be used
            </summary>
        </member>
        <member name="F:VDS.RDF.TripleIndexType.SubjectObject">
            <summary>
            Subject-Object Index should be used
            </summary>
        </member>
        <member name="T:VDS.RDF.TripleIndexSorter">
            <summary>
            A Comparer which sorts based on Triple Index Type
            </summary>
        </member>
        <member name="M:VDS.RDF.TripleIndexSorter.Compare(VDS.RDF.TripleIndexType,VDS.RDF.TripleIndexType)">
            <summary>
            Compares two Triple Index types to see which is greater
            </summary>
            <param name="x">First Index type</param>
            <param name="y">Second Index type</param>
            <returns></returns>
            <remarks>
            Implemented by converting to Integers and then using the Integer comparison function
            </remarks>
        </member>
        <member name="T:VDS.RDF.IndexHelper">
            <summary>
            Helper Class for indexing related operations
            </summary>
        </member>
        <member name="M:VDS.RDF.IndexHelper.SearchIndex``1(System.Collections.Generic.List{``0},System.Collections.Generic.IComparer{``0},``0)">
            <summary>
            Searches an Index using the given Comparer
            </summary>
            <typeparam name="T">Indexed Object Type</typeparam>
            <param name="index">Index</param>
            <param name="comparer">Comparer to use for binary search</param>
            <param name="search">Item to search for</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Ontology.Individual">
            <summary>
            Represents an Individual i.e. an instance of some class in an ontology
            </summary>
            <remarks>
            <para>
            See <a href="http://www.dotnetrdf.org/content.asp?pageID=Ontology%20API">Using the Ontology API</a> for some informal documentation on the use of the Ontology namespace
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Ontology.OntologyResource">
            <summary>
            Base class for representing a resource in an Ontology
            </summary>
            <remarks>
            <para>
            See <a href="http://www.dotnetrdf.org/content.asp?pageID=Ontology%20API">Using the Ontology API</a> for some informal documentation on the use of the Ontology namespace
            </para>
            </remarks>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyResource._literalProperties">
            <summary>
            Storage of Literal Properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyResource._resourceProperties">
            <summary>
            Storage of Resource Properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyResource._resource">
            <summary>
            The Node which this Resource is a wrapper around
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyResource._graph">
            <summary>
            The Graph from which this Resource originates
            </summary>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.#ctor(VDS.RDF.INode,VDS.RDF.IGraph)">
            <summary>
            Creates a new Ontology Resource for the given Resource in the given Graph
            </summary>
            <param name="resource">Resource</param>
            <param name="graph">Graph</param>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.#ctor(System.Uri,VDS.RDF.IGraph)">
            <summary>
            Creates a new Ontology Resource for the given Resource in the given Graph
            </summary>
            <param name="resource">Resource</param>
            <param name="graph">Graph</param>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.IntialiseProperty(System.String,System.Boolean)">
            <summary>
            Retrieves all the Triples which have the Resource as the subject and the given property URI as the predicate from the Graph and stores the values locally
            </summary>
            <param name="propertyUri">Property URI</param>
            <param name="requireLiteral">Whether only Literal values are acceptable</param>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.AddLiteralProperty(System.String,VDS.RDF.ILiteralNode,System.Boolean)">
            <summary>
            Adds a new literal value for a property
            </summary>
            <param name="propertyUri">Property URI</param>
            <param name="value">Literal Value</param>
            <param name="persist">Whether the new value should be added to the Graph</param>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.AddLiteralProperty(System.Uri,VDS.RDF.ILiteralNode,System.Boolean)">
            <summary>
            Adds a new literal value for a property
            </summary>
            <param name="propertyUri">Property URI</param>
            <param name="value">Literal Value</param>
            <param name="persist">Whether the new value should be added to the Graph</param>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.AddResourceProperty(System.String,VDS.RDF.INode,System.Boolean)">
            <summary>
            Adds a new value for a property
            </summary>
            <param name="propertyUri">Property URI</param>
            <param name="value">Literal Value</param>
            <param name="persist">Whether the new value should be added to the Graph</param>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.AddResourceProperty(System.Uri,VDS.RDF.INode,System.Boolean)">
            <summary>
            Adds a new value for a property
            </summary>
            <param name="propertyUri">Property URI</param>
            <param name="value">Literal Value</param>
            <param name="persist">Whether the new value should be added to the Graph</param>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.ClearLiteralProperty(System.String,System.Boolean)">
            <summary>
            Clears all values for a Literal Property
            </summary>
            <param name="propertyUri">Property URI</param>
            <param name="persist">Whether the removed values are removed from the Graph</param>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.ClearLiteralProperty(System.Uri,System.Boolean)">
            <summary>
            Clears all values for a Literal Property
            </summary>
            <param name="propertyUri">Property URI</param>
            <param name="persist">Whether the removed values are removed from the Graph</param>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.ClearResourceProperty(System.String,System.Boolean)">
            <summary>
            Clears all values for a Resource Property
            </summary>
            <param name="propertyUri">Property URI</param>
            <param name="persist">Whether the removed values are removed from the Graph</param>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.ClearResourceProperty(System.Uri,System.Boolean)">
            <summary>
            Clears all values for a Resource Property
            </summary>
            <param name="propertyUri">Property URI</param>
            <param name="persist">Whether the removed values are removed from the Graph</param>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveLiteralProperty(System.String,VDS.RDF.ILiteralNode,System.Boolean)">
            <summary>
            Removes a literal value for a property
            </summary>
            <param name="propertyUri">Property URI</param>
            <param name="value">Value to remove</param>
            <param name="persist">Whether the removed value is removed from the Graph</param>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveLiteralProperty(System.Uri,VDS.RDF.ILiteralNode,System.Boolean)">
            <summary>
            Removes a literal value for a property
            </summary>
            <param name="propertyUri">Property URI</param>
            <param name="value">Value to remove</param>
            <param name="persist">Whether the removed value is removed from the Graph</param>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveResourceProperty(System.String,VDS.RDF.INode,System.Boolean)">
            <summary>
            Removes a value for a property
            </summary>
            <param name="propertyUri">Property URI</param>
            <param name="value">Value to remove</param>
            <param name="persist">Whether the removed value is removed from the Graph</param>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveResourceProperty(System.Uri,VDS.RDF.INode,System.Boolean)">
            <summary>
            Removes a value for a property
            </summary>
            <param name="propertyUri">Property URI</param>
            <param name="value">Value to remove</param>
            <param name="persist">Whether the removed value is removed from the Graph</param>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.AddComment(System.String)">
            <summary>
            Adds a comment for this resource
            </summary>
            <param name="comment">Comment</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.AddComment(System.String,System.String)">
            <summary>
            Adds a comment in a specific language for this resource
            </summary>
            <param name="comment">Comment</param>
            <param name="lang">Language</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.ClearComments">
            <summary>
            Removes all comments for this resource
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveComment(VDS.RDF.ILiteralNode)">
            <summary>
            Removes a comment for this resource
            </summary>
            <param name="comment">Comment</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveComment(System.String)">
            <summary>
            Removes a comment for this resource
            </summary>
            <param name="comment">Comment</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveComment(System.String,System.String)">
            <summary>
            Removes a comment in a specific language for this resource
            </summary>
            <param name="comment">Comment</param>
            <param name="lang">Language</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.AddDifferentFrom(VDS.RDF.INode)">
            <summary>
            Adds a new <em>owl:differentFrom</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.AddDifferentFrom(System.Uri)">
            <summary>
            Adds a new <em>owl:differentFrom</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.AddDifferentFrom(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Adds a new <em>owl:differentFrom</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
            <remarks>
            This overload also adds this resource as different from the given resource
            </remarks>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.ClearDifferentFrom">
            <summary>
            Clears all <em>owl:differentFrom</em> triples for the resource
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveDifferentFrom(VDS.RDF.INode)">
            <summary>
            Removes a <em>owl:differentFrom</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveDifferentFrom(System.Uri)">
            <summary>
            Removes a <em>owl:differentFrom</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveDifferentFrom(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Removes a <em>owl:differentFrom</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
            <remarks>
            This overload also removes this resource as different from the given resource
            </remarks>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.AddIsDefinedBy(VDS.RDF.INode)">
            <summary>
            Adds a new <em>rdfs:isDefinedBy</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.AddIsDefinedBy(System.Uri)">
            <summary>
            Adds a new <em>rdfs:isDefinedBy</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.AddIsDefinedBy(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Adds a new <em>rdfs:isDefinedBy</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.ClearIsDefinedBy">
            <summary>
            Removes all <em>rdfs:isDefinedBy</em> triples for the resource
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveIsDefinedBy(VDS.RDF.INode)">
            <summary>
            Removes a <em>rdfs:isDefinedBy</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveIsDefinedBy(System.Uri)">
            <summary>
            Removes a <em>rdfs:isDefinedBy</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveIsDefinedBy(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Removes a <em>rdfs:isDefinedBy</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.AddLabel(System.String)">
            <summary>
            Adds a label for the resource
            </summary>
            <param name="label">Label</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.AddLabel(System.String,System.String)">
            <summary>
            Adds a label in a specific language for a resource
            </summary>
            <param name="label">Label</param>
            <param name="lang">Language</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.ClearLabels">
            <summary>
            Clears all labels for a resource
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveLabel(VDS.RDF.ILiteralNode)">
            <summary>
            Removes a specific label for a resource
            </summary>
            <param name="label">Label</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveLabel(System.String)">
            <summary>
            Removes a label for a resource
            </summary>
            <param name="label">Label</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveLabel(System.String,System.String)">
            <summary>
            Removes a label in a specific language for a resource
            </summary>
            <param name="label">Label</param>
            <param name="lang">Language</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.AddSameAs(VDS.RDF.INode)">
            <summary>
            Adds a new <em>owl:sameAs</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.AddSameAs(System.Uri)">
            <summary>
            Adds a new <em>owl:sameAs</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.AddSameAs(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Adds a new <em>owl:sameAs</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
            <remarks>
            This overload also adds this resource as an <em>owl:sameAs</em> triple for the given resource
            </remarks>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.ClearSameAs">
            <summary>
            Removes all <em>owl:sameAs</em> triples for the resource
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveSameAs(VDS.RDF.INode)">
            <summary>
            Removes a <em>owl:sameAs</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveSameAs(System.Uri)">
            <summary>
            Removes a <em>owl:sameAs</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveSameAs(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Removes a <em>owl:sameAs</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
            <remarks>
            This overload also removes the <em>owl:sameAs</em> triple for the given resource
            </remarks>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.AddSeeAlso(VDS.RDF.INode)">
            <summary>
            Adds a new <em>rdfs:seeAlso</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.AddSeeAlso(System.Uri)">
            <summary>
            Adds a new <em>rdfs:seeAlso</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.AddSeeAlso(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Adds a new <em>rdfs:seeAlso</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.ClearSeeAlso">
            <summary>
            Removes all <em>rdfs:seeAlso</em> triples for the resource
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveSeeAlso(VDS.RDF.INode)">
            <summary>
            Removes a <em>rdfs:seeAlso</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveSeeAlso(System.Uri)">
            <summary>
            Removes a <em>rdfs:seeAlso</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveSeeAlso(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Removes a <em>rdfs:seeAlso</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.AddType(VDS.RDF.INode)">
            <summary>
            Adds a new <em>rdf:type</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.AddType(System.Uri)">
            <summary>
            Adds a new <em>rdf:type</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.AddType(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Adds a new <em>rdf:type</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.ClearTypes">
            <summary>
            Removes all <em>rdf:type</em> triples for the resource
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveType(VDS.RDF.INode)">
            <summary>
            Removes a <em>rdf:type</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveType(System.Uri)">
            <summary>
            Removes a <em>rdf:type</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveType(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Removes a <em>rdf:type</em> triple for the resource
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.AddVersionInfo(System.String)">
            <summary>
            Adds version information for the resource
            </summary>
            <param name="info">Version Information</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.ClearVersionInfo">
            <summary>
            Clears version information for the resource
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveVersionInfo(VDS.RDF.ILiteralNode)">
            <summary>
            Remove version information for the resource
            </summary>
            <param name="info">Version Information</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.RemoveVersionInfo(System.String)">
            <summary>
            Remove version information for the resource
            </summary>
            <param name="info">Version Information</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.GetLiteralProperty(System.String)">
            <summary>
            Gets the values for a property which is restricted to literals
            </summary>
            <param name="propertyUri">Property URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.GetLiteralProperty(System.Uri)">
            <summary>
            Gets the values for a property which is restricted to literals
            </summary>
            <param name="propertyUri">Property URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.GetResourceProperty(System.String)">
            <summary>
            Gets the values for a property which can be any node type
            </summary>
            <param name="propertyUri">Property URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.GetResourceProperty(System.Uri)">
            <summary>
            Gets the values for a property which can be any node type
            </summary>
            <param name="propertyUri">Property URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.ToString">
            <summary>
            Gets the String representation of the Resource
            </summary>
            <returns></returns>
            <remarks>
            This is either the first label (if any are declared) or the string representation of the <see cref="T:VDS.RDF.INode">INode</see> that this resource wraps
            </remarks>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.AsClass">
            <summary>
            Casts a Resource into an Ontology Class
            </summary>
            <returns></returns>
            <remarks>
            Anything may be cast to a <see cref="T:VDS.RDF.Ontology.OntologyClass"/> regardless of whether it actually represents a class in the ontology
            </remarks>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.AsProperty">
            <summary>
            Casts a Resource into an Ontology Property
            </summary>
            <returns></returns>
            <remarks>
            Anything may be cast to a <see cref="T:VDS.RDF.Ontology.OntologyProperty"/> regardless of whether it actually represents a property in the ontology
            </remarks>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyResource.op_Explicit(VDS.RDF.Ontology.OntologyResource)~VDS.RDF.Graph">
            <summary>
            Casts a Resource into a Graph
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
            <remarks>
            Equivalent to doing a SPARQL DESCRIBE query on this resource
            </remarks>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyResource.Resource">
            <summary>
            Gets the Resource that this Ontology Resource refers to
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyResource.Graph">
            <summary>
            Gets the Graph that this Ontology Resource is from
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyResource.VersionInfo">
            <summary>
            Gets the Version Information for the Resource
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyResource.Comment">
            <summary>
            Gets the Comment(s) for the Resource
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyResource.Label">
            <summary>
            Gets the Label(s) for the Resource
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyResource.SeeAlso">
            <summary>
            Gets the See Also(s) for the Resource
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyResource.SameAs">
            <summary>
            Gets the Same As('s) for the Resource
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyResource.IsDefinedBy">
            <summary>
            Gets the Is Defined By(s) for the Resource
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyResource.DifferentFrom">
            <summary>
            Gets the Different From(s) for the Resource
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyResource.Types">
            <summary>
            Gets the rdf:type's for the Resource
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyResource.TriplesWithSubject">
            <summary>
            Gets all the Triples from the Graph where the Resource occurs as the Subject
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyResource.TriplesWithObject">
            <summary>
            Gets all the Triples from the Graph where the Resource occurs as the Object
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyResource.TriplesWithPredicate">
            <summary>
            Gets all the Triples from the Graph where the Resource occurs as the Predicate
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyResource.Triples">
            <summary>
            Gets all the Triples where the Resource occurs in any position
            </summary>
        </member>
        <member name="M:VDS.RDF.Ontology.Individual.#ctor(VDS.RDF.INode,VDS.RDF.IGraph)">
            <summary>
            Gets an Individual from the Graph
            </summary>
            <param name="resource">Resource that represents the Individual</param>
            <param name="graph">Graph the Individual is in</param>
            <remarks>
            Requires that an individual (a resource which is the subject of at least one triple where the predicate is <strong>rdf:type</strong>) is already present in the Graph
            </remarks>
        </member>
        <member name="M:VDS.RDF.Ontology.Individual.#ctor(VDS.RDF.INode,VDS.RDF.INode,VDS.RDF.IGraph)">
            <summary>
            Gets/Creates an Individual from the Graph
            </summary>
            <param name="resource">Resource that represents the Individual</param>
            <param name="resourceClass">Class to create/add the Individual to</param>
            <param name="graph">Graph the Individual is in</param>
            <remarks>
            Allows for creating new Individuals in the Graph or adding existing resources to another Class.  If the resource for the Individual or the given Class are new then they will be added to the Graph
            </remarks>
        </member>
        <member name="M:VDS.RDF.Ontology.Individual.IntialiseClasses">
            <summary>
            Helper method which finds all the Types given for this Resource
            </summary>
        </member>
        <member name="M:VDS.RDF.Ontology.Individual.HasClass(VDS.RDF.Ontology.OntologyClass)">
            <summary>
            Gets whether the Individual belongs to a specific class
            </summary>
            <param name="class">Class</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Individual.HasClass(VDS.RDF.INode)">
            <summary>
            Gets whether the Individual belongs to a class identified by the given resource
            </summary>
            <param name="class">Class</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Individual.HasClass(System.Uri)">
            <summary>
            Gets whether the Individual belongs to a class identified by the given URI
            </summary>
            <param name="class">Class URI</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Ontology.Individual.Classes">
            <summary>
            Gets all the Classes that this resource belongs to
            </summary>
        </member>
        <member name="T:VDS.RDF.Ontology.Ontology">
            <summary>
            Represents the meta-information about an Ontology
            </summary>
            <remarks>
            <para>
            See <a href="http://www.dotnetrdf.org/content.asp?pageID=Ontology%20API">Using the Ontology API</a> for some informal documentation on the use of the Ontology namespace
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.#ctor(VDS.RDF.INode,VDS.RDF.IGraph)">
            <summary>
            Creates a new Ontology for the given resource
            </summary>
            <param name="resource">Resource</param>
            <param name="graph">Graph</param>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.AddBackwardsCompatibleWith(VDS.RDF.INode)">
            <summary>
            Adds a new <em>owl:backwardsCompatibleWith</em> triple for this Ontology
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.AddBackwardsCompatibleWith(System.Uri)">
            <summary>
            Adds a new <em>owl:backwardsCompatibleWith</em> triple for this Ontology
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.AddBackwardsCompatibleWith(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Adds a new <em>owl:backwardsCompatibleWith</em> triple for this Ontology
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.ClearBackwardsCompatibleWith">
            <summary>
            Removes all <em>owl:backwardsCompatibleWith</em> triples for this Ontology
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.RemoveBackwardsCompatibleWith(VDS.RDF.INode)">
            <summary>
            Removes a <em>owl:backwardsCompatibleWith</em> triple for this Ontology
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.RemoveBackwardsCompatibleWith(System.Uri)">
            <summary>
            Removes a <em>owl:backwardsCompatibleWith</em> triple for this Ontology
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.RemoveBackwardsCompatibleWith(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Removes a <em>owl:backwardsCompatibleWith</em> triple for this Ontology
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.AddIncompatibleWith(VDS.RDF.INode)">
            <summary>
            Adds a new <em>owl:incompatibleWith</em> triple for this Ontology
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.AddIncompatibleWith(System.Uri)">
            <summary>
            Adds a new <em>owl:incompatibleWith</em> triple for this Ontology
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.AddIncompatibleWith(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Adds a new <em>owl:incompatibleWith</em> triple for this Ontology
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.ClearIncompatibleWith">
            <summary>
            Removes all <em>owl:incompatibleWith</em> triples for this Ontology
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.RemoveIncompatibleWith(VDS.RDF.INode)">
            <summary>
            Removes a <em>owl:incompatibleWith</em> triple for this Ontology
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.RemoveIncompatibleWith(System.Uri)">
            <summary>
            Removes a <em>owl:incompatibleWith</em> triple for this Ontology
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.RemoveIncompatibleWith(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Removes a <em>owl:incompatibleWith</em> triple for this Ontology
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.AddImports(VDS.RDF.INode)">
            <summary>
            Adds a new <em>owl:imports</em> triple for this Ontology
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.AddImports(System.Uri)">
            <summary>
            Adds a new <em>owl:imports</em> triple for this Ontology
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.AddImports(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Adds a new <em>owl:imports</em> triple for this Ontology
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.ClearImports">
            <summary>
            Removes all <em>owl:imports</em> triples for this Ontology
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.RemoveImports(VDS.RDF.INode)">
            <summary>
            Removes a <em>owl:imports</em> triple for this Ontology
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.RemoveImports(System.Uri)">
            <summary>
            Removes a <em>owl:imports</em> triple for this Ontology
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.RemoveImports(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Removes a <em>owl:imports</em> triple for this Ontology
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.AddPriorVersion(VDS.RDF.INode)">
            <summary>
            Adds a new <em>owl:priorVersion</em> triple for this Ontology
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.AddPriorVersion(System.Uri)">
            <summary>
            Adds a new <em>owl:priorVersion</em> triple for this Ontology
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.AddPriorVersion(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Adds a new <em>owl:priorVersion</em> triple for this Ontology
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.ClearPriorVersions">
            <summary>
            Removes all <em>owl:priorVersion</em> triples for this Ontology
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.RemovePriorVersion(VDS.RDF.INode)">
            <summary>
            Removes a <em>owl:priorVersion</em> triple for this Ontology
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.RemovePriorVersion(System.Uri)">
            <summary>
            Removes a <em>owl:priorVersion</em> triple for this Ontology
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.Ontology.RemovePriorVersion(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Removes a <em>owl:priorVersion</em> triple for this Ontology
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Ontology.Ontology.BackwardsCompatibleWith">
            <summary>
            Gets all the Ontologies that this Ontology is backwards compatible with
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.Ontology.IncompatibleWith">
            <summary>
            Gets all the Ontologies that this Ontology is incompatible with
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.Ontology.Imports">
            <summary>
            Gets all the Ontologies that this Ontology imports
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.Ontology.PriorVersions">
            <summary>
            Gets all the Ontologies that are prior versions of this Ontology
            </summary>
        </member>
        <member name="T:VDS.RDF.Ontology.OntologyClass">
            <summary>
            Class for representing a class in an Ontology
            </summary>
            <remarks>
            <para>
            See <a href="http://www.dotnetrdf.org/content.asp?pageID=Ontology%20API">Using the Ontology API</a> for some informal documentation on the use of the Ontology namespace
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.#ctor(VDS.RDF.INode,VDS.RDF.IGraph)">
            <summary>
            Creates a new representation of a Class in the given Ontology Mode
            </summary>
            <param name="resource">Resource</param>
            <param name="graph">Graph</param>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.AddSubClass(VDS.RDF.INode)">
            <summary>
            Adds a new sub-class for this class
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.AddSubClass(System.Uri)">
            <summary>
            Adds a new sub-class for this class
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.AddSubClass(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Adds a new sub-class for this class
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.AddSubClass(VDS.RDF.Ontology.OntologyClass)">
            <summary>
            Adds a new sub-class for this class
            </summary>
            <param name="class">Class</param>
            <returns></returns>
            <remarks>
            This overload also adds this class as a super-class of the given class
            </remarks>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.ClearSubClasses">
            <summary>
            Removes all sub-classes for this class
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.RemoveSubClass(VDS.RDF.INode)">
            <summary>
            Removes a sub-class for this class
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.RemoveSubClass(System.Uri)">
            <summary>
            Removes a sub-class for this class
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.RemoveSubClass(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Removes a sub-class for this class
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.RemoveSubClass(VDS.RDF.Ontology.OntologyClass)">
            <summary>
            Removes a sub-class for this class
            </summary>
            <param name="class">Class</param>
            <returns></returns>
            <remarks>
            This overload also removes this class from being a super-class of the given class
            </remarks>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.AddSuperClass(VDS.RDF.INode)">
            <summary>
            Adds a new super-class for this class
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.AddSuperClass(System.Uri)">
            <summary>
            Adds a new super-class for this class
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.AddSuperClass(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Adds a new super-class for this class
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.AddSuperClass(VDS.RDF.Ontology.OntologyClass)">
            <summary>
            Adds a new super-class for this class
            </summary>
            <param name="class">Class</param>
            <returns></returns>
            <remarks>
            This overload also adds this class as a sub-class of the given class
            </remarks>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.ClearSuperClasses">
            <summary>
            Removes all super-classes
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.RemoveSuperClass(VDS.RDF.INode)">
            <summary>
            Removes a super-class for this class
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.RemoveSuperClass(System.Uri)">
            <summary>
            Removes a super-class for this class
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.RemoveSuperClass(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Removes a super-class for this class
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.RemoveSuperClass(VDS.RDF.Ontology.OntologyClass)">
            <summary>
            Removes a super-class for this class
            </summary>
            <param name="class">Class</param>
            <returns></returns>
            <remarks>
            This overload also removes this class as a sub-class of the given class
            </remarks>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.AddEquivalentClass(VDS.RDF.INode)">
            <summary>
            Adds an equivalent class for this class
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.AddEquivalentClass(System.Uri)">
            <summary>
            Adds an equivalent class for this class
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.AddEquivalentClass(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Adds an equivalent class for this class
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.AddEquivalentClass(VDS.RDF.Ontology.OntologyClass)">
            <summary>
            Adds an equivalent class for this class
            </summary>
            <param name="class">Class</param>
            <returns></returns>
            <remarks>
            This overload also adds this class as an equivalent class of the given class
            </remarks>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.ClearEquivalentClasses">
            <summary>
            Removes all equivalent classes for this class
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.RemoveEquivalentClass(VDS.RDF.INode)">
            <summary>
            Removes an equivalent class for this class
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.RemoveEquivalentClass(System.Uri)">
            <summary>
            Removes an equivalent class for this class
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.RemoveEquivalentClass(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Removes an equivalent class for this class
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.RemoveEquivalentClass(VDS.RDF.Ontology.OntologyClass)">
            <summary>
            Removes an equivalent class for this class
            </summary>
            <param name="class">Class</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.AddDisjointClass(VDS.RDF.INode)">
            <summary>
            Adds a new disjoint class for this class
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.AddDisjointClass(System.Uri)">
            <summary>
            Adds a new disjoint class for this class
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.AddDisjointClass(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Adds a new disjoint class for this class
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.AddDisjointClass(VDS.RDF.Ontology.OntologyClass)">
            <summary>
            Adds a new disjoint class for this class
            </summary>
            <param name="class">Class</param>
            <returns></returns>
            <remarks>
            This overload also adds this class as a disjoint class of the given class
            </remarks>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.ClearDisjointClasses">
            <summary>
            Removes all disjoint classes for this class
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.RemoveDisjointClass(VDS.RDF.INode)">
            <summary>
            Removes a disjoint class for this class
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.RemoveDisjointClass(System.Uri)">
            <summary>
            Removes a disjoint class for this class
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.RemoveDisjointClass(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Removes a disjoint class for this class
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.RemoveDisjointClass(VDS.RDF.Ontology.OntologyClass)">
            <summary>
            Removes a disjoint class for this class
            </summary>
            <param name="class">Class</param>
            <returns></returns>
            <remarks>
            This overload also removes this class as a disjoint class of the given class
            </remarks>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.CreateIndividual(System.Uri)">
            <summary>
            Gets/Creates an Individual of this class
            </summary>
            <param name="resource">Resource identifying the individual</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyClass.Equals(System.Object)">
            <summary>
            Gets whether this Class is equal to another Class
            </summary>
            <param name="obj">Object to test</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyClass.SubClasses">
            <summary>
            Gets the sub-classes of this class (both direct and indirect)
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyClass.DirectSubClasses">
            <summary>
            Gets the direct sub-classes of this class
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyClass.IndirectSubClasses">
            <summary>
            Gets the indirect sub-classes of this class
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyClass.SuperClasses">
            <summary>
            Gets the super-classes of this class (both direct and indirect)
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyClass.DirectSuperClasses">
            <summary>
            Gets the direct super-classes of this class
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyClass.IndirectSuperClasses">
            <summary>
            Gets the indirect super-classes of this class
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyClass.Siblings">
            <summary>
            Gets the Sibling classes of this class, if this class is the root of the ontology nothing is returned even if there are multiple root classes
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyClass.EquivalentClasses">
            <summary>
            Gets the equivalent classes of this class
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyClass.DisjointClasses">
            <summary>
            Gets the disjoint classes of this class
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyClass.Instances">
            <summary>
            Gets the instances (individuals) of this class
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyClass.IsDomainOf">
            <summary>
            Gets the properties which have this class as a domain
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyClass.IsRangeOf">
            <summary>
            Gets the properties which have this class as a range
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyClass.IsTopClass">
            <summary>
            Gets whether something is a Top Class i.e. has no super classes
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyClass.IsBottomClass">
            <summary>
            Gets whether something is a Bottom Class i.e. has no sub classes
            </summary>
        </member>
        <member name="T:VDS.RDF.Ontology.OntologyGraph">
            <summary>
            Represents a Graph with additional methods for extracting ontology based information from it
            </summary>
            <remarks>
            <para>
            See <a href="http://www.dotnetrdf.org/content.asp?pageID=Ontology%20API">Using the Ontology API</a> for some informal documentation on the use of the Ontology namespace
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyGraph.#ctor">
            <summary>
            Creates a new Ontology Graph
            </summary>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyGraph.CreateOntologyResource(VDS.RDF.INode)">
            <summary>
            Gets/Creates an ontology resource in the Graph
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyGraph.CreateOntologyResource(System.Uri)">
            <summary>
            Gets/Creates an ontology resource in the Graph
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyGraph.CreateOntologyResource">
            <summary>
            Gets/Creates an anonymous ontology resource in the Graph
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyGraph.CreateOntologyClass(VDS.RDF.INode)">
            <summary>
            Gets/Creates an ontology class in the Graph
            </summary>
            <param name="resource">Class Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyGraph.CreateOntologyClass(System.Uri)">
            <summary>
            Gets/Creates an ontology class in the Graph
            </summary>
            <param name="resource">Class Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyGraph.CreateOntologyClass">
            <summary>
            Gets/Creates an anonymous ontology class in the Graph
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyGraph.CreateOntologyProperty(VDS.RDF.INode)">
            <summary>
            Gets/Creates an ontology property in the Graph
            </summary>
            <param name="resource">Property Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyGraph.CreateOntologyProperty(System.Uri)">
            <summary>
            Gets/Creates an ontology property in the Graph
            </summary>
            <param name="resource">Property Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyGraph.CreateIndividual(VDS.RDF.INode)">
            <summary>
            Gets an existing individual in the Graph
            </summary>
            <param name="resource">Individual Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyGraph.CreateIndividual(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets/Creates an individual in the Graph of the given class
            </summary>
            <param name="resource">Individual Resource</param>
            <param name="class">Class</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyGraph.CreateIndividual(System.Uri)">
            <summary>
            Gets an existing individual in the Graph
            </summary>
            <param name="resource">Individual Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyGraph.CreateIndividual(System.Uri,System.Uri)">
            <summary>
            Gets/Creates an individual in the Graph of the given class
            </summary>
            <param name="resource">Individual Resource</param>
            <param name="class">Class</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyGraph.GetClasses(VDS.RDF.INode)">
            <summary>
            Get all classes defined in the graph where anything of a specific type is considered a class
            </summary>
            <param name="classType">Type which represents classes</param>
            <returns>Enumeration of classes</returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyGraph.GetProperties(VDS.RDF.INode)">
            <summary>
            Get all properties defined in the graph where anything of a specific type is considered a property
            </summary>
            <param name="propertyType">Type which represents properties</param>
            <returns>Enumeration of properties</returns>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyGraph.OwlClasses">
            <summary>
            Get all OWL classes defined in the graph
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyGraph.RdfClasses">
            <summary>
            Get all the RDFS classes defined in the graph
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyGraph.AllClasses">
            <summary>
            Gets all classes defined in the graph using the standard rdfs:Class and owl:Class types
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyGraph.RdfProperties">
            <summary>
            Gets all RDF properties defined in the graph
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyGraph.OwlObjectProperties">
            <summary>
            Gets all OWL Object properties defined in the graph
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyGraph.OwlDatatypeProperties">
            <summary>
            Gets all OWL Data properties defined in the graph
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyGraph.OwlAnnotationProperties">
            <summary>
            Gets all OWL Annotation properties defined in the graph
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyGraph.OwlProperties">
            <summary>
            Gets all properties defined in the graph using any of the standard OWL property types (owl:AnnotationProperty, owl:DataProperty, owl:ObjectProperty)
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyGraph.AllProperties">
            <summary>
            Gets all properties defined in the graph using any of the standard property types (rdf:Property, owl:AnnotationProperty, owl:DataProperty, owl:ObjectProperty)
            </summary>
        </member>
        <member name="T:VDS.RDF.Ontology.OntologyHelper">
            <summary>
            Static Helper class for the Ontology API
            </summary>
            <remarks>
            <para>
            See <a href="http://www.dotnetrdf.org/content.asp?pageID=Ontology%20API">Using the Ontology API</a> for some informal documentation on the use of the Ontology namespace
            </para>
            </remarks>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.PropertyVersionInfo">
            <summary>
            Constant URIs for properties exposed by <see cref="T:VDS.RDF.Ontology.OntologyResource">OntologyResource</see> and its derived classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.PropertySameAs">
            <summary>
            Constant URIs for properties exposed by <see cref="T:VDS.RDF.Ontology.OntologyResource">OntologyResource</see> and its derived classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.PropertyDifferentFrom">
            <summary>
            Constant URIs for properties exposed by <see cref="T:VDS.RDF.Ontology.OntologyResource">OntologyResource</see> and its derived classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.PropertyEquivalentClass">
            <summary>
            Constant URIs for properties exposed by <see cref="T:VDS.RDF.Ontology.OntologyResource">OntologyResource</see> and its derived classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.PropertyDisjointWith">
            <summary>
            Constant URIs for properties exposed by <see cref="T:VDS.RDF.Ontology.OntologyResource">OntologyResource</see> and its derived classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.PropertyEquivalentProperty">
            <summary>
            Constant URIs for properties exposed by <see cref="T:VDS.RDF.Ontology.OntologyResource">OntologyResource</see> and its derived classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.PropertyInverseOf">
            <summary>
            Constant URIs for properties exposed by <see cref="T:VDS.RDF.Ontology.OntologyResource">OntologyResource</see> and its derived classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.PropertyBackwardCompatibleWith">
            <summary>
            Constant URIs for properties exposed by <see cref="T:VDS.RDF.Ontology.OntologyResource">OntologyResource</see> and its derived classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.PropertyIncompatibleWith">
            <summary>
            Constant URIs for properties exposed by <see cref="T:VDS.RDF.Ontology.OntologyResource">OntologyResource</see> and its derived classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.PropertyPriorVersion">
            <summary>
            Constant URIs for properties exposed by <see cref="T:VDS.RDF.Ontology.OntologyResource">OntologyResource</see> and its derived classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.PropertyImports">
            <summary>
            Constant URIs for properties exposed by <see cref="T:VDS.RDF.Ontology.OntologyResource">OntologyResource</see> and its derived classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.PropertyComment">
            <summary>
            Constant URIs for properties exposed by <see cref="T:VDS.RDF.Ontology.OntologyResource">OntologyResource</see> and its derived classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.PropertyLabel">
            <summary>
            Constant URIs for properties exposed by <see cref="T:VDS.RDF.Ontology.OntologyResource">OntologyResource</see> and its derived classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.PropertySeeAlso">
            <summary>
            Constant URIs for properties exposed by <see cref="T:VDS.RDF.Ontology.OntologyResource">OntologyResource</see> and its derived classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.PropertyIsDefinedBy">
            <summary>
            Constant URIs for properties exposed by <see cref="T:VDS.RDF.Ontology.OntologyResource">OntologyResource</see> and its derived classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.PropertySubClassOf">
            <summary>
            Constant URIs for properties exposed by <see cref="T:VDS.RDF.Ontology.OntologyResource">OntologyResource</see> and its derived classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.PropertySubPropertyOf">
            <summary>
            Constant URIs for properties exposed by <see cref="T:VDS.RDF.Ontology.OntologyResource">OntologyResource</see> and its derived classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.PropertyRange">
            <summary>
            Constant URIs for properties exposed by <see cref="T:VDS.RDF.Ontology.OntologyResource">OntologyResource</see> and its derived classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.PropertyDomain">
            <summary>
            Constant URIs for properties exposed by <see cref="T:VDS.RDF.Ontology.OntologyResource">OntologyResource</see> and its derived classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.PropertyType">
            <summary>
            Constant URIs for properties exposed by <see cref="T:VDS.RDF.Ontology.OntologyResource">OntologyResource</see> and its derived classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.RdfsClass">
            <summary>
            Constants for URIs for classes in Ontologies
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.OwlClass">
            <summary>
            Constants for URIs for classes in Ontologies
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.RdfProperty">
            <summary>
            Constants for URIs for classes in Ontologies
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.RdfsResource">
            <summary>
            Constants for URIs for classes in Ontologies
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.OwlObjectProperty">
            <summary>
            Constants for URIs for classes in Ontologies
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.OwlDatatypeProperty">
            <summary>
            Constants for URIs for classes in Ontologies
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.OwlAnnotationProperty">
            <summary>
            Constants for URIs for classes in Ontologies
            </summary>
        </member>
        <member name="F:VDS.RDF.Ontology.OntologyHelper.OwlOntology">
            <summary>
            Constants for URIs for classes in Ontologies
            </summary>
        </member>
        <member name="T:VDS.RDF.Ontology.OntologyProperty">
            <summary>
            Class for representing a property in an Ontology
            </summary>
            <remarks>
            <para>
            See <a href="http://www.dotnetrdf.org/content.asp?pageID=Ontology%20API">Using the Ontology API</a> for some informal documentation on the use of the Ontology namespace
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.#ctor(VDS.RDF.INode,VDS.RDF.IGraph)">
            <summary>
            Creates a new Ontology Property for the given resource in the given Graph
            </summary>
            <param name="resource">Resource</param>
            <param name="graph">Graph</param>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.#ctor(System.Uri,VDS.RDF.IGraph)">
            <summary>
            Creates a new RDFS Ontology Property for the given resource in the given Graph
            </summary>
            <param name="resource">Resource</param>
            <param name="graph">Graph</param>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.AddDomain(VDS.RDF.INode)">
            <summary>
            Adds a new domain for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.AddDomain(System.Uri)">
            <summary>
            Adds a new domain for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.AddDomain(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Adds a new domain for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.ClearDomains">
            <summary>
            Clears all domains for the property
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.RemoveDomain(VDS.RDF.INode)">
            <summary>
            Removes a domain for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.RemoveDomain(System.Uri)">
            <summary>
            Removes a domain for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.RemoveDomain(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Removes a domain for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.AddRange(VDS.RDF.INode)">
            <summary>
            Adds a new range for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.AddRange(System.Uri)">
            <summary>
            Adds a new range for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.AddRange(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Adds a new range for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.ClearRanges">
            <summary>
            Clears all ranges for the property
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.RemoveRange(VDS.RDF.INode)">
            <summary>
            Removes a range for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.RemoveRange(System.Uri)">
            <summary>
            Removes a range for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.RemoveRange(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Removes a range for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.AddEquivalentProperty(VDS.RDF.INode)">
            <summary>
            Adds a new equivalent property for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.AddEquivalentProperty(System.Uri)">
            <summary>
            Adds a new equivalent property for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.AddEquivalentProperty(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Adds a new equivalent property for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.AddEquivalentProperty(VDS.RDF.Ontology.OntologyProperty)">
            <summary>
            Adds a new equivalent property for the property
            </summary>
            <param name="property">Property</param>
            <returns></returns>
            <remarks>
            This overload also adds this property as an equivalent property of the given property
            </remarks>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.ClearEquivalentProperties">
            <summary>
            Clears all equivalent properties for this property
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.RemoveEquivalentProperty(VDS.RDF.INode)">
            <summary>
            Removes an equivalent property for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.RemoveEquivalentProperty(System.Uri)">
            <summary>
            Removes an equivalent property for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.RemoveEquivalentProperty(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Removes an equivalent property for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.RemoveEquivalentProperty(VDS.RDF.Ontology.OntologyProperty)">
            <summary>
            Removes an equivalent property for the property
            </summary>
            <param name="property">Property</param>
            <returns></returns>
            <remarks>
            This overload also removes this property as an equivalent property of the given property
            </remarks>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.AddInverseProperty(VDS.RDF.INode)">
            <summary>
            Adds an inverse property for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.AddInverseProperty(System.Uri)">
            <summary>
            Adds an inverse property for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.AddInverseProperty(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Adds an inverse property for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.AddInverseProperty(VDS.RDF.Ontology.OntologyProperty)">
            <summary>
            Adds an inverse property for the property
            </summary>
            <param name="property">Property</param>
            <returns></returns>
            <remarks>
            This overload also adds this property as an inverse property of the given property
            </remarks>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.ClearInverseProperties">
            <summary>
            Removes all inverse properties for this property
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.RemoveInverseProperty(VDS.RDF.INode)">
            <summary>
            Removes an inverse property for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.RemoveInverseProperty(System.Uri)">
            <summary>
            Removes an inverse property for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.RemoveInverseProperty(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Removes an inverse property for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.RemoveInverseProperty(VDS.RDF.Ontology.OntologyProperty)">
            <summary>
            Removes an inverse property for the property
            </summary>
            <param name="property">Property</param>
            <returns></returns>
            <remarks>
            This overload also removes this property as an inverse property of the given property
            </remarks>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.AddSubProperty(VDS.RDF.INode)">
            <summary>
            Adds a sub-property for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.AddSubProperty(System.Uri)">
            <summary>
            Adds a sub-property for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.AddSubProperty(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Adds a sub-property for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.AddSubProperty(VDS.RDF.Ontology.OntologyProperty)">
            <summary>
            Adds a sub-property for the property
            </summary>
            <param name="property">Property</param>
            <returns></returns>
            <remarks>
            This overload also adds this property as a super-property of the given property
            </remarks>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.ClearSubProperties">
            <summary>
            Clears all sub-properties of this property
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.RemoveSubProperty(VDS.RDF.INode)">
            <summary>
            Removes a sub-property for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.RemoveSubProperty(System.Uri)">
            <summary>
            Removes a sub-property for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.RemoveSubProperty(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Removes a sub-property for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.RemoveSubProperty(VDS.RDF.Ontology.OntologyProperty)">
            <summary>
            Removes a sub-property for the property
            </summary>
            <param name="property">Property</param>
            <returns></returns>
            <remarks>
            This overload also removes this property as a super-property of the given property
            </remarks>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.AddSuperProperty(VDS.RDF.INode)">
            <summary>
            Adds a super-property for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.AddSuperProperty(System.Uri)">
            <summary>
            Adds a super-property for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.AddSuperProperty(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Adds a super-property for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.AddSuperProperty(VDS.RDF.Ontology.OntologyProperty)">
            <summary>
            Adds a super-property for the property
            </summary>
            <param name="property">Property</param>
            <returns></returns>
            <remarks>
            This overload also adds this property as a sub-property of the given property
            </remarks>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.ClearSuperProperties">
            <summary>
            Removes all super-properties of this property
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.RemoveSuperProperty(VDS.RDF.INode)">
            <summary>
            Removes a super-property for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.RemoveSuperProperty(System.Uri)">
            <summary>
            Removes a super-property for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.RemoveSuperProperty(VDS.RDF.Ontology.OntologyResource)">
            <summary>
            Removes a super-property for the property
            </summary>
            <param name="resource">Resource</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Ontology.OntologyProperty.RemoveSuperProperty(VDS.RDF.Ontology.OntologyProperty)">
            <summary>
            Removes a super-property for the property
            </summary>
            <param name="property">Property</param>
            <returns></returns>
            <remarks>
            This overload also removes this property as a sub-property of the given property
            </remarks>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyProperty.Domains">
            <summary>
            Gets all the Classes which are in the properties Domain
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyProperty.Ranges">
            <summary>
            Gets all the Classes which are in this properties Range
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyProperty.EquivalentProperties">
            <summary>
            Gets all the equivalent properties of this property
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyProperty.SubProperties">
            <summary>
            Gets the sub-properties of this property (both direct and indirect)
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyProperty.DirectSubProperties">
            <summary>
            Gets the direct sub-classes of this class
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyProperty.IndirectSubProperties">
            <summary>
            Gets the indirect sub-classes of this class
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyProperty.SuperProperties">
            <summary>
            Gets the super-properties of this property (both direct and indirect)
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyProperty.DirectSuperProperties">
            <summary>
            Gets the direct super-properties of this property
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyProperty.IndirectSuperProperty">
            <summary>
            Gets the indirect super-properties of this property
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyProperty.IsTopProperty">
            <summary>
            Gets whether this is a top property i.e. has no super properties defined
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyProperty.IsBottomProperty">
            <summary>
            Gets whether this is a btoom property i.e. has no sub properties defined
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyProperty.Siblings">
            <summary>
            Gets the Sibling properties of this property, if this property is the root of the ontology nothing is returned even if there are multiple root properties
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyProperty.InverseProperties">
            <summary>
            Gets all the inverse properties of this property
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.OntologyProperty.UsedBy">
            <summary>
            Gets all the resources that use this property
            </summary>
        </member>
        <member name="T:VDS.RDF.Ontology.ReasonerGraph">
            <summary>
            Represents a Graph with a reasoner attached
            </summary>
            <remarks>
            <para>
            This class wraps an existing Graph and applies the given reasoner to it materialising the Triples in this Graph.  The original Graph itself is not modified but can be accessed if necessary using the <see cref="P:VDS.RDF.Ontology.ReasonerGraph.BaseGraph">BaseGraph</see> property
            </para>
            <para>
            Any changes to this Graph (via <see cref="M:VDS.RDF.IGraph.Assert(VDS.RDF.Triple)">Assert()</see> and <see cref="M:VDS.RDF.IGraph.Retract(VDS.RDF.Triple)">Retract()</see>) affect this Graph - specifically the set of materialised Triples - rather than the original Graph around which this Graph is a wrapper
            </para>
            <para>
            See <a href="http://www.dotnetrdf.org/content.asp?pageID=Ontology%20API">Using the Ontology API</a> for some informal documentation on the use of the Ontology namespace
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Ontology.ReasonerGraph.#ctor(VDS.RDF.IGraph,VDS.RDF.Query.Inference.IInferenceEngine)">
            <summary>
            Creates a new Reasoner Graph which is a wrapper around an existing Graph with a reasoner applied and the resulting Triples materialised
            </summary>
            <param name="g">Graph</param>
            <param name="reasoner">Reasoner</param>
        </member>
        <member name="M:VDS.RDF.Ontology.ReasonerGraph.#ctor(VDS.RDF.IGraph,System.Collections.Generic.IEnumerable{VDS.RDF.Query.Inference.IInferenceEngine})">
            <summary>
            Creates a new Reasoner Graph which is a wrapper around an existing Graph with multiple reasoners applied and the resulting Triples materialised
            </summary>
            <param name="g">Graph</param>
            <param name="reasoners">Reasoner</param>
        </member>
        <member name="M:VDS.RDF.Ontology.ReasonerGraph.Initialise">
            <summary>
            Internal method which initialises the Graph by applying the reasoners and setting the Node and Triple collections to be union collections
            </summary>
        </member>
        <member name="P:VDS.RDF.Ontology.ReasonerGraph.BaseGraph">
            <summary>
            Gets the Base Graph which the reasoning is based upon
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.SparqlCsvParser">
            <summary>
            Parser for reading SPARQL Results that have been serialized in the SPARQL Results CSV format
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlCsvParser.Load(VDS.RDF.Query.SparqlResultSet,System.IO.StreamReader)">
            <summary>
            Loads a Result Set from an Input Stream
            </summary>
            <param name="results">Result Set to load into</param>
            <param name="input">Input Stream to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlCsvParser.Load(VDS.RDF.Query.SparqlResultSet,System.IO.TextReader)">
            <summary>
            Loads a Result Set from an Input
            </summary>
            <param name="results">Result Set to load into</param>
            <param name="input">Input to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlCsvParser.Load(VDS.RDF.ISparqlResultsHandler,System.IO.StreamReader)">
            <summary>
            Loads a Result Set from an Input Stream using a Results Handler
            </summary>
            <param name="handler">Results Handler to use</param>
            <param name="input">Input Stream to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlCsvParser.Load(VDS.RDF.ISparqlResultsHandler,System.IO.TextReader)">
            <summary>
            Loads a Result Set from an Input using a Results Handler
            </summary>
            <param name="handler">Results Handler to use</param>
            <param name="input">Input to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlCsvParser.ToString">
            <summary>
            Gets the String representation of the Parser
            </summary>
            <returns></returns>
        </member>
        <member name="E:VDS.RDF.Parsing.SparqlCsvParser.Warning">
            <summary>
            Event which is raised when the parser encounters a non-fatal issue with the syntax being parsed
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Handlers.AnyHandler">
            <summary>
            A RDF Handler which just determines whether any Triples are present terminating parsing as soon as the first triple is received
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.AnyHandler.#ctor">
            <summary>
            Creates a new Any Handler
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.AnyHandler.StartRdfInternal">
            <summary>
            Starts handling RDF by resetting the <see cref="P:VDS.RDF.Parsing.Handlers.AnyHandler.Any">Any</see> flag to false
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.AnyHandler.HandleBaseUriInternal(System.Uri)">
            <summary>
            Handles Base URIs by ignoring them
            </summary>
            <param name="baseUri">Base URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.AnyHandler.HandleNamespaceInternal(System.String,System.Uri)">
            <summary>
            Handles Namespaces by ignoring them
            </summary>
            <param name="prefix">Prefix</param>
            <param name="namespaceUri">Namespace URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.AnyHandler.HandleTripleInternal(VDS.RDF.Triple)">
            <summary>
            Handles Triples by setting the <see cref="P:VDS.RDF.Parsing.Handlers.AnyHandler.Any">Any</see> flag and terminating parsing
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Parsing.Handlers.AnyHandler.Any">
            <summary>
            Gets whether any Triples have been parsed
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Handlers.AnyHandler.AcceptsAll">
            <summary>
            Gets that this handler does not accept all triples since it stops as soon as it sees the first triple
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Handlers.GraphUriRewriteHandler">
            <summary>
            A RDF Handler that rewrites the Graph URIs of Triples before passing them to an inner handler
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.GraphUriRewriteHandler.#ctor(VDS.RDF.IRdfHandler,System.Uri)">
            <summary>
            Creates a new Graph URI rewriting handler
            </summary>
            <param name="handler">Handler to wrap</param>
            <param name="graphUri">Graph URI to rewrite to</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.GraphUriRewriteHandler.StartRdfInternal">
            <summary>
            Starts handling of RDF
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.GraphUriRewriteHandler.EndRdfInternal(System.Boolean)">
            <summary>
            Ends handling of RDF
            </summary>
            <param name="ok">Whether parsing completed OK</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.GraphUriRewriteHandler.HandleBaseUriInternal(System.Uri)">
            <summary>
            Handles a Base URI declaration
            </summary>
            <param name="baseUri">Base URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.GraphUriRewriteHandler.HandleNamespaceInternal(System.String,System.Uri)">
            <summary>
            Handles a Namespace declaration
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="namespaceUri">Namespace URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.GraphUriRewriteHandler.HandleTripleInternal(VDS.RDF.Triple)">
            <summary>
            Handles a Triple by rewriting the Graph URI and passing it to the inner handler
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Parsing.Handlers.GraphUriRewriteHandler.InnerHandlers">
            <summary>
            Gets the Inner Handler
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Handlers.GraphUriRewriteHandler.AcceptsAll">
            <summary>
            Returns true since this handler accepts all triples
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.SparqlTsvParser">
            <summary>
            Parser for reading SPARQL Results that have been serialized in the SPARQL Results TSV format
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlTsvParser.Load(VDS.RDF.Query.SparqlResultSet,System.IO.StreamReader)">
            <summary>
            Loads a Result Set from an Input Stream
            </summary>
            <param name="results">Result Set to load into</param>
            <param name="input">Input Stream to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlTsvParser.Load(VDS.RDF.Query.SparqlResultSet,System.IO.TextReader)">
            <summary>
            Loads a Result Set from an Input
            </summary>
            <param name="results">Result Set to load into</param>
            <param name="input">Input to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlTsvParser.Load(VDS.RDF.ISparqlResultsHandler,System.IO.StreamReader)">
            <summary>
            Loads a Result Set from an Input Stream using a Results Handler
            </summary>
            <param name="handler">Results Handler to use</param>
            <param name="input">Input Stream to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlTsvParser.Load(VDS.RDF.ISparqlResultsHandler,System.IO.TextReader)">
            <summary>
            Loads a Result Set from an Input using a Results Handler
            </summary>
            <param name="handler">Results Handler to use</param>
            <param name="input">Input to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlTsvParser.ToString">
            <summary>
            Gets the String representation of the Parser
            </summary>
            <returns></returns>
        </member>
        <member name="E:VDS.RDF.Parsing.SparqlTsvParser.Warning">
            <summary>
            Event which is raised when the parser encounters a non-fatal issue with the syntax being parsed
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.CsvTokeniser">
            <summary>
            Tokeniser for tokenising CSV inputs
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.CsvTokeniser.#ctor(VDS.RDF.Parsing.ParsingTextReader)">
            <summary>
            Creates a new CSV Tokeniser
            </summary>
            <param name="reader">Text Reader</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.CsvTokeniser.#ctor(System.IO.StreamReader)">
            <summary>
            Creates a new CSV Tokeniser
            </summary>
            <param name="reader">Stream Reader</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.CsvTokeniser.GetNextToken">
            <summary>
            Gets the next available token from the input
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.TsvTokeniser">
            <summary>
            Tokeniser for tokenising TSV inputs
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TsvTokeniser.#ctor(VDS.RDF.Parsing.ParsingTextReader)">
            <summary>
            Creates a new TSV Tokeniser
            </summary>
            <param name="reader">Text Reader</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TsvTokeniser.#ctor(System.IO.StreamReader)">
            <summary>
            Creates a new TSV Tokeniser
            </summary>
            <param name="reader">Stream Reader</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TsvTokeniser.GetNextToken">
            <summary>
            Gets the next available token from the input
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Parsing.ParsingTextReader">
            <summary>
            An extended <see cref="T:System.IO.TextReader"/> for use in parsing
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.ParsingTextReader.Create(System.IO.TextReader,System.Int32)">
            <summary>
            Creates a new Blocking Text Reader
            </summary>
            <param name="input">Text Reader to wrap</param>
            <param name="bufferSize">Buffer Size</param>
            <remarks>
            If the given <see cref="T:System.IO.TextReader">TextReader</see> is already a Blocking Text Reader this is a no-op
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.ParsingTextReader.Create(System.IO.TextReader)">
            <summary>
            Creates a new Blocking Text Reader
            </summary>
            <param name="input">Text Reader to wrap</param>
            <remarks>
            If the given <see cref="T:System.IO.TextReader">TextReader</see> is already a Blocking Text Reader this is a no-op
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.ParsingTextReader.Create(System.IO.Stream,System.Int32)">
            <summary>
            Creates a new Blocking Text Reader
            </summary>
            <param name="input">Input Stream</param>
            <param name="bufferSize">Buffer Size</param>
        </member>
        <member name="M:VDS.RDF.Parsing.ParsingTextReader.Create(System.IO.Stream)">
            <summary>
            Creates a new Blocking Text Reader
            </summary>
            <param name="input">Input Stream</param>
        </member>
        <member name="M:VDS.RDF.Parsing.ParsingTextReader.CreateBlocking(System.IO.TextReader)">
            <summary>
            Creates a new Blocking Text Reader
            </summary>
            <param name="input">Input reader</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.ParsingTextReader.CreateBlocking(System.IO.TextReader,System.Int32)">
            <summary>
            Creates a new Blocking Text Reader
            </summary>
            <param name="input">Input reader</param>
            <param name="bufferSize">Buffer Size</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.ParsingTextReader.CreateNonBlocking(System.IO.TextReader)">
            <summary>
            Creates a new non-blocking Text Reader
            </summary>
            <param name="input">Input reader</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.ParsingTextReader.CreateNonBlocking(System.IO.TextReader,System.Int32)">
            <summary>
            Creates a new non-blocking Text Reader
            </summary>
            <param name="input">Input reader</param>
            <param name="bufferSize">Buffer Size</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Parsing.ParsingTextReader.EndOfStream">
            <summary>
            Gets whether the end of the stream has been reached
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.BufferedTextReader">
            <summary>
            Abstract class representing a text reader that provides buffering on top of another text reader
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.BufferedTextReader.DefaultBufferSize">
            <summary>
            Default Buffer Size
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.BufferedTextReader._buffer">
            <summary>
            Buffer array
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.BufferedTextReader._pos">
            <summary>
            Current buffer position
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.BufferedTextReader._bufferAmount">
            <summary>
            Current buffer size (may be less than length of buffer array)
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.BufferedTextReader._finished">
            <summary>
            Whether underlying reader has been exhausted
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.BufferedTextReader._reader">
            <summary>
            Underlying reader
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.BufferedTextReader.#ctor(System.IO.TextReader,System.Int32)">
            <summary>
            Creates a buffered reader
            </summary>
            <param name="reader"></param>
            <param name="bufferSize"></param>
        </member>
        <member name="M:VDS.RDF.Parsing.BufferedTextReader.FillBuffer">
            <summary>
            Requests that the buffer be filled
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.BufferedTextReader.ReadBlock(System.Char[],System.Int32,System.Int32)">
            <summary>
            Reads a sequence of characters from the buffer in a blocking way
            </summary>
            <param name="buffer">Buffer</param>
            <param name="index">Index at which to start writing to the Buffer</param>
            <param name="count">Number of characters to read</param>
            <returns>Number of characters read</returns>
        </member>
        <member name="M:VDS.RDF.Parsing.BufferedTextReader.Read(System.Char[],System.Int32,System.Int32)">
            <summary>
            Reads a sequence of characters from the buffer
            </summary>
            <param name="buffer">Buffer</param>
            <param name="index">Index at which to start writing to the Buffer</param>
            <param name="count">Number of characters to read</param>
            <returns>Number of characters read</returns>
        </member>
        <member name="M:VDS.RDF.Parsing.BufferedTextReader.Read">
            <summary>
            Reads a single character from the underlying Text Reader
            </summary>
            <returns>Character read or -1 if at end of input</returns>
        </member>
        <member name="M:VDS.RDF.Parsing.BufferedTextReader.Peek">
            <summary>
            Peeks at the next character from the underlying Text Reader
            </summary>
            <returns>Character peeked or -1 if at end of input</returns>
        </member>
        <member name="M:VDS.RDF.Parsing.BufferedTextReader.Dispose(System.Boolean)">
            <summary>
            Disposes of the reader and the underlying reader
            </summary>
            <param name="disposing">Whether this was called from the Dispose() method</param>
        </member>
        <member name="P:VDS.RDF.Parsing.BufferedTextReader.EndOfStream">
            <summary>
            Gets whether the end of the input has been reached
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.BlockingTextReader">
            <summary>
            The BlockingTextReader is an implementation of a <see cref="T:VDS.RDF.Parsing.BufferedTextReader"/> designed to wrap other readers which may or may not have high latency and thus ensures that premature end of input bug is not experienced.
            </summary>
            <remarks>
            <para>
            This is designed to avoid premature detection of end of input when the input has high latency and the consumer tries to read from the input faster than it can return data.  This derives from <see cref="T:VDS.RDF.Parsing.BufferedTextReader"/> and ensures the buffer is filled by calling the <see cref="M:System.IO.TextReader.ReadBlock(System.Char[],System.Int32,System.Int32)">ReadBlock()</see> method of the underlying <see cref="T:System.IO.TextReader">TextReader</see> thus avoiding the scenario where input appears to end prematurely.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.BlockingTextReader.#ctor(System.IO.TextReader,System.Int32)">
            <summary>
            Creates a new Blocking Text Reader
            </summary>
            <param name="reader">Text Reader to wrap</param>
            <param name="bufferSize">Buffer Size</param>
        </member>
        <member name="M:VDS.RDF.Parsing.BlockingTextReader.#ctor(System.IO.TextReader)">
            <summary>
            Creates a new Blocking Text Reader
            </summary>
            <param name="reader">Text Reader to wrap</param>
        </member>
        <member name="M:VDS.RDF.Parsing.BlockingTextReader.#ctor(System.IO.Stream,System.Int32)">
            <summary>
            Creates a new Blocking Text Reader
            </summary>
            <param name="input">Input Stream</param>
            <param name="bufferSize">Buffer Size</param>
        </member>
        <member name="M:VDS.RDF.Parsing.BlockingTextReader.#ctor(System.IO.Stream)">
            <summary>
            Creates a new Blocking Text Reader
            </summary>
            <param name="input">Input Stream</param>
        </member>
        <member name="M:VDS.RDF.Parsing.BlockingTextReader.FillBuffer">
            <summary>
            Fills the Buffer
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.NonBlockingTextReader">
            <summary>
            The NonBlockingTextReader is an implementation of a <see cref="T:VDS.RDF.Parsing.BufferedTextReader"/> designed to wrap other readers where latency is known not to be a problem and we don't expect to ever have an empty read occur before the actual end of the stream
            </summary>
            <remarks>
            Currently we only use this for file and network streams, you can force this to never be used with the global static <see cref="P:VDS.RDF.Options.ForceBlockingIO"/> option
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.NonBlockingTextReader.FillBuffer">
            <summary>
            Fills the buffer in a non-blocking manner
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Contexts.BaseResultsParserContext">
            <summary>
            Base class for SPARQL Results Parser Contexts
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Contexts.IResultsParserContext">
            <summary>
            Interface for SPARQL Results Parser Contexts
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.IResultsParserContext.Handler">
            <summary>
            Gets the SPARQL Results Handler to use
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Contexts.BaseResultsParserContext._traceParsing">
            <summary>
            Controls parser tracing behaviour
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.BaseResultsParserContext.#ctor(VDS.RDF.Query.SparqlResultSet,System.Boolean)">
            <summary>
            Creates a new Results Parser Context
            </summary>
            <param name="results">Result Set</param>
            <param name="traceParsing">Whether to trace parsing</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.BaseResultsParserContext.#ctor(VDS.RDF.Query.SparqlResultSet)">
            <summary>
            Creates a new Results Parser Context
            </summary>
            <param name="results">Result Set</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.BaseResultsParserContext.#ctor(VDS.RDF.ISparqlResultsHandler,System.Boolean)">
            <summary>
            Creates a new Parser Context
            </summary>
            <param name="handler">Results Handler</param>
            <param name="traceParsing">Whether to trace parsing</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.BaseResultsParserContext.#ctor(VDS.RDF.ISparqlResultsHandler)">
            <summary>
            Creates a new Results Parser Context
            </summary>
            <param name="handler">Results Handler</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.BaseResultsParserContext.Handler">
            <summary>
            Gets the Results Handler to be used
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.BaseResultsParserContext.Variables">
            <summary>
            Gets the Variables that have been seen
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.BaseResultsParserContext.TraceParsing">
            <summary>
            Gets/Sets whether Parser Tracing is used
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Contexts.TokenisingResultParserContext">
            <summary>
            Class for Tokenising SPARQL Results Parser Contexts
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Contexts.TokenisingResultParserContext._queue">
            <summary>
            Tokeniser
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Contexts.TokenisingResultParserContext._traceTokeniser">
            <summary>
            Is Tokeniser traced?
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Contexts.TokenisingResultParserContext._localTokens">
            <summary>
            Local Tokens
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TokenisingResultParserContext.#ctor(VDS.RDF.Query.SparqlResultSet,VDS.RDF.Parsing.Tokens.ITokeniser)">
            <summary>
            Creates a new Tokenising Parser Context with default settings
            </summary>
            <param name="results">Result Set to parse into</param>
            <param name="tokeniser">Tokeniser to use</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TokenisingResultParserContext.#ctor(VDS.RDF.Query.SparqlResultSet,VDS.RDF.Parsing.Tokens.ITokeniser,VDS.RDF.Parsing.Tokens.TokenQueueMode)">
            <summary>
            Creates a new Tokenising Parser Context with custom settings
            </summary>
            <param name="results">Result Set to parse into</param>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="queueMode">Tokeniser Queue Mode</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TokenisingResultParserContext.#ctor(VDS.RDF.Query.SparqlResultSet,VDS.RDF.Parsing.Tokens.ITokeniser,System.Boolean,System.Boolean)">
            <summary>
            Creates a new Tokenising Parser Context with custom settings
            </summary>
            <param name="results">Result Set to parse into</param>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="traceParsing">Whether to trace parsing</param>
            <param name="traceTokeniser">Whether to trace tokenisation</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TokenisingResultParserContext.#ctor(VDS.RDF.Query.SparqlResultSet,VDS.RDF.Parsing.Tokens.ITokeniser,VDS.RDF.Parsing.Tokens.TokenQueueMode,System.Boolean,System.Boolean)">
            <summary>
            Creates a new Tokenising Parser Context with custom settings
            </summary>
            <param name="results">Result Set to parse into</param>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="queueMode">Tokeniser Queue Mode</param>
            <param name="traceParsing">Whether to trace parsing</param>
            <param name="traceTokeniser">Whether to trace tokenisation</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TokenisingResultParserContext.#ctor(VDS.RDF.ISparqlResultsHandler,VDS.RDF.Parsing.Tokens.ITokeniser)">
            <summary>
            Creates a new Tokenising Parser Context with default settings
            </summary>
            <param name="handler">Results Handler</param>
            <param name="tokeniser">Tokeniser to use</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TokenisingResultParserContext.#ctor(VDS.RDF.ISparqlResultsHandler,VDS.RDF.Parsing.Tokens.ITokeniser,VDS.RDF.Parsing.Tokens.TokenQueueMode)">
            <summary>
            Creates a new Tokenising Parser Context with custom settings
            </summary>
            <param name="handler">Results Handler</param>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="queueMode">Tokeniser Queue Mode</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TokenisingResultParserContext.#ctor(VDS.RDF.ISparqlResultsHandler,VDS.RDF.Parsing.Tokens.ITokeniser,System.Boolean,System.Boolean)">
            <summary>
            Creates a new Tokenising Parser Context with custom settings
            </summary>
            <param name="handler">Results Handler</param>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="traceParsing">Whether to trace parsing</param>
            <param name="traceTokeniser">Whether to trace tokenisation</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TokenisingResultParserContext.#ctor(VDS.RDF.ISparqlResultsHandler,VDS.RDF.Parsing.Tokens.ITokeniser,VDS.RDF.Parsing.Tokens.TokenQueueMode,System.Boolean,System.Boolean)">
            <summary>
            Creates a new Tokenising Parser Context with custom settings
            </summary>
            <param name="handler">Results Handler</param>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="queueMode">Tokeniser Queue Mode</param>
            <param name="traceParsing">Whether to trace parsing</param>
            <param name="traceTokeniser">Whether to trace tokenisation</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.TokenisingResultParserContext.Tokens">
            <summary>
            Gets the Token Queue
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.TokenisingResultParserContext.LocalTokens">
            <summary>
            Gets the Local Tokens stack
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.TokenisingResultParserContext.TraceTokeniser">
            <summary>
            Gets/Sets whether tokeniser tracing is used
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Contexts.BaseStoreParserContext">
            <summary>
            Base Class for Store Parser Contexts
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Contexts.IStoreParserContext">
            <summary>
            Interface for Store Parser Contexts
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.IStoreParserContext.Handler">
            <summary>
            Gets the RDF Handler which is used to instantiate Nodes and to handle the generated RDF
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.IStoreParserContext.TraceParsing">
            <summary>
            Gets/Sets whether Parser Tracing should be used (if the Parser supports it)
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.IStoreParserContext.Namespaces">
            <summary>
            Gets the Namespace Map for the Handler
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.IStoreParserContext.BaseUri">
            <summary>
            Gets the Base URI for the Handler
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Contexts.BaseStoreParserContext._traceParsing">
            <summary>
            Is Parsing Traced?
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.BaseStoreParserContext.#ctor(VDS.RDF.IRdfHandler,System.Boolean)">
            <summary>
            Creates a new Store Parser Context
            </summary>
            <param name="handler">RDF Handler</param>
            <param name="traceParsing">Whether to trace parsing</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.BaseStoreParserContext.#ctor(VDS.RDF.IRdfHandler)">
            <summary>
            Creates a new Store Parser Context
            </summary>
            <param name="handler">RDF Handler</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.BaseStoreParserContext.#ctor(VDS.RDF.ITripleStore)">
            <summary>
            Creates a new Base Store Parser Context
            </summary>
            <param name="store">Triple Store</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.BaseStoreParserContext.#ctor(VDS.RDF.ITripleStore,System.Boolean)">
            <summary>
            Creates a new Base Parser Context
            </summary>
            <param name="store">Triple Store</param>
            <param name="traceParsing">Whether to trace parsing</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.BaseStoreParserContext.TraceParsing">
            <summary>
            Gets/Sets whether to trace parsing
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.BaseStoreParserContext.Handler">
            <summary>
            Gets the RDF Handler that is in-use
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.BaseStoreParserContext.Namespaces">
            <summary>
            Gets the Namespace Map for the parser context
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.BaseStoreParserContext.BaseUri">
            <summary>
            Gets the Base URI for the parser context
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Contexts.TokenisingStoreParserContext">
            <summary>
            Class for Store Parser Contexts for Tokeniser based Parsing
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Contexts.TokenisingStoreParserContext._queue">
            <summary>
            Tokeniser
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Contexts.TokenisingStoreParserContext._traceTokeniser">
            <summary>
            Is Tokeniser traced?
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Contexts.TokenisingStoreParserContext._localTokens">
            <summary>
            Local Tokens
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TokenisingStoreParserContext.#ctor(VDS.RDF.ITripleStore,VDS.RDF.Parsing.Tokens.ITokeniser)">
            <summary>
            Creates a new Tokenising Store Parser Context with default settings
            </summary>
            <param name="store">Store to parse into</param>
            <param name="tokeniser">Tokeniser to use</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TokenisingStoreParserContext.#ctor(VDS.RDF.ITripleStore,VDS.RDF.Parsing.Tokens.ITokeniser,VDS.RDF.Parsing.Tokens.TokenQueueMode)">
            <summary>
            Creates a new Tokenising Store Parser Context with custom settings
            </summary>
            <param name="store">Store to parse into</param>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="queueMode">Tokeniser Queue Mode</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TokenisingStoreParserContext.#ctor(VDS.RDF.ITripleStore,VDS.RDF.Parsing.Tokens.ITokeniser,System.Boolean,System.Boolean)">
            <summary>
            Creates a new Tokenising Store Parser Context with custom settings
            </summary>
            <param name="store">Store to parse into</param>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="traceParsing">Whether to trace parsing</param>
            <param name="traceTokeniser">Whether to trace tokenisation</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TokenisingStoreParserContext.#ctor(VDS.RDF.ITripleStore,VDS.RDF.Parsing.Tokens.ITokeniser,VDS.RDF.Parsing.Tokens.TokenQueueMode,System.Boolean,System.Boolean)">
            <summary>
            Creates a new Tokenising Store Parser Context with custom settings
            </summary>
            <param name="store">Store to parse into</param>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="queueMode">Tokeniser Queue Mode</param>
            <param name="traceParsing">Whether to trace parsing</param>
            <param name="traceTokeniser">Whether to trace tokenisation</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TokenisingStoreParserContext.#ctor(VDS.RDF.IRdfHandler,VDS.RDF.Parsing.Tokens.ITokeniser)">
            <summary>
            Creates a new Tokenising Store Parser Context with default settings
            </summary>
            <param name="handler">Store to parse into</param>
            <param name="tokeniser">Tokeniser to use</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TokenisingStoreParserContext.#ctor(VDS.RDF.IRdfHandler,VDS.RDF.Parsing.Tokens.ITokeniser,VDS.RDF.Parsing.Tokens.TokenQueueMode)">
            <summary>
            Creates a new Tokenising Store Parser Context with custom settings
            </summary>
            <param name="handler">Store to parse into</param>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="queueMode">Tokeniser Queue Mode</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TokenisingStoreParserContext.#ctor(VDS.RDF.IRdfHandler,VDS.RDF.Parsing.Tokens.ITokeniser,System.Boolean,System.Boolean)">
            <summary>
            Creates a new Tokenising Store Parser Context with custom settings
            </summary>
            <param name="handler">Store to parse into</param>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="traceParsing">Whether to trace parsing</param>
            <param name="traceTokeniser">Whether to trace tokenisation</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TokenisingStoreParserContext.#ctor(VDS.RDF.IRdfHandler,VDS.RDF.Parsing.Tokens.ITokeniser,VDS.RDF.Parsing.Tokens.TokenQueueMode,System.Boolean,System.Boolean)">
            <summary>
            Creates a new Tokenising Store Parser Context with custom settings
            </summary>
            <param name="handler">Store to parse into</param>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="queueMode">Tokeniser Queue Mode</param>
            <param name="traceParsing">Whether to trace parsing</param>
            <param name="traceTokeniser">Whether to trace tokenisation</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.TokenisingStoreParserContext.Tokens">
            <summary>
            Gets the Token Queue
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.TokenisingStoreParserContext.LocalTokens">
            <summary>
            Gets the Local Tokens stack
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.TokenisingStoreParserContext.TraceTokeniser">
            <summary>
            Gets/Sets whether tokeniser tracing is used
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Contexts.IEventParserContext`1">
            <summary>
            Interface for Event Parser contexts
            </summary>
            <typeparam name="T">Event Type</typeparam>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.IEventParserContext`1.Events">
            <summary>
            Queue of Events
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Contexts.JsonParserContext">
            <summary>
            Parser Context for RDF/JSON Parsers
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.JsonParserContext.#ctor(VDS.RDF.IGraph,Newtonsoft.Json.JsonTextReader)">
            <summary>
            Creates a new JSON Parser Context
            </summary>
            <param name="g">Graph to parse into</param>
            <param name="input">JSON Text Reader to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.JsonParserContext.#ctor(VDS.RDF.IRdfHandler,Newtonsoft.Json.JsonTextReader)">
            <summary>
            Creates a new JSON Parser Context
            </summary>
            <param name="handler">RDF Handler to use</param>
            <param name="input">JSON Text Reader to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.JsonParserContext.GetPositionRange(VDS.RDF.Parsing.PositionInfo)">
            <summary>
            Gets the Position range from the given Start Position to the current Position
            </summary>
            <param name="startPosition">Start Position</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.JsonParserContext.Input">
            <summary>
            Gets the JSON Text Reader which input is read from
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.JsonParserContext.CurrentPosition">
            <summary>
            Gets the Current Position of the JSON Text Reader
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Contexts.Notation3ParserContext">
            <summary>
            Parser Context for Notation 3 Parsers
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.Notation3ParserContext.#ctor(VDS.RDF.IGraph,VDS.RDF.Parsing.Tokens.ITokeniser)">
            <summary>
            Creates a new Notation 3 Parser Context with default settings
            </summary>
            <param name="g">Graph to parse into</param>
            <param name="tokeniser">Tokeniser to use</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.Notation3ParserContext.#ctor(VDS.RDF.IGraph,VDS.RDF.Parsing.Tokens.ITokeniser,VDS.RDF.Parsing.Tokens.TokenQueueMode)">
            <summary>
            Creates a new Notation 3 Parser Context with custom settings
            </summary>
            <param name="g">Graph to parse into</param>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="queueMode">Tokeniser Queue Mode</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.Notation3ParserContext.#ctor(VDS.RDF.IGraph,VDS.RDF.Parsing.Tokens.ITokeniser,System.Boolean,System.Boolean)">
            <summary>
            Creates a new Notation 3 Parser Context with custom settings
            </summary>
            <param name="g">Graph to parse into</param>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="traceParsing">Whether to trace parsing</param>
            <param name="traceTokeniser">Whether to trace tokenisation</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.Notation3ParserContext.#ctor(VDS.RDF.IGraph,VDS.RDF.Parsing.Tokens.ITokeniser,VDS.RDF.Parsing.Tokens.TokenQueueMode,System.Boolean,System.Boolean)">
            <summary>
            Creates a new Notation 3 Parser Context with custom settings
            </summary>
            <param name="g">Graph to parse into</param>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="queueMode">Tokeniser Queue Mode</param>
            <param name="traceParsing">Whether to trace parsing</param>
            <param name="traceTokeniser">Whether to trace tokenisation</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.Notation3ParserContext.#ctor(VDS.RDF.IRdfHandler,VDS.RDF.Parsing.Tokens.ITokeniser)">
            <summary>
            Creates a new Notation 3 Parser Context with default settings
            </summary>
            <param name="handler">RDF Handler to use</param>
            <param name="tokeniser">Tokeniser to use</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.Notation3ParserContext.#ctor(VDS.RDF.IRdfHandler,VDS.RDF.Parsing.Tokens.ITokeniser,VDS.RDF.Parsing.Tokens.TokenQueueMode)">
            <summary>
            Creates a new Notation 3 Parser Context with custom settings
            </summary>
            <param name="handler">RDF Handler to use</param>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="queueMode">Tokeniser Queue Mode</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.Notation3ParserContext.#ctor(VDS.RDF.IRdfHandler,VDS.RDF.Parsing.Tokens.ITokeniser,System.Boolean,System.Boolean)">
            <summary>
            Creates a new Notation 3 Parser Context with custom settings
            </summary>
            <param name="handler">RDF Handler to use</param>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="traceParsing">Whether to trace parsing</param>
            <param name="traceTokeniser">Whether to trace tokenisation</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.Notation3ParserContext.#ctor(VDS.RDF.IRdfHandler,VDS.RDF.Parsing.Tokens.ITokeniser,VDS.RDF.Parsing.Tokens.TokenQueueMode,System.Boolean,System.Boolean)">
            <summary>
            Creates a new Notation 3 Parser Context with custom settings
            </summary>
            <param name="handler">RDF Handler to use</param>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="queueMode">Tokeniser Queue Mode</param>
            <param name="traceParsing">Whether to trace parsing</param>
            <param name="traceTokeniser">Whether to trace tokenisation</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.Notation3ParserContext.PushGraph">
            <summary>
            Pushes the current in-scope Graph onto the Graph stack and creates a new empty Graph to be the in-scope Graph
            </summary>
            <remarks>
            Used for Graph Literal parsing - Base Uri and Namespace Maps of the outermost Graph is propogated to the innermost Graph
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.Notation3ParserContext.PopGraph">
            <summary>
            Pops a Graph from the Graph stack to become the in-scope Graph
            </summary>
            <remarks>
            Used for Graph Literal parsing
            </remarks>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.Notation3ParserContext.KeywordsMode">
            <summary>
            Gets/Sets whether Keywords Mode is in use
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.Notation3ParserContext.Keywords">
            <summary>
            Gets the list of in-use Keywords
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.Notation3ParserContext.VariableContext">
            <summary>
            Gets the Variable Context for Triples
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.Notation3ParserContext.SubGraph">
            <summary>
            Gets the current sub-graph (if any)
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.Notation3ParserContext.GraphLiteralMode">
            <summary>
            Gets whether the Context is currently for a Graph Literal
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Contexts.RdfXmlParserContext">
            <summary>
            Parser Context for RDF/XML Parser
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.RdfXmlParserContext.#ctor(VDS.RDF.IGraph,System.IO.Stream)">
            <summary>
            Creates a new Parser Context which uses Streaming parsing
            </summary>
            <param name="g">Graph</param>
            <param name="stream">Stream</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.RdfXmlParserContext.#ctor(VDS.RDF.IRdfHandler,System.IO.Stream)">
            <summary>
            Creates a new Parser Context which uses Streaming parsing
            </summary>
            <param name="handler">RDF Handler</param>
            <param name="stream">Stream</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.RdfXmlParserContext.#ctor(VDS.RDF.IGraph,System.IO.TextReader)">
            <summary>
            Creates a new Parser Context which uses Streaming parsing
            </summary>
            <param name="g">Graph</param>
            <param name="input">Input</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.RdfXmlParserContext.#ctor(VDS.RDF.IRdfHandler,System.IO.TextReader)">
            <summary>
            Creates a new Parser Context which uses Streaming parsing
            </summary>
            <param name="handler">RDF Handler</param>
            <param name="input">Input</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.RdfXmlParserContext.Events">
            <summary>
            Gets the Event Queue
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.RdfXmlParserContext.IDs">
            <summary>
            Gets the Mapping of in-use IDs
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Contexts.SparqlJsonParserContext">
            <summary>
            SPARQL JSON Parser Context
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.SparqlJsonParserContext.#ctor(Newtonsoft.Json.JsonTextReader,VDS.RDF.ISparqlResultsHandler)">
            <summary>
            Creates a new Parser Context
            </summary>
            <param name="reader">JSON Text Reader</param>
            <param name="handler">Results Handler</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.SparqlJsonParserContext.#ctor(Newtonsoft.Json.JsonTextReader,VDS.RDF.Query.SparqlResultSet)">
            <summary>
            Creates a new Parser Context
            </summary>
            <param name="reader">JSON Text Reader</param>
            <param name="results">SPARQL Result Set</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.SparqlJsonParserContext.Input">
            <summary>
            Gets the JSON Text Reader
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Contexts.SparqlQueryParserContext">
            <summary>
            Parser Context for SPARQL Query parser
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.SparqlQueryParserContext.#ctor(VDS.RDF.Parsing.Tokens.ITokeniser)">
            <summary>
            Creates a new SPARQL Query Parser Context with default settings
            </summary>
            <param name="tokeniser">Tokeniser to use</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.SparqlQueryParserContext.#ctor(VDS.RDF.Parsing.Tokens.ITokeniser,VDS.RDF.Parsing.Tokens.TokenQueueMode)">
            <summary>
            Creates a new SPARQL Query Parser Context with custom settings
            </summary>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="queueMode">Tokeniser Queue Mode</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.SparqlQueryParserContext.#ctor(VDS.RDF.Parsing.Tokens.ITokeniser,System.Boolean,System.Boolean)">
            <summary>
            Creates a new SPARQL Query Parser Context with custom settings
            </summary>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="traceParsing">Whether to trace parsing</param>
            <param name="traceTokeniser">Whether to trace tokenisation</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.SparqlQueryParserContext.#ctor(VDS.RDF.Parsing.Tokens.ITokeniser,VDS.RDF.Parsing.Tokens.TokenQueueMode,System.Boolean,System.Boolean)">
            <summary>
            Creates a new SPARQL Query Parser Context with custom settings
            </summary>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="queueMode">Tokeniser Queue Mode</param>
            <param name="traceParsing">Whether to trace parsing</param>
            <param name="traceTokeniser">Whether to trace tokenisation</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.SparqlQueryParserContext.#ctor(VDS.RDF.Parsing.Contexts.SparqlQueryParserContext,VDS.RDF.Parsing.Tokens.ITokenQueue)">
            <summary>
            Creates a new SPARQL Query Parser Context for parsing sub-queries
            </summary>
            <param name="parent">Parent Query Parser Context</param>
            <param name="tokens">Tokens that need parsing to form a subquery</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.SparqlQueryParserContext.#ctor(VDS.RDF.Parsing.Tokens.ITokenQueue)">
            <summary>
            Creates a new Query Parser Context from the given Token Queue
            </summary>
            <param name="tokens">Token Queue</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.SparqlQueryParserContext.GetNewBlankNodeID">
            <summary>
            Gets a new Blank Node ID
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.SparqlQueryParserContext.Query">
            <summary>
            Gets the Query that this Parser Context is populating
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.SparqlQueryParserContext.VerbSeen">
            <summary>
            Gets/Sets whether the Query Verb has been seen
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.SparqlQueryParserContext.SubQueryMode">
            <summary>
            Returns whether this Parser Context is for a sub-query
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.SparqlQueryParserContext.SyntaxMode">
            <summary>
            Gets/Sets the Syntax that should be supported
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.SparqlQueryParserContext.DefaultBaseUri">
            <summary>
            Gets/Sets the default Base Uri to resolve relative URIs against
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.SparqlQueryParserContext.ExpressionParser">
            <summary>
            Gets the Expression Parser
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.SparqlQueryParserContext.PathParser">
            <summary>
            Gets the Property Path Parser
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.SparqlQueryParserContext.GraphPatternID">
            <summary>
            Gets/Sets the current Graph Pattern ID
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.SparqlQueryParserContext.BlankNodeIDUsages">
            <summary>
            Gets the mapping of in use Blank Nodes IDs
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.SparqlQueryParserContext.BlankNodeID">
            <summary>
            Gets the last Blank Node ID that was issued
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.SparqlQueryParserContext.CheckBlankNodeScope">
            <summary>
            Gets/Sets whether Blank Node scoping must be checked
            </summary>
            <remarks>
            If false then only name tracking will be done to prevent auto-generated IDs colliding with user allocated IDs
            </remarks>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.SparqlQueryParserContext.NextAliasID">
            <summary>
            Gets the Next Available Alias ID for aliasing Project Expressions and Aggregates which don't have an Aggregate Specified
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.SparqlQueryParserContext.ExpressionFactories">
            <summary>
            Gets the Custom Expression Factories valid for this Parser
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Contexts.SparqlRdfParserContext">
            <summary>
            Parser Context for SPARQL RDF Parser
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.SparqlRdfParserContext.#ctor(VDS.RDF.IGraph,VDS.RDF.ISparqlResultsHandler)">
            <summary>
            Creates a new Parser Context
            </summary>
            <param name="g">Graph to parse from</param>
            <param name="handler">Results Handler</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.SparqlRdfParserContext.#ctor(VDS.RDF.IGraph,VDS.RDF.Query.SparqlResultSet)">
            <summary>
            Creates a new Parser Context
            </summary>
            <param name="g">Graph to parse from</param>
            <param name="results">Results Handler</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.SparqlRdfParserContext.Graph">
            <summary>
            Gets the Graph being parsed from
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Contexts.SparqlUpdateParserContext">
            <summary>
            Parser Context for SPARQL Update Parser
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.SparqlUpdateParserContext.#ctor(VDS.RDF.Parsing.Tokens.ITokeniser)">
            <summary>
            Creates a new SPARQL Update Parser Context
            </summary>
            <param name="tokeniser">Tokeniser</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.SparqlUpdateParserContext.#ctor(VDS.RDF.Parsing.Tokens.ITokeniser,VDS.RDF.Parsing.Tokens.TokenQueueMode)">
            <summary>
            Creates a new SPARQL Update Parser Context with custom settings
            </summary>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="queueMode">Tokeniser Queue Mode</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.SparqlUpdateParserContext.#ctor(VDS.RDF.Parsing.Tokens.ITokeniser,System.Boolean,System.Boolean)">
            <summary>
            Creates a new SPARQL Update Parser Context with custom settings
            </summary>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="traceParsing">Whether to trace parsing</param>
            <param name="traceTokeniser">Whether to trace tokenisation</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.SparqlUpdateParserContext.#ctor(VDS.RDF.Parsing.Tokens.ITokeniser,VDS.RDF.Parsing.Tokens.TokenQueueMode,System.Boolean,System.Boolean)">
            <summary>
            Creates a new SPARQL Update Parser Context with custom settings
            </summary>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="queueMode">Tokeniser Queue Mode</param>
            <param name="traceParsing">Whether to trace parsing</param>
            <param name="traceTokeniser">Whether to trace tokenisation</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.SparqlUpdateParserContext.CommandSet">
            <summary>
            Gets the Update Command Set that is being populated
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.SparqlUpdateParserContext.ExpressionParser">
            <summary>
            Gets the Expression Parser
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.SparqlUpdateParserContext.PathParser">
            <summary>
            Gets the Path Parser
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.SparqlUpdateParserContext.QueryParser">
            <summary>
            Gets the Query Parser
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.SparqlUpdateParserContext.NamespaceMap">
            <summary>
            Gets the Namespace Map
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.SparqlUpdateParserContext.ExpressionFactories">
            <summary>
            Gets/Sets the locally scoped custom expression factories
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.SparqlUpdateParserContext.DataBNodes">
            <summary>
            Gets the set of BNodes used in INSERT DATA commands so far
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Contexts.SparqlXmlParserContext">
            <summary>
            Parser Context for SPARQL XML Results parsers
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.SparqlXmlParserContext.#ctor(System.Xml.XmlReader,VDS.RDF.ISparqlResultsHandler)">
            <summary>
            Creates a new Parser Context
            </summary>
            <param name="reader">XML Reader</param>
            <param name="handler">Results Handler</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.SparqlXmlParserContext.#ctor(System.Xml.XmlReader,VDS.RDF.Query.SparqlResultSet)">
            <summary>
            Creates a new Parser Context
            </summary>
            <param name="reader">XML Reader</param>
            <param name="results">Results Set to load into</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.SparqlXmlParserContext.Input">
            <summary>
            Gets the XML Reader
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Contexts.TriGParserContext">
            <summary>
            Parser Context class for TriG Parsers
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TriGParserContext.#ctor(VDS.RDF.ITripleStore,VDS.RDF.Parsing.Tokens.ITokeniser)">
            <summary>
            Creates a new TriG Parser Context with default settings
            </summary>
            <param name="store">Store to parse into</param>
            <param name="tokeniser">Tokeniser to use</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TriGParserContext.#ctor(VDS.RDF.ITripleStore,VDS.RDF.Parsing.Tokens.ITokeniser,VDS.RDF.Parsing.Tokens.TokenQueueMode)">
            <summary>
            Creates a new TrigG Parser Context with custom settings
            </summary>
            <param name="store">Store to parse into</param>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="queueMode">Tokeniser Queue Mode</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TriGParserContext.#ctor(VDS.RDF.ITripleStore,VDS.RDF.Parsing.Tokens.ITokeniser,System.Boolean,System.Boolean)">
            <summary>
            Creates a new TriG Parser Context with custom settings
            </summary>
            <param name="store">Store to parse into</param>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="traceParsing">Whether to trace parsing</param>
            <param name="traceTokeniser">Whether to trace tokenisation</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TriGParserContext.#ctor(VDS.RDF.ITripleStore,VDS.RDF.Parsing.Tokens.ITokeniser,VDS.RDF.Parsing.Tokens.TokenQueueMode,System.Boolean,System.Boolean)">
            <summary>
            Creates a new TriG Parser Context with custom settings
            </summary>
            <param name="store">Store to parse into</param>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="queueMode">Tokeniser Queue Mode</param>
            <param name="traceParsing">Whether to trace parsing</param>
            <param name="traceTokeniser">Whether to trace tokenisation</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TriGParserContext.#ctor(VDS.RDF.IRdfHandler,VDS.RDF.Parsing.Tokens.ITokeniser)">
            <summary>
            Creates a new TriG Parser Context with default settings
            </summary>
            <param name="handler">Store to parse into</param>
            <param name="tokeniser">Tokeniser to use</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TriGParserContext.#ctor(VDS.RDF.IRdfHandler,VDS.RDF.Parsing.Tokens.ITokeniser,VDS.RDF.Parsing.Tokens.TokenQueueMode)">
            <summary>
            Creates a new TrigG Parser Context with custom settings
            </summary>
            <param name="handler">Store to parse into</param>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="queueMode">Tokeniser Queue Mode</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TriGParserContext.#ctor(VDS.RDF.IRdfHandler,VDS.RDF.Parsing.Tokens.ITokeniser,System.Boolean,System.Boolean)">
            <summary>
            Creates a new TriG Parser Context with custom settings
            </summary>
            <param name="handler">Store to parse into</param>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="traceParsing">Whether to trace parsing</param>
            <param name="traceTokeniser">Whether to trace tokenisation</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Contexts.TriGParserContext.#ctor(VDS.RDF.IRdfHandler,VDS.RDF.Parsing.Tokens.ITokeniser,VDS.RDF.Parsing.Tokens.TokenQueueMode,System.Boolean,System.Boolean)">
            <summary>
            Creates a new TriG Parser Context with custom settings
            </summary>
            <param name="handler">Store to parse into</param>
            <param name="tokeniser">Tokeniser to use</param>
            <param name="queueMode">Tokeniser Queue Mode</param>
            <param name="traceParsing">Whether to trace parsing</param>
            <param name="traceTokeniser">Whether to trace tokenisation</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.TriGParserContext.DefaultGraphExists">
            <summary>
            Gets/Sets whether the Default Graph exists
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Contexts.TriGParserContext.Syntax">
            <summary>
            Gets/Sets the Syntax to be used
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.DataUriLoader">
            <summary>
            A Class for parsing RDF data from Data URIs
            </summary>
            <remarks>
            <para>
            Data URIs use the data: scheme and are defined by the IETF in <a href="http://tools.ietf.org/html/rfc2397">RFC 2397</a> and provide a means to embed data directly in a URI either in Base64 or ASCII encoded format.  This class can extract the data from such URIs and attempt to parse it as RDF using the <see cref="T:VDS.RDF.Parsing.StringParser">StringParser</see>
            </para>
            <para>
            The parsing process for data: URIs involves first extracting and decoding the data embedded in the URI - this may either be in Base64 or ASCII encoding - and then using the <see cref="T:VDS.RDF.Parsing.StringParser">StringParser</see> to actually parse the data string.  If the data: URI defines a MIME type then a parser is selected (if one exists for the given MIME type) and that is used to parse the data, in the event that no MIME type is given or the one given does not have a corresponding parser then the <see cref="T:VDS.RDF.Parsing.StringParser">StringParser</see> will use its basic heuristics to attempt to auto-detect the format and select an appropriate parser.
            </para>
            <para>
            If you attempt to use this loader for non data: URIs then the standard <see cref="T:VDS.RDF.Parsing.UriLoader">UriLoader</see> is used instead.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.DataUriLoader.Load(VDS.RDF.IGraph,System.Uri)">
            <summary>
            Loads RDF data into a Graph from a data: URI
            </summary>
            <param name="g">Graph to load into</param>
            <param name="u">URI to load from</param>
            <remarks>
            Invokes the normal <see cref="T:VDS.RDF.Parsing.UriLoader">UriLoader</see> instead if a the URI provided is not a data: URI
            </remarks>
            <exception cref="!:UriFormatException">Thrown if the metadata portion of the URI which indicates the MIME Type, Character Set and whether Base64 encoding is used is malformed</exception>
        </member>
        <member name="M:VDS.RDF.Parsing.DataUriLoader.Load(VDS.RDF.IRdfHandler,System.Uri)">
            <summary>
            Loads RDF data using an RDF Handler from a data: URI
            </summary>
            <param name="handler">RDF Handler</param>
            <param name="u">URI to load from</param>
            <remarks>
            Invokes the normal <see cref="T:VDS.RDF.Parsing.UriLoader">UriLoader</see> instead if a the URI provided is not a data: URI
            </remarks>
            <exception cref="!:UriFormatException">Thrown if the metadata portion of the URI which indicates the MIME Type, Character Set and whether Base64 encoding is used is malformed</exception>
        </member>
        <member name="T:VDS.RDF.Parsing.EmbeddedResourceLoader">
            <summary>
            Static Helper Class for loading Graphs and Triple Stores from Embedded Resources
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.EmbeddedResourceLoader.Load(VDS.RDF.IGraph,System.String,VDS.RDF.IRdfReader)">
            <summary>
            Loads a Graph from an Embedded Resource
            </summary>
            <param name="g">Graph to load into</param>
            <param name="resource">Assembly Qualified Name of the Resource to load</param>
            <param name="parser">Parser to use (leave null for auto-selection)</param>
        </member>
        <member name="M:VDS.RDF.Parsing.EmbeddedResourceLoader.Load(VDS.RDF.IRdfHandler,System.String,VDS.RDF.IRdfReader)">
            <summary>
            Loads a Graph from an Embedded Resource
            </summary>
            <param name="handler">RDF Handler to use</param>
            <param name="resource">Assembly Qualified Name of the Resource to load</param>
            <param name="parser">Parser to use (leave null for auto-selection)</param>
        </member>
        <member name="M:VDS.RDF.Parsing.EmbeddedResourceLoader.Load(VDS.RDF.IRdfHandler,System.String)">
            <summary>
            Loads a Graph from an Embedded Resource
            </summary>
            <param name="handler">RDF Handler to use</param>
            <param name="resource">Assembly Qualified Name of the Resource to load</param>
        </member>
        <member name="M:VDS.RDF.Parsing.EmbeddedResourceLoader.Load(VDS.RDF.IGraph,System.String)">
            <summary>
            Loads a Graph from an Embedded Resource
            </summary>
            <param name="g">Graph to load into</param>
            <param name="resource">Assembly Qualified Name of the Resource to load</param>
            <remarks>
            Parser will be auto-selected
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.EmbeddedResourceLoader.LoadGraphInternal(VDS.RDF.IRdfHandler,System.Reflection.Assembly,System.String,VDS.RDF.IRdfReader)">
            <summary>
            Internal Helper method which does the actual loading of the Graph from the Resource
            </summary>
            <param name="handler">RDF Handler to use</param>
            <param name="asm">Assembly to get the resource stream from</param>
            <param name="resource">Full name of the Resource (without the Assembly Name)</param>
            <param name="parser">Parser to use (if null then will be auto-selected)</param>
        </member>
        <member name="M:VDS.RDF.Parsing.EmbeddedResourceLoader.Load(VDS.RDF.ITripleStore,System.String,VDS.RDF.IStoreReader)">
            <summary>
            Loads a RDF Dataset from an Embedded Resource
            </summary>
            <param name="store">Store to load into</param>
            <param name="resource">Assembly Qualified Name of the Resource to load</param>
            <param name="parser">Parser to use (leave null for auto-selection)</param>
        </member>
        <member name="M:VDS.RDF.Parsing.EmbeddedResourceLoader.Load(VDS.RDF.ITripleStore,System.String)">
            <summary>
            Loads a RDF Dataset from an Embedded Resource
            </summary>
            <param name="store">Store to load into</param>
            <param name="resource">Assembly Qualified Name of the Resource to load</param>
            <remarks>
            Parser will be auto-selected
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.EmbeddedResourceLoader.Load(VDS.RDF.IRdfHandler,System.String,VDS.RDF.IStoreReader)">
            <summary>
            Loads a RDF Dataset from an Embedded Resource
            </summary>
            <param name="handler">RDF Handler to use</param>
            <param name="resource">Assembly Qualified Name of the Resource to load</param>
            <param name="parser">Parser to use (leave null for auto-selection)</param>
        </member>
        <member name="M:VDS.RDF.Parsing.EmbeddedResourceLoader.LoadDataset(VDS.RDF.IRdfHandler,System.String)">
            <summary>
            Loads a RDF Dataset from an Embedded Resource
            </summary>
            <param name="handler">RDF Handler to use</param>
            <param name="resource">Assembly Qualified Name of the Resource to load</param>
        </member>
        <member name="M:VDS.RDF.Parsing.EmbeddedResourceLoader.LoadDatasetInternal(VDS.RDF.IRdfHandler,System.Reflection.Assembly,System.String,VDS.RDF.IStoreReader)">
            <summary>
            Internal Helper method which does the actual loading of the Triple Store from the Resource
            </summary>
            <param name="handler">RDF Handler to use</param>
            <param name="asm">Assembly to get the resource stream from</param>
            <param name="resource">Full name of the Resource (without the Assembly Name)</param>
            <param name="parser">Parser to use (if null will be auto-selected)</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.EventQueue`1">
            <summary>
            Represents a Queue of events for use by event based parsers
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.BaseEventQueue`1">
            <summary>
            Abstract base implementation of an Event Queue
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.IEventQueue`1">
            <summary>
            Interface for implementing Event Queues which provide Bufferable wrappers to Event Generators
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.IEventQueue`1.Dequeue">
            <summary>
            Removes the first Event from the Queue
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.IEventQueue`1.Enqueue(`0)">
            <summary>
            Adds an Event to the end of the Queue
            </summary>
            <param name="e">Event to add</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.IEventQueue`1.Peek">
            <summary>
            Gets the first Event from the Queue without removing it
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.IEventQueue`1.Clear">
            <summary>
            Clears the Event Queue
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.IEventQueue`1.EventGenerator">
            <summary>
            Gets the Event Generator that this Queue uses
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.IEventQueue`1.Count">
            <summary>
            Gets the number of Events in the Queue
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.IEventQueue`1.Tracing">
            <summary>
            Gets/Sets whether Generator Tracing should be used
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.IEventQueue`1.LastEventType">
            <summary>
            Gets the Event Type of the last Event dequeued
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Events.BaseEventQueue`1._eventgen">
            <summary>
            Generator used to fill the Event Queue
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Events.BaseEventQueue`1._tracing">
            <summary>
            Variable indicating whether Generator Tracing is enabled
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Events.BaseEventQueue`1._lasteventtype">
            <summary>
            Type of Last Event dequeued
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.BaseEventQueue`1.Dequeue">
            <summary>
            Dequeues an Event from the Queue
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.BaseEventQueue`1.Enqueue(`0)">
            <summary>
            Adds an Event to the Queue
            </summary>
            <param name="e">Event</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.BaseEventQueue`1.Peek">
            <summary>
            Gets the next Event from the Queue without removing it from the queue
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.BaseEventQueue`1.Clear">
            <summary>
            Clears the Event Queue
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.BaseEventQueue`1.EventGenerator">
            <summary>
            Gets the Event Generator used by the Queue
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.BaseEventQueue`1.Count">
            <summary>
            Gets the number of Events in the Queue
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.BaseEventQueue`1.Tracing">
            <summary>
            Gets/Sets Tracing for the Event Queue
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.BaseEventQueue`1.LastEventType">
            <summary>
            Gets the Event Type of the last Event dequeued
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Events.EventQueue`1._events">
            <summary>
            Queue of Events
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.EventQueue`1.#ctor">
            <summary>
            Creates a new Event Queue
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.EventQueue`1.#ctor(VDS.RDF.Parsing.Events.IEventGenerator{`0})">
            <summary>
            Creates a new Event Queue with the given Event Generator
            </summary>
            <param name="generator">Event Generator</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.EventQueue`1.Dequeue">
            <summary>
            Dequeues and returns the next event in the Queue
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.EventQueue`1.Enqueue(`0)">
            <summary>
            Adds an event to the end of the Queue
            </summary>
            <param name="e">Event</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.EventQueue`1.Peek">
            <summary>
            Peeks and returns the next event in the Queue
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.EventQueue`1.Clear">
            <summary>
            Clears the Queue
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.EventQueue`1.Count">
            <summary>
            Gets the number of events currently in the Queue
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.StreamingEventQueue`1">
            <summary>
            Represents a Queue of events which are streamed from an instance of a <see cref="T:VDS.RDF.Parsing.Events.IJitEventGenerator`1">IJitEventGenerator</see> for use by an event based parser
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.StreamingEventQueue`1.#ctor(VDS.RDF.Parsing.Events.IJitEventGenerator{`0})">
            <summary>
            Creates a new Streaming Event Queue
            </summary>
            <param name="generator">Event Generator</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.StreamingEventQueue`1.Enqueue(`0)">
            <summary>
            Adds an event to the Queue
            </summary>
            <param name="e">Event</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.StreamingEventQueue`1.Dequeue">
            <summary>
            Gets the next event from the Queue and removes it from the Queue
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.StreamingEventQueue`1.Peek">
            <summary>
            Gets the next event from the Queue while leaving the Queue unchanged
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.StreamingEventQueue`1.Count">
            <summary>
            Gets the Count of events in the queue
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.IEventGenerator`1">
            <summary>
            Interface for Event Generators
            </summary>
            <remarks>
            <para>
            An Event Generator is a class which takes an input stream which contains XML and generates a series of events from it
            </para>
            <para>
            This interface is a marker interface which indicates that the class is an event generator, implementations should implement one of the concrete derived interfaces as appropriate to their mode of operation.
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.IPreProcessingEventGenerator`2">
            <summary>
            Interface for pre-processing event generators
            </summary>
            <typeparam name="TEvent">Event Type</typeparam>
            <typeparam name="TContext">Event Parser Context Type</typeparam>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.IPreProcessingEventGenerator`2.GetAllEvents(`1)">
            <summary>
            Gets all available events
            </summary>
            <param name="context">Context</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.IRdfXmlPreProcessingEventGenerator">
            <summary>
            Interface for event generators which generate all RDF/XML events in one go prior to parsing taking place
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.IJitEventGenerator`1">
            <summary>
            Interface for Just-in-time event generators
            </summary>
            <typeparam name="T">Event Type</typeparam>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.IJitEventGenerator`1.GetNextEvent">
            <summary>
            Gets the next available event
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.IJitEventGenerator`1.Finished">
            <summary>
            Gets whether the Event Generator has finished reading events i.e. there are no further events available
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.IRdfXmlJitEventGenerator">
            <summary>
            Interface for RDF/XML event generators which generate events as required during the parsing process
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Handlers.CancellableHandler">
            <summary>
            A RDF Handler which wraps another Handler allowing handling to be cancelled
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.CancellableHandler.#ctor(VDS.RDF.IRdfHandler)">
            <summary>
            Creates a new Cancellable Handler
            </summary>
            <param name="handler"></param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.CancellableHandler.StartRdfInternal">
            <summary>
            Starts RDF Handling on the inner Handler
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.CancellableHandler.EndRdfInternal(System.Boolean)">
            <summary>
            Ends RDF Handling on the inner Handler
            </summary>
            <param name="ok">Indicates whether parsing completed without error</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.CancellableHandler.HandleBaseUriInternal(System.Uri)">
            <summary>
            Handles Base URIs by passing them to the inner handler and cancelling handling if it has been requested
            </summary>
            <param name="baseUri">Base URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.CancellableHandler.HandleNamespaceInternal(System.String,System.Uri)">
            <summary>
            Handles Namespace Declarations by passing them to the inner handler and cancelling handling if it has been requested
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="namespaceUri">Namespace URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.CancellableHandler.HandleTripleInternal(VDS.RDF.Triple)">
            <summary>
            Handles Triples by passing them to the inner handler and cancelling handling if it has been requested
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.CancellableHandler.Cancel">
            <summary>
            Informs the Handler that it should cancel handling at the next point possible assuming handling has not already completed
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Handlers.CancellableHandler.InnerHandlers">
            <summary>
            Gets the Inner Handler wrapped by this Handler
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Handlers.CancellableHandler.AcceptsAll">
            <summary>
            Gets that this Handler does not accept all Triples
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Handlers.HandlerExtensions">
            <summary>
            Static Class of extension methods for use with Handler classes
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.HandlerExtensions.GetBaseUri(VDS.RDF.IRdfHandler)">
            <summary>
            Gets the Base URI from the RDF Handler
            </summary>
            <param name="handler">RDF Handler</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.HandlerExtensions.Apply(VDS.RDF.IRdfHandler,VDS.RDF.IGraph)">
            <summary>
            Applies the triples of a Graph to an RDF Handler
            </summary>
            <param name="handler">RDF Handler</param>
            <param name="g">Graph</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.HandlerExtensions.Apply(VDS.RDF.IRdfHandler,System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Applies the triples to an RDF Handler
            </summary>
            <param name="handler">RDF Handler</param>
            <param name="ts">Triples</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.HandlerExtensions.Apply(VDS.RDF.ISparqlResultsHandler,VDS.RDF.Query.SparqlResultSet)">
            <summary>
            Applies the result set to a Results Handler
            </summary>
            <param name="handler">Results Handler</param>
            <param name="results">Result Set</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Handlers.MultisetHandler">
            <summary>
            A SPARQL Results Handler which loads directly into a <see cref="T:VDS.RDF.Query.Algebra.Multiset">Multiset</see>
            </summary>
            <remarks>
            Primarily intended for internal usage for future optimisation of some SPARQL evaluation
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.MultisetHandler.#ctor(VDS.RDF.Query.Algebra.Multiset)">
            <summary>
            Creates a new Multiset Handler
            </summary>
            <param name="mset">Multiset</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.MultisetHandler.HandleBooleanResultInternal(System.Boolean)">
            <summary>
            Handles a Boolean Result by doing nothing
            </summary>
            <param name="result">Boolean Result</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.MultisetHandler.HandleVariableInternal(System.String)">
            <summary>
            Handles a Variable by adding it to the Multiset
            </summary>
            <param name="var">Variable</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.MultisetHandler.HandleResultInternal(VDS.RDF.Query.SparqlResult)">
            <summary>
            Handles a Result by adding it to the Multiset
            </summary>
            <param name="result">Result</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Parsing.Handlers.ResultCountHandler">
            <summary>
            A SPARQL Results Handler which just counts Results
            </summary>
            <remarks>
            <strong>Note: </strong> For a Boolean Result Set the counter will either be 1 for true or 0 for false
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.ResultCountHandler.#ctor">
            <summary>
            Creates a new Result Count Handler
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.ResultCountHandler.StartResultsInternal">
            <summary>
            Starts Results Handling and resets the counter to zero
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.ResultCountHandler.HandleBooleanResultInternal(System.Boolean)">
            <summary>
            Handles a Boolean Result
            </summary>
            <param name="result">Result</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.ResultCountHandler.HandleVariableInternal(System.String)">
            <summary>
            Handles a Variable Declaration
            </summary>
            <param name="var">Variable Name</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.ResultCountHandler.HandleResultInternal(VDS.RDF.Query.SparqlResult)">
            <summary>
            Handles a SPARQL Result by incrementing the counter
            </summary>
            <param name="result">Result</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Parsing.Handlers.ResultCountHandler.Count">
            <summary>
            Gets the Count of Results 
            </summary>
            <remarks>
            For Boolean Results counter will be either 1 or 0 depending on whether the result was True/False
            </remarks>
        </member>
        <member name="T:VDS.RDF.Parsing.Handlers.ResultSetHandler">
            <summary>
            A SPARQL Results Handler which loads Results into a <see cref="T:VDS.RDF.Query.SparqlResultSet">SparqlResultSet</see>
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.ResultSetHandler.#ctor(VDS.RDF.Query.SparqlResultSet)">
            <summary>
            Creates a new Result Set Handler
            </summary>
            <param name="results">Result Set</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.ResultSetHandler.StartResultsInternal">
            <summary>
            Starts Results Handling
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.ResultSetHandler.HandleBooleanResultInternal(System.Boolean)">
            <summary>
            Handles a Boolean Result by setting the <see cref="P:VDS.RDF.Query.SparqlResultSet.Result">Result</see> property of the Result Set
            </summary>
            <param name="result">Result</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.ResultSetHandler.HandleVariableInternal(System.String)">
            <summary>
            Handles a Variable Declaration by adding the Variable to the Result Set
            </summary>
            <param name="var">Variable Name</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.ResultSetHandler.HandleResultInternal(VDS.RDF.Query.SparqlResult)">
            <summary>
            Handles a Result by adding it to the Result Set
            </summary>
            <param name="result">Result</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Parsing.Handlers.MergingResultSetHandler">
            <summary>
            A SPARQL Results Handler which allows you to load multiple Result Sets into a single <see cref="T:VDS.RDF.Query.SparqlResultSet">SparqlResultSet</see> which the standard <see cref="T:VDS.RDF.Parsing.Handlers.ResultSetHandler">ResultSetHandler</see> does not permit
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.MergingResultSetHandler.#ctor(VDS.RDF.Query.SparqlResultSet)">
            <summary>
            Creates a new Merging Result Set Handler
            </summary>
            <param name="results">Result Set</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.MergingResultSetHandler.StartResultsInternal">
            <summary>
            Overrides the base classes logic to avoid the empty check on the Result Set thus allowing multiple result sets to be merged
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Handlers.StoreCountHandler">
            <summary>
            A RDF Handler which simply counts the Triples and Graphs
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.StoreCountHandler.#ctor">
            <summary>
            Creates a new Store Count Handler
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.StoreCountHandler.StartRdfInternal">
            <summary>
            Starts RDF Handling by reseting the counters
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.StoreCountHandler.HandleTripleInternal(VDS.RDF.Triple)">
            <summary>
            Handles Triples/Quads by counting the Triples and distinct Graph URIs
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Parsing.Handlers.StoreCountHandler.TripleCount">
            <summary>
            Gets the count of Triples
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Handlers.StoreCountHandler.GraphCount">
            <summary>
            Gets the count of distinct Graph URIs
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Handlers.StoreCountHandler.AcceptsAll">
            <summary>
            Gets that this Handler accepts all Triples
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Handlers.MultiHandler">
            <summary>
            A Handler which passes the RDF to be handled to multiple Handlers where Handling terminates in the handling request where one of the Handlers returns false
            </summary>
            <remarks>
            <para>
            This differs from <see cref="T:VDS.RDF.Parsing.Handlers.ChainedHandler">ChainedHandler</see> in that even if one Handler indicates that handling should stop by returning false all the Handlers still have a chance to handle the Base URI/Namespace/Triple before handling is terminated.  All Handlers will always have their StartRdf and EndRdf methods called
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.MultiHandler.#ctor(System.Collections.Generic.IEnumerable{VDS.RDF.IRdfHandler})">
            <summary>
            Creates a new Multi Handler
            </summary>
            <param name="handlers">Inner Handlers for this Handler</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.MultiHandler.StartRdfInternal">
            <summary>
            Starts RDF Handling by starting handling on all inner handlers
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.MultiHandler.EndRdfInternal(System.Boolean)">
            <summary>
            Ends RDF Handling by ending handling on all inner handlers
            </summary>
            <param name="ok">Whether parsing completed without error</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.MultiHandler.HandleBaseUriInternal(System.Uri)">
            <summary>
            Handles Base URIs by getting all inner handlers to handle the Base URI
            </summary>
            <param name="baseUri">Base URI</param>
            <returns></returns>
            <remarks>
            Handling ends if any of the Handlers indicates it should stop but all Handlers are given the chance to finish the current handling action first
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.MultiHandler.HandleNamespaceInternal(System.String,System.Uri)">
            <summary>
            Handles Namespace Declarations by getting all inner handlers to handle it
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="namespaceUri">Namespace URI</param>
            <returns></returns>
            <remarks>
            Handling ends if any of the Handlers indicates it should stop but all Handlers are given the chance to finish the current handling action first
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.MultiHandler.HandleTripleInternal(VDS.RDF.Triple)">
            <summary>
            Handles Triples by getting all inner handlers to handler it
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
            <remarks>
            Handling ends if any of the Handlers indicates it should stop but all Handlers are given the chance to finish the current handling action first
            </remarks>
        </member>
        <member name="P:VDS.RDF.Parsing.Handlers.MultiHandler.InnerHandlers">
            <summary>
            Gets the Inner Handlers used by this Handler
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Handlers.MultiHandler.AcceptsAll">
            <summary>
            Gets whether this Handler accepts all Triples based on whether all inner handlers do so
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Handlers.ChainedHandler">
            <summary>
            A Handler which passes the RDF to be handled through a sequence of Handlers where Handling is terminated as soon as any Handler returns false
            </summary>
            <remarks>
            <para>
            This differs from the <see cref="T:VDS.RDF.Parsing.Handlers.MultiHandler">MultiHandler</see> in that as soon as any Handler indicates that handling should stop by returning false handling is <strong>immediately</strong> terminated.  All Handlers will always have their StartRdf and EndRdf methods called
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.ChainedHandler.#ctor(System.Collections.Generic.IEnumerable{VDS.RDF.IRdfHandler})">
            <summary>
            Creates a new Chained Handler
            </summary>
            <param name="handlers">Inner Handlers to use</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.ChainedHandler.StartRdfInternal">
            <summary>
            Starts the Handling of RDF for each inner handler
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.ChainedHandler.EndRdfInternal(System.Boolean)">
            <summary>
            Ends the Handling of RDF for each inner handler
            </summary>
            <param name="ok">Whether parsing completed without errors</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.ChainedHandler.HandleBaseUriInternal(System.Uri)">
            <summary>
            Handles Base URIs by getting each inner handler to attempt to handle it
            </summary>
            <param name="baseUri">Base URI</param>
            <returns></returns>
            <remarks>
            Handling terminates at the first Handler which indicates handling should stop
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.ChainedHandler.HandleNamespaceInternal(System.String,System.Uri)">
            <summary>
            Handles Namespaces by getting each inner handler to attempt to handle it
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="namespaceUri">Namespace URI</param>
            <returns></returns>
            <remarks>
            Handling terminates at the first Handler which indicates handling should stop
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.ChainedHandler.HandleTripleInternal(VDS.RDF.Triple)">
            <summary>
            Handles Triples by getting each inner handler to attempt to handle it
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
            <remarks>
            Handling terminates at the first Handler which indicates handling should stop
            </remarks>
        </member>
        <member name="P:VDS.RDF.Parsing.Handlers.ChainedHandler.InnerHandlers">
            <summary>
            Gets the Inner Handlers used by this Handler
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Handlers.ChainedHandler.AcceptsAll">
            <summary>
            Gets that this Handler accepts all Triples if all inner handlers do so
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Handlers.NullHandler">
            <summary>
            A RDF Handler that ignores everything it handles
            </summary>
            <remarks>
            Useful if you simply want to parse some RDF to see if it parses and don't care about the actual data being parsed
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.NullHandler.#ctor">
            <summary>
            Creates a new Null Handler
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.NullHandler.HandleTripleInternal(VDS.RDF.Triple)">
            <summary>
            Handles a Triple by doing nothing
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Parsing.Handlers.NullHandler.AcceptsAll">
            <summary>
            Indicates that the Handler accepts all Triples
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Handlers.CountHandler">
            <summary>
            A RDF Handler which simply counts the Triples
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.CountHandler.#ctor">
            <summary>
            Creates a Handler which counts Triples
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.CountHandler.StartRdfInternal">
            <summary>
            Resets the current count to zero
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.CountHandler.HandleTripleInternal(VDS.RDF.Triple)">
            <summary>
            Handles the Triple by incrementing the Triple count
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Parsing.Handlers.CountHandler.Count">
            <summary>
            Gets the Count of Triples handled in the most recent parsing operation
            </summary>
            <remarks>
            Note that each time you reuse the handler the count is reset to 0
            </remarks>
        </member>
        <member name="P:VDS.RDF.Parsing.Handlers.CountHandler.AcceptsAll">
            <summary>
            Gets that the Handler accepts all Triples
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Handlers.GraphHandler">
            <summary>
            A RDF Handler which asserts Triples into a Graph
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.GraphHandler.#ctor(VDS.RDF.IGraph)">
            <summary>
            Creates a new Graph Handler
            </summary>
            <param name="g">Graph</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.GraphHandler.StartRdfInternal">
            <summary>
            Starts Handling RDF ensuring that if the target Graph is non-empty RDF is handling into a temporary Graph until parsing completes successfully
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.GraphHandler.EndRdfInternal(System.Boolean)">
            <summary>
            Ends Handling RDF discarding the handled Triples if parsing failed (indicated by false for the <paramref name="ok">ok</paramref> parameter) and otherwise merging the handled triples from the temporary graph into the target graph if necessary
            </summary>
            <param name="ok">Indicates whether parsing completed OK</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.GraphHandler.HandleNamespaceInternal(System.String,System.Uri)">
            <summary>
            Handles Namespace Declarations by adding them to the Graphs Namespace Map
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="namespaceUri">Namespace URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.GraphHandler.HandleBaseUriInternal(System.Uri)">
            <summary>
            Handles Base URI Declarations by setting the Graphs Base URI
            </summary>
            <param name="baseUri">Base URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.GraphHandler.HandleTripleInternal(VDS.RDF.Triple)">
            <summary>
            Handles Triples by asserting them in the Graph
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Parsing.Handlers.GraphHandler.BaseUri">
            <summary>
            Gets the Base URI of the Graph currently being parsed into
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Handlers.GraphHandler.Graph">
            <summary>
            Gets the Graph that this handler wraps
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Handlers.GraphHandler.AcceptsAll">
            <summary>
            Gets that this Handler accepts all Triples
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Handlers.PagingHandler">
            <summary>
            A RDF Handler which wraps another handler passing only the chunk of triples falling within a given limit and offset to the underlying Handler
            </summary>
            <remarks>
            This handler does not guarantee that you will receive exactly the chunk specified by the limit and offset for two reasons:
            <ol>
            <li>It does not perform any sort of data de-duplication so it is possible that if this handler receives duplicate triples and the underlying handler performs de-duplication then you may see less triples than you expect in your final output since although the underlying handler will receive at most the specified chunk size of triples it may not retain them all</li>
            <li>If there are fewer triples than the chunk size or if the chunk exceeds the bounds of the data then you will only receive the triples that fall within the chunk (if any)</li>
            </ol>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.PagingHandler.#ctor(VDS.RDF.IRdfHandler,System.Int32,System.Int32)">
            <summary>
            Creates a new Paging Handler
            </summary>
            <param name="handler">Inner Handler to use</param>
            <param name="limit">Limit</param>
            <param name="offset">Offset</param>
            <remarks>
            If you just want to use an offset and not apply a limit then set limit to be less than zero
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.PagingHandler.#ctor(VDS.RDF.IRdfHandler,System.Int32)">
            <summary>
            Creates a new Paging Handler
            </summary>
            <param name="handler">Inner Handler to use</param>
            <param name="limit">Limit</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.PagingHandler.StartRdfInternal">
            <summary>
            Starts RDF Handler
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.PagingHandler.EndRdfInternal(System.Boolean)">
            <summary>
            Ends RDF Handler
            </summary>
            <param name="ok">Indicated whether parsing completed without error</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.PagingHandler.HandleTripleInternal(VDS.RDF.Triple)">
            <summary>
            Handles a Triple by passing it to the Inner Handler only if the Offset has been passed and the Limit has yet to be reached
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
            <remarks>
            Terminates handling immediately upon the reaching of the limit
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.PagingHandler.HandleNamespaceInternal(System.String,System.Uri)">
            <summary>
            Handles Namespace Declarations by allowing the inner handler to handle it
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="namespaceUri">Namespace URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.PagingHandler.HandleBaseUriInternal(System.Uri)">
            <summary>
            Handles Base URI Declarations by allowing the inner handler to handle it
            </summary>
            <param name="baseUri">Base URI</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Handlers.PagingHandler.InnerHandlers">
            <summary>
            Gets the Inner Handler wrapped by this Handler
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Handlers.PagingHandler.AcceptsAll">
            <summary>
            Gets whether the Handler will accept all Triples based on its Limit setting
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Handlers.StoreHandler">
            <summary>
            A RDF Handler that loads Quads into a <see cref="T:VDS.RDF.ITripleStore">ITripleStore</see> instance
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.StoreHandler.#ctor(VDS.RDF.ITripleStore)">
            <summary>
            Creates a new Store Handler
            </summary>
            <param name="store">Triple Store</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.StoreHandler.HandleNamespaceInternal(System.String,System.Uri)">
            <summary>
            Handles namespaces by adding them to each graph
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="namespaceUri">Namespace URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.StoreHandler.HandleTripleInternal(VDS.RDF.Triple)">
            <summary>
            Handles Triples by asserting them into the appropriate Graph creating the Graph if necessary
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.StoreHandler.StartRdfInternal">
            <summary>
            Starts handling RDF
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.StoreHandler.EndRdfInternal(System.Boolean)">
            <summary>
            Ends RDF handling and propogates all discovered namespaces to all discovered graphs
            </summary>
            <param name="ok">Whether parsing completed successfully</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Handlers.StoreHandler.Store">
            <summary>
            Gets the Triple Store that this Handler is populating
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Handlers.StoreHandler.AcceptsAll">
            <summary>
            Gets that the Handler accepts all Triples
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Handlers.WriteThroughHandler">
            <summary>
            A RDF Handler which writes the handled Triples out to a <see cref="T:System.IO.TextWriter">TextWriter</see> using a provided <see cref="T:VDS.RDF.Writing.Formatting.ITripleFormatter">ITripleFormatter</see>
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.WriteThroughHandler.#ctor(VDS.RDF.Writing.Formatting.ITripleFormatter,System.IO.TextWriter,System.Boolean)">
            <summary>
            Creates a new Write-Through Handler
            </summary>
            <param name="formatter">Triple Formatter to use</param>
            <param name="writer">Text Writer to write to</param>
            <param name="closeOnEnd">Whether to close the writer at the end of RDF handling</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.WriteThroughHandler.#ctor(VDS.RDF.Writing.Formatting.ITripleFormatter,System.IO.TextWriter)">
            <summary>
            Creates a new Write-Through Handler
            </summary>
            <param name="formatter">Triple Formatter to use</param>
            <param name="writer">Text Writer to write to</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.WriteThroughHandler.#ctor(System.Type,System.IO.TextWriter,System.Boolean)">
            <summary>
            Creates a new Write-Through Handler
            </summary>
            <param name="formatterType">Type of the formatter to create</param>
            <param name="writer">Text Writer to write to</param>
            <param name="closeOnEnd">Whether to close the writer at the end of RDF handling</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.WriteThroughHandler.#ctor(System.Type,System.IO.TextWriter)">
            <summary>
            Creates a new Write-Through Handler
            </summary>
            <param name="formatterType">Type of the formatter to create</param>
            <param name="writer">Text Writer to write to</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.WriteThroughHandler.StartRdfInternal">
            <summary>
            Starts RDF Handling instantiating a Triple Formatter if necessary
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.WriteThroughHandler.EndRdfInternal(System.Boolean)">
            <summary>
            Ends RDF Handling closing the <see cref="T:System.IO.TextWriter">TextWriter</see> being used if the setting is enabled
            </summary>
            <param name="ok">Indicates whether parsing completed without error</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.WriteThroughHandler.HandleNamespaceInternal(System.String,System.Uri)">
            <summary>
            Handles Namespace Declarations passing them to the underlying formatter if applicable
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="namespaceUri">Namespace URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.WriteThroughHandler.HandleBaseUriInternal(System.Uri)">
            <summary>
            Handles Base URI Declarations passing them to the underlying formatter if applicable
            </summary>
            <param name="baseUri">Base URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.WriteThroughHandler.HandleTripleInternal(VDS.RDF.Triple)">
            <summary>
            Handles Triples by writing them using the underlying formatter
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Parsing.Handlers.WriteThroughHandler.AcceptsAll">
            <summary>
            Gets that the Handler accepts all Triples
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Handlers.ResultWriteThroughHandler">
            <summary>
            A Results Handler which writes the handled Results out to a <see cref="T:System.IO.TextWriter">TextWriter</see> using a provided <see cref="T:VDS.RDF.Writing.Formatting.IResultFormatter">IResultFormatter</see>
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.ResultWriteThroughHandler.#ctor(VDS.RDF.Writing.Formatting.IResultFormatter,System.IO.TextWriter,System.Boolean)">
            <summary>
            Creates a new Write-Through Handler
            </summary>
            <param name="formatter">Triple Formatter to use</param>
            <param name="writer">Text Writer to write to</param>
            <param name="closeOnEnd">Whether to close the writer at the end of RDF handling</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.ResultWriteThroughHandler.#ctor(VDS.RDF.Writing.Formatting.IResultFormatter,System.IO.TextWriter)">
            <summary>
            Creates a new Write-Through Handler
            </summary>
            <param name="formatter">Triple Formatter to use</param>
            <param name="writer">Text Writer to write to</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.ResultWriteThroughHandler.#ctor(System.Type,System.IO.TextWriter,System.Boolean)">
            <summary>
            Creates a new Write-Through Handler
            </summary>
            <param name="formatterType">Type of the formatter to create</param>
            <param name="writer">Text Writer to write to</param>
            <param name="closeOnEnd">Whether to close the writer at the end of RDF handling</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.ResultWriteThroughHandler.#ctor(System.Type,System.IO.TextWriter)">
            <summary>
            Creates a new Write-Through Handler
            </summary>
            <param name="formatterType">Type of the formatter to create</param>
            <param name="writer">Text Writer to write to</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.ResultWriteThroughHandler.StartResultsInternal">
            <summary>
            Starts writing results
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.ResultWriteThroughHandler.EndResultsInternal(System.Boolean)">
            <summary>
            Ends the writing of results closing the <see cref="T:System.IO.TextWriter">TextWriter</see> depending on the option set when this instance was instantiated
            </summary>
            <param name="ok"></param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.ResultWriteThroughHandler.HandleBooleanResultInternal(System.Boolean)">
            <summary>
            Writes a Boolean Result to the output
            </summary>
            <param name="result">Boolean Result</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.ResultWriteThroughHandler.HandleVariableInternal(System.String)">
            <summary>
            Writes a Variable declaration to the output
            </summary>
            <param name="var">Variable Name</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.ResultWriteThroughHandler.HandleResultInternal(VDS.RDF.Query.SparqlResult)">
            <summary>
            Writes a Result to the output
            </summary>
            <param name="result">SPARQL Result</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Parsing.Handlers.WriteToStoreHandler">
            <summary>
            A RDF Handler which writes the Triples being parsed directly to a <see cref="T:VDS.RDF.Storage.IStorageProvider">IStorageProvider</see> in batches provided the manager supports the <see cref="M:VDS.RDF.Storage.IStorageProvider.UpdateGraph(System.Uri,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">UpdateGraph()</see> method
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Handlers.WriteToStoreHandler.DefaultBatchSize">
            <summary>
            Default Batch Size for writes
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.WriteToStoreHandler.#ctor(VDS.RDF.Storage.IStorageProvider,System.Uri,System.Int32)">
            <summary>
            Creates a new Write to Store Handler
            </summary>
            <param name="manager">Manager to write to</param>
            <param name="defaultGraphUri">Graph URI to write Triples from the default graph to</param>
            <param name="batchSize">Batch Size</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.WriteToStoreHandler.#ctor(VDS.RDF.Storage.IStorageProvider,System.Uri)">
            <summary>
            Creates a new Write to Store Handler
            </summary>
            <param name="manager">Manager to write to</param>
            <param name="defaultGraphUri">Graph URI to write Triples from the default graph to</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.WriteToStoreHandler.#ctor(VDS.RDF.Storage.IStorageProvider,System.Int32)">
            <summary>
            Creates a new Write to Store Handler
            </summary>
            <param name="manager">Manager to write to</param>
            <param name="batchSize">Batch Size</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.WriteToStoreHandler.#ctor(VDS.RDF.Storage.IStorageProvider)">
            <summary>
            Creates a new Write to Store Handler
            </summary>
            <param name="manager">Manager to write to</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.WriteToStoreHandler.StartRdfInternal">
            <summary>
            Starts RDF Handling by ensuring the queue of Triples to write is empty
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.WriteToStoreHandler.EndRdfInternal(System.Boolean)">
            <summary>
            Ends RDF Handling by ensuring the queue of Triples to write has been processed
            </summary>
            <param name="ok">Indicates whether parsing completed without error</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Handlers.WriteToStoreHandler.HandleTripleInternal(VDS.RDF.Triple)">
            <summary>
            Handles Triples by queuing them for writing and enacting the writing if the Batch Size has been reached/exceeded
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Parsing.Handlers.WriteToStoreHandler.AcceptsAll">
            <summary>
            Gets that the Handler accepts all Triples
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.IRdfAVocabulary">
            <summary>
            Interface for RDFa Vocabularies
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.IRdfAVocabulary.HasTerm(System.String)">
            <summary>
            Gets whether a Vocabulary contains a Term
            </summary>
            <param name="term">Term</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IRdfAVocabulary.ResolveTerm(System.String)">
            <summary>
            Resolves a Term in the Vocabulary
            </summary>
            <param name="term">Term</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IRdfAVocabulary.AddTerm(System.String,System.String)">
            <summary>
            Adds a Term to the Vocabulary
            </summary>
            <param name="term">Term</param>
            <param name="uri">URI</param>
        </member>
        <member name="M:VDS.RDF.Parsing.IRdfAVocabulary.AddNamespace(System.String,System.String)">
            <summary>
            Adds a Namespace to the Vocabulary
            </summary>
            <param name="prefix">Prefix</param>
            <param name="nsUri">Namespace URI</param>
        </member>
        <member name="M:VDS.RDF.Parsing.IRdfAVocabulary.Merge(VDS.RDF.Parsing.IRdfAVocabulary)">
            <summary>
            Merges another Vocabulary into this one
            </summary>
            <param name="vocab">Vocabulary</param>
        </member>
        <member name="P:VDS.RDF.Parsing.IRdfAVocabulary.VocabularyUri">
            <summary>
            Gets/Sets the Vocabulary URI
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.IRdfAVocabulary.Mappings">
            <summary>
            Gets the Term Mappings
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.IRdfAVocabulary.Namespaces">
            <summary>
            Gets the Namespace Mappings
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.TermMappings">
            <summary>
            Represents a dynamic vocabulary for RDFa
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.TermMappings.#ctor">
            <summary>
            Creates a new set of Term Mappings
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.TermMappings.#ctor(System.String)">
            <summary>
            Creates a new set of Term Mappings with the given Vocabulary URI
            </summary>
            <param name="vocabUri">Vocabulary URI</param>
        </member>
        <member name="M:VDS.RDF.Parsing.TermMappings.#ctor(VDS.RDF.Parsing.IRdfAVocabulary)">
            <summary>
            Creates a new set of Term Mappings from the given Vocabulary
            </summary>
            <param name="vocab">Vocabulary</param>
        </member>
        <member name="M:VDS.RDF.Parsing.TermMappings.Merge(VDS.RDF.Parsing.IRdfAVocabulary)">
            <summary>
            Merges another Vocabulary into this one
            </summary>
            <param name="vocab">Vocabulary</param>
        </member>
        <member name="M:VDS.RDF.Parsing.TermMappings.HasTerm(System.String)">
            <summary>
            Gets whether the Vocabulary contains a Term
            </summary>
            <param name="term">Term</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.TermMappings.ResolveTerm(System.String)">
            <summary>
            Resolves a Term in the Vocabulary
            </summary>
            <param name="term">Term</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.TermMappings.AddNamespace(System.String,System.String)">
            <summary>
            Adds a Namespace to the Vocabulary
            </summary>
            <param name="prefix">Prefix</param>
            <param name="nsUri">Namespace URI</param>
        </member>
        <member name="M:VDS.RDF.Parsing.TermMappings.AddTerm(System.String,System.String)">
            <summary>
            Adds a Term to the Vocabulary
            </summary>
            <param name="term">Term</param>
            <param name="uri">URI</param>
        </member>
        <member name="P:VDS.RDF.Parsing.TermMappings.Mappings">
            <summary>
            Gets the Term Mappings
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.TermMappings.Namespaces">
            <summary>
            Gets the Namespace Mappings
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.TermMappings.VocabularyUri">
            <summary>
            Gets/Sets the Vocabulary URI
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.IriSpecsHelper">
            <summary>
            Static Helper class which can be used to validate IRIs according to <a href="http://www.ietf.org/rfc/rfc3987.txt">RFC 3987</a>
            </summary>
            <remarks>
            Some valid IRIs may be rejected by these validating functions as the IRI specification allows character codes which are outside the range of the .Net char type
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsIri(System.String)">
            <summary>
            Gets whether a string matches the IRI production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsIHierPart(System.String)">
            <summary>
            Gets whether a string matches the ihier-part production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsIriReference(System.String)">
            <summary>
            Gets whether a string matches the IRI-reference production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsAbsoluteIri(System.String)">
            <summary>
            Gets whether a string matches the absolute-IRI production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsIrelativeRef(System.String)">
            <summary>
            Gets whether a string matches the irelative-ref production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsIrelativePart(System.String)">
            <summary>
            Gets whether a string matches the irelative-part production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsIAuthority(System.String)">
            <summary>
            Gets whether a string matches the iauthority production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsIUserInfo(System.String)">
            <summary>
            Gets whether a string matches the userinfo production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsIHost(System.String)">
            <summary>
            Gets whether a string matches the ihost production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsIRegName(System.String)">
            <summary>
            Gets whether a string matches the ireg-name production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsIPath(System.String)">
            <summary>
            Gets whether a string matches the ipath production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsIPathAbEmpty(System.String)">
            <summary>
            Gets whether a string matches the ipath-abempty production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsIPathAbsolute(System.String)">
            <summary>
            Gets whether a string matches the ipath-absolute production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsIPathNoScheme(System.String)">
            <summary>
            Gets whether a string matches the ipath-noscheme production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsIPathRootless(System.String)">
            <summary>
            Gets whether a string matches the ipath-rootless production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsIPathEmpty(System.String)">
            <summary>
            Gets whether a string matches the ipath-empty production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsISegment(System.String)">
            <summary>
            Gets whether a string matches the isegment production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsISegmentNz(System.String)">
            <summary>
            Gets whether a string matches the isegment-nz production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsISegmentNzNc(System.String)">
            <summary>
            Gets whether a string matches the isegment-nz-nc production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsIpChar(System.String)">
            <summary>
            Gets whether a string matches the ipchar production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsIQuery(System.String)">
            <summary>
            Gets whether a string matches the iquery production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsIFragment(System.String)">
            <summary>
            Gets whether a string matches the ifragment production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsIUnreserved(System.Char)">
            <summary>
            Gets whether a character matches the iunreserved production
            </summary>
            <param name="c">Character</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsUcsChar(System.Char)">
            <summary>
            Gets whether a character matches the ucschar production
            </summary>
            <param name="c">Character</param>
            <returns></returns>
            <remarks>
            Not all strings that will match the official ucschar production will be matched by this function as the ucschar production permits character codes beyond the range of the .Net char type
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsScheme(System.String)">
            <summary>
            Gets whether a string matches the scheme production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsPort(System.String)">
            <summary>
            Gets whether a string matches the port production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsIPLiteral(System.String)">
            <summary>
            Gets whether a string matches the IP-literal production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsIPvFuture(System.String)">
            <summary>
            Gets whether a string matches the IPvFuture production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsIPv6Address(System.String)">
            <summary>
            Gets whether a string matches the IPv6address production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsH16(System.String)">
            <summary>
            Gets whether a string matches the h16 production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsLs32(System.String)">
            <summary>
            Gets whether a string matches the ls32 production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsIPv4Address(System.String)">
            <summary>
            Gets whether a string matches the IPv4address production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsDecOctet(System.String)">
            <summary>
            Gets whether a string matches the dec-octet production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsPctEncoded(System.String)">
            <summary>
            Gets whether a string matches the pct-encoded production
            </summary>
            <param name="value">String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsUnreserved(System.Char)">
            <summary>
            Gets whether a character matches the unreserved production
            </summary>
            <param name="c">Character</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsReserved(System.Char)">
            <summary>
            Gets whether a character matches the reserved production
            </summary>
            <param name="c">Character</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsGenDelims(System.Char)">
            <summary>
            Gets whether a character matches the gen-delims production
            </summary>
            <param name="c">Character</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsSubDelims(System.Char)">
            <summary>
            Gets whether a character matches the sub-delims production
            </summary>
            <param name="c">Character</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.IriSpecsHelper.IsHexDigit(System.Char)">
            <summary>
            Gets whether a character matches the HEXDIG terminal
            </summary>
            <param name="c">Character</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Parsing.Notation3Parser">
            <summary>
            Parser for Notation 3 syntax
            </summary>
            <remarks>
            </remarks>
            <threadsafety instance="true">Designed to be Thread Safe - should be able to call Load from multiple threads on different Graphs without issue</threadsafety>
        </member>
        <member name="F:VDS.RDF.Parsing.Notation3Parser.ImpliesUri">
            <summary>
            The Uri for log:implies
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Notation3Parser.SameAsUri">
            <summary>
            The Uri for owl:sameAs
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Notation3Parser.#ctor">
            <summary>
            Creates a new Notation 3 Parser
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Notation3Parser.#ctor(VDS.RDF.Parsing.Tokens.TokenQueueMode)">
            <summary>
            Creates a new Notation 3 Parser which uses the given Token Queue Mode
            </summary>
            <param name="queueMode">Queue Mode for Tokenising</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Notation3Parser.Load(VDS.RDF.IGraph,System.IO.StreamReader)">
            <summary>
            Loads a Graph by reading Notation 3 syntax from the given input
            </summary>
            <param name="g">Graph to load into</param>
            <param name="input">Stream to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Notation3Parser.Load(VDS.RDF.IGraph,System.IO.TextReader)">
            <summary>
            Loads a Graph by reading Notation 3 syntax from the given input
            </summary>
            <param name="g">Graph to load into</param>
            <param name="input">Input to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Notation3Parser.Load(VDS.RDF.IRdfHandler,System.IO.StreamReader)">
            <summary>
            Loads RDF using a RDF handler by reading Notation 3 syntax from the given input
            </summary>
            <param name="handler">RDF Handler to use</param>
            <param name="input">Stream to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Notation3Parser.Load(VDS.RDF.IRdfHandler,System.IO.TextReader)">
            <summary>
            Loads RDF using a RDF handler by reading Notation 3 syntax from the given input
            </summary>
            <param name="handler">RDF Handler to use</param>
            <param name="input">Input to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Notation3Parser.Parse(VDS.RDF.Parsing.Contexts.Notation3ParserContext)">
            <summary>
            Internal method which does the parsing of the input
            </summary>
            <param name="context">Parser Context</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Notation3Parser.TryParseDirective(VDS.RDF.Parsing.Contexts.Notation3ParserContext)">
            <summary>
            Tries to parse declarations
            </summary>
            <param name="context">Parse Context</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Notation3Parser.TryParseForAll(VDS.RDF.Parsing.Contexts.Notation3ParserContext)">
            <summary>
            Tries to parse forAll quantifiers
            </summary>
            <param name="context">Parser Context</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Notation3Parser.TryParseForSome(VDS.RDF.Parsing.Contexts.Notation3ParserContext)">
            <summary>
            Tries to parse forSome quantifiers
            </summary>
            <param name="context">Parser Context</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Notation3Parser.TryParseTriples(VDS.RDF.Parsing.Contexts.Notation3ParserContext)">
            <summary>
            Tries to parse Triples
            </summary>
            <param name="context">Parser Context</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Notation3Parser.TryParsePredicateObjectList(VDS.RDF.Parsing.Contexts.Notation3ParserContext,VDS.RDF.INode,System.Boolean)">
            <summary>
            Tries to parse Predicate Object lists
            </summary>
            <param name="context">Parse Context</param>
            <param name="subj">Subject of the Triples</param>
            <param name="bnodeList">Whether this is a Blank Node Predicate Object list</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Notation3Parser.TryParseObjectList(VDS.RDF.Parsing.Contexts.Notation3ParserContext,VDS.RDF.INode,VDS.RDF.INode,System.Boolean,System.Boolean)">
            <summary>
            Tries to parse Object lists
            </summary>
            <param name="context">Parse Context</param>
            <param name="subj">Subject of the Triples</param>
            <param name="pred">Predicate of the Triples</param>
            <param name="bnodeList">Whether this is a Blank Node Object list</param>
            <param name="reverse">Indicates whether the asserted triples should have it's subject and object swapped</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Notation3Parser.TryParseCollection(VDS.RDF.Parsing.Contexts.Notation3ParserContext,VDS.RDF.INode)">
            <summary>
            Tries to parse Collections
            </summary>
            <param name="context">Parser Context</param>
            <param name="firstSubj">Blank Node which is the head of the collection</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Notation3Parser.TryParseGraphLiteral(VDS.RDF.Parsing.Contexts.Notation3ParserContext)">
            <summary>
            Tries to parse a Graph Literal
            </summary>
            <param name="context"></param>
        </member>
        <member name="M:VDS.RDF.Parsing.Notation3Parser.TryParseLiteral(VDS.RDF.Parsing.Contexts.Notation3ParserContext,VDS.RDF.Parsing.Tokens.IToken)">
            <summary>
            Tries to parse Literal Tokens into Literal Nodes
            </summary>
            <param name="context">Parser Context</param>
            <param name="lit">Literal Token</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Notation3Parser.RaiseWarning(System.String)">
            <summary>
            Helper method which raises the Warning event if there is an event handler registered
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:VDS.RDF.Parsing.Notation3Parser.ToString">
            <summary>
            Gets the String representation of the Parser which is a description of the syntax it parses
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Parsing.Notation3Parser.TraceParsing">
            <summary>
            Gets/Sets whether Parsing Trace is written to the Console
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Notation3Parser.TraceTokeniser">
            <summary>
            Gets/Sets whether Tokeniser Trace is written to the Console
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Notation3Parser.TokenQueueMode">
            <summary>
            Gets/Sets the token queue mode used
            </summary>
        </member>
        <member name="E:VDS.RDF.Parsing.Notation3Parser.Warning">
            <summary>
            Event which is raised when the parser detects issues with the input which are non-fatal
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.ParserHelper">
            <summary>
            Static Helper class containing useful methods for Parsers
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.ParserHelper.TryResolveUri(VDS.RDF.Parsing.Contexts.IParserContext,VDS.RDF.Parsing.Tokens.IToken)">
            <summary>
            Attempts to resolve a QName or URI Token into a URI Node and produces appropriate error messages if this fails
            </summary>
            <param name="context">Parser Context</param>
            <param name="t">Token to resolve</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.ParserHelper.TryResolveUri(VDS.RDF.Parsing.Contexts.IParserContext,VDS.RDF.Parsing.Tokens.IToken,System.Boolean)">
            <summary>
            Attempts to resolve a QName or URI Token into a URI Node and produces appropriate error messages if this fails
            </summary>
            <param name="context">Parser Context</param>
            <param name="t">Token to resolve</param>
            <param name="allowDefaultPrefixFallback">Whether when the default prefix is used but not defined it can fallback to the Base URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.ParserHelper.TryResolveUri(VDS.RDF.Parsing.Contexts.IParserContext,VDS.RDF.Parsing.Tokens.IToken,System.Boolean,System.Func{System.String,System.String})">
            <summary>
            Attempts to resolve a QName or URI Token into a URI Node and produces appropriate error messages if this fails
            </summary>
            <param name="context">Parser Context</param>
            <param name="t">Token to resolve</param>
            <param name="allowDefaultPrefixFallback">Whether when the default prefix is used but not defined it can fallback to the Base URI</param>
            <param name="qnameUnescape">QName unescaping function</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.ParserHelper.TryResolveUri(VDS.RDF.Parsing.Contexts.IStoreParserContext,VDS.RDF.Parsing.Tokens.IToken)">
            <summary>
            Attempts to resolve a QName or URI Token into a URI Node and produces appropriate error messages if this fails
            </summary>
            <param name="context">Parser Context</param>
            <param name="t">Token to resolve</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.ParserHelper.TryResolveUri(VDS.RDF.IRdfHandler,VDS.RDF.Parsing.Tokens.IToken)">
            <summary>
            Attempts to resolve a QName or URI Token into a URI Node and produces appropriate error messages if this fails
            </summary>
            <param name="handler">RDF Handler</param>
            <param name="t">Token to resolve</param>
            <returns></returns>
            <remarks>
            It is <strong>not</strong> recommended to use this overload since an <see cref="T:VDS.RDF.IRdfHandler">IRdfHandler</see> cannot resolve QNames
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.ParserHelper.TryResolveUri(VDS.RDF.ISparqlResultsHandler,VDS.RDF.Parsing.Tokens.IToken)">
            <summary>
            Attempts to resolve a QName or URI Token into a URI Node and produces appropriate error messages if this fails
            </summary>
            <param name="handler">Results Handler</param>
            <param name="t">Token to resolve</param>
            <returns></returns>
            <remarks>
            It is <strong>not</strong> recommended to use this overload since an <see cref="T:VDS.RDF.IRdfHandler">IRdfHandler</see> cannot resolve QNames
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.ParserHelper.TryResolveUri(VDS.RDF.IGraph,VDS.RDF.Parsing.Tokens.IToken)">
            <summary>
            Attempts to resolve a QName or URI Token into a URI Node and produces appropriate error messages if this fails
            </summary>
            <param name="g">Graph</param>
            <param name="t">Token to resolve</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.ParserHelper.Error(System.String,VDS.RDF.Parsing.Tokens.IToken)">
            <summary>
            Helper method for raising informative standardised Parser Errors
            </summary>
            <param name="msg">The Error Message</param>
            <param name="t">The Token that is the cause of the Error</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.ParserHelper.Error(System.String,VDS.RDF.Parsing.Events.IRdfXmlEvent)">
            <summary>
            Helper function which generates standardised Error Messages
            </summary>
            <param name="message">Error Message</param>
            <param name="evt">Event causing the Error</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.ParserHelper.Error(System.String,System.String,VDS.RDF.Parsing.Events.IRdfXmlEvent)">
            <summary>
            Helper function which generates standardised Error Messages
            </summary>
            <param name="message">Error Message</param>
            <param name="production">The Production where the Error occurred</param>
            <param name="evt">Event causing the Error</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.ParserHelper.Stop">
            <summary>
            Throws a <see cref="T:VDS.RDF.Parsing.RdfParsingTerminatedException">RdfParsingTerminatedException</see> which is used to tell the parser that it should stop parsing.
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Parsing.PositionInfo">
            <summary>
            Represents Position Information from Parsers
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.PositionInfo.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new set of Position Information
            </summary>
            <param name="line">Line</param>
            <param name="position">Column</param>
        </member>
        <member name="M:VDS.RDF.Parsing.PositionInfo.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new set of Position Information
            </summary>
            <param name="line">Line</param>
            <param name="startPosition">Start Column</param>
            <param name="endPosition">End Column</param>
        </member>
        <member name="M:VDS.RDF.Parsing.PositionInfo.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new set of Position Information
            </summary>
            <param name="startLine">Start Line</param>
            <param name="endLine">End Line</param>
            <param name="startPosition">Start Column</param>
            <param name="endPosition">End Column</param>
        </member>
        <member name="M:VDS.RDF.Parsing.PositionInfo.#ctor(System.Xml.IXmlLineInfo)">
            <summary>
            Creates a new set of Position Information form some XML Line Information
            </summary>
            <param name="info">XML Line Information</param>
        </member>
        <member name="P:VDS.RDF.Parsing.PositionInfo.StartLine">
            <summary>
            Gets the Start Line
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.PositionInfo.EndLine">
            <summary>
            Gets the End Line
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.PositionInfo.StartPosition">
            <summary>
            Gets the Start Column
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.PositionInfo.EndPosition">
            <summary>
            Gets the End Column
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.RdfXmlSpecsHelper">
            <summary>
            Static Helper class for providing Constants and Helper functions for use by RDF/XML parsers
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlSpecsHelper.IsAbsoluteURI(System.String)">
            <summary>
            Checks whether a Uri Reference is an absolute Uri
            </summary>
            <param name="uriref">Uri Reference to Test</param>
            <returns></returns>
            <remarks>Implemented by seeing if the Uri Reference starts with a Uri scheme specifier</remarks>
        </member>
        <member name="F:VDS.RDF.Parsing.RdfXmlSpecsHelper.coreSyntaxTerms">
            <summary>
            Array containing the Core Syntax Terms
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.RdfXmlSpecsHelper.syntaxTerms">
            <summary>
            Array containing the other Syntax Terms
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.RdfXmlSpecsHelper.oldTerms">
            <summary>
            Array containing the Old Syntax Terms
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.RdfXmlSpecsHelper.requiresRdfPrefix">
            <summary>
            Array containing Syntax Terms where the rdf: Prefix is mandated
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlSpecsHelper.IsCoreSyntaxTerm(System.String)">
            <summary>
            Checks whether a given QName is a Core Syntax Term
            </summary>
            <param name="qname">QName to Test</param>
            <returns>True if the QName is a Core Syntax Term</returns>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlSpecsHelper.IsSyntaxTerm(System.String)">
            <summary>
            Checks whether a given QName is a Syntax Term
            </summary>
            <param name="qname">QName to Test</param>
            <returns>True if the QName is a Syntax Term</returns>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlSpecsHelper.IsOldTerm(System.String)">
            <summary>
            Checks whether a given QName is a Old Syntax Term
            </summary>
            <param name="qname">QName to Test</param>
            <returns>True if the QName is a Old Syntax Term</returns>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlSpecsHelper.IsNodeElementUri(System.String)">
            <summary>
            Checks whether a given QName is valid as a Node Element Uri
            </summary>
            <param name="qname">QName to Test</param>
            <returns>True if the QName is valid</returns>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlSpecsHelper.IsPropertyElementURI(System.String)">
            <summary>
            Checks whether a given QName is valid as a Property Element Uri
            </summary>
            <param name="qname">QName to Test</param>
            <returns>True if the QName is valid</returns>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlSpecsHelper.IsPropertyAttributeURI(System.String)">
            <summary>
            Checks whether a given QName is valid as a Property Attribute Uri
            </summary>
            <param name="qname">QName to Test</param>
            <returns>True if the QName is valid</returns>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlSpecsHelper.IsAmbigiousAttributeName(System.String)">
            <summary>
            Checks whether a given Local Name is potentially ambigious
            </summary>
            <param name="name">Local Name to Test</param>
            <returns>True if the Local Name is ambigious</returns>
            <remarks>This embodies Local Names which must have an rdf prefix</remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlSpecsHelper.IsValidUriRefEncoding(System.String)">
            <summary>
            Checks whether a given URIRef is encoded in Unicode Normal Form C
            </summary>
            <param name="uriref">URIRef to Test</param>
            <returns>True if the URIRef is encoded correctly</returns>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlSpecsHelper.IsValidBaseUri(System.String)">
            <summary>
            Checks whether a given Base Uri can be used for relative Uri resolution
            </summary>
            <param name="baseUri">Base Uri to Test</param>
            <returns>True if the Base Uri can be used for relative Uri resolution</returns>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlSpecsHelper.IsValidQName(System.String)">
            <summary>
            Determines whether a QName is valid for use in RDF/XML
            </summary>
            <param name="qname">QName</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlSpecsHelper.IsIDAttribute(VDS.RDF.Parsing.Events.RdfXml.AttributeEvent)">
            <summary>
            Checks whether an attribute is an rdf:ID attribute
            </summary>
            <param name="attr">Attribute to Test</param>
            <returns>True if is an rdf:ID attribute</returns>
            <remarks>Does some validation on ID value but other validation occurs at other points in the Parsing</remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlSpecsHelper.IsNodeIDAttribute(VDS.RDF.Parsing.Events.RdfXml.AttributeEvent)">
            <summary>
            Checks whether an attribute is an rdf:nodeID attribute
            </summary>
            <param name="attr">Attribute to Test</param>
            <returns>True if is an rdf:nodeID attribute</returns>
            <remarks>Does some validation on ID value but other validation occurs at other points in the Parsing</remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlSpecsHelper.IsAboutAttribute(VDS.RDF.Parsing.Events.RdfXml.AttributeEvent)">
            <summary>
            Checks whether an attribute is an rdf:about attribute
            </summary>
            <param name="attr">Attribute to Test</param>
            <returns>True if is an rdf:about attribute</returns>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlSpecsHelper.IsPropertyAttribute(VDS.RDF.Parsing.Events.RdfXml.AttributeEvent)">
            <summary>
            Checks whether an attribute is an property attribute
            </summary>
            <param name="attr">Attribute to Test</param>
            <returns>True if is an property attribute</returns>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlSpecsHelper.IsResourceAttribute(VDS.RDF.Parsing.Events.RdfXml.AttributeEvent)">
            <summary>
            Checks whether an attribute is an rdf:resource attribute
            </summary>
            <param name="attr">Attribute to Test</param>
            <returns>True if is an rdf:resource attribute</returns>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlSpecsHelper.IsDataTypeAttribute(VDS.RDF.Parsing.Events.RdfXml.AttributeEvent)">
            <summary>
            Checks whether an attribute is an rdf:datatype attribute
            </summary>
            <param name="attr">Attribute to Test</param>
            <returns>True if is an rdf:datatype attribute</returns>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlSpecsHelper.IsRdfID(System.String)">
            <summary>
            Validates that an ID is a valid NCName
            </summary>
            <param name="value">ID Value to Test</param>
            <returns>True if the ID is valid</returns>
        </member>
        <member name="M:VDS.RDF.Parsing.RdfXmlSpecsHelper.IsRdfUriReference(System.String)">
            <summary>
            Validates that a URIReference is valid
            </summary>
            <param name="value">URIReference to Test</param>
            <returns>True</returns>
            <remarks>
            Currently partially implemented, some invalid Uri References may be considered valid
            </remarks>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.RdfXml.StreamingEventGenerator">
            <summary>
            A JIT event generator for RDF/XML parsing that uses Streaming parsing to parse the events
            </summary>
            <remarks>
            Currently unimplemented stub class
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.RdfXml.StreamingEventGenerator.#ctor(System.IO.Stream)">
            <summary>
            Creates a new Streaming Event Generator
            </summary>
            <param name="stream">Stream</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.RdfXml.StreamingEventGenerator.#ctor(System.IO.Stream,System.String)">
            <summary>
            Creates a new Streaming Event Generator
            </summary>
            <param name="stream">Stream</param>
            <param name="baseUri">Base URI</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.RdfXml.StreamingEventGenerator.#ctor(System.IO.TextReader)">
            <summary>
            Creates a new Streaming Event Generator
            </summary>
            <param name="reader">Text Reader</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.RdfXml.StreamingEventGenerator.#ctor(System.IO.TextReader,System.String)">
            <summary>
            Creates a new Streaming Event Generator
            </summary>
            <param name="reader">Text Reader</param>
            <param name="baseUri">Base URI</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.RdfXml.StreamingEventGenerator.GetSettings">
            <summary>
            Initialises the XML Reader settings
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.Events.RdfXml.StreamingEventGenerator.GetNextEvent">
            <summary>
            Gets the next event from the XML stream
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Parsing.Events.RdfXml.StreamingEventGenerator.Finished">
            <summary>
            Gets whether the event generator has finished generating events
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.SparqlRdfParser">
            <summary>
            Parser for reading SPARQL Results which have been encoded in the RDF schema for Result Sets and serialized as RDF
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlRdfParser.#ctor">
            <summary>
            Creates a new SPARQL RDF Parser which will use auto-detection for determining the syntax of input streams/files
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlRdfParser.#ctor(VDS.RDF.IRdfReader)">
            <summary>
            Creates a new SPARQL RDF Parser which will use the given RDF Parser
            </summary>
            <param name="parser">RDF Parser</param>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlRdfParser.Load(VDS.RDF.Query.SparqlResultSet,System.IO.TextReader)">
            <summary>
            Loads a SPARQL Result Set from RDF contained in the given Input
            </summary>
            <param name="results">SPARQL Result Set to populate</param>
            <param name="input">Input to read from</param>
            <remarks>
            Uses the <see cref="T:VDS.RDF.Parsing.StringParser">StringParser</see> which will use simple heuristics to 'guess' the format of the RDF unless the parser was instaniated with a specific <see cref="T:VDS.RDF.IRdfReader">IRdfReader</see> to use
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlRdfParser.Load(VDS.RDF.Query.SparqlResultSet,System.IO.StreamReader)">
            <summary>
            Loads a SPARQL Result Set from RDF contained in the given Stream
            </summary>
            <param name="results">SPARQL Result Set to populate</param>
            <param name="input">Stream to read from</param>
            <remarks>
            Uses the <see cref="T:VDS.RDF.Parsing.StringParser">StringParser</see> which will use simple heuristics to 'guess' the format of the RDF unless the parser was instaniated with a specific <see cref="T:VDS.RDF.IRdfReader">IRdfReader</see> to use
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlRdfParser.Load(VDS.RDF.ISparqlResultsHandler,System.IO.TextReader)">
            <summary>
            Loads a SPARQL Results from RDF contained in the given Input using a Results Handler
            </summary>
            <param name="handler">Results Handler to use</param>
            <param name="input">Input to read from</param>
            <remarks>
            Uses the <see cref="T:VDS.RDF.Parsing.StringParser">StringParser</see> which will use simple heuristics to 'guess' the format of the RDF unless the parser was instaniated with a specific <see cref="T:VDS.RDF.IRdfReader">IRdfReader</see> to use
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlRdfParser.Load(VDS.RDF.ISparqlResultsHandler,System.IO.StreamReader)">
            <summary>
            Loads a SPARQL Results from RDF contained in the given Stream using a Results Handler
            </summary>
            <param name="handler">Results Handler to use</param>
            <param name="input">Stream to read from</param>
            <remarks>
            Uses the <see cref="T:VDS.RDF.Parsing.StringParser">StringParser</see> which will use simple heuristics to 'guess' the format of the RDF unless the parser was instaniated with a specific <see cref="T:VDS.RDF.IRdfReader">IRdfReader</see> to use
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlRdfParser.Parse(VDS.RDF.Parsing.Contexts.SparqlRdfParserContext)">
            <summary>
            Internal method which actually parses the Result Set by traversing the RDF Graph appropriately
            </summary>
            <param name="context">Parser Context</param>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlRdfParser.RaiseWarning(System.String)">
            <summary>
            Helper Method which raises the Warning event when a non-fatal issue with the SPARQL Results being parsed is detected
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlRdfParser.ToString">
            <summary>
            Gets the String representation of the Parser which is a description of the syntax it parses
            </summary>
            <returns></returns>
        </member>
        <member name="E:VDS.RDF.Parsing.SparqlRdfParser.Warning">
            <summary>
            Event raised when a non-fatal issue with the SPARQL Results being parsed is detected
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.SparqlUpdateParser">
            <summary>
            Class for parsing SPARQL Update commands into <see cref="T:VDS.RDF.Update.SparqlUpdateCommandSet">SparqlUpdateCommandSet</see> objects that can be used to modify a Triple Store
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlUpdateParser.RaiseWarning(System.String)">
            <summary>
            Helper Method which raises the Warning event when a non-fatal issue with the SPARQL Update Commands being parsed is detected
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlUpdateParser.Parse(System.IO.StreamReader)">
            <summary>
            Parses a SPARQL Update Command Set from the input stream
            </summary>
            <param name="input">Input Stream</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlUpdateParser.Parse(System.IO.TextReader)">
            <summary>
            Parses a SPARQL Update Command Set from the input
            </summary>
            <param name="input">Input</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlUpdateParser.ParseFromString(System.String)">
            <summary>
            Parses a SPARQL Update Command Set from the given String
            </summary>
            <param name="updates">SPARQL Update Commands</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlUpdateParser.ParseFromString(VDS.RDF.Query.SparqlParameterizedString)">
            <summary>
            Parses a SPARQL Update Command Set from the given String
            </summary>
            <param name="updates">SPARQL Update Commands</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Parsing.SparqlUpdateParser.TraceTokeniser">
            <summary>
            Gets/Sets whether Tokeniser Tracing is used
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.SparqlUpdateParser.ExpressionFactories">
            <summary>
            Gets/Sets the locally scoped custom expression factories
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.SparqlUpdateParser.DefaultBaseUri">
            <summary>
            Gets/Sets the Default Base URI used for Updated Commands parsed by this parser instance
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.SparqlUpdateParser.QueryOptimiser">
            <summary>
            Gets/Sets the locally scoped Query Optimiser applied to graph patterns in update commands at the end of the parsing process
            </summary>
            <remarks>
            <para>
            May be null if no locally scoped optimiser is set in which case the globally scoped optimiser will be used
            </para>
            </remarks>
        </member>
        <member name="E:VDS.RDF.Parsing.SparqlUpdateParser.Warning">
            <summary>
            Event raised when a non-fatal issue with the SPARQL Update Commands being parsed is detected
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.PathToken">
            <summary>
            Special Token which acts as a Placeholder for SPARQL Property Paths
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.PathToken.#ctor(VDS.RDF.Query.Paths.ISparqlPath)">
            <summary>
            Creates a new Path Token
            </summary>
            <param name="path">Path</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Tokens.PathToken.Path">
            <summary>
            Gets the Path this Token acts as a placeholder for
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.SelectKeywordToken">
            <summary>
            Token which represents the SPARQL SELECT Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.SelectKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new SELECT Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.AskKeywordToken">
            <summary>
            Token which represents the SPARQL ASK Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.AskKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new ASK Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.DescribeKeywordToken">
            <summary>
            Token which represents the SPARQL DESCRIBE Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.DescribeKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new DESCRIBE Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.ConstructKeywordToken">
            <summary>
            Token which represents the SPARQL CONSTRUCT Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.ConstructKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new CONSTRUCT Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.AllToken">
            <summary>
            Token which represents the use of the * character to mean All
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.AllToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new All Token
            </summary>
            <param name="line">Line the * occurs on</param>
            <param name="pos">Position the * occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.AbsKeywordToken">
            <summary>
            Token which represents the SPARQL ABS Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.AbsKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new ABS Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.AllKeywordToken">
            <summary>
            Token which represents the SPARQL ALL Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.AllKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new ALL Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.AsKeywordToken">
            <summary>
            Token which represents the SPARQL AS Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.AsKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new AS Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.AscKeywordToken">
            <summary>
            Token which represents the SPARQL ASC Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.AscKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new ASC Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.AvgKeywordToken">
            <summary>
            Token which represents the SPARQL AVG Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.AvgKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new AVG Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.BindKeywordToken">
            <summary>
            Token which represents the SPARQL BIND Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BindKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new BIND Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.BindingsKeywordToken">
            <summary>
            Token which represents the SPARQL BINDINGS Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BindingsKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new BINDINGS Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.BNodeKeywordToken">
            <summary>
            Token which represents the SPARQL BNODE Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BNodeKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new BNODE Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.BoundKeywordToken">
            <summary>
            Token which represents the SPARQL BOUND Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.BoundKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new BOUND Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.CallKeywordToken">
            <summary>
            Token which represents the SPARQL CALL Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.CallKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new CALL Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.CeilKeywordToken">
            <summary>
            Token which represents the SPARQL CEIL Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.CeilKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new CEIL Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.CoalesceKeywordToken">
            <summary>
            Token which represents the SPARQL COALESCE Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.CoalesceKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new COALESCE Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.ConcatKeywordToken">
            <summary>
            Token which represents the SPARQL CONCAT Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.ConcatKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new CONCAT Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.CountKeywordToken">
            <summary>
            Token which represents the SPARQL COUNT Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.CountKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new COUNT Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.DataTypeKeywordToken">
            <summary>
            Token which represents the SPARQL DATATYPE Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.DataTypeKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new DATATYPE Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.DayKeywordToken">
            <summary>
            Token which represents the SPARQL DAY Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.DayKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new DAY Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.DescKeywordToken">
            <summary>
            Token which represents the SPARQL DESC Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.DescKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new DESC Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.DistinctKeywordToken">
            <summary>
            Token which represents the SPARQL DISTINCT Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.DistinctKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new DISTINCT Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.EncodeForUriKeywordToken">
            <summary>
            Token which represents the SPARQL ENCODE_FOR_URI Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.EncodeForUriKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new ENCODE_FOR_URI Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.ExistsKeywordToken">
            <summary>
            Token which represents the SPARQL EXISTS Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.ExistsKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new EXISTS Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.FilterKeywordToken">
            <summary>
            Token which represents the SPARQL FILTER Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.FilterKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new FILTER Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.FloorKeywordToken">
            <summary>
            Token which represents the SPARQL FLOOR Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.FloorKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new FLOOR Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.FromKeywordToken">
            <summary>
            Token which represents the SPARQL FROM Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.FromKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new FROM Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.FromNamedKeywordToken">
            <summary>
            Token which represents the SPARQL FROM NAMED Keyword combination
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.FromNamedKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new FROM NAMED Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.GraphKeywordToken">
            <summary>
            Token which represents the SPARQL GRAPH Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.GraphKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new GRAPH Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.GroupByKeywordToken">
            <summary>
            Token which represents the SPARQL GROUP BY Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.GroupByKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new GROUP BY Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.GroupConcatKeywordToken">
            <summary>
            Token which represents the SPARQL GROUP_CONCAT Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.GroupConcatKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new GROUP_CONCAT Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.HavingKeywordToken">
            <summary>
            Token which represents the SPARQL HAVING Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.HavingKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new HAVING Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.HoursKeywordToken">
            <summary>
            Token which represents the SPARQL HOURS Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.HoursKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new HOURS Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.IfKeywordToken">
            <summary>
            Token which represents the SPARQL IF Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.IfKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new IF Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.InKeywordToken">
            <summary>
            Token which represents the SPARQL IN Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.InKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new IN Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.IriKeywordToken">
            <summary>
            Token which represents the SPARQL IRI Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.IriKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new IRI Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.IsBlankKeywordToken">
            <summary>
            Token which represents the SPARQL ISBLANK Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.IsBlankKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new ISBLANK Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.IsIriKeywordToken">
            <summary>
            Token which represents the SPARQL ISIRI Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.IsIriKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new ISIRI Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.IsLiteralKeywordToken">
            <summary>
            Token which represents the SPARQL ISLITERAL Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.IsLiteralKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new ISLITERAL Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.IsNumericKeywordToken">
            <summary>
            Token which represents the SPARQL ISNUMERIC Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.IsNumericKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new ISNUMERIC Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.IsUriKeywordToken">
            <summary>
            Token which represents the SPARQL ISURI Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.IsUriKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new ISURI Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.LangKeywordToken">
            <summary>
            Token which represents the SPARQL LANG Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.LangKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new LANG Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.LangMatchesKeywordToken">
            <summary>
            Token which represents the SPARQL LANGMATCHES Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.LangMatchesKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new LANGMATCHES Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.LCaseKeywordToken">
            <summary>
            Token which represents the SPARQL LCASE Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.LCaseKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new LCASE Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.LengthKeywordToken">
            <summary>
            Token which represents the SPARQL LENGTH Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.LengthKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new LENGTH Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.LetKeywordToken">
            <summary>
            Token which represents the SPARQL LET Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.LetKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new LET Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.LimitKeywordToken">
            <summary>
            Token which represents the SPARQL LIMIT Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.LimitKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new LIMIT Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.MaxKeywordToken">
            <summary>
            Token which represents the SPARQL MAX Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.MaxKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new MAX Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.MD5KeywordToken">
            <summary>
            Token which represents the SPARQL MD5 Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.MD5KeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new MD5 Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.MedianKeywordToken">
            <summary>
            Token which represents the SPARQL MEDIAN Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.MedianKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new MEDIAN Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.MinKeywordToken">
            <summary>
            Token which represents the SPARQL MIN Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.MinKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new MIN Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.MinutesKeywordToken">
            <summary>
            Token which represents the SPARQL MINUTES Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.MinutesKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new MINUTES Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.MinusKeywordToken">
            <summary>
            Token which represents the SPARQL MINUS Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.MinusKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new MINUS Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.ModeKeywordToken">
            <summary>
            Token which represents the SPARQL MODE Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.ModeKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new MODE Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.MonthKeywordToken">
            <summary>
            Token which represents the SPARQL MONTH Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.MonthKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new MONTH Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.NamedKeywordToken">
            <summary>
            Token which represents the SPARQL NAMED Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.NamedKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new NAMED Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.NotInKeywordToken">
            <summary>
            Token which represents the SPARQL NOT IN Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.NotInKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new NOT IN Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.NumericMaxKeywordToken">
            <summary>
            Token which represents the SPARQL NMAX Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.NumericMaxKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new NMAX Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.NumericMinKeywordToken">
            <summary>
            Token which represents the SPARQL NMIN Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.NumericMinKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new NMIN Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.NotExistsKeywordToken">
            <summary>
            Token which represents the SPARQL NOT EXISTS Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.NotExistsKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new NOT EXISTS Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.NowKeywordToken">
            <summary>
            Token which represents the SPARQL NOW Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.NowKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new NOW Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.OffsetKeywordToken">
            <summary>
            Token which represents the SPARQL OFFSET Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.OffsetKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new OFFSET Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.OptionalKeywordToken">
            <summary>
            Token which represents the SPARQL OPTIONAL Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.OptionalKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new OPTIONAL Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.OrderByKeywordToken">
            <summary>
            Token which represents the SPARQL ORDER BY Keyword combination
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.OrderByKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new ORDER BY Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.RandKeywordToken">
            <summary>
            Token which represents the SPARQL RAND Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.RandKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new RAND Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.ReducedKeywordToken">
            <summary>
            Token which represents the SPARQL REDUCED Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.ReducedKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new REDUCED Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.RegexKeywordToken">
            <summary>
            Token which represents the SPARQL REGEX Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.RegexKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new REGEX Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.ReplaceKeywordToken">
            <summary>
            Token which represents the SPARQL REPLACE Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.ReplaceKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new REPLACE Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.RoundKeywordToken">
            <summary>
            Token which represents the SPARQL ROUND Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.RoundKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new ROUND Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.SameTermKeywordToken">
            <summary>
            Token which represents the SPARQL SAMETERM Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.SameTermKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new SAMETERM Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.SampleKeywordToken">
            <summary>
            Token which represents the SPARQL SAMPLE Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.SampleKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new SAMPLE Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.SecondsKeywordToken">
            <summary>
            Token which represents the SPARQL SECONDS Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.SecondsKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new SECONDS Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.SeparatorKeywordToken">
            <summary>
            Token which represents the SPARQL SEPARATOR Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.SeparatorKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new SEPARATOR Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.ServiceKeywordToken">
            <summary>
            Token which represents the SPARQL SERVICE Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.ServiceKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new SERVICE Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.Sha1KeywordToken">
            <summary>
            Token which represents the SPARQL SHA1 Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.Sha1KeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new SHA1 Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.Sha224KeywordToken">
            <summary>
            Token which represents the SPARQL SHA224 Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.Sha224KeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new SHA224 Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.Sha256KeywordToken">
            <summary>
            Token which represents the SPARQL SHA256 Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.Sha256KeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new SHA256 Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.Sha384KeywordToken">
            <summary>
            Token which represents the SPARQL SHA384 Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.Sha384KeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new SHA384 Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.Sha512KeywordToken">
            <summary>
            Token which represents the SPARQL SHA512 Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.Sha512KeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new SHA512 Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.StrKeywordToken">
            <summary>
            Token which represents the SPARQL STR Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.StrKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new STR Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.StrAfterKeywordToken">
            <summary>
            Token which represents the SPARQL STRAFTER Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.StrAfterKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new STRAFTER Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.StrBeforeKeywordToken">
            <summary>
            Token which represents the SPARQL STRBEFORE Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.StrBeforeKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new STRBEFORE Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.StrContainsKeywordToken">
            <summary>
            Token which represents the SPARQL CONTAINS Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.StrContainsKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new CONTAINS Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.StrDtKeywordToken">
            <summary>
            Token which represents the SPARQL STRDT Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.StrDtKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new STRDT Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.StrEndsKeywordToken">
            <summary>
            Token which represents the SPARQL STRENDS Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.StrEndsKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new STRENDS Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.StrLangKeywordToken">
            <summary>
            Token which represents the SPARQL STRLANG Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.StrLangKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new STRLANG Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.StrLenKeywordToken">
            <summary>
            Token which represents the SPARQL STRLEN Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.StrLenKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new STRLEN Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.StrStartsKeywordToken">
            <summary>
            Token which represents the SPARQL STRSTARTS Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.StrStartsKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new STRSTARTS Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.StrUUIDKeywordToken">
            <summary>
            Token which represents the SPARQL STRUUID Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.StrUUIDKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new STRUUID Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.SubStrKeywordToken">
            <summary>
            Token which represents the SPARQL SUBSTR Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.SubStrKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new SUBSTR Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.SumKeywordToken">
            <summary>
            Token which represents the SPARQL SUM Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.SumKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new SUM Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.TimezoneKeywordToken">
            <summary>
            Token which represents the SPARQL TIMEZONE Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TimezoneKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new TIMEZONE Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.TZKeywordToken">
            <summary>
            Token which represents the SPARQL TZ Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.TZKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new TZ Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.UCaseKeywordToken">
            <summary>
            Token which represents the SPARQL UCASE Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.UCaseKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new UCASE Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.UndefKeywordToken">
            <summary>
            Token which represents the SPARQL UNDEF Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.UndefKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new UNDEF Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.UnionKeywordToken">
            <summary>
            Token which represents the SPARQL UNION Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.UnionKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new UNION Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.UnsaidKeywordToken">
            <summary>
            Token which represents the SPARQL UNSAID Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.UnsaidKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new UNSAID Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.UriKeywordToken">
            <summary>
            Token which represents the SPARQL URI Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.UriKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new URI Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.UUIDKeywordToken">
            <summary>
            Token which represents the SPARQL UUID Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.UUIDKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new UUID Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.ValuesKeywordToken">
            <summary>
            Token which represents the SPARQL VALUES Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.ValuesKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new VALUES Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="post">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.WhereKeywordToken">
            <summary>
            Token which represents the SPARQL WHERE Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.WhereKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new WHERE Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.YearKeywordToken">
            <summary>
            Token which represents the SPARQL YEAR Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.YearKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new YEAR Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.PlusToken">
            <summary>
            Token which represents Mathematical Plus
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.PlusToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new Mathematical Plus Token
            </summary>
            <param name="line">Line the Token occurs on</param>
            <param name="pos">Position the Token occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.MinusToken">
            <summary>
            Token which represents Mathematical Minus
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.MinusToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new Mathematical Minus Token
            </summary>
            <param name="line">Line the Token occurs on</param>
            <param name="pos">Position the Token occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.MultiplyToken">
            <summary>
            Token which represents Mathematical Multiply
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.MultiplyToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new Mathematical Multiply Token
            </summary>
            <param name="line">Line the Token occurs on</param>
            <param name="pos">Position the Token occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.DivideToken">
            <summary>
            Token which represents Mathematical Divide
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.DivideToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new Mathematical Divide Token
            </summary>
            <param name="line">Line the Token occurs on</param>
            <param name="pos">Position the Token occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.NotEqualsToken">
            <summary>
            Token which represents Logical Not Equals
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.NotEqualsToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new Logical Not Equals Token
            </summary>
            <param name="line">Line the Token occurs on</param>
            <param name="pos">Position the Token occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.NegationToken">
            <summary>
            Token which represents Logical Negation
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.NegationToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new Logical Negation Token
            </summary>
            <param name="line">Line the Token occurs on</param>
            <param name="pos">Position the Token occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.AndToken">
            <summary>
            Token which represents Logical And
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.AndToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new Logical And Token
            </summary>
            <param name="line">Line the Token occurs on</param>
            <param name="pos">Position the Token occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.OrToken">
            <summary>
            Token which represents Logical Or
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.OrToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new Logical Or Token
            </summary>
            <param name="line">Line the Token occurs on</param>
            <param name="pos">Position the Token occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.LessThanToken">
            <summary>
            Token which represents Relational Less Than
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.LessThanToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new Relation Less Than Token
            </summary>
            <param name="line">Line the Token occurs on</param>
            <param name="pos">Position the Token occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.LessThanOrEqualToToken">
            <summary>
            Token which represents Relational Less Than or Equal To
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.LessThanOrEqualToToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new Relation Less Than or Equal To Token
            </summary>
            <param name="line">Line the Token occurs on</param>
            <param name="pos">Position the Token occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.GreaterThanToken">
            <summary>
            Token which represents Relational Greater Than
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.GreaterThanToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new Relation Greater Than Token
            </summary>
            <param name="line">Line the Token occurs on</param>
            <param name="pos">Position the Token occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.GreaterThanOrEqualToToken">
            <summary>
            Token which represents Greater Than or Equal To
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.GreaterThanOrEqualToToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new Relation Greater Than or Equal To Token
            </summary>
            <param name="line">Line the Token occurs on</param>
            <param name="pos">Position the Token occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.AddKeywordToken">
            <summary>
            Token which represents the SPARQL Update ADD Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.AddKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new ADD Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.ClearKeywordToken">
            <summary>
            Token which represents the SPARQL Update CLEAR Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.ClearKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new CLEAR Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.CopyKeywordToken">
            <summary>
            Token which represents the SPARQL Update COPY Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.CopyKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new COPY Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.CreateKeywordToken">
            <summary>
            Token which represents the SPARQL Update CREATE Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.CreateKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new CREATE Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.DataKeywordToken">
            <summary>
            Token which represents the SPARQL Update DATA Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.DataKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new DATA Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.DefaultKeywordToken">
            <summary>
            Token which represents the SPARQL Update DEFAULT Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.DefaultKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new DEFAULT Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.DeleteKeywordToken">
            <summary>
            Token which represents the SPARQL Update DELETE Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.DeleteKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new DELETE Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.DropKeywordToken">
            <summary>
            Token which represents the SPARQL Update DROP Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.DropKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new DROP Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.InsertKeywordToken">
            <summary>
            Token which represents the SPARQL Update INSERT Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.InsertKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new INSERT Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.IntoKeywordToken">
            <summary>
            Token which represents the SPARQL Update INTO Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.IntoKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new INTO Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.LoadKeywordToken">
            <summary>
            Token which represents the SPARQL Update LOAD Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.LoadKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new LOAD Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.MoveKeywordToken">
            <summary>
            Token which represents the SPARQL Update MOVE Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.MoveKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new MOVE Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.SilentKeywordToken">
            <summary>
            Token which represents the SPARQL Update SILENT Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.SilentKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new SILENT Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.ToKeywordToken">
            <summary>
            Token which represents the SPARQL Update TO Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.ToKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new TO Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.UsingKeywordToken">
            <summary>
            Token which represents the SPARQL Update USING Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.UsingKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new USING Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.WithKeywordToken">
            <summary>
            Token which represents the SPARQL Update WITH Keyword
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Tokens.WithKeywordToken.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new WITH Keyword Token
            </summary>
            <param name="line">Line the Keyword occurs on</param>
            <param name="pos">Position the Keyword occurs at</param>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.Token">
            <summary>
            Static Class which defines the Integer Constants used for Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.UNKNOWN">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.BOF">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.PREFIXDIRECTIVE">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.PREFIX">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.BASEDIRECTIVE">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.KEYWORDDIRECTIVE">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.FORALL">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.FORSOME">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.URI">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.QNAME">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.LITERAL">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.LONGLITERAL">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.LANGSPEC">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.DATATYPE">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.PLAINLITERAL">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.LITERALWITHLANG">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.LITERALWITHDT">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.GRAPHLITERAL">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.BLANKNODE">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.BLANKNODEWITHID">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.BLANKNODECOLLECTION">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.IMPLIES">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.IMPLIEDBY">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.EQUALS">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.AT">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.DOT">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.SEMICOLON">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.COMMA">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.HASH">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.UNDERSCORE">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.HATHAT">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.LEFTSQBRACKET">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.RIGHTSQBRACKET">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.LEFTBRACKET">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.RIGHTBRACKET">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.LEFTCURLYBRACKET">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.RIGHTCURLYBRACKET">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.HAT">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.EXCLAMATION">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.ASSIGNMENT">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.QUESTION">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.PATH">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.TAB">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.EOL">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.KEYWORDA">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.KEYWORDIS">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.KEYWORDOF">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.KEYWORDCUSTOM">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.KEYWORDDEF">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.VARIABLE">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.COMMENT">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.ASK">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.CONSTRUCT">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.DESCRIBE">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.SELECT">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.ORDERBY">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.LIMIT">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.OFFSET">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.DISTINCT">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.REDUCED">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.FROM">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.NAMED">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.FROMNAMED">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.WHERE">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.GRAPH">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.OPTIONAL">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.FILTER">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.ALL">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.UNION">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.ASC">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.DESC">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.AS">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.HAVING">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.GROUPBY">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.EXISTS">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.NOTEXISTS">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.LET">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.UNSAID">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.MINUS_P">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.SERVICE">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.BINDINGS">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.UNDEF">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.BIND">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.VALUES">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.STR">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.LANG">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.LANGMATCHES">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.SPARQLDATATYPE">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.BOUND">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.SAMETERM">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.ISURI">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.ISIRI">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.ISLITERAL">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.REGEX">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.DATATYPEFUNC">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.ISBLANK">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.IN">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.NOTIN">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.STRLANG">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.STRDT">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.IRI">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.COALESCE">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.IF">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.URIFUNC">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.ISNUMERIC">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.STRLEN">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.SUBSTR">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.UCASE">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.LCASE">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.STRSTARTS">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.STRENDS">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.CONTAINS">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.ENCODEFORURI">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.CONCAT">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.ABS">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.ROUND">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.CEIL">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.FLOOR">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.NOW">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.YEAR">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.MONTH">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.DAY">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.HOURS">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.MINUTES">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.SECONDS">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.TIMEZONE">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.TZ">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.MD5">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.SHA1">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.SHA224">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.SHA256">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.SHA384">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.SHA512">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.BNODE">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.RAND">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.STRAFTER">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.STRBEFORE">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.REPLACE">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.STRUUID">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.UUID">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.CALL">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.PLUS">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.MINUS">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.NOT">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.DIVIDE">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.MULTIPLY">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.GREATERTHAN">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.LESSTHAN">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.GREATERTHANOREQUALTO">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.LESSTHANOREQUALTO">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.NOTEQUALS">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.NEGATION">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.AND">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.OR">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.BITWISEOR">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.COUNT">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.SUM">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.AVG">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.MIN">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.MAX">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.NMIN">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.NMAX">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.MEDIAN">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.MODE">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.GROUPCONCAT">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.SAMPLE">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.SEPARATOR">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.LENGTH">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.INSERT">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.DELETE">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.DATA">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.LOAD">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.CLEAR">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.CREATE">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.DROP">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.SILENT">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.INTO">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.WITH">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.USING">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.DEFAULT">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.ALLWORD">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.ADD">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.COPY">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.MOVE">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.TO">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Tokens.Token.EOF">
            <summary>
            Constants defining Token Types
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.TurtleParser">
            <summary>
            Parser for Turtle syntax
            </summary>
            <threadsafety instance="true">Designed to be Thread Safe - should be able to call Load from multiple threads on different Graphs without issue</threadsafety>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleParser.#ctor">
            <summary>
            Creates a new Turtle Parser
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleParser.#ctor(VDS.RDF.Parsing.TurtleSyntax)">
            <summary>
            Creates a new Turtle Parser
            </summary>
            <param name="syntax">Turtle Syntax</param>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleParser.#ctor(VDS.RDF.Parsing.Tokens.TokenQueueMode)">
            <summary>
            Creates a new Turtle Parser which uses the given Token Queue Mode
            </summary>
            <param name="queueMode">Queue Mode for Turtle</param>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleParser.#ctor(VDS.RDF.Parsing.Tokens.TokenQueueMode,VDS.RDF.Parsing.TurtleSyntax)">
            <summary>
            Creates a new Turtle Parser which uses the given Token Queue Mode
            </summary>
            <param name="queueMode">Queue Mode for Turtle</param>
            <param name="syntax">Turtle Syntax</param>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleParser.Load(VDS.RDF.IGraph,System.IO.StreamReader)">
            <summary>
            Loads a Graph by reading Turtle syntax from the given input
            </summary>
            <param name="g">Graph to load into</param>
            <param name="input">Stream to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleParser.Load(VDS.RDF.IGraph,System.IO.TextReader)">
            <summary>
            Loads a Graph by reading Turtle syntax from the given input
            </summary>
            <param name="g">Graph to load into</param>
            <param name="input">Input to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleParser.Load(VDS.RDF.IRdfHandler,System.IO.StreamReader)">
            <summary>
            Loads RDF by reading Turtle syntax from the given input using a RDF Handler
            </summary>
            <param name="handler">RDF Handle to use</param>
            <param name="input">Stream to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleParser.Load(VDS.RDF.IRdfHandler,System.IO.TextReader)">
            <summary>
            Loads RDF by reading Turtle syntax from the given input using a RDF Handler
            </summary>
            <param name="handler">RDF Handle to use</param>
            <param name="input">Input to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleParser.Parse(VDS.RDF.Parsing.Contexts.TurtleParserContext)">
            <summary>
            Internal method which does the parsing of the input
            </summary>
            <param name="context">Parser Context</param>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleParser.TryParseDirective(VDS.RDF.Parsing.Contexts.TurtleParserContext,System.Boolean)">
            <summary>
            Tries to parse Base/Prefix declarations
            </summary>
            <param name="context">Parse Context</param>
            <param name="turtleStyle">Whether declarations are Turtle style (if false SPARQL style is assumed)</param>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleParser.TryParseTriples(VDS.RDF.Parsing.Contexts.TurtleParserContext)">
            <summary>
            Tries to parse Triples
            </summary>
            <param name="context">Parser Context</param>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleParser.TryParsePredicateObjectList(VDS.RDF.Parsing.Contexts.TurtleParserContext,VDS.RDF.INode,System.Boolean)">
            <summary>
            Tries to parse Predicate Object lists
            </summary>
            <param name="context">Parse Context</param>
            <param name="subj">Subject of the Triples</param>
            <param name="bnodeList">Whether this is a Blank Node Predicate Object list</param>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleParser.TryParseObjectList(VDS.RDF.Parsing.Contexts.TurtleParserContext,VDS.RDF.INode,VDS.RDF.INode,System.Boolean)">
            <summary>
            Tries to parse Object lists
            </summary>
            <param name="context">Parse Context</param>
            <param name="subj">Subject of the Triples</param>
            <param name="pred">Predicate of the Triples</param>
            <param name="bnodeList">Whether this is a Blank Node Object list</param>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleParser.TryParseCollection(VDS.RDF.Parsing.Contexts.TurtleParserContext,VDS.RDF.INode)">
            <summary>
            Tries to parse Collections
            </summary>
            <param name="context">Parser Context</param>
            <param name="firstSubj">Blank Node which is the head of the collection</param>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleParser.TryParseLiteral(VDS.RDF.Parsing.Contexts.TurtleParserContext,VDS.RDF.Parsing.Tokens.IToken)">
            <summary>
            Tries to parse Literal Tokens into Literal Nodes
            </summary>
            <param name="context">Parser Context</param>
            <param name="lit">Literal Token</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleParser.RaiseWarning(System.String)">
            <summary>
            Helper method which raises the Warning event if there is an event handler registered
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:VDS.RDF.Parsing.TurtleParser.ToString">
            <summary>
            Gets the String representation of the Parser which is a description of the syntax it parses
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Parsing.TurtleParser.TraceParsing">
            <summary>
            Gets/Sets whether Parsing Trace is written to the Console
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.TurtleParser.TraceTokeniser">
            <summary>
            Gets/Sets whether Tokeniser Trace is written to the Console
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.TurtleParser.TokenQueueMode">
            <summary>
            Gets/Sets the token queue mode used
            </summary>
        </member>
        <member name="E:VDS.RDF.Parsing.TurtleParser.Warning">
            <summary>
            Event which is raised when the parser detects issues with the input which are non-fatal
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.NQuadsSyntax">
            <summary>
            Possible NQuads Syntax modes
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.NQuadsSyntax.Original">
            <summary>
            The original <a href="http://sw.deri.org/2008/07/n-quads/">NQuads specification</a>
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.NQuadsSyntax.Rdf11">
            <summary>
            Standardized NQuads as specified in the <a href="http://www.w3.org/TR/n-quads/">RDF 1.1 NQuads</a> specification
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.NQuadsParser">
            <summary>
            Parser for parsing NQuads (NTriples with an additional Context i.e. Named Graphs)
            </summary>
            <remarks>
            <para>
            The Default Graph (if any) will be given the special Uri <strong>nquads:default-graph</strong>
            </para>
            <para>
            NQuads permits Blank Nodes and Literals to be used as Context, since the library only supports Graphs named with URIs these are translated into URIs of the following form:
            </para>
            <pre>
            nquads:bnode:12345678
            </pre>
            <pre>
            nquads:literal:87654321
            </pre>
            <para>
            In these URIs the numbers are the libraries hash codes for the node used as the Context.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Parsing.NQuadsParser.#ctor">
            <summary>
            Creates a new NQuads parser
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.NQuadsParser.#ctor(VDS.RDF.Parsing.NQuadsSyntax)">
            <summary>
            Creates a new NQuads parser
            </summary>
            <param name="syntax">NQuads syntax mode</param>
        </member>
        <member name="M:VDS.RDF.Parsing.NQuadsParser.#ctor(VDS.RDF.Parsing.Tokens.TokenQueueMode)">
            <summary>
            Creates a new NQuads parser
            </summary>
            <param name="queueMode">Token Queue Mode</param>
        </member>
        <member name="M:VDS.RDF.Parsing.NQuadsParser.#ctor(VDS.RDF.Parsing.NQuadsSyntax,VDS.RDF.Parsing.Tokens.TokenQueueMode)">
            <summary>
            Creates a new NQuads parser
            </summary>
            <param name="queueMode">Token Queue Mode</param>
            <param name="syntax">NQuads syntax mode</param>
        </member>
        <member name="M:VDS.RDF.Parsing.NQuadsParser.Load(VDS.RDF.ITripleStore,System.IO.TextReader)">
            <summary>
            Loads a RDF Dataset from the NQuads input into the given Triple Store
            </summary>
            <param name="store">Triple Store to load into</param>
            <param name="input">Input to load from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.NQuadsParser.Load(VDS.RDF.IRdfHandler,System.IO.TextReader)">
            <summary>
            Loads a RDF Dataset from the NQuads input using a RDF Handler
            </summary>
            <param name="handler">RDF Handler to use</param>
            <param name="input">Input to load from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.NQuadsParser.AsNTriplesSyntax(VDS.RDF.Parsing.NQuadsSyntax)">
            <summary>
            Converts syntax enumeration values from NQuads to NTriples
            </summary>
            <param name="syntax">NQuads Syntax</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.NQuadsParser.TryParseUri(VDS.RDF.IRdfHandler,System.String)">
            <summary>
            Tries to parse a URI
            </summary>
            <param name="handler">RDF Handler</param>
            <param name="uri">URI</param>
            <returns>URI Node if parsed successfully</returns>
        </member>
        <member name="M:VDS.RDF.Parsing.NQuadsParser.RaiseWarning(System.String)">
            <summary>
            Helper method used to raise the Warning event if there is an event handler registered
            </summary>
            <param name="message">Warning message</param>
        </member>
        <member name="M:VDS.RDF.Parsing.NQuadsParser.ToString">
            <summary>
            Gets the String representation of the Parser which is a description of the syntax it parses
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Parsing.NQuadsParser.TraceTokeniser">
            <summary>
            Gets/Sets whether Tokeniser Tracing is used
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.NQuadsParser.TokenQueueMode">
            <summary>
            Gets/Sets the token queue mode used
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.NQuadsParser.Syntax">
            <summary>
            Gets/Sets the NQuads syntax mode
            </summary>
        </member>
        <member name="E:VDS.RDF.Parsing.NQuadsParser.Warning">
            <summary>
            Event which Readers can raise when they notice syntax that is ambigious/deprecated etc which can still be parsed
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.SparqlBooleanParser">
            <summary>
            Parser for SPARQL Boolean results as Plain Text
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlBooleanParser.Load(VDS.RDF.Query.SparqlResultSet,System.IO.StreamReader)">
            <summary>
            Loads a Result Set from an Input Stream
            </summary>
            <param name="results">Result Set to load into</param>
            <param name="input">Input Stream to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlBooleanParser.Load(VDS.RDF.Query.SparqlResultSet,System.IO.TextReader)">
            <summary>
            Loads a Result Set from an Input 
            </summary>
            <param name="results">Result Set to load into</param>
            <param name="input">Input to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlBooleanParser.Load(VDS.RDF.ISparqlResultsHandler,System.IO.TextReader)">
            <summary>
            Loads a Result Set from an Input using a Results Handler
            </summary>
            <param name="handler">Results Handler to use</param>
            <param name="input">Input to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlBooleanParser.Load(VDS.RDF.ISparqlResultsHandler,System.IO.StreamReader)">
            <summary>
            Loads a Result Set from an Input Stream using a Results Handler
            </summary>
            <param name="handler">Results Handler to use</param>
            <param name="input">Input Stream to read from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlBooleanParser.RaiseWarning(System.String)">
            <summary>
            Helper Method which raises the Warning event when a non-fatal issue with the SPARQL Results being parsed is detected
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="M:VDS.RDF.Parsing.SparqlBooleanParser.ToString">
            <summary>
            Gets the String representation of the Parser which is a description of the syntax it parses
            </summary>
            <returns></returns>
        </member>
        <member name="E:VDS.RDF.Parsing.SparqlBooleanParser.Warning">
            <summary>
            Event raised when a non-fatal issue with the SPARQL Results being parsed is detected
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.TriXParser">
            <summary>
            Parser for parsing TriX (a named Graph XML format for RDF)
            </summary>
            <remarks>
            <para>
            The Default Graph (if any) will be given the special Uri <strong>trix:default-graph</strong>
            </para>
            <para>
            TriX permits Graphs to be named with Blank Node IDs, since the library only supports Graphs named with URIs these are converted to URIs of the form <strong>trix:local:ID</strong>
            </para>
            </remarks>
        </member>
        <member name="F:VDS.RDF.Parsing.TriXParser.TriXNamespaceURI">
            <summary>
            Current W3C Namespace Uri for TriX
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.TriXParser.Load(VDS.RDF.ITripleStore,System.IO.TextReader)">
            <summary>
            Loads the RDF Dataset from the TriX input into the given Triple Store
            </summary>
            <param name="store">Triple Store to load into</param>
            <param name="input">Input to load from</param>
        </member>
        <member name="M:VDS.RDF.Parsing.TriXParser.Error(System.String,System.Xml.XmlReader)">
            <summary>
            Helper method for raising informative standardised Parser Errors
            </summary>
            <param name="msg">The Error Message</param>
            <param name="n">The Node that is the cause of the Error</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Parsing.TriXParser.RaiseWarning(System.String)">
            <summary>
            Helper method used to raise the Warning event if there is an event handler registered
            </summary>
            <param name="message">Warning message</param>
        </member>
        <member name="M:VDS.RDF.Parsing.TriXParser.ToString">
            <summary>
            Gets the String representation of the Parser which is a description of the syntax it parses
            </summary>
            <returns></returns>
        </member>
        <member name="E:VDS.RDF.Parsing.TriXParser.Warning">
            <summary>
            Event which Readers can raise when they notice syntax that is ambigious/deprecated etc which can still be parsed
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Validation.ISyntaxValidator">
            <summary>
            Interface for classes which can validate Syntax
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Validation.ISyntaxValidator.Validate(System.String)">
            <summary>
            Validates the given Data
            </summary>
            <param name="data">Data</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Parsing.Validation.ISyntaxValidationResults">
            <summary>
            Interface for Validation Results
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Validation.ISyntaxValidationResults.IsValid">
            <summary>
            Gets whether the Syntax was valid
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Validation.ISyntaxValidationResults.Message">
            <summary>
            Gets an informational message about the validity/invalidity of the Syntax
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Validation.ISyntaxValidationResults.Warnings">
            <summary>
            Gets an enumeration of any warning messages
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Validation.ISyntaxValidationResults.Error">
            <summary>
            Gets any validation error
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Validation.ISyntaxValidationResults.Result">
            <summary>
            Gets any result object that was parsed from the syntax
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Validation.RdfDatasetSyntaxValidator">
            <summary>
            Syntax Validator for RDF Dataset Formats
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Validation.RdfDatasetSyntaxValidator.#ctor(VDS.RDF.IStoreReader)">
            <summary>
            Creates a new RDF Dataset Syntax Validator
            </summary>
            <param name="parser">Dataset Parser</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Validation.RdfDatasetSyntaxValidator.Validate(System.String)">
            <summary>
            Determines whether the data provided is valid syntax
            </summary>
            <param name="data">Data</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Parsing.Validation.RdfSyntaxValidator">
            <summary>
            Syntax Validator for validating RDF Graph syntaxes
            </summary>
        </member>
        <member name="F:VDS.RDF.Parsing.Validation.RdfSyntaxValidator._parser">
            <summary>
            Parser to use
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Validation.RdfSyntaxValidator.#ctor(VDS.RDF.IRdfReader)">
            <summary>
            Creates a new RDF Syntax Validator using the given Parser
            </summary>
            <param name="parser">Parser</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Validation.RdfSyntaxValidator.Validate(System.String)">
            <summary>
            Validates the given data to see if it is valid RDF Syntax
            </summary>
            <param name="data">Data</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Parsing.Validation.RdfStrictSyntaxValidator">
            <summary>
            Syntax Validator for RDF Graph syntaxes which is strict (any warnings are treated as errors)
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Validation.RdfStrictSyntaxValidator.#ctor(VDS.RDF.IRdfReader)">
            <summary>
            Creates a new Strict RDF Syntax Validator
            </summary>
            <param name="parser">Parser</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Validation.RdfStrictSyntaxValidator.Validate(System.String)">
            <summary>
            Validates the data to see if it is valid RDF syntax which does not produce any warnings
            </summary>
            <param name="data">Data</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Parsing.Validation.SparqlQueryValidator">
            <summary>
            Syntax Validator for SPARQL Queries
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Validation.SparqlQueryValidator.#ctor">
            <summary>
            Creates a new SPARQL Query Validator
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Validation.SparqlQueryValidator.#ctor(VDS.RDF.Parsing.SparqlQuerySyntax)">
            <summary>
            Creates a new SPARQL Query Validator using the given Syntax
            </summary>
            <param name="syntax">Query Syntax</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Validation.SparqlQueryValidator.#ctor(VDS.RDF.Parsing.SparqlQueryParser)">
            <summary>
            Creates a new SPARQL Query Validator using the given Query Parser
            </summary>
            <param name="parser">Query Parser</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Validation.SparqlQueryValidator.Validate(System.String)">
            <summary>
            Validates whether the given Data is a valid SPARQL Query
            </summary>
            <param name="data">Data</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Parsing.Validation.SparqlResultsValidator">
            <summary>
            Syntax Validator which validates SPARQL Results formats
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Validation.SparqlResultsValidator.#ctor(VDS.RDF.ISparqlResultsReader)">
            <summary>
            Creates a new SPARQL Results Format validator that uses the given parser
            </summary>
            <param name="parser">SPARQL Results Parser</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Validation.SparqlResultsValidator.Validate(System.String)">
            <summary>
            Validates the syntax to see if it is valid SPARQL Results
            </summary>
            <param name="data">Data to validate</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Parsing.Validation.SparqlUpdateValidator">
            <summary>
            A Syntax Validator for validating SPARQL Update Commands
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Validation.SparqlUpdateValidator.Validate(System.String)">
            <summary>
            Validates whether the given data is a SPARQL Update Command
            </summary>
            <param name="data">Data</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Parsing.Validation.SyntaxValidationResults">
            <summary>
            Represents Syntax Validation Results
            </summary>
        </member>
        <member name="M:VDS.RDF.Parsing.Validation.SyntaxValidationResults.#ctor(System.Boolean,System.String)">
            <summary>
            Creates new Syntax Validation Results
            </summary>
            <param name="valid">Whether the Syntax was valid</param>
            <param name="message">Validation Message</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Validation.SyntaxValidationResults.#ctor(System.Boolean,System.String,System.Object)">
            <summary>
            Creates new Syntax Validation Results
            </summary>
            <param name="valid">Whether the Syntax was valid</param>
            <param name="message">Validation Message</param>
            <param name="result">Results Object</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Validation.SyntaxValidationResults.#ctor(System.Boolean,System.String,System.Object,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates new Syntax Validation Results
            </summary>
            <param name="valid">Whether the Syntax was valid</param>
            <param name="message">Validation Message</param>
            <param name="result">Results Object</param>
            <param name="warnings">Enumeration of Warnings</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Validation.SyntaxValidationResults.#ctor(System.Boolean,System.String,System.Object,System.Collections.Generic.IEnumerable{System.String},System.Exception)">
            <summary>
            Creates new Syntax Validation Results
            </summary>
            <param name="valid">Whether the Syntax was valid</param>
            <param name="message">Validation Message</param>
            <param name="result">Results Object</param>
            <param name="warnings">Enumeration of Warnings</param>
            <param name="error">Error that occurred</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Validation.SyntaxValidationResults.#ctor(System.Boolean,System.String,System.Exception)">
            <summary>
            Creates new Syntax Validation Results
            </summary>
            <param name="valid">Whether the Syntax was valid</param>
            <param name="message">Validation Message</param>
            <param name="error">Error that occurred</param>
        </member>
        <member name="M:VDS.RDF.Parsing.Validation.SyntaxValidationResults.#ctor(System.String,System.Exception)">
            <summary>
            Creates new Syntax Validation Results
            </summary>
            <param name="message">Validation Message</param>
            <param name="error">Error that occurred</param>
        </member>
        <member name="P:VDS.RDF.Parsing.Validation.SyntaxValidationResults.IsValid">
            <summary>
            Whether the Syntax was valid
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Validation.SyntaxValidationResults.Message">
            <summary>
            Gets the Validation Message
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Validation.SyntaxValidationResults.Warnings">
            <summary>
            Gets the Warnings that were produced
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Validation.SyntaxValidationResults.Error">
            <summary>
            Gets the Error that occurred
            </summary>
        </member>
        <member name="P:VDS.RDF.Parsing.Validation.SyntaxValidationResults.Result">
            <summary>
            Gets the Result Object that was produced
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Aggregates.BaseAggregate">
            <summary>
            Abstract Base Class for Aggregate Functions
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Aggregates.ISparqlAggregate">
            <summary>
            Interface for SPARQL Aggregates which can be used to calculate aggregates over Results
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.ISparqlAggregate.Apply(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Applies the Aggregate to the Result Binder and returns a single Node as a Result
            </summary>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.ISparqlAggregate.Apply(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Applies the Aggregate to the Result Binder and returns a single Node as a Result
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingIDs">Enumerable of Binding IDs which the aggregate is applied over</param>
        </member>
        <member name="P:VDS.RDF.Query.Aggregates.ISparqlAggregate.Expression">
            <summary>
            Gets the Expression that the Aggregate is applied to
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Aggregates.ISparqlAggregate.Type">
            <summary>
            Gets the Type of the Aggregate
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Aggregates.ISparqlAggregate.Functor">
            <summary>
            Gets the URI/Keyword of the Aggregate
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Aggregates.ISparqlAggregate.Arguments">
            <summary>
            Gets the Arguments of the Aggregate
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Aggregates.BaseAggregate._expr">
            <summary>
            Expression that the aggregate operates over
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Aggregates.BaseAggregate._distinct">
            <summary>
            Whether a DISTINCT modifer is applied
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.BaseAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Base Constructor for Aggregates
            </summary>
            <param name="expr">Expression that the aggregate is over</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.BaseAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,System.Boolean)">
            <summary>
            Base Constructor for Aggregates
            </summary>
            <param name="expr">Expression that the aggregate is over</param>
            <param name="distinct">Whether a Distinct modifer is applied</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.BaseAggregate.Apply(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Applies the Aggregate to the Result Binder
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.BaseAggregate.Apply(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Applies the Aggregate to the Result Binder
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingIDs">Enumerable of Binding IDs over which the Aggregate applies</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.BaseAggregate.ToString">
            <summary>
            Gets the String representation of the Aggregate
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Aggregates.BaseAggregate.Expression">
            <summary>
            Expression that the Aggregate executes over
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Aggregates.BaseAggregate.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Aggregates.BaseAggregate.Functor">
            <summary>
            Gets the Functor of the Aggregate
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Aggregates.BaseAggregate.Arguments">
            <summary>
            Gets the Arguments of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Aggregates.Leviathan.AllAggregate">
            <summary>
            A Custom aggregate which requires the Expression to evaluate to true for all Sets in the Group
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Leviathan.AllAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new All Aggregate
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Leviathan.AllAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,System.Boolean)">
            <summary>
            Creates a new All Aggregate
            </summary>
            <param name="expr">Expression</param>
            <param name="distinct">Whether a DISTINCT modifier applies</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Leviathan.AllAggregate.Apply(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Applies the Aggregate to see if the expression evaluates true for every member of the Group
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingIDs">Binding IDs</param>
            <returns></returns>
            <remarks>
            Does lazy evaluation - as soon as it encounters a false/error it will return false
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Leviathan.AllAggregate.ToString">
            <summary>
            Gets the String Representation of the Aggregate
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Aggregates.Leviathan.AllAggregate.Functor">
            <summary>
            Gets the Functor of the Aggregate
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Aggregates.Leviathan.AnyAggregate">
            <summary>
            A Custom aggregate which requires the Expression to evaluate to true for at least one of the Sets in the Group
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Leviathan.AnyAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Any Aggregate
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Leviathan.AnyAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,System.Boolean)">
            <summary>
            Creates a new Any Aggregate
            </summary>
            <param name="expr">Expression</param>
            <param name="distinct">Whether a DISTINCT modifer applies</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Leviathan.AnyAggregate.Apply(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Applies the Aggregate to see if the expression evaluates true for any member of the Group
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingIDs">Binding IDs</param>
            <returns></returns>
            <remarks>
            Does lazy evaluation - as soon as it encounters a true it will return true
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Leviathan.AnyAggregate.ToString">
            <summary>
            Gets the String Representation of the Aggregate
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Aggregates.Leviathan.AnyAggregate.Functor">
            <summary>
            Gets the Functor of the Aggregate
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Aggregates.Leviathan.MedianAggregate">
            <summary>
            Class representing MEDIAN Aggregate Functions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Leviathan.MedianAggregate.#ctor(VDS.RDF.Query.Expressions.Primary.VariableTerm)">
            <summary>
            Creates a new MEDIAN Aggregate
            </summary>
            <param name="expr">Variable Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Leviathan.MedianAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new MEDIAN Aggregate
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Leviathan.MedianAggregate.#ctor(VDS.RDF.Query.Expressions.Primary.VariableTerm,System.Boolean)">
            <summary>
            Creates a new MEDIAN Aggregate
            </summary>
            <param name="expr">Variable Expression</param>
            <param name="distinct">Whether a DISTINCT modifier applies</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Leviathan.MedianAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,System.Boolean)">
            <summary>
            Creates a new MEDIAN Aggregate
            </summary>
            <param name="expr">Expression</param>
            <param name="distinct">Whether a DISTINCT modifer applies</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Leviathan.MedianAggregate.Apply(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Applies the Median Aggregate function to the results
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingIDs">Binding IDs over which the Aggregate applies</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Leviathan.MedianAggregate.ToString">
            <summary>
            Gets the String representation of the Aggregate
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Aggregates.Leviathan.MedianAggregate.Functor">
            <summary>
            Gets the Functor of the Aggregate
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Aggregates.Leviathan.ModeAggregate">
            <summary>
            Class representing MODE Aggregate Functions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Leviathan.ModeAggregate.#ctor(VDS.RDF.Query.Expressions.Primary.VariableTerm)">
            <summary>
            Creates a new MODE Aggregate
            </summary>
            <param name="expr">Variable Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Leviathan.ModeAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new MODE Aggregate
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Leviathan.ModeAggregate.#ctor(VDS.RDF.Query.Expressions.Primary.VariableTerm,System.Boolean)">
            <summary>
            Creates a new MODE Aggregate
            </summary>
            <param name="expr">Variable Expression</param>
            <param name="distinct">Whether a DISTINCT modifier applies</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Leviathan.ModeAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,System.Boolean)">
            <summary>
            Creates a new MODE Aggregate
            </summary>
            <param name="expr">Expression</param>
            <param name="distinct">Whether a DISTINCT modifier applies</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Leviathan.ModeAggregate.Apply(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Applies the Mode Aggregate function to the results
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingIDs">Binding IDs over which the Aggregate applies</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Leviathan.ModeAggregate.ToString">
            <summary>
            Gets the String representation of the Aggregate
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Aggregates.Leviathan.ModeAggregate.Functor">
            <summary>
            Gets the Functor of the Aggregate
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Aggregates.Leviathan.NoneAggregate">
            <summary>
            A Custom aggregate which requires the Expression to evaluate to false/error for all Sets in the Group
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Leviathan.NoneAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new None Aggregate
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Leviathan.NoneAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,System.Boolean)">
            <summary>
            Creates a new None Aggregate
            </summary>
            <param name="expr">Expression</param>
            <param name="distinct">Whether a DISTINCT modifer applies</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Leviathan.NoneAggregate.Apply(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Applies the Aggregate to see if the expression evaluates false/error for every member of the Group
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingIDs">Binding IDs</param>
            <returns></returns>
            <remarks>
            Does lazy evaluation - as soon as it encounters a true it will return false
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Leviathan.NoneAggregate.ToString">
            <summary>
            Gets the String Representation of the Aggregate
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Aggregates.Leviathan.NoneAggregate.Functor">
            <summary>
            Gets the Functor of the Aggregate
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Aggregates.Leviathan.NumericMaxAggregate">
            <summary>
            Class representing NMAX Aggregate Functions
            </summary>
            <remarks>
            Only operates over numeric data which is typed to one of the supported SPARQL Numeric types (integers, decimals and doubles)
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Leviathan.NumericMaxAggregate.#ctor(VDS.RDF.Query.Expressions.Primary.VariableTerm)">
            <summary>
            Creates a new NMAX Aggregate
            </summary>
            <param name="expr">Variable Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Leviathan.NumericMaxAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new NMAX Aggregate
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Leviathan.NumericMaxAggregate.#ctor(VDS.RDF.Query.Expressions.Primary.VariableTerm,System.Boolean)">
            <summary>
            Creates a new NMAX Aggregate
            </summary>
            <param name="expr">Variable Expression</param>
            <param name="distinct">Whether a DISTINCT modifier applies</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Leviathan.NumericMaxAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,System.Boolean)">
            <summary>
            Creates a new NMAX Aggregate
            </summary>
            <param name="expr">Expression</param>
            <param name="distinct">Whether a DISTINCT modifier applies</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Leviathan.NumericMaxAggregate.Apply(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Applies the Numeric Max Aggregate function to the results
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingIDs">Binding IDs over which the Aggregate applies</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Leviathan.NumericMaxAggregate.ToString">
            <summary>
            Gets the String representation of the Aggregate
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Aggregates.Leviathan.NumericMaxAggregate.Functor">
            <summary>
            Gets the Functor of the Aggregate
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Aggregates.Leviathan.NumericMinAggregate">
            <summary>
            Class representing NMIN Aggregate Functions
            </summary>
            <remarks>
            Only operates over numeric data which is typed to one of the supported SPARQL Numeric types (integers, decimals and doubles)
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Leviathan.NumericMinAggregate.#ctor(VDS.RDF.Query.Expressions.Primary.VariableTerm)">
            <summary>
            Creates a new NMIN Aggregate
            </summary>
            <param name="expr">Variable Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Leviathan.NumericMinAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new NMIN Aggregate
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Leviathan.NumericMinAggregate.#ctor(VDS.RDF.Query.Expressions.Primary.VariableTerm,System.Boolean)">
            <summary>
            Creates a new NMIN Aggregate
            </summary>
            <param name="expr">Variable Expression</param>
            <param name="distinct">Whether a DISTINCT modifier applies</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Leviathan.NumericMinAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,System.Boolean)">
            <summary>
            Creates a new NMIN Aggregate
            </summary>
            <param name="expr">Expression</param>
            <param name="distinct">Whether a DISTINCT modifier applies</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Leviathan.NumericMinAggregate.Apply(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Applies the Numeric Min Aggregate function to the results
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingIDs">Binding IDs over which the Aggregate applies</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Leviathan.NumericMinAggregate.ToString">
            <summary>
            Gets the String representation of the Aggregate
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Aggregates.Leviathan.NumericMinAggregate.Functor">
            <summary>
            Gets the Functor of the Aggregate
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Aggregates.Sparql.AverageAggregate">
            <summary>
            Class representing AVG Aggregate Functions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Sparql.AverageAggregate.#ctor(VDS.RDF.Query.Expressions.Primary.VariableTerm,System.Boolean)">
            <summary>
            Creates a new AVG Aggregate
            </summary>
            <param name="expr">Variable Expression</param>
            <param name="distinct">Whether a DISTINCT modifier applies</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Sparql.AverageAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,System.Boolean)">
            <summary>
            Creates a new AVG Aggregate
            </summary>
            <param name="expr">Expression</param>
            <param name="distinct">Whether a DISTINCT modifier applies</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Sparql.AverageAggregate.#ctor(VDS.RDF.Query.Expressions.Primary.VariableTerm)">
            <summary>
            Creates a new AVG Aggregate
            </summary>
            <param name="expr">Variable Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Sparql.AverageAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new AVG Aggregate
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Sparql.AverageAggregate.Apply(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Applies the Average Aggregate function to the results
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingIDs">Binding IDs over which the aggregate applies</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Sparql.AverageAggregate.ToString">
            <summary>
            Gets the String representation of the Aggregate
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Aggregates.Sparql.AverageAggregate.Functor">
            <summary>
            Gets the Functor of the Aggregate
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Aggregates.Sparql.CountAggregate">
            <summary>
            Class representing COUNT Aggregate Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Sparql.CountAggregate.#ctor(VDS.RDF.Query.Expressions.Primary.VariableTerm)">
            <summary>
            Creates a new COUNT Aggregate
            </summary>
            <param name="expr">Variable Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Sparql.CountAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Count Aggregate
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Sparql.CountAggregate.Apply(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Counts the results
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingIDs">Binding IDs over which the Aggregate applies</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Sparql.CountAggregate.ToString">
            <summary>
            Gets the String representation of the Aggregate
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Aggregates.Sparql.CountAggregate.Functor">
            <summary>
            Gets the Functor of the Aggregate
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Aggregates.Sparql.CountAllAggregate">
            <summary>
            Class representing COUNT(*) Aggregate Function
            </summary>
            <remarks>
            Differs from a COUNT in that it justs counts rows in the results
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Sparql.CountAllAggregate.#ctor">
            <summary>
            Creates a new COUNT(*) Aggregate
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Sparql.CountAllAggregate.Apply(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Counts the results
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingIDs">Binding IDs over which the Aggregate applies</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Sparql.CountAllAggregate.ToString">
            <summary>
            Gets the String representation of the Aggregate
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Aggregates.Sparql.CountAllAggregate.Functor">
            <summary>
            Gets the Functor of the Aggregate
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Aggregates.Sparql.CountAllAggregate.Arguments">
            <summary>
            Gets the Arguments of the Aggregate
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Aggregates.Sparql.CountAllDistinctAggregate">
            <summary>
            Class representing COUNT(DISTINCT *) Aggregate Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Sparql.CountAllDistinctAggregate.#ctor">
            <summary>
            Creates a new COUNT(DISTINCT*) Aggregate
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Sparql.CountAllDistinctAggregate.Apply(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Counts the results
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingIDs">Binding IDs over which the Aggregate applies</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Sparql.CountAllDistinctAggregate.ToString">
            <summary>
            Gets the String representation of the Aggregate
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Aggregates.Sparql.CountAllDistinctAggregate.Functor">
            <summary>
            Gets the Functor of the Aggregate
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Aggregates.Sparql.CountAllDistinctAggregate.Arguments">
            <summary>
            Gets the Arguments of the Aggregate
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Aggregates.Sparql.CountDistinctAggregate">
            <summary>
            Class representing COUNT(DISTINCT ?x) Aggregate Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Sparql.CountDistinctAggregate.#ctor(VDS.RDF.Query.Expressions.Primary.VariableTerm)">
            <summary>
            Creates a new COUNT(DISTINCT ?x) Aggregate
            </summary>
            <param name="expr">Variable Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Sparql.CountDistinctAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new COUNT DISTINCT Aggregate
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Sparql.CountDistinctAggregate.Apply(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Counts the results
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingIDs">Binding IDs over which the Aggregate applies</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Sparql.CountDistinctAggregate.ToString">
            <summary>
            Gets the String representation of the Aggregate
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Aggregates.Sparql.CountDistinctAggregate.Functor">
            <summary>
            Gets the Functor of the Aggregate
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Aggregates.Sparql.CountDistinctAggregate.Arguments">
            <summary>
            Gets the Arguments of the Aggregate
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Aggregates.Sparql.GroupConcatAggregate">
            <summary>
            Class representing GROUP_CONCAT Aggregate
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Aggregates.XPath.StringJoinAggregate">
            <summary>
            Represents the XPath fn:string-join() aggregate
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Aggregates.XPath.StringJoinAggregate._sep">
            <summary>
            Separator Expression
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.XPath.StringJoinAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath String Join aggregate which uses no separator
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.XPath.StringJoinAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath String Join aggregate
            </summary>
            <param name="expr">Expression</param>
            <param name="sep">Separator Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.XPath.StringJoinAggregate.Apply(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Applies the Aggregate in the given Context over the given Binding IDs
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingIDs">Binding IDs</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.XPath.StringJoinAggregate.ValueInternal(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the value of a member of the Group for concatenating as part of the result for the Group
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.XPath.StringJoinAggregate.GetSeparator(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the separator to use in the concatenation
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.XPath.StringJoinAggregate.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Aggregates.XPath.StringJoinAggregate.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Sparql.GroupConcatAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,System.Boolean)">
            <summary>
            Creates a new GROUP_CONCAT aggregate
            </summary>
            <param name="expr">Expression</param>
            <param name="distinct">Should a distinct modifer be applied</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Sparql.GroupConcatAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new GROUP_CONCAT aggregate
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Sparql.GroupConcatAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression,System.Boolean)">
            <summary>
            Creates a new GROUP_CONCAT aggregate
            </summary>
            <param name="expr">Expression</param>
            <param name="sepExpr">Separator Expression</param>
            <param name="distinct">Should a distinct modifer be applied</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Sparql.GroupConcatAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new GROUP_CONCAT aggregate
            </summary>
            <param name="expr">Expression</param>
            <param name="sepExpr">Separator Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Sparql.GroupConcatAggregate.Apply(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Applies the aggregate over the given bindings
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingIDs">Binding IDs</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Sparql.GroupConcatAggregate.ToString">
            <summary>
            Gets the String representation of the Aggregate
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Sparql.GroupConcatAggregate.ValueInternal(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the value of the aggregate for the given binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Aggregates.Sparql.GroupConcatAggregate.Functor">
            <summary>
            Gets the Functor of the Aggregate
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Aggregates.Sparql.MaxAggregate">
            <summary>
            Class representing MAX Aggregate Functions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Sparql.MaxAggregate.#ctor(VDS.RDF.Query.Expressions.Primary.VariableTerm,System.Boolean)">
            <summary>
            Creates a new MAX Aggregate
            </summary>
            <param name="expr">Variable Expression</param>
            <param name="distinct">Whether a DISTINCT modifier applies</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Sparql.MaxAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,System.Boolean)">
            <summary>
            Creates a new MAX Aggregate
            </summary>
            <param name="expr">Expression</param>
            <param name="distinct">Whether a DISTINCT modifier applies</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Sparql.MaxAggregate.#ctor(VDS.RDF.Query.Expressions.Primary.VariableTerm)">
            <summary>
            Creates a new MAX Aggregate
            </summary>
            <param name="expr">Variable Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Sparql.MaxAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new MAX Aggregate
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Sparql.MaxAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new MAX Aggregate
            </summary>
            <param name="distinct">Distinct Modifier</param>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Sparql.MaxAggregate.Apply(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Applies the Max Aggregate function to the results
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingIDs">Binding IDs over which the Aggregate applies</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Sparql.MaxAggregate.ToString">
            <summary>
            Gets the String representation of the Aggregate
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Aggregates.Sparql.MaxAggregate.Functor">
            <summary>
            Gets the Functor of the Aggregate
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Aggregates.Sparql.MinAggregate">
            <summary>
            Class representing MIN Aggregate Functions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Sparql.MinAggregate.#ctor(VDS.RDF.Query.Expressions.Primary.VariableTerm,System.Boolean)">
            <summary>
            Creates a new MIN Aggregate
            </summary>
            <param name="expr">Variable Expression</param>
            <param name="distinct">Whether a DISTINCT modifier applies</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Sparql.MinAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,System.Boolean)">
            <summary>
            Creates a new MIN Aggregate
            </summary>
            <param name="expr">Expression</param>
            <param name="distinct">Whether a DISTINCT modifier applies</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Sparql.MinAggregate.#ctor(VDS.RDF.Query.Expressions.Primary.VariableTerm)">
            <summary>
            Creates a new MIN Aggregate
            </summary>
            <param name="expr">Variable Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Sparql.MinAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new MIN Aggregate
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Sparql.MinAggregate.Apply(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Applies the Min Aggregate function to the results
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingIDs">Binding IDs over which the Aggregate applies</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Sparql.MinAggregate.ToString">
            <summary>
            Gets the String representation of the Aggregate
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Aggregates.Sparql.MinAggregate.Functor">
            <summary>
            Gets the Functor of the Aggregate
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Aggregates.Sparql.SampleAggregate">
            <summary>
            Class representing the SAMPLE aggregate
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Sparql.SampleAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new SAMPLE Aggregate
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Sparql.SampleAggregate.Apply(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Applies the SAMPLE Aggregate
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingIDs">Binding IDs</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Sparql.SampleAggregate.ToString">
            <summary>
            Gets the String representation
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Aggregates.Sparql.SampleAggregate.Functor">
            <summary>
            Gets the Functor of the Aggregate
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Aggregates.Sparql.SumAggregate">
            <summary>
            Class representing SUM Aggregate Functions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Sparql.SumAggregate.#ctor(VDS.RDF.Query.Expressions.Primary.VariableTerm,System.Boolean)">
            <summary>
            Creates a new SUM Aggregate
            </summary>
            <param name="expr">Variable Expression</param>
            <param name="distinct">Whether a DISTINCT modifier applies</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Sparql.SumAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,System.Boolean)">
            <summary>
            Creates a new SUM Aggregate
            </summary>
            <param name="expr">Expression</param>
            <param name="distinct">Whether a DISTINCT modifier applies</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Sparql.SumAggregate.#ctor(VDS.RDF.Query.Expressions.Primary.VariableTerm)">
            <summary>
            Creates a new SUM Aggregate
            </summary>
            <param name="expr">Variable Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Sparql.SumAggregate.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new SUM Aggregate
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Sparql.SumAggregate.Apply(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Applies the Sum Aggregate function to the results
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingIDs">Binding IDs over which the Aggregate applies</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Aggregates.Sparql.SumAggregate.ToString">
            <summary>
            Gets the String representation of the Aggregate
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Aggregates.Sparql.SumAggregate.Functor">
            <summary>
            Gets the Functor of the Aggregate
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.AlgebraExtensions">
            <summary>
            Static Helper class containing extensions used in the Algebra evaluation process
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.AlgebraExtensions.ProductWithTimeout(VDS.RDF.Query.Algebra.BaseMultiset,VDS.RDF.Query.Algebra.BaseMultiset,System.Int64)">
            <summary>
            Calculates the product of two mutlisets asynchronously with a timeout to restrict long running computations
            </summary>
            <param name="multiset">Multiset</param>
            <param name="other">Other Multiset</param>
            <param name="timeout">Timeout, if &lt;=0 no timeout is used and product will be computed sychronously</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.AlgebraExtensions.GenerateProduct(VDS.RDF.Query.Algebra.BaseMultiset,VDS.RDF.Query.Algebra.BaseMultiset,VDS.RDF.Query.Algebra.BaseMultiset,VDS.RDF.Query.Algebra.StopToken)">
            <summary>
            Method for generating product of two multisets asynchronously
            </summary>
            <param name="multiset">Multiset</param>
            <param name="other">Other Multiset</param>
            <param name="target">Mutliset to generate the product in</param>
            <param name="stop">Stop Token</param>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.AlgebraExtensions.GenerateProductDelegate">
            <summary>
            Delegate for generating product of two multisets asynchronously
            </summary>
            <param name="multiset">Multiset</param>
            <param name="other">Other Multiset</param>
            <param name="target">Mutliset to generate the product in</param>
            <param name="stop">Stop Token</param>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.StopToken">
            <summary>
            Token passed to asynchronous code to allow stop signalling
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.StopToken.ShouldStop">
            <summary>
            Gets/Sets whether the code should stop
            </summary>
            <remarks>
            Once set to true cannot be reset
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.AskBgp">
            <summary>
            Represents a BGP which is a set of Triple Patterns
            </summary>
            <remarks>
            <para>
            An Ask BGP differs from a BGP in that rather than evaluating each Triple Pattern in turn it evaluates across all Triple Patterns.  This is used for ASK queries where we are only concerned with whether a BGP matches and not in the specific solutions
            </para>
            <para>
            An Ask BGP can only contain concrete Triple Patterns and/or FILTERs and not any of the other specialised Triple Pattern classes
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.IBgp">
            <summary>
            Represents an Algebra construct which is a BGP
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.IBgp.PatternCount">
            <summary>
            Gets the Number of Patterns in the BGP
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.IBgp.TriplePatterns">
            <summary>
            Gets the Triple Patterns in the BGP
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.AskBgp.#ctor(VDS.RDF.Query.Patterns.ITriplePattern)">
            <summary>
            Creates a Streamed BGP containing a single Triple Pattern
            </summary>
            <param name="p">Triple Pattern</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.AskBgp.#ctor(System.Collections.Generic.IEnumerable{VDS.RDF.Query.Patterns.ITriplePattern})">
            <summary>
            Creates a Streamed BGP containing a set of Triple Patterns
            </summary>
            <param name="ps">Triple Patterns</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.AskBgp.IsAskEvaluablePattern(VDS.RDF.Query.Patterns.ITriplePattern)">
            <summary>
            Determines whether a Triple Pattern can be evaluated using a Lazy ASK approach
            </summary>
            <param name="p">Triple Pattern</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.AskBgp.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates the BGP against the Evaluation Context
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.AskBgp.ToString">
            <summary>
            Gets the String representation of the Algebra
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.AskBgp.ToQuery">
            <summary>
            Converts the Algebra back to a SPARQL Query
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.AskBgp.ToGraphPattern">
            <summary>
            Converts the BGP back to a Graph Pattern
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.AskBgp.PatternCount">
            <summary>
            Gets the number of Triple Patterns in the BGP
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.AskBgp.TriplePatterns">
            <summary>
            Gets the Triple Patterns in the BGP
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.AskBgp.Variables">
            <summary>
            Gets the Variables used in the Algebra
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.AskBgp.FixedVariables">
            <summary>
            Gets the enumeration of fixed variables in the algebra i.e. variables that are guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.AskBgp.FloatingVariables">
            <summary>
            Gets the enumeration of floating variables in the algebra i.e. variables that are not guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.AskBgp.IsEmpty">
            <summary>
            Gets whether the BGP is the emtpy BGP
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.AskUnion">
            <summary>
            Represents a Union
            </summary>
            <remarks>
            <para>
            An Ask Union differs from a standard Union in that if it finds a solution on the LHS it has no need to evaluate the RHS
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.IUnion">
            <summary>
            Represents an Algebra construct which is a Union
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.AskUnion.#ctor(VDS.RDF.Query.Algebra.ISparqlAlgebra,VDS.RDF.Query.Algebra.ISparqlAlgebra)">
            <summary>
            Creates a new Ask Union
            </summary>
            <param name="lhs">LHS Pattern</param>
            <param name="rhs">RHS Pattern</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.AskUnion.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates the Ask Union
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.AskUnion.ToString">
            <summary>
            Gets the String representation of the Algebra
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.AskUnion.ToQuery">
            <summary>
            Converts the Algebra back to a SPARQL Query
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.AskUnion.ToGraphPattern">
            <summary>
            Converts the Union back to Graph Patterns
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.AskUnion.Transform(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Transforms both sides of the Join using the given Optimiser
            </summary>
            <param name="optimiser">Optimser</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.AskUnion.TransformLhs(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Transforms the LHS of the Join using the given Optimiser
            </summary>
            <param name="optimiser">Optimser</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.AskUnion.TransformRhs(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Transforms the RHS of the Join using the given Optimiser
            </summary>
            <param name="optimiser">Optimser</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.AskUnion.Variables">
            <summary>
            Gets the Variables used in the Algebra
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.AskUnion.FloatingVariables">
            <summary>
            Gets the enumeration of floating variables in the algebra i.e. variables that are not guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.AskUnion.FixedVariables">
            <summary>
            Gets the enumeration of fixed variables in the algebra i.e. variables that are guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.AskUnion.Lhs">
            <summary>
            Gets the LHS of the Join
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.AskUnion.Rhs">
            <summary>
            Gets the RHS of the Join
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.BaseMultiset">
            <summary>
            Abstract Base Class for representing Multisets
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Algebra.BaseMultiset._orderedIDs">
            <summary>
            List of IDs that is used to return the Sets in order if the Multiset has been sorted
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BaseMultiset.Join(VDS.RDF.Query.Algebra.BaseMultiset)">
            <summary>
            Joins this Multiset to another Multiset
            </summary>
            <param name="other">Other Multiset</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BaseMultiset.LeftJoin(VDS.RDF.Query.Algebra.BaseMultiset,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Does a Left Join of this Multiset to another Multiset where the Join is predicated on the given Expression
            </summary>
            <param name="other">Other Multiset</param>
            <param name="expr">Expression</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BaseMultiset.ExistsJoin(VDS.RDF.Query.Algebra.BaseMultiset,System.Boolean)">
            <summary>
            Does an Exists Join of this Multiset to another Multiset where the Join is predicated on the existence/non-existence of a joinable solution on the RHS
            </summary>
            <param name="other">Other Multiset</param>
            <param name="mustExist">Whether a solution must exist in the Other Multiset for the join to be made</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BaseMultiset.MinusJoin(VDS.RDF.Query.Algebra.BaseMultiset)">
            <summary>
            Does a Minus Join of this Multiset to another Multiset where any joinable results are subtracted from this Multiset to give the resulting Multiset
            </summary>
            <param name="other">Other Multiset</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BaseMultiset.Product(VDS.RDF.Query.Algebra.BaseMultiset)">
            <summary>
            Does a Product of this Multiset and another Multiset
            </summary>
            <param name="other">Other Multiset</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BaseMultiset.Union(VDS.RDF.Query.Algebra.BaseMultiset)">
            <summary>
            Does a Union of this Multiset and another Multiset
            </summary>
            <param name="other">Other Multiset</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BaseMultiset.ContainsValue(System.String,VDS.RDF.INode)">
            <summary>
            Determines whether the Multiset contains the given Value for the given Variable
            </summary>
            <param name="var">Variable</param>
            <param name="n">Value</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BaseMultiset.ContainsVariable(System.String)">
            <summary>
            Determines whether the Multiset contains the given Variable
            </summary>
            <param name="var">Variable</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BaseMultiset.IsDisjointWith(VDS.RDF.Query.Algebra.BaseMultiset)">
            <summary>
            Determines whether the Mutliset is disjoint with the given Multiset
            </summary>
            <param name="other">Multiset</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BaseMultiset.Add(VDS.RDF.Query.Algebra.ISet)">
            <summary>
            Adds a Set to the Mutliset
            </summary>
            <param name="s">Set to add</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BaseMultiset.AddVariable(System.String)">
            <summary>
            Adds a Variable to the Multiset
            </summary>
            <param name="variable">Variable</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BaseMultiset.SetVariableOrder(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Sets the variable ordering for the multiset
            </summary>
            <param name="variables">Variable Ordering</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BaseMultiset.Remove(System.Int32)">
            <summary>
            Removes a Set (by ID) from the Multiset
            </summary>
            <param name="id">ID</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BaseMultiset.Sort(System.Collections.Generic.IComparer{VDS.RDF.Query.Algebra.ISet})">
            <summary>
            Sorts a Set based on the given Comparer
            </summary>
            <param name="comparer">Comparer on Sets</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BaseMultiset.Trim">
            <summary>
            Trims the Multiset of Temporary Variables
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BaseMultiset.Trim(System.String)">
            <summary>
            Trims the Multiset by removing all Values for the given Variable
            </summary>
            <param name="variable">Variable</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BaseMultiset.ToString">
            <summary>
            Gets the string representation of the multiset (intended for debugging only)
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.BaseMultiset.VirtualCount">
            <summary>
            The number of results that would be returned without any limit clause to a query or -1 if not supported. Defaults to the same value as the Count member
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.BaseMultiset.IsEmpty">
            <summary>
            Returns whether the Multiset is Empty
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.BaseMultiset.Count">
            <summary>
            Gets the Count of Sets in the Multiset
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.BaseMultiset.Variables">
            <summary>
            Gets the Variables in the Multiset
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.BaseMultiset.Sets">
            <summary>
            Gets the Sets in the Multiset
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.BaseMultiset.SetIDs">
            <summary>
            Gets the IDs of Sets in the Multiset
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.BaseMultiset.Item(System.Int32)">
            <summary>
            Retrieves the Set with the given ID
            </summary>
            <param name="id">ID</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.Bgp">
            <summary>
            Represents a BGP which is a set of Triple Patterns
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Bgp.#ctor">
            <summary>
            Creates a new empty BGP
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Bgp.#ctor(VDS.RDF.Query.Patterns.ITriplePattern)">
            <summary>
            Creates a BGP containing a single Triple Pattern
            </summary>
            <param name="p">Triple Pattern</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Bgp.#ctor(System.Collections.Generic.IEnumerable{VDS.RDF.Query.Patterns.ITriplePattern})">
            <summary>
            Creates a BGP containing a set of Triple Patterns
            </summary>
            <param name="ps">Triple Patterns</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Bgp.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates the BGP against the Evaluation Context
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Bgp.ToString">
            <summary>
            Returns the String representation of the BGP
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Bgp.ToQuery">
            <summary>
            Converts the Algebra back to a SPARQL Query
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Bgp.ToGraphPattern">
            <summary>
            Converts the BGP to a Graph Pattern
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Bgp.PatternCount">
            <summary>
            Gets the number of Triple Patterns in the BGP
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Bgp.TriplePatterns">
            <summary>
            Gets the Triple Patterns in the BGP
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Bgp.Variables">
            <summary>
            Gets the Variables used in the Algebra
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Bgp.FixedVariables">
            <summary>
            Gets the enumeration of fixed variables in the algebra i.e. variables that are guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Bgp.FloatingVariables">
            <summary>
            Gets the enumeration of floating variables in the algebra i.e. variables that are not guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Bgp.IsEmpty">
            <summary>
            Gets whether the BGP is the emtpy BGP
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.Bindings">
            <summary>
            Represents a BINDINGS modifier on a SPARQL Query
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Bindings.#ctor(VDS.RDF.Query.Patterns.BindingsPattern)">
            <summary>
            Creates a new BINDINGS modifier
            </summary>
            <param name="bindings">Bindings</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Bindings.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates the BINDINGS modifier
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Bindings.ToString">
            <summary>
            Gets the String representation of the Algebra
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Bindings.ToQuery">
            <summary>
            Converts the Algebra back to a SPARQL Query
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Bindings.ToGraphPattern">
            <summary>
            Convers the Algebra back to a Graph Pattern
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Bindings.Variables">
            <summary>
            Gets the Variables used in the Algebra
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Bindings.FloatingVariables">
            <summary>
            Gets the enumeration of floating variables in the algebra i.e. variables that are not guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Bindings.FixedVariables">
            <summary>
            Gets the enumeration of fixed variables in the algebra i.e. variables that are guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Bindings.BindingsPattern">
            <summary>
            Gets the Bindings 
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.Extend">
            <summary>
            Represents an Extend operation which is the formal algebraic form of the BIND operation
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Extend.#ctor(VDS.RDF.Query.Algebra.ISparqlAlgebra,VDS.RDF.Query.Expressions.ISparqlExpression,System.String)">
            <summary>
            Creates a new Extend operator
            </summary>
            <param name="pattern">Pattern</param>
            <param name="expr">Expression</param>
            <param name="var">Variable to bind to</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Extend.Transform(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Transforms the Inner Algebra using the given Optimiser
            </summary>
            <param name="optimiser">Optimiser</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Extend.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates the Algebra in the given context
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Extend.ToQuery">
            <summary>
            Converts the Algebra to a Query
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Extend.ToGraphPattern">
            <summary>
            Converts the Algebra to a Graph Pattern
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Extend.ToString">
            <summary>
            Gets the String representation of the Extend
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Extend.VariableName">
            <summary>
            Gets the Variable Name to be bound
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Extend.AssignExpression">
            <summary>
            Gets the Assignment Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Extend.InnerAlgebra">
            <summary>
            Gets the Inner Algebra
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Extend.Variables">
            <summary>
            Gets the variables used in the algebra
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Extend.FloatingVariables">
            <summary>
            Gets the enumeration of floating variables in the algebra i.e. variables that are not guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Extend.FixedVariables">
            <summary>
            Gets the enumeration of fixed variables in the algebra i.e. variables that are guaranteed to have a bound value
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.ISet">
            <summary>
            Interface for Sets which represents a possible solution during SPARQL evaluation
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.ISet.Add(System.String,VDS.RDF.INode)">
            <summary>
            Adds a Value for a Variable to the Set
            </summary>
            <param name="variable">Variable</param>
            <param name="value">Value</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.ISet.ContainsVariable(System.String)">
            <summary>
            Checks whether the Set contains a given Variable
            </summary>
            <param name="variable">Variable</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.ISet.IsCompatibleWith(VDS.RDF.Query.Algebra.ISet,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Gets whether the Set is compatible with a given set based on the given variables
            </summary>
            <param name="s">Set</param>
            <param name="vars">Variables</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.ISet.IsMinusCompatibleWith(VDS.RDF.Query.Algebra.ISet,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Gets whether the Set is minus compatible with a given set based on the given variables
            </summary>
            <param name="s">Set</param>
            <param name="vars">Variables</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.ISet.Remove(System.String)">
            <summary>
            Removes a Value for a Variable from the Set
            </summary>
            <param name="variable">Variable</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.ISet.Join(VDS.RDF.Query.Algebra.ISet)">
            <summary>
            Joins the set to another set
            </summary>
            <param name="other">Other Set</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.ISet.Copy">
            <summary>
            Copies the Set
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.ISet.ID">
            <summary>
            Gets/Sets the ID of the Set
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.ISet.Item(System.String)">
            <summary>
            Retrieves the Value in this set for the given Variable
            </summary>
            <param name="variable">Variable</param>
            <returns>Either a Node or a null</returns>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.ISet.Values">
            <summary>
            Gets the Values in the Set
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.ISet.Variables">
            <summary>
            Gets the Variables in the Set
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.BaseSet">
            <summary>
            Abstract Base Class for implementations of the <see cref="T:VDS.RDF.Query.Algebra.ISet">ISet</see> interface
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BaseSet.Add(System.String,VDS.RDF.INode)">
            <summary>
            Adds a Value for a Variable to the Set
            </summary>
            <param name="variable">Variable</param>
            <param name="value">Value</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BaseSet.ContainsVariable(System.String)">
            <summary>
            Checks whether the Set contains a given Variable
            </summary>
            <param name="variable">Variable</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BaseSet.IsCompatibleWith(VDS.RDF.Query.Algebra.ISet,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Gets whether the Set is compatible with a given set based on the given variables
            </summary>
            <param name="s">Set</param>
            <param name="vars">Variables</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BaseSet.IsMinusCompatibleWith(VDS.RDF.Query.Algebra.ISet,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Gets whether the Set is minus compatible with a given set based on the given variables
            </summary>
            <param name="s">Set</param>
            <param name="vars">Variables</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BaseSet.Remove(System.String)">
            <summary>
            Removes a Value for a Variable from the Set
            </summary>
            <param name="variable">Variable</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BaseSet.Join(VDS.RDF.Query.Algebra.ISet)">
            <summary>
            Joins the set to another set
            </summary>
            <param name="other">Other Set</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BaseSet.Copy">
            <summary>
            Copies the Set
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BaseSet.Equals(VDS.RDF.Query.Algebra.ISet)">
            <summary>
            Gets whether the Set is equal to another set
            </summary>
            <param name="other">Set to compare with</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BaseSet.Equals(System.Object)">
            <summary>
            Gets whether the Set is equal to another object
            </summary>
            <param name="obj">Object to compare with</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BaseSet.GetHashCode">
            <summary>
            Gets the Hash Code of the Set
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BaseSet.ToString">
            <summary>
            Gets the String representation of the Set
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.BaseSet.ID">
            <summary>
            Gets/Sets the ID of the Set
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.BaseSet.Item(System.String)">
            <summary>
            Retrieves the Value in this set for the given Variable
            </summary>
            <param name="variable">Variable</param>
            <returns>Either a Node or a null</returns>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.BaseSet.Values">
            <summary>
            Gets the Values in the Set
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.BaseSet.Variables">
            <summary>
            Gets the Variables in the Set
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.LazyBgp">
            <summary>
            Represents a BGP which is a set of Triple Patterns
            </summary>
            <remarks>
            <para>
            A Lazy BGP differs from a BGP in that rather than evaluating each Triple Pattern in turn it evaluates across all Triple Patterns.  This is used for queries where we are only want to retrieve a limited number of solutions
            </para>
            <para>
            A Lazy BGP can only contain concrete Triple Patterns and/or FILTERs and not any of other the specialised Triple Pattern classes
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.LazyBgp.#ctor(VDS.RDF.Query.Patterns.ITriplePattern)">
            <summary>
            Creates a Streamed BGP containing a single Triple Pattern
            </summary>
            <param name="p">Triple Pattern</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.LazyBgp.#ctor(System.Collections.Generic.IEnumerable{VDS.RDF.Query.Patterns.ITriplePattern})">
            <summary>
            Creates a Streamed BGP containing a set of Triple Patterns
            </summary>
            <param name="ps">Triple Patterns</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.LazyBgp.#ctor(VDS.RDF.Query.Patterns.ITriplePattern,System.Int32)">
            <summary>
            Creates a Streamed BGP containing a single Triple Pattern
            </summary>
            <param name="p">Triple Pattern</param>
            <param name="requiredResults">The number of Results the BGP should attempt to return</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.LazyBgp.#ctor(System.Collections.Generic.IEnumerable{VDS.RDF.Query.Patterns.ITriplePattern},System.Int32)">
            <summary>
            Creates a Streamed BGP containing a set of Triple Patterns
            </summary>
            <param name="ps">Triple Patterns</param>
            <param name="requiredResults">The number of Results the BGP should attempt to return</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.LazyBgp.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates the BGP against the Evaluation Context
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.LazyBgp.ToString">
            <summary>
            Gets the String representation of the Algebra
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.LazyBgp.ToQuery">
            <summary>
            Converts the Algebra back to a SPARQL Query
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.LazyBgp.ToGraphPattern">
            <summary>
            Converts the BGP to a Graph Pattern
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.LazyBgp.PatternCount">
            <summary>
            Gets the number of Triple Patterns in the BGP
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.LazyBgp.TriplePatterns">
            <summary>
            Gets the Triple Patterns in the BGP
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.LazyBgp.Variables">
            <summary>
            Gets the Variables used in the Algebra
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.LazyBgp.FixedVariables">
            <summary>
            Gets the enumeration of fixed variables in the algebra i.e. variables that are guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.LazyBgp.FloatingVariables">
            <summary>
            Gets the enumeration of floating variables in the algebra i.e. variables that are not guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.LazyBgp.IsEmpty">
            <summary>
            Gets whether the BGP is the emtpy BGP
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.LazyUnion">
            <summary>
            Represents a Union
            </summary>
            <remarks>
            <para>
            A Lazy Union differs from a standard Union in that if it finds sufficient solutions on the LHS it has no need to evaluate the RHS
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.LazyUnion.#ctor(VDS.RDF.Query.Algebra.ISparqlAlgebra,VDS.RDF.Query.Algebra.ISparqlAlgebra)">
            <summary>
            Creates a new Lazy Union
            </summary>
            <param name="lhs">LHS Pattern</param>
            <param name="rhs">RHS Pattern</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.LazyUnion.#ctor(VDS.RDF.Query.Algebra.ISparqlAlgebra,VDS.RDF.Query.Algebra.ISparqlAlgebra,System.Int32)">
            <summary>
            Creates a new Lazy Union
            </summary>
            <param name="lhs">LHS Pattern</param>
            <param name="rhs">RHS Pattern</param>
            <param name="requiredResults">The number of results that the Union should attempt to return</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.LazyUnion.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates the Lazy Union
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.LazyUnion.ToString">
            <summary>
            Gets the String representation of the Algebra
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.LazyUnion.ToQuery">
            <summary>
            Converts the Algebra back to a SPARQL Query
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.LazyUnion.ToGraphPattern">
            <summary>
            Converts the Union back to Graph Patterns
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.LazyUnion.Transform(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Transforms both sides of the Join using the given Optimiser
            </summary>
            <param name="optimiser">Optimser</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.LazyUnion.TransformLhs(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Transforms the LHS of the Join using the given Optimiser
            </summary>
            <param name="optimiser">Optimser</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.LazyUnion.TransformRhs(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Transforms the RHS of the Join using the given Optimiser
            </summary>
            <param name="optimiser">Optimser</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.LazyUnion.Variables">
            <summary>
            Gets the Variables used in the Algebra
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.LazyUnion.FloatingVariables">
            <summary>
            Gets the enumeration of floating variables in the algebra i.e. variables that are not guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.LazyUnion.FixedVariables">
            <summary>
            Gets the enumeration of fixed variables in the algebra i.e. variables that are guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.LazyUnion.Lhs">
            <summary>
            Gets the LHS of the Join
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.LazyUnion.Rhs">
            <summary>
            Gets the RHS of the Join
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.Distinct">
            <summary>
            Represents a Distinct modifier on a SPARQL Query
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Distinct.#ctor(VDS.RDF.Query.Algebra.ISparqlAlgebra)">
            <summary>
            Creates a new Distinct Modifier
            </summary>
            <param name="pattern">Pattern</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Distinct.#ctor(VDS.RDF.Query.Algebra.ISparqlAlgebra,System.Boolean)">
            <summary>
            Creates a new Distinct Modifier
            </summary>
            <param name="algebra">Inner Algebra</param>
            <param name="ignoreTemporaryVariables">Whether to ignore temporary variables</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Distinct.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates the Distinct Modifier
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Distinct.ToString">
            <summary>
            Gets the String representation of the Algebra
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Distinct.ToQuery">
            <summary>
            Converts the Algebra back to a SPARQL Query
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Distinct.ToGraphPattern">
            <summary>
            Throws an exception since a Distinct() cannot be converted back to a Graph Pattern
            </summary>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">Thrown since a Distinct() cannot be converted to a Graph Pattern</exception>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Distinct.Transform(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Transforms the Inner Algebra using the given Optimiser
            </summary>
            <param name="optimiser">Optimiser</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Distinct.Variables">
            <summary>
            Gets the Variables used in the Algebra
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Distinct.FloatingVariables">
            <summary>
            Gets the enumeration of floating variables in the algebra i.e. variables that are not guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Distinct.FixedVariables">
            <summary>
            Gets the enumeration of fixed variables in the algebra i.e. variables that are guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Distinct.InnerAlgebra">
            <summary>
            Gets the Inner Algebra
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.Reduced">
            <summary>
            Represents a Reduced modifier on a SPARQL Query
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Reduced.#ctor(VDS.RDF.Query.Algebra.ISparqlAlgebra)">
            <summary>
            Creates a new Reduced Modifier
            </summary>
            <param name="pattern">Pattern</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Reduced.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates the Reduced Modifier
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Reduced.ToString">
            <summary>
            Gets the String representation of the Algebra
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Reduced.ToQuery">
            <summary>
            Converts the Algebra back to a SPARQL Query
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Reduced.ToGraphPattern">
            <summary>
            Throws an exception since a Reduced() cannot be converted back to a Graph Pattern
            </summary>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">Thrown since a Reduced() cannot be converted to a Graph Pattern</exception>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Reduced.Transform(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Transforms the Inner Algebra using the given Optimiser
            </summary>
            <param name="optimiser">Optimiser</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Reduced.Variables">
            <summary>
            Gets the Variables used in the Algebra
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Reduced.FloatingVariables">
            <summary>
            Gets the enumeration of floating variables in the algebra i.e. variables that are not guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Reduced.FixedVariables">
            <summary>
            Gets the enumeration of fixed variables in the algebra i.e. variables that are guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Reduced.InnerAlgebra">
            <summary>
            Gets the Inner Algebra
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.Filter">
            <summary>
            Represents a Filter
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.IFilter">
            <summary>
            Represents an Algebra construct which is a Filter
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.IFilter.SparqlFilter">
            <summary>
            Gets the Filter
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Filter.#ctor(VDS.RDF.Query.Algebra.ISparqlAlgebra,VDS.RDF.Query.Filters.ISparqlFilter)">
            <summary>
            Creates a new Filter
            </summary>
            <param name="pattern">Algebra the Filter applies over</param>
            <param name="filter">Filter to apply</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Filter.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Applies the Filter over the results of evaluating the inner pattern
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Filter.ToString">
            <summary>
            Gets the String representation of the FILTER
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Filter.ToQuery">
            <summary>
            Converts the Algebra back to a SPARQL Query
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Filter.ToGraphPattern">
            <summary>
            Converts the Algebra back to a Graph Pattern
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Filter.Transform(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Transforms the Inner Algebra using the given Optimiser
            </summary>
            <param name="optimiser">Optimiser</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Filter.Variables">
            <summary>
            Gets the Variables used in the Algebra
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Filter.FloatingVariables">
            <summary>
            Gets the enumeration of floating variables in the algebra i.e. variables that are not guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Filter.FixedVariables">
            <summary>
            Gets the enumeration of fixed variables in the algebra i.e. variables that are guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Filter.SparqlFilter">
            <summary>
            Gets the Filter to be used
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Filter.InnerAlgebra">
            <summary>
            Gets the Inner Algebra
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.Graph">
            <summary>
            Represents a GRAPH clause
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Graph.#ctor(VDS.RDF.Query.Algebra.ISparqlAlgebra,VDS.RDF.Parsing.Tokens.IToken)">
            <summary>
            Creates a new Graph clause
            </summary>
            <param name="pattern">Pattern</param>
            <param name="graphSpecifier">Graph Specifier</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Graph.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates the Graph Clause by setting up the dataset, applying the pattern and then generating additional bindings if necessary
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Graph.ToString">
            <summary>
            Gets the String representation of the Algebra
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Graph.ToQuery">
            <summary>
            Converts the Algebra back to a SPARQL Query
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Graph.ToGraphPattern">
            <summary>
            Converts the Algebra back to a Graph Pattern
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Graph.Transform(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Transforms the Inner Algebra using the given Optimiser
            </summary>
            <param name="optimiser">Optimiser</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Graph.Variables">
            <summary>
            Gets the Variables used in the Algebra
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Graph.FixedVariables">
            <summary>
            Gets the enumeration of fixed variables in the algebra i.e. variables that are guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Graph.GraphSpecifier">
            <summary>
            Gets the Graph Specifier
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Graph.InnerAlgebra">
            <summary>
            Gets the Inner Algebra
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.GroupBy">
            <summary>
            Represents a Grouping
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.GroupBy.#ctor(VDS.RDF.Query.Algebra.ISparqlAlgebra,VDS.RDF.Query.Grouping.ISparqlGroupBy,System.Collections.Generic.IEnumerable{VDS.RDF.Query.SparqlVariable})">
            <summary>
            Creates a new Group By
            </summary>
            <param name="pattern">Pattern</param>
            <param name="grouping">Grouping to use</param>
            <param name="aggregates">Aggregates to calculate</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.GroupBy.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates a Group By by generating a <see cref="T:VDS.RDF.Query.Algebra.GroupMultiset">GroupMultiset</see> from the Input Multiset
            </summary>
            <param name="context">SPARQL Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.GroupBy.ToString">
            <summary>
            Gets the String representation of the 
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.GroupBy.ToQuery">
            <summary>
            Converts the Algebra back to a SPARQL Query
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.GroupBy.ToGraphPattern">
            <summary>
            Throws an exception since GroupBy() cannot be converted to a Graph Pattern
            </summary>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">Thrown since GroupBy() cannot be converted to a GraphPattern</exception>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.GroupBy.Transform(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Transforms the Inner Algebra using the given Optimiser
            </summary>
            <param name="optimiser">Optimiser</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.GroupBy.Variables">
            <summary>
            Gets the Variables used in the Algebra
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.GroupBy.FloatingVariables">
            <summary>
            Gets the enumeration of floating variables in the algebra i.e. variables that are not guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.GroupBy.FixedVariables">
            <summary>
            Gets the enumeration of fixed variables in the algebra i.e. variables that are guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.GroupBy.InnerAlgebra">
            <summary>
            Gets the Inner Algebra
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.GroupBy.Grouping">
            <summary>
            Gets the Grouping that is used
            </summary>
            <remarks>
            If the Query supplied in the <see cref="T:VDS.RDF.Query.SparqlEvaluationContext">SparqlEvaluationContext</see> is non-null and has a GROUP BY clause then that is applied rather than the clause with which the GroupBy algebra is instantiated
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.GroupBy.Aggregates">
            <summary>
            Gets the Aggregates that will be applied
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.GroupMultiset">
            <summary>
            Multiset which represents a Grouping of Sets from another Multiset
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.Multiset">
            <summary>
            Represents a Multiset of possible solutions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Algebra.Multiset._variables">
            <summary>
            Variables contained in the Multiset
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Algebra.Multiset._sets">
            <summary>
            Dictionary of Sets in the Multiset
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Algebra.Multiset._counter">
            <summary>
            Counter used to assign Set IDs
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Multiset.#ctor">
            <summary>
            Creates a new Empty Multiset
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Multiset.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a new Empty Mutliset that has the list of given Variables
            </summary>
            <param name="variables"></param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Multiset.#ctor(VDS.RDF.Query.SparqlResultSet)">
            <summary>
            Creates a new Multiset from a SPARQL Result Set
            </summary>
            <param name="results">Result Set</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Multiset.#ctor(VDS.RDF.Query.Algebra.GroupMultiset)">
            <summary>
            Creates a new Multiset by flattening a Group Multiset
            </summary>
            <param name="multiset">Group Multiset</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Multiset.ContainsValue(System.String,VDS.RDF.INode)">
            <summary>
            Determines whether a given Value is present for a given Variable in any Set in this Multiset
            </summary>
            <param name="var">Variable</param>
            <param name="n">Value</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Multiset.ContainsVariable(System.String)">
            <summary>
            Returns whether a given Variable is present in any Set in this Multiset
            </summary>
            <param name="var">Variable</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Multiset.IsDisjointWith(VDS.RDF.Query.Algebra.BaseMultiset)">
            <summary>
            Determines whether this Multiset is disjoint with another Multiset
            </summary>
            <param name="other">Other Multiset</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Multiset.Add(VDS.RDF.Query.Algebra.ISet)">
            <summary>
            Adds a Set to the Multiset
            </summary>
            <param name="s">Set</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Multiset.AddVariable(System.String)">
            <summary>
            Adds a Variable to the list of Variables present in this Multiset
            </summary>
            <param name="variable">Variable</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Multiset.SetVariableOrder(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Sets the variable ordering for the multiset
            </summary>
            <param name="variables">Variable Ordering</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Multiset.Remove(System.Int32)">
            <summary>
            Removes a Set from the Multiset
            </summary>
            <param name="id">Set ID</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Multiset.Trim">
            <summary>
            Trims the Multiset to remove Temporary Variables
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Multiset.Trim(System.String)">
            <summary>
            Trims the Multiset to remove the given Variable
            </summary>
            <param name="variable">Variable</param>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Multiset.IsEmpty">
            <summary>
            Gets whether the Multiset is empty
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Multiset.Count">
            <summary>
            Gets the number of Sets in the Multiset
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Multiset.Variables">
            <summary>
            Gets the Variables in the Multiset
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Multiset.Sets">
            <summary>
            Gets the Sets in the Multiset
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Multiset.SetIDs">
            <summary>
            Gets the IDs of Sets in the Multiset
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Multiset.Item(System.Int32)">
            <summary>
            Gets a Set from the Multiset
            </summary>
            <param name="id">Set ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.GroupMultiset.#ctor(VDS.RDF.Query.Algebra.BaseMultiset)">
            <summary>
            Creates a new Group Multiset
            </summary>
            <param name="contents">Multiset which contains the sets that are being grouped</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.GroupMultiset.GroupSetIDs(System.Int32)">
            <summary>
            Gets the enumeration of the IDs of Sets in the group with the given ID
            </summary>
            <param name="id">Group ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.GroupMultiset.Group(System.Int32)">
            <summary>
            Gets the Group with the given ID
            </summary>
            <param name="id">Group ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.GroupMultiset.AddGroup(VDS.RDF.Query.BindingGroup)">
            <summary>
            Adds a Group to the Multiset
            </summary>
            <param name="group"></param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.GroupMultiset.Add(VDS.RDF.Query.Algebra.ISet)">
            <summary>
            Adds a Set to the Group Multiset
            </summary>
            <param name="s">Set</param>
            <exception cref="T:VDS.RDF.Query.RdfQueryException">Thrown since this action is invalid on a Group Multiset</exception>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.GroupMultiset.Groups">
            <summary>
            Gets the enumeration of the Groups in the Multiset
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.GroupMultiset.Contents">
            <summary>
            Gets the Multiset which contains the Sets who are the members of the Groups this Multiset represents
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.Having">
            <summary>
            Represents a Having Clause
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Having.#ctor(VDS.RDF.Query.Algebra.ISparqlAlgebra,VDS.RDF.Query.Filters.ISparqlFilter)">
            <summary>
            Creates a new Having Clause
            </summary>
            <param name="pattern">Pattern</param>
            <param name="having">Having Clause</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Having.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates the Having Clause
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Having.ToString">
            <summary>
            Gets the String representation of the Algebra
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Having.ToQuery">
            <summary>
            Converts the Algebra back to a SPARQL Query
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Having.ToGraphPattern">
            <summary>
            Throws an exception since a Having() cannot be converted back to a Graph Pattern
            </summary>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">Thrown since a Having() cannot be converted to a Graph Pattern</exception>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Having.Transform(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Transforms the Inner Algebra using the given Optimiser
            </summary>
            <param name="optimiser">Optimiser</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Having.Variables">
            <summary>
            Gets the Variables used in the Algebra
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Having.FloatingVariables">
            <summary>
            Gets the enumeration of floating variables in the algebra i.e. variables that are not guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Having.FixedVariables">
            <summary>
            Gets the enumeration of fixed variables in the algebra i.e. variables that are guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Having.InnerAlgebra">
            <summary>
            Gets the Inner Algebra
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Having.HavingClause">
            <summary>
            Gets the HAVING clause used
            </summary>
            <remarks>
            If the Query supplied in the <see cref="T:VDS.RDF.Query.SparqlEvaluationContext">SparqlEvaluationContext</see> is non-null and has a HAVING clause then that is applied rather than the clause with which the Having algebra is instantiated
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.IdentityMultiset">
            <summary>
            Represents the Identity Multiset
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.IdentityMultiset.Join(VDS.RDF.Query.Algebra.BaseMultiset)">
            <summary>
            Joins the Multiset to another Multiset
            </summary>
            <param name="other">Other Multiset</param>
            <returns>
            The other Multiset
            </returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.IdentityMultiset.LeftJoin(VDS.RDF.Query.Algebra.BaseMultiset,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Left Joins the Multiset to another Multiset
            </summary>
            <param name="other">Other Multiset</param>
            <param name="expr">Expression which the Join is predicated on</param>
            <returns>The other Multiset</returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.IdentityMultiset.ExistsJoin(VDS.RDF.Query.Algebra.BaseMultiset,System.Boolean)">
            <summary>
            Exists Joins the Multiset to another Multiset
            </summary>
            <param name="other">Other Multiset</param>
            <param name="mustExist">Whether solutions must exist in the Other Multiset for the Join to suceed</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.IdentityMultiset.MinusJoin(VDS.RDF.Query.Algebra.BaseMultiset)">
            <summary>
            Minus Joins this Multiset to another Multiset
            </summary>
            <param name="other">Other Multiset</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.IdentityMultiset.Product(VDS.RDF.Query.Algebra.BaseMultiset)">
            <summary>
            Generates the Product of this Set and another Multiset
            </summary>
            <param name="other">Other Multiset</param>
            <returns>The other Multiset</returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.IdentityMultiset.Union(VDS.RDF.Query.Algebra.BaseMultiset)">
            <summary>
            Generates the Union of this Set and another Multiset
            </summary>
            <param name="other">Other Multiset</param>
            <returns>The other Multiset</returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.IdentityMultiset.ContainsValue(System.String,VDS.RDF.INode)">
            <summary>
            Returns True since the Identity Multiset is considered to contain all values
            </summary>
            <param name="var">Variable</param>
            <param name="n">Value</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.IdentityMultiset.ContainsVariable(System.String)">
            <summary>
            Returns False since the Identity Multiset contains no Variables
            </summary>
            <param name="var">Variable</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.IdentityMultiset.IsDisjointWith(VDS.RDF.Query.Algebra.BaseMultiset)">
            <summary>
            Returns False since the Identity Multiset is not disjoint with anything
            </summary>
            <param name="other">Other Multiset</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.IdentityMultiset.Add(VDS.RDF.Query.Algebra.ISet)">
            <summary>
            Adds a Set to the Multiset
            </summary>
            <param name="s">Set</param>
            <exception cref="T:VDS.RDF.Query.RdfQueryException">Thrown since this operation is invalid on an Identity Multiset</exception>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.IdentityMultiset.AddVariable(System.String)">
            <summary>
            Adds a Variable to the Multiset
            </summary>
            <param name="variable">Variable</param>
            <exception cref="T:VDS.RDF.Query.RdfQueryException">Thrown since this operation is invalid on an Identity Multiset</exception>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.IdentityMultiset.SetVariableOrder(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Sets the variable ordering for the multiset
            </summary>
            <param name="variables">Variable Ordering</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.IdentityMultiset.Remove(System.Int32)">
            <summary>
            Removes a Set to the Multiset
            </summary>
            <param name="id">Set ID</param>
            <exception cref="T:VDS.RDF.Query.RdfQueryException">Thrown since this operation is invalid on an Identity Multiset</exception>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.IdentityMultiset.IsEmpty">
            <summary>
            Returns false as the Identity Multiset is not considered empty
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.IdentityMultiset.Variables">
            <summary>
            Returns an empty enumerable as the Identity Multiset contains no Variables
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.IdentityMultiset.Sets">
            <summary>
            Returns an empty enumerable as the Identity Multiset contains no Sets
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.IdentityMultiset.SetIDs">
            <summary>
            Returns an empty enumerable as the Identity Multiset contains no Sets
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.IdentityMultiset.Item(System.Int32)">
            <summary>
            Gets the Set with the given ID
            </summary>
            <param name="index">Set ID</param>
            <returns></returns>
            <exception cref="T:VDS.RDF.Query.RdfQueryException">Thrown since the Identity Multiset contains no Sets</exception>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.IJoin">
            <summary>
            Represents an Algebra construct which is a Join
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.ILeftJoin">
            <summary>
            Represents an Algebra construct which is a Left Join
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.ILeftJoin.Filter">
            <summary>
            Gets the Filter used on the Join
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.IMinus">
            <summary>
            Represents an Algebra construct which is a Minus
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.IExistsJoin">
            <summary>
            Represents an Algebra construct which is an Exists Join
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.IExistsJoin.MustExist">
            <summary>
            Gets whether the Join requires compatible solutions to exist on the RHS
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.ExistsJoin">
            <summary>
            Represents a LeftJoin predicated on the existence/non-existence of joinable sets on the RHS for each item on the LHS
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.ExistsJoin.#ctor(VDS.RDF.Query.Algebra.ISparqlAlgebra,VDS.RDF.Query.Algebra.ISparqlAlgebra,System.Boolean)">
            <summary>
            Creates a new Exists Join
            </summary>
            <param name="lhs">LHS Pattern</param>
            <param name="rhs">RHS Pattern</param>
            <param name="mustExist">Whether a joinable set must exist on the RHS for the LHS set to be preserved</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.ExistsJoin.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates an ExistsJoin
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.ExistsJoin.ToString">
            <summary>
            Gets the String representation of the Algebra
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.ExistsJoin.ToQuery">
            <summary>
            Converts the Algebra back to a SPARQL Query
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.ExistsJoin.ToGraphPattern">
            <summary>
            Converts the Algebra back to a Graph Pattern
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.ExistsJoin.Transform(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Transforms both sides of the Join using the given Optimiser
            </summary>
            <param name="optimiser">Optimser</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.ExistsJoin.TransformLhs(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Transforms the LHS of the Join using the given Optimiser
            </summary>
            <param name="optimiser">Optimser</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.ExistsJoin.TransformRhs(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Transforms the RHS of the Join using the given Optimiser
            </summary>
            <param name="optimiser">Optimser</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.ExistsJoin.Variables">
            <summary>
            Gets the Variables used in the Algebra
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.ExistsJoin.FloatingVariables">
            <summary>
            Gets the enumeration of floating variables in the algebra i.e. variables that are not guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.ExistsJoin.FixedVariables">
            <summary>
            Gets the enumeration of fixed variables in the algebra i.e. variables that are guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.ExistsJoin.Lhs">
            <summary>
            Gets the LHS of the Join
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.ExistsJoin.Rhs">
            <summary>
            Gets the RHS of the Join
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.ExistsJoin.MustExist">
            <summary>
            Gets whether this is an EXISTS join
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.LeftJoin">
            <summary>
            Represents a LeftJoin predicated on an arbitrary filter expression
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.LeftJoin.#ctor(VDS.RDF.Query.Algebra.ISparqlAlgebra,VDS.RDF.Query.Algebra.ISparqlAlgebra)">
            <summary>
            Creates a new LeftJoin where there is no Filter over the join
            </summary>
            <param name="lhs">LHS Pattern</param>
            <param name="rhs">RHS Pattern</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.LeftJoin.#ctor(VDS.RDF.Query.Algebra.ISparqlAlgebra,VDS.RDF.Query.Algebra.ISparqlAlgebra,VDS.RDF.Query.Filters.ISparqlFilter)">
            <summary>
            Creates a new LeftJoin where there is a Filter over the join
            </summary>
            <param name="lhs">LHS Pattern</param>
            <param name="rhs">RHS Pattern</param>
            <param name="filter">Filter to decide which RHS solutions are valid</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.LeftJoin.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates the LeftJoin
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.LeftJoin.ToString">
            <summary>
            Gets the String representation of the Algebra
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.LeftJoin.ToQuery">
            <summary>
            Converts the Algebra back to a SPARQL Query
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.LeftJoin.ToGraphPattern">
            <summary>
            Converts the Algebra back to a SPARQL Query
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.LeftJoin.Transform(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Transforms both sides of the Join using the given Optimiser
            </summary>
            <param name="optimiser">Optimser</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.LeftJoin.TransformLhs(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Transforms the LHS of the Join using the given Optimiser
            </summary>
            <param name="optimiser">Optimser</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.LeftJoin.TransformRhs(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Transforms the RHS of the Join using the given Optimiser
            </summary>
            <param name="optimiser">Optimser</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.LeftJoin.Variables">
            <summary>
            Gets the Variables used in the Algebra
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.LeftJoin.FloatingVariables">
            <summary>
            Gets the enumeration of floating variables in the algebra i.e. variables that are not guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.LeftJoin.FixedVariables">
            <summary>
            Gets the enumeration of fixed variables in the algebra i.e. variables that are guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.LeftJoin.Filter">
            <summary>
            Gets the Filter that applies across the Join
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.LeftJoin.Lhs">
            <summary>
            Gets the LHS of the Join
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.LeftJoin.Rhs">
            <summary>
            Gets the RHS of the Join
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.Join">
            <summary>
            Represents a Join
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Join.#ctor(VDS.RDF.Query.Algebra.ISparqlAlgebra,VDS.RDF.Query.Algebra.ISparqlAlgebra)">
            <summary>
            Creates a new Join
            </summary>
            <param name="lhs">Left Hand Side</param>
            <param name="rhs">Right Hand Side</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Join.CreateJoin(VDS.RDF.Query.Algebra.ISparqlAlgebra,VDS.RDF.Query.Algebra.ISparqlAlgebra)">
            <summary>
            Creates either a Join or returns just one of the sides of the Join if one side is the empty BGP
            </summary>
            <param name="lhs">Left Hand Side</param>
            <param name="rhs">Right Hand Side</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Join.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evalutes a Join
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Join.ToString">
            <summary>
            Gets the String representation of the Join
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Join.ToQuery">
            <summary>
            Converts the Algebra back to a SPARQL Query
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Join.ToGraphPattern">
            <summary>
            Converts the Algebra back to a SPARQL Query
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Join.Transform(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Transforms both sides of the Join using the given Optimiser
            </summary>
            <param name="optimiser">Optimser</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Join.TransformLhs(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Transforms the LHS of the Join using the given Optimiser
            </summary>
            <param name="optimiser">Optimser</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Join.TransformRhs(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Transforms the RHS of the Join using the given Optimiser
            </summary>
            <param name="optimiser">Optimser</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Join.Variables">
            <summary>
            Gets the Variables used in the Algebra
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Join.FloatingVariables">
            <summary>
            Gets the enumeration of floating variables in the algebra i.e. variables that are not guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Join.FixedVariables">
            <summary>
            Gets the enumeration of fixed variables in the algebra i.e. variables that are guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Join.Lhs">
            <summary>
            Gets the LHS of the Join
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Join.Rhs">
            <summary>
            Gets the RHS of the Join
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.Union">
            <summary>
            Represents a Union
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Union.#ctor(VDS.RDF.Query.Algebra.ISparqlAlgebra,VDS.RDF.Query.Algebra.ISparqlAlgebra)">
            <summary>
            Creates a new Union
            </summary>
            <param name="lhs">LHS Pattern</param>
            <param name="rhs">RHS Pattern</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Union.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates the Union
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Union.ToString">
            <summary>
            Gets the String representation of the Algebra
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Union.ToQuery">
            <summary>
            Converts the Algebra back to a SPARQL Query
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Union.ToGraphPattern">
            <summary>
            Converts the Algebra back to a SPARQL Query
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Union.Transform(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Transforms both sides of the Join using the given Optimiser
            </summary>
            <param name="optimiser">Optimser</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Union.TransformLhs(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Transforms the LHS of the Join using the given Optimiser
            </summary>
            <param name="optimiser">Optimser</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Union.TransformRhs(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Transforms the RHS of the Join using the given Optimiser
            </summary>
            <param name="optimiser">Optimser</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Union.Variables">
            <summary>
            Gets the Variables used in the Algebra
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Union.FloatingVariables">
            <summary>
            Gets the enumeration of floating variables in the algebra i.e. variables that are not guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Union.FixedVariables">
            <summary>
            Gets the enumeration of fixed variables in the algebra i.e. variables that are guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Union.Lhs">
            <summary>
            Gets the LHS of the Join
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Union.Rhs">
            <summary>
            Gets the RHS of the Join
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.NegatedPropertySet">
            <summary>
            Represents a Negated Property Set in the SPARQL Algebra
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.NegatedPropertySet.#ctor(VDS.RDF.Query.Patterns.PatternItem,VDS.RDF.Query.Patterns.PatternItem,System.Collections.Generic.IEnumerable{VDS.RDF.Query.Paths.Property},System.Boolean)">
            <summary>
            Creates a new Negated Property Set
            </summary>
            <param name="start">Path Start</param>
            <param name="end">Path End</param>
            <param name="properties">Negated Properties</param>
            <param name="inverse">Whether this is a set of Inverse Negated Properties</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.NegatedPropertySet.#ctor(VDS.RDF.Query.Patterns.PatternItem,VDS.RDF.Query.Patterns.PatternItem,System.Collections.Generic.IEnumerable{VDS.RDF.Query.Paths.Property})">
            <summary>
            Creates a new Negated Property Set
            </summary>
            <param name="start">Path Start</param>
            <param name="end">Path End</param>
            <param name="properties">Negated Properties</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.NegatedPropertySet.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates the Negated Property Set
            </summary>
            <param name="context">SPARQL Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.NegatedPropertySet.ToQuery">
            <summary>
            Transforms the Algebra back into a SPARQL QUery
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.NegatedPropertySet.ToGraphPattern">
            <summary>
            Transforms the Algebra back into a Graph Pattern
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.NegatedPropertySet.ToString">
            <summary>
            Gets the String representation of the Algebra
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.NegatedPropertySet.PathStart">
            <summary>
            Gets the Path Start
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.NegatedPropertySet.PathEnd">
            <summary>
            Gets the Path End
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.NegatedPropertySet.Properties">
            <summary>
            Gets the Negated Properties
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.NegatedPropertySet.Inverse">
            <summary>
            Gets whether this is a set of Inverse Negated Properties
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.NegatedPropertySet.Variables">
            <summary>
            Gets the Variables used in the Algebra
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.NegatedPropertySet.FixedVariables">
            <summary>
            Gets the enumeration of fixed variables in the algebra i.e. variables that are guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.NegatedPropertySet.FloatingVariables">
            <summary>
            Gets the enumeration of floating variables in the algebra i.e. variables that are not guaranteed to have a bound value
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.NullOperator">
            <summary>
            Represents a part of the algebra that has been determined to not return any results in advance and so can be replaced with this operator which always returns null
            </summary>
            <remarks>
            Primarily intended for use with Algebra Optimisers which are rewriting the algebra to run against an out of memory dataset (e.g. SQL based) where it may be easily possible to determine if a triple pattern will match in advance of actually returning the matches.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.NullOperator.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a new Null Operator
            </summary>
            <param name="variables">Variables in the algebra that this null is replacing</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.NullOperator.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates the Null operator which of course always returns a <see cref="T:VDS.RDF.Query.Algebra.NullMultiset">NullMultiset</see>
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.NullOperator.ToQuery">
            <summary>
            Throws an error since a null operator cannot be transformed back into a query
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.NullOperator.ToGraphPattern">
            <summary>
            Throws an error since a null operator cannot be transformed back into a query
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.NullOperator.ToString">
            <summary>
            Gets the string representation of the algebra
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.NullOperator.Variables">
            <summary>
            Gets the variables used in this algebra
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.NullOperator.FixedVariables">
            <summary>
            Gets the enumeration of fixed variables in the algebra i.e. variables that are guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.NullOperator.FloatingVariables">
            <summary>
            Gets the enumeration of floating variables in the algebra i.e. variables that are not guaranteed to have a bound value
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.OneOrMorePath">
            <summary>
            Represents a One or More Path (e.g. rdf:type+) in the SPARQL Algebra
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.BaseArbitraryLengthPathOperator">
            <summary>
            Abstract Base Class for Arbitrary Length Path Operators
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.BasePathOperator">
            <summary>
            Abstract Base Class for Path Operators
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.IPathOperator">
            <summary>
            Interface for Property Path Operators
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.IPathOperator.PathStart">
            <summary>
            Gets the Path Start
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.IPathOperator.PathEnd">
            <summary>
            Gets the Path End
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.IPathOperator.Path">
            <summary>
            Gets the Property Path
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BasePathOperator.#ctor(VDS.RDF.Query.Patterns.PatternItem,VDS.RDF.Query.Paths.ISparqlPath,VDS.RDF.Query.Patterns.PatternItem)">
            <summary>
            Creates a new Path Operator
            </summary>
            <param name="start">Path Start</param>
            <param name="path">Property Path</param>
            <param name="end">Path End</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BasePathOperator.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates the Property Path
            </summary>
            <param name="context">SPARQL Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BasePathOperator.ToQuery">
            <summary>
            Transforms the Algebra back into a Query
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BasePathOperator.ToGraphPattern">
            <summary>
            Transforms the Algebra back into a Graph Pattern
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BasePathOperator.ToString">
            <summary>
            Gets the String representation of the Algebra
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.BasePathOperator.PathStart">
            <summary>
            Gets the Path Start
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.BasePathOperator.PathEnd">
            <summary>
            Gets the Path End
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.BasePathOperator.Path">
            <summary>
            Gets the Property Path
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.BasePathOperator.Variables">
            <summary>
            Gets the Variables used in the Algebra
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.BasePathOperator.FixedVariables">
            <summary>
            Gets the enumeration of fixed variables in the algebra i.e. variables that are guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.BasePathOperator.FloatingVariables">
            <summary>
            Gets the enumeration of floating variables in the algebra i.e. variables that are not guaranteed to have a bound value
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BaseArbitraryLengthPathOperator.#ctor(VDS.RDF.Query.Patterns.PatternItem,VDS.RDF.Query.Patterns.PatternItem,VDS.RDF.Query.Paths.ISparqlPath)">
            <summary>
            Creates a new Arbitrary Lengh Path Operator
            </summary>
            <param name="start">Path Start</param>
            <param name="end">Path End</param>
            <param name="path">Property Path</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BaseArbitraryLengthPathOperator.GetPathStarts(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.List{System.Collections.Generic.List{VDS.RDF.INode}},System.Boolean)">
            <summary>
            Determines the starting points for Path evaluation
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="paths">Paths</param>
            <param name="reverse">Whether to evaluate Paths in reverse</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.BaseArbitraryLengthPathOperator.EvaluateStep(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.List{VDS.RDF.INode},System.Boolean)">
            <summary>
            Evaluates a setp of the Path
            </summary>
            <param name="context">Context</param>
            <param name="path">Paths</param>
            <param name="reverse">Whether to evaluate Paths in reverse</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.OneOrMorePath.#ctor(VDS.RDF.Query.Patterns.PatternItem,VDS.RDF.Query.Patterns.PatternItem,VDS.RDF.Query.Paths.ISparqlPath)">
            <summary>
            Creates a new One or More Path
            </summary>
            <param name="start">Path Start</param>
            <param name="end">Path End</param>
            <param name="path">Path</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.OneOrMorePath.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates the One or More Path
            </summary>
            <param name="context">SPARQL Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.OneOrMorePath.ToString">
            <summary>
            Gets the String representation of the Algebra
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.OneOrMorePath.ToGraphPattern">
            <summary>
            Transforms the Algebra back into a Graph Pattern
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.ParallelUnion">
            <summary>
            Represents a Union which will be evaluated in parallel
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.ParallelUnion.#ctor(VDS.RDF.Query.Algebra.ISparqlAlgebra,VDS.RDF.Query.Algebra.ISparqlAlgebra)">
            <summary>
            Creates a new Union
            </summary>
            <param name="lhs">LHS Pattern</param>
            <param name="rhs">RHS Pattern</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.ParallelUnion.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates the Union
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.ParallelUnion.ToString">
            <summary>
            Gets the String representation of the Algebra
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.ParallelUnion.ToQuery">
            <summary>
            Converts the Algebra back to a SPARQL Query
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.ParallelUnion.ToGraphPattern">
            <summary>
            Converts the Algebra back to a SPARQL Query
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.ParallelUnion.Transform(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Transforms both sides of the Join using the given Optimiser
            </summary>
            <param name="optimiser">Optimser</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.ParallelUnion.TransformLhs(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Transforms the LHS of the Join using the given Optimiser
            </summary>
            <param name="optimiser">Optimser</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.ParallelUnion.TransformRhs(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Transforms the RHS of the Join using the given Optimiser
            </summary>
            <param name="optimiser">Optimser</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.ParallelUnion.Variables">
            <summary>
            Gets the Variables used in the Algebra
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.ParallelUnion.FloatingVariables">
            <summary>
            Gets the enumeration of floating variables in the algebra i.e. variables that are not guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.ParallelUnion.FixedVariables">
            <summary>
            Gets the enumeration of fixed variables in the algebra i.e. variables that are guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.ParallelUnion.Lhs">
            <summary>
            Gets the LHS of the Join
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.ParallelUnion.Rhs">
            <summary>
            Gets the RHS of the Join
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.ParallelJoin">
            <summary>
            Represents a Join which will be evaluated in parallel
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.ParallelJoin.#ctor(VDS.RDF.Query.Algebra.ISparqlAlgebra,VDS.RDF.Query.Algebra.ISparqlAlgebra)">
            <summary>
            Creates a new Join
            </summary>
            <param name="lhs">Left Hand Side</param>
            <param name="rhs">Right Hand Side</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.ParallelJoin.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evalutes a Join
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.ParallelJoin.ToString">
            <summary>
            Gets the String representation of the Join
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.ParallelJoin.ToQuery">
            <summary>
            Converts the Algebra back to a SPARQL Query
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.ParallelJoin.ToGraphPattern">
            <summary>
            Converts the Algebra back to a SPARQL Query
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.ParallelJoin.Transform(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Transforms both sides of the Join using the given Optimiser
            </summary>
            <param name="optimiser">Optimser</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.ParallelJoin.TransformLhs(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Transforms the LHS of the Join using the given Optimiser
            </summary>
            <param name="optimiser">Optimser</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.ParallelJoin.TransformRhs(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Transforms the RHS of the Join using the given Optimiser
            </summary>
            <param name="optimiser">Optimser</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.ParallelJoin.Variables">
            <summary>
            Gets the Variables used in the Algebra
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.ParallelJoin.FloatingVariables">
            <summary>
            Gets the enumeration of floating variables in the algebra i.e. variables that are not guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.ParallelJoin.FixedVariables">
            <summary>
            Gets the enumeration of fixed variables in the algebra i.e. variables that are guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.ParallelJoin.Lhs">
            <summary>
            Gets the LHS of the Join
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.ParallelJoin.Rhs">
            <summary>
            Gets the RHS of the Join
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.PropertyPath">
            <summary>
            Represents an arbitrary property path in the algebra (only used when strict algebra is generated)
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.PropertyPath.#ctor(VDS.RDF.Query.Patterns.PatternItem,VDS.RDF.Query.Paths.ISparqlPath,VDS.RDF.Query.Patterns.PatternItem)">
            <summary>
            Creates a new Property Path operator
            </summary>
            <param name="start">Path Start</param>
            <param name="path">Path Expression</param>
            <param name="end">Path End</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.PropertyPath.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates the Path in the given context
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.PropertyPath.ToGraphPattern">
            <summary>
            Converts the algebra back into a Graph Pattern
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.PropertyPath.ToString">
            <summary>
            Gets the string representation of the algebra
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.VariableRestrictionFilter">
            <summary>
            Abstract Base Class for specialised Filters which restrict the value of a variable to some values
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.VariableRestrictionFilter.#ctor(VDS.RDF.Query.Algebra.ISparqlAlgebra,System.String,VDS.RDF.Query.Filters.ISparqlFilter)">
            <summary>
            Creates a new Variable Restriction Filter
            </summary>
            <param name="pattern">Algebra the filter applies over</param>
            <param name="var">Variable to restrict on</param>
            <param name="filter">Filter to use</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.VariableRestrictionFilter.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evalutes the algebra for the given evaluation context
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.VariableRestrictionFilter.ToString">
            <summary>
            Gets the String representation of the FILTER
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.VariableRestrictionFilter.ToQuery">
            <summary>
            Converts the Algebra back to a SPARQL Query
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.VariableRestrictionFilter.ToGraphPattern">
            <summary>
            Converts the Algebra back to a Graph Pattern
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.VariableRestrictionFilter.Transform(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Transforms the Inner Algebra using the given Optimiser
            </summary>
            <param name="optimiser">Optimiser</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.VariableRestrictionFilter.RestrictionVariable">
            <summary>
            Gets the Variable that this filter restricts the value of
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.VariableRestrictionFilter.Variables">
            <summary>
            Gets the Variables used in the Algebra
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.VariableRestrictionFilter.FloatingVariables">
            <summary>
            Gets the enumeration of floating variables in the algebra i.e. variables that are not guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.VariableRestrictionFilter.FixedVariables">
            <summary>
            Gets the enumeration of fixed variables in the algebra i.e. variables that are guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.VariableRestrictionFilter.SparqlFilter">
            <summary>
            Gets the Filter to be used
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.VariableRestrictionFilter.InnerAlgebra">
            <summary>
            Gets the Inner Algebra
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.SingleValueRestrictionFilter">
            <summary>
            Abstract Base Class for specialised Filters which restrict the value of a variable to a single value
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.SingleValueRestrictionFilter.#ctor(VDS.RDF.Query.Algebra.ISparqlAlgebra,System.String,VDS.RDF.Query.Expressions.Primary.ConstantTerm,VDS.RDF.Query.Filters.ISparqlFilter)">
            <summary>
            Creates a new Single Value Restriction Filter
            </summary>
            <param name="pattern">Algebra the filter applies over</param>
            <param name="var">Variable to restrict on</param>
            <param name="term">Value to restrict to</param>
            <param name="filter">Filter to use</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.SingleValueRestrictionFilter.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Applies the Filter over the results of evaluating the inner pattern
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.SingleValueRestrictionFilter.RestrictionValue">
            <summary>
            Gets the Value Restriction which this filter applies
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.IdentityFilter">
            <summary>
            Represents a special case Filter where the Filter restricts a variable to just one value i.e. FILTER(?x = &lt;value&gt;)
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.IdentityFilter.#ctor(VDS.RDF.Query.Algebra.ISparqlAlgebra,System.String,VDS.RDF.Query.Expressions.Primary.ConstantTerm)">
            <summary>
            Creates a new Identity Filter
            </summary>
            <param name="pattern">Algebra the Filter applies over</param>
            <param name="var">Variable to restrict on</param>
            <param name="term">Expression Term</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.IdentityFilter.Transform(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Transforms the Inner Algebra using the given Optimiser
            </summary>
            <param name="optimiser">Optimiser</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.SameTermFilter">
            <summary>
            Represents a special case Filter where the Filter is supposed to restrict a variable to just one value i.e. FILTER(SAMETERM(?x, &lt;value&gt;))
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.SameTermFilter.#ctor(VDS.RDF.Query.Algebra.ISparqlAlgebra,System.String,VDS.RDF.Query.Expressions.Primary.ConstantTerm)">
            <summary>
            Creates a new Same Term Filter
            </summary>
            <param name="pattern">Algebra the Filter applies over</param>
            <param name="var">Variable to restrict on</param>
            <param name="term">Expression Term</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.SameTermFilter.Transform(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Transforms the Inner Algebra using the given Optimiser
            </summary>
            <param name="optimiser">Optimiser</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.SubQuery">
            <summary>
            Represents a sub-query as an Algebra operator (only used when strict algebra is generated)
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.SubQuery.#ctor(VDS.RDF.Query.SparqlQuery)">
            <summary>
            Creates a new subquery operator
            </summary>
            <param name="q">Subquery</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.SubQuery.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates the subquery in the given context
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.SubQuery.ToQuery">
            <summary>
            Converts the algebra back into a Query
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.SubQuery.ToGraphPattern">
            <summary>
            Converts the algebra back into a Subquery
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.SubQuery.ToString">
            <summary>
            Gets the string representation of the algebra
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.SubQuery.Variables">
            <summary>
            Gets the variables used in the subquery which are projected out of it
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.SubQuery.FloatingVariables">
            <summary>
            Gets the enumeration of floating variables in the algebra i.e. variables that are not guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.SubQuery.FixedVariables">
            <summary>
            Gets the enumeration of fixed variables in the algebra i.e. variables that are guaranteed to have a bound value
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.ZeroLengthPath">
            <summary>
            Represents a Zero Length Path in the SPARQL Algebra
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.ZeroLengthPath.#ctor(VDS.RDF.Query.Patterns.PatternItem,VDS.RDF.Query.Patterns.PatternItem,VDS.RDF.Query.Paths.ISparqlPath)">
            <summary>
            Creates a new Zero Length Path
            </summary>
            <param name="start">Path Start</param>
            <param name="end">Path End</param>
            <param name="path">Property Path</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.ZeroLengthPath.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates a Zero Length Path
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.ZeroLengthPath.ToString">
            <summary>
            Gets the String representation of the Algebra
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.ZeroLengthPath.ToGraphPattern">
            <summary>
            Transforms the Algebra back into a Graph Pattern
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.ZeroOrMorePath">
            <summary>
            Represents a Zero or More Path in the SPARQL Algebra
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.ZeroOrMorePath.#ctor(VDS.RDF.Query.Patterns.PatternItem,VDS.RDF.Query.Patterns.PatternItem,VDS.RDF.Query.Paths.ISparqlPath)">
            <summary>
            Creates a new Zero or More Path
            </summary>
            <param name="start">Path Start</param>
            <param name="end">Path End</param>
            <param name="path">Property Path</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.ZeroOrMorePath.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates a Zero or More Path
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.ZeroOrMorePath.ToString">
            <summary>
            Gets the String representation of the Algebra
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.ZeroOrMorePath.ToGraphPattern">
            <summary>
            Transforms the Algebra into a Graph Pattern
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Datasets.BaseQuadDataset">
            <summary>
            Abstract Base class of dataset designed around out of memory datasets where you rarely wish to load data into memory but simply wish to know which graph to look in for data
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseQuadDataset.#ctor">
            <summary>
            Creates a new Quad Dataset
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseQuadDataset.#ctor(System.Boolean)">
            <summary>
            Creates a new Quad Dataset
            </summary>
            <param name="unionDefaultGraph">Whether to make the default graph the union of all graphs</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseQuadDataset.#ctor(System.Uri)">
            <summary>
            Creates a new Quad Dataset
            </summary>
            <param name="defaultGraphUri">URI of the Default Graph</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseQuadDataset.SetActiveGraph(System.Collections.Generic.IEnumerable{System.Uri})">
            <summary>
            Sets the Active Graph
            </summary>
            <param name="graphUris">Graph URIs</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseQuadDataset.SetActiveGraph(System.Uri)">
            <summary>
            Sets the Active Graph
            </summary>
            <param name="graphUri">Graph URI</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseQuadDataset.SetDefaultGraph(System.Uri)">
            <summary>
            Sets the Default Graph
            </summary>
            <param name="graphUri">Graph URI</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseQuadDataset.SetDefaultGraph(System.Collections.Generic.IEnumerable{System.Uri})">
            <summary>
            Sets the Default Graph
            </summary>
            <param name="graphUris">Graph URIs</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseQuadDataset.ResetActiveGraph">
            <summary>
            Resets the Active Graph
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseQuadDataset.ResetDefaultGraph">
            <summary>
            Resets the Default Graph
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseQuadDataset.IsDefaultGraph(System.Uri)">
            <summary>
            Gets whether the given URI represents the default graph of the dataset
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseQuadDataset.AddGraph(VDS.RDF.IGraph)">
            <summary>
            Adds a Graph to the dataset
            </summary>
            <param name="g">Graph</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseQuadDataset.AddQuad(System.Uri,VDS.RDF.Triple)">
            <summary>
            Adds a Quad to the Dataset
            </summary>
            <param name="graphUri">Graph URI</param>
            <param name="t">Triple</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseQuadDataset.RemoveGraph(System.Uri)">
            <summary>
            Removes a Graph from the Dataset
            </summary>
            <param name="graphUri">Graph URI</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseQuadDataset.RemoveQuad(System.Uri,VDS.RDF.Triple)">
            <summary>
            Removes a Quad from the Dataset
            </summary>
            <param name="graphUri">Graph URI</param>
            <param name="t">Triple</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseQuadDataset.HasGraph(System.Uri)">
            <summary>
            Gets whether a Graph with the given URI is the Dataset
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseQuadDataset.HasGraphInternal(System.Uri)">
            <summary>
            Determines whether a given Graph exists in the Dataset
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseQuadDataset.GetGraphInternal(System.Uri)">
            <summary>
            Gets a Graph from the dataset
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseQuadDataset.GetModifiableGraph(System.Uri)">
            <summary>
            Gets a modifiable graph from the dataset
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseQuadDataset.ContainsTriple(VDS.RDF.Triple)">
            <summary>
            Gets whether the dataset contains a triple
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseQuadDataset.ContainsQuad(System.Uri,VDS.RDF.Triple)">
            <summary>
            Gets whether a Triple exists in a specific Graph of the dataset
            </summary>
            <param name="graphUri">Graph URI</param>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseQuadDataset.GetQuads(System.Uri)">
            <summary>
            Gets all the Triples for a specific graph of the dataset
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseQuadDataset.GetTriplesWithSubject(VDS.RDF.INode)">
            <summary>
            Gets all the Triples with a given subject
            </summary>
            <param name="subj">Subject</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseQuadDataset.GetQuadsWithSubject(System.Uri,VDS.RDF.INode)">
            <summary>
            Gets all the Triples with a given subject from a specific graph of the dataset
            </summary>
            <param name="graphUri">Graph URI</param>
            <param name="subj">Subject</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseQuadDataset.GetTriplesWithPredicate(VDS.RDF.INode)">
            <summary>
            Gets all the Triples with a given predicate
            </summary>
            <param name="pred">Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseQuadDataset.GetQuadsWithPredicate(System.Uri,VDS.RDF.INode)">
            <summary>
            Gets all the Triples with a given predicate from a specific graph of the dataset
            </summary>
            <param name="graphUri">Graph URI</param>
            <param name="pred">Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseQuadDataset.GetTriplesWithObject(VDS.RDF.INode)">
            <summary>
            Gets all the Triples with a given object
            </summary>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseQuadDataset.GetQuadsWithObject(System.Uri,VDS.RDF.INode)">
            <summary>
            Gets all the Triples with a given object from a specific graph of the dataset
            </summary>
            <param name="graphUri">Graph URI</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseQuadDataset.GetTriplesWithSubjectPredicate(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets all the Triples with a given subject and predicate
            </summary>
            <param name="subj">Subject</param>
            <param name="pred">Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseQuadDataset.GetQuadsWithSubjectPredicate(System.Uri,VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets all the Triples with a given subject and predicate from a specific graph of the dataset
            </summary>
            <param name="graphUri">Graph URI</param>
            <param name="subj">Subject</param>
            <param name="pred">Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseQuadDataset.GetTriplesWithSubjectObject(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets all the Triples with a given subject and object
            </summary>
            <param name="subj">Subject</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseQuadDataset.GetQuadsWithSubjectObject(System.Uri,VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets all the Triples with a given subject and object from a specific graph of the dataset
            </summary>
            <param name="graphUri">Graph URI</param>
            <param name="subj">Subject</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseQuadDataset.GetTriplesWithPredicateObject(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets all the Triples with a given predicate and object
            </summary>
            <param name="pred">Predicate</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseQuadDataset.GetQuadsWithPredicateObject(System.Uri,VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets all the Triples with a given predicate and object from a specific graph of the dataset
            </summary>
            <param name="graphUri">Graph URI</param>
            <param name="pred">Predicate</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseQuadDataset.Flush">
            <summary>
            Flushes any changes to the dataset
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseQuadDataset.Discard">
            <summary>
            Discards any changes to the dataset
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Datasets.BaseQuadDataset.DefaultGraphUris">
            <summary>
            Gets the Default Graph URIs
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Datasets.BaseQuadDataset.ActiveGraphUris">
            <summary>
            Gets the Active Graph URIs
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Datasets.BaseQuadDataset.UsesUnionDefaultGraph">
            <summary>
            Gets whether this dataset uses a union default graph
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Datasets.BaseQuadDataset.Graphs">
            <summary>
            Gets the Graphs in the dataset
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Datasets.BaseQuadDataset.GraphUris">
            <summary>
            Gets the URIs of the graphs in the dataset
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Datasets.BaseQuadDataset.Item(System.Uri)">
            <summary>
            Gets the Graph with the given URI from the Dataset
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
            <remarks>
            <para>
            This property need only return a read-only view of the Graph, code which wishes to modify Graphs should use the <see cref="M:VDS.RDF.Query.Datasets.ISparqlDataset.GetModifiableGraph(System.Uri)">GetModifiableGraph()</see> method to guarantee a Graph they can modify and will be persisted to the underlying storage
            </para>
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.Datasets.BaseQuadDataset.HasTriples">
            <summary>
            Gets whether the dataset has any triples
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Datasets.BaseQuadDataset.Triples">
            <summary>
            Gets all triples from the dataset
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Datasets.BaseImmutableQuadDataset">
            <summary>
            Abstract Base class for immutable quad datasets
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseImmutableQuadDataset.AddGraph(VDS.RDF.IGraph)">
            <summary>
            Throws an error as this dataset is immutable
            </summary>
            <param name="g">Graph</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseImmutableQuadDataset.AddQuad(System.Uri,VDS.RDF.Triple)">
            <summary>
            Throws an error as this dataset is immutable
            </summary>
            <param name="graphUri">Graph URI</param>
            <param name="t">Triple</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseImmutableQuadDataset.RemoveGraph(System.Uri)">
            <summary>
            Throws an error as this dataset is immutable
            </summary>
            <param name="graphUri">Graph URI</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseImmutableQuadDataset.RemoveQuad(System.Uri,VDS.RDF.Triple)">
            <summary>
            Throws an error as this dataset is immutable
            </summary>
            <param name="graphUri">Graph URI</param>
            <param name="t">Triple</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseImmutableQuadDataset.GetModifiableGraph(System.Uri)">
            <summary>
            Throws an error as this dataset is immutable
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Datasets.BaseTransactionalQuadDataset">
            <summary>
            Abstract Base class for quad datasets that support transactions
            </summary>
            <remarks>
            <para>
            The Transaction implementation of dotNetRDF is based upon a MRSW concurrency model, since only one writer may be active changes are immediately pushed to the dataset and visible within the transaction and they are committed or rolled back when <see cref="M:VDS.RDF.Query.Datasets.BaseTransactionalDataset.Flush">Flush()</see> or <see cref="M:VDS.RDF.Query.Datasets.BaseTransactionalDataset.Discard">Discard()</see> are called.
            </para>
            <para>
            So in practical terms it is perfectly OK for the storage to be updated during a transaction because if the transaction fails the changes will be rolled back because all changes are stored in-memory until the end of the transaction.  This may not be an ideal transaction model for all scenarios so you may wish to implement your own version of transactions or code your implementations of the abstract methods accordingly to limit actual persistence to the end of a transaction.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseTransactionalQuadDataset.#ctor">
            <summary>
            Creates a Transactional Quad Dataset
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseTransactionalQuadDataset.#ctor(System.Boolean)">
            <summary>
            Creates a Transactional Quad Dataset
            </summary>
            <param name="unionDefaultGraph">Sets whether the default graph should be the union of all graphs</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseTransactionalQuadDataset.#ctor(System.Uri)">
            <summary>
            Creates a Transactional Quad Dataset
            </summary>
            <param name="defaultGraphUri">Default Graph URI</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseTransactionalQuadDataset.AddGraph(VDS.RDF.IGraph)">
            <summary>
            Adds a Graph to the Dataset
            </summary>
            <param name="g">Graph to add</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseTransactionalQuadDataset.AddGraphInternal(VDS.RDF.IGraph)">
            <summary>
            Adds a Graph to the Dataset
            </summary>
            <param name="g">Graph to add</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseTransactionalQuadDataset.RemoveGraph(System.Uri)">
            <summary>
            Removes a Graph from the Dataset
            </summary>
            <param name="graphUri">Graph URI</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseTransactionalQuadDataset.RemoveGraphInternal(System.Uri)">
            <summary>
            Removes a Graph from the dataset
            </summary>
            <param name="graphUri">Graph URI</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseTransactionalQuadDataset.GetModifiableGraph(System.Uri)">
            <summary>
            Gets a Graph from the Dataset that can be modified
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseTransactionalQuadDataset.GetModifiableGraphInternal(System.Uri)">
            <summary>
            Gets a Graph from the Dataset that can be modified transactionally
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseTransactionalQuadDataset.Flush">
            <summary>
            Ensures that any changes to the Dataset (if any) are flushed to the underlying Storage
            </summary>
            <remarks>
            Commits the Active Transaction
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseTransactionalQuadDataset.Discard">
            <summary>
            Ensures that any changes to the Dataset (if any) are discarded
            </summary>
            <remarks>
            Rollsback the Active Transaction
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseTransactionalQuadDataset.FlushInternal">
            <summary>
            Allows the derived dataset to take any post-Flush() actions required
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseTransactionalQuadDataset.DiscardInternal">
            <summary>
            Allows the derived dataset to take any post-Discard() actions required
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Datasets.BaseTransactionalQuadDataset.Item(System.Uri)">
            <summary>
            Gets a Graph from the dataset
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Datasets.InMemoryQuadDataset">
            <summary>
            An in-memory dataset that operates in terms of quads, underlying storage is identical to a <see cref="T:VDS.RDF.Query.Datasets.InMemoryDataset">InMemoryDataset</see> though this dataset should be more performant for queries that access named graphs frequently
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.InMemoryQuadDataset.#ctor">
            <summary>
            Creates a new in-memory dataset using the default in-memory <see cref="T:VDS.RDF.TripleStore">TripleStore</see> as the underlying storage
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.InMemoryQuadDataset.#ctor(System.Boolean)">
            <summary>
            Creates a new in-memory dataset using the default in-memory <see cref="T:VDS.RDF.TripleStore">TripleStore</see> as the underlying storage
            </summary>
            <param name="unionDefaultGraph">Whether the Default Graph when no Active/Default Graph is explicitly set should be the union of all Graphs in the Dataset</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.InMemoryQuadDataset.#ctor(VDS.RDF.IGraph)">
            <summary>
            Creates a new in-memory dataset containing initially just the given graph and treating the given graph as the default graph of the dataset
            </summary>
            <param name="g">Graph</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.InMemoryQuadDataset.#ctor(VDS.RDF.IInMemoryQueryableStore)">
            <summary>
            Creates a new In-Memory dataset
            </summary>
            <param name="store">In-Memory queryable store</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.InMemoryQuadDataset.#ctor(VDS.RDF.IInMemoryQueryableStore,System.Boolean)">
            <summary>
            Creates a new In-Memory dataset
            </summary>
            <param name="store">In-Memory queryable store</param>
            <param name="unionDefaultGraph">Whether the Default Graph when no Active/Default Graph is explicitly set should be the union of all Graphs in the Dataset</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.InMemoryQuadDataset.#ctor(VDS.RDF.IInMemoryQueryableStore,System.Uri)">
            <summary>
            Creates a new In-Memory dataset
            </summary>
            <param name="store">In-Memory queryable store</param>
            <param name="defaultGraphUri">Default Graph URI</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.InMemoryQuadDataset.AddGraphInternal(VDS.RDF.IGraph)">
            <summary>
            Adds a Graph to the Dataset merging it with any existing Graph with the same URI
            </summary>
            <param name="g">Graph</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.InMemoryQuadDataset.RemoveGraphInternal(System.Uri)">
            <summary>
            Removes a Graph from the Dataset
            </summary>
            <param name="graphUri">Graph URI</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.InMemoryQuadDataset.HasGraphInternal(System.Uri)">
            <summary>
            Gets whether a Graph with the given URI is the Dataset
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.InMemoryQuadDataset.GetGraphInternal(System.Uri)">
            <summary>
            Gets the Graph with the given URI from the Dataset
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
            <remarks>
            <para>
            For In-Memory datasets the Graph returned from this property is no different from the Graph returned by the <see cref="M:VDS.RDF.Query.Datasets.InMemoryDataset.GetModifiableGraphInternal(System.Uri)">GetModifiableGraphInternal()</see> method
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.InMemoryQuadDataset.GetModifiableGraphInternal(System.Uri)">
            <summary>
            Gets a Modifiable wrapper around a Graph in the Dataset
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.InMemoryQuadDataset.AddQuad(System.Uri,VDS.RDF.Triple)">
            <summary>
            Adds a quad to the dataset
            </summary>
            <param name="graphUri">Graph URI</param>
            <param name="t">Triple</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.InMemoryQuadDataset.ContainsQuad(System.Uri,VDS.RDF.Triple)">
            <summary>
            Gets whether the dataset contains a given Quad
            </summary>
            <param name="graphUri">Graph URI</param>
            <param name="t">Triple</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.InMemoryQuadDataset.GetQuads(System.Uri)">
            <summary>
            Gets all quads for a given graph
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.InMemoryQuadDataset.GetQuadsWithObject(System.Uri,VDS.RDF.INode)">
            <summary>
            Gets all Quads with a given object
            </summary>
            <param name="graphUri">Graph URI</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.InMemoryQuadDataset.GetQuadsWithPredicate(System.Uri,VDS.RDF.INode)">
            <summary>
            Gets all Quads with a given predicate
            </summary>
            <param name="graphUri">Graph URI</param>
            <param name="pred">Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.InMemoryQuadDataset.GetQuadsWithPredicateObject(System.Uri,VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets all Quads with a given predicate and object
            </summary>
            <param name="graphUri">Graph URI</param>
            <param name="pred">Predicate</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.InMemoryQuadDataset.GetQuadsWithSubject(System.Uri,VDS.RDF.INode)">
            <summary>
            Gets all Quads with a given subject
            </summary>
            <param name="graphUri">Graph URI</param>
            <param name="subj">Subject</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.InMemoryQuadDataset.GetQuadsWithSubjectObject(System.Uri,VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets all Quads with a given subject and object
            </summary>
            <param name="graphUri">Graph URI</param>
            <param name="subj">Subject</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.InMemoryQuadDataset.GetQuadsWithSubjectPredicate(System.Uri,VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets all Quads with a given subject and predicate
            </summary>
            <param name="graphUri">Graph URI</param>
            <param name="subj">Subject</param>
            <param name="pred">Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.InMemoryQuadDataset.RemoveQuad(System.Uri,VDS.RDF.Triple)">
            <summary>
            Removes a quad from the dataset
            </summary>
            <param name="graphUri">Graph URI</param>
            <param name="t">Triple</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.InMemoryQuadDataset.FlushInternal">
            <summary>
            Flushes any changes to the store
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Datasets.InMemoryQuadDataset.Graphs">
            <summary>
            Gets all the Graphs in the Dataset
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Datasets.InMemoryQuadDataset.GraphUris">
            <summary>
            Gets all the URIs of Graphs in the Dataset
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Datasets.QuadDatasetTripleCollection">
            <summary>
            A Triple Collection which is a thin wrapper around a <see cref="T:VDS.RDF.Query.Datasets.BaseQuadDataset">BaseQuadDataset</see> to reduce much of the complexity for <see cref="T:VDS.RDF.Query.Datasets.ISparqlDataset">ISparqlDataset</see> implementors around returning of Graphs
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.ExplanationLevel">
            <summary>
            Represents the level of Query Explanation that is desired
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.ExplanationLevel.None">
            <summary>
            Specifies No Explanations
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.ExplanationLevel.OutputToDebug">
            <summary>
            Specifies Explanations are output to Debug
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.ExplanationLevel.OutputToTrace">
            <summary>
            Specifies Explanations are output to Trace
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.ExplanationLevel.OutputToConsoleStdOut">
            <summary>
            Specifies Explanations are output to Console Standard Output
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.ExplanationLevel.OutputToConsoleStdErr">
            <summary>
            Specifies Explanations are output to Console Standard Error
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.ExplanationLevel.OutputDefault">
            <summary>
            Specifies Explanations are output to Debug and Console Standard Output
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.ExplanationLevel.OutputAll">
            <summary>
            Specifies Explanations are output to all
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.ExplanationLevel.ShowThreadID">
            <summary>
            Show the Thread ID of the Thread evaluating the query (useful in multi-threaded environments)
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.ExplanationLevel.ShowDepth">
            <summary>
            Show the Depth of the Algebra Operator
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.ExplanationLevel.ShowOperator">
            <summary>
            Show the Type of the Algebra Operator
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.ExplanationLevel.ShowAction">
            <summary>
            Show the Action being performed (makes it clear whether the explanation marks the start/end of an operation)
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.ExplanationLevel.ShowTimings">
            <summary>
            Shows Timings for the Query
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.ExplanationLevel.ShowIntermediateResultCount">
            <summary>
            Show Intermediate Result Counts at each stage of evaluation
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.ExplanationLevel.ShowBasic">
            <summary>
            Shows Basic Information (Depth, Operator and Action)
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.ExplanationLevel.ShowDefault">
            <summary>
            Shows Default Information (Thread ID, Depth, Operator and Action)
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.ExplanationLevel.ShowAll">
            <summary>
            Shows All Information
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.ExplanationLevel.AnalyseBgps">
            <summary>
            Shows an analysis of BGPs prior to evaluating them
            </summary>
            <remarks>
            This lets you see how many joins, cross products, filters, assignments etc must be applied in each BGP
            </remarks>
        </member>
        <member name="F:VDS.RDF.Query.ExplanationLevel.AnalyseJoins">
            <summary>
            Shows an analysis of Joins prior to evaluating them
            </summary>
            <remarks>
            This lets you see whether the join is a join/cross product and in the case of a Minus whether the RHS can be ignored completely
            </remarks>
        </member>
        <member name="F:VDS.RDF.Query.ExplanationLevel.AnalyseNamedGraphs">
            <summary>
            Shows an analysis of Named Graphs used by a Graph clause prior to evaluating them
            </summary>
            <remarks>
            This lets you see how many graphs a given Graph clause will operate over.  As the Graph clause in SPARQL is defined as the union of evaluating the inner operator over each named graph in the dataset graph clauses applied to datasets with many named graphs can be expensive.
            </remarks>
        </member>
        <member name="F:VDS.RDF.Query.ExplanationLevel.Simulate">
            <summary>
            Sets whether Evaluation should be simulated (means timings will not be accurate but allows you to explain queries without needing actual data to evaluate them against)
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.ExplanationLevel.AnalyseAll">
            <summary>
            Shows all analysis information
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.ExplanationLevel.Basic">
            <summary>
            Basic Explanation Level (Console Standard Output and Basic Information)
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.ExplanationLevel.Default">
            <summary>
            Default Explanation Level (Default Outputs and Default Information)
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.ExplanationLevel.Detailed">
            <summary>
            Detailed Explanation Level (Default Outputs and All Information)
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.ExplanationLevel.Full">
            <summary>
            Full Explanation Level (All Outputs, All Information and All Analysis)
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.ExplanationLevel.BasicSimulation">
            <summary>
            Basic Explanation Level with Query Evaluation simulated
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.ExplanationLevel.DefaultSimulation">
            <summary>
            Default Explanation Level with Query Evaluation simulated
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.ExplanationLevel.DetailedSimulation">
            <summary>
            Detailed Explanation Level with Query Evaluation simulated
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.ExplanationLevel.FullSimulation">
            <summary>
            Full Explanation Level with Query Evaluation simulated
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.ExplainQueryProcessor">
            <summary>
            A Query Processor which evaluates queries while printing explanations to any/all of Debug, Trace, Console Standard Output and Console Standard Error
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.LeviathanQueryProcessor">
            <summary>
            Default SPARQL Query Processor provided by the library's Leviathan SPARQL Engine
            </summary>
            <remarks>
            <para>
            The Leviathan Query Processor simply invokes the <see cref="T:VDS.RDF.Query.Algebra.ISparqlAlgebra">Evaluate</see> method of the SPARQL Algebra it is asked to process
            </para>
            <para>
            In future releases much of the Leviathan Query engine logic will be moved into this class to make it possible for implementors to override specific bits of the algebra processing but this is not possible at this time
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.ISparqlQueryProcessor">
            <summary>
            Interface for SPARQL Query Processors
            </summary>
            <remarks>
            <para>
            A SPARQL Query Processor is a class that knows how to evaluate SPARQL queries against some data source to which the processor has access
            </para>
            <para>
            The point of this interface is to allow for end users to implement custom query processors or to extend and modify the behaviour of the default Leviathan engine as required.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryProcessor.ProcessQuery(VDS.RDF.Query.SparqlQuery)">
            <summary>
            Processes a SPARQL Query returning a <see cref="T:VDS.RDF.IGraph">IGraph</see> instance or a <see cref="T:VDS.RDF.Query.SparqlResultSet">SparqlResultSet</see> depending on the type of the query
            </summary>
            <param name="query">SPARQL Query</param>
            <returns>
            Either an <see cref="T:VDS.RDF.IGraph">IGraph</see> instance of a <see cref="T:VDS.RDF.Query.SparqlResultSet">SparqlResultSet</see> depending on the type of the query
            </returns>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryProcessor.ProcessQuery(VDS.RDF.IRdfHandler,VDS.RDF.ISparqlResultsHandler,VDS.RDF.Query.SparqlQuery)">
            <summary>
            Processes a SPARQL Query passing the results to the RDF or Results handler as appropriate
            </summary>
            <param name="rdfHandler">RDF Handler</param>
            <param name="resultsHandler">Results Handler</param>
            <param name="query">SPARQL Query</param>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryProcessor.ProcessQuery(VDS.RDF.Query.SparqlQuery,VDS.RDF.GraphCallback,VDS.RDF.SparqlResultsCallback,System.Object)">
            <summary>
            Processes a SPARQL Query asynchronously invoking the relevant callback when the query completes
            </summary>
            <param name="query">SPARQL QUery</param>
            <param name="rdfCallback">Callback for queries that return a Graph</param>
            <param name="resultsCallback">Callback for queries that return a Result Set</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryProcessor.ProcessQuery(VDS.RDF.IRdfHandler,VDS.RDF.ISparqlResultsHandler,VDS.RDF.Query.SparqlQuery,VDS.RDF.QueryCallback,System.Object)">
            <summary>
            Processes a SPARQL Query asynchronously passing the results to the relevant handler and invoking the callback when the query completes
            </summary>
            <param name="rdfHandler">RDF Handler</param>
            <param name="resultsHandler">Results Handler</param>
            <param name="query">SPARQL Query</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="T:VDS.RDF.Query.ISparqlQueryAlgebraProcessor`2">
            <summary>
            Interface for SPARQL Query Algebra Processors
            </summary>
            <remarks>
            A SPARQL Query Algebra Processor is a class which knows how to evaluate the
            </remarks>
            <typeparam name="TResult">Type of intermediate results produced by processing an Algebra operator</typeparam>
            <typeparam name="TContext">Type of context object providing evaluation context</typeparam>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryAlgebraProcessor`2.ProcessAlgebra(VDS.RDF.Query.Algebra.ISparqlAlgebra,`1)">
            <summary>
            Processes SPARQL Algebra
            </summary>
            <param name="algebra">Algebra</param>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryAlgebraProcessor`2.ProcessAsk(VDS.RDF.Query.Algebra.Ask,`1)">
            <summary>
            Processes an Ask
            </summary>
            <param name="ask">Ask</param>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryAlgebraProcessor`2.ProcessBgp(VDS.RDF.Query.Algebra.IBgp,`1)">
            <summary>
            Processes a BGP
            </summary>
            <param name="bgp">BGP</param>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryAlgebraProcessor`2.ProcessBindings(VDS.RDF.Query.Algebra.Bindings,`1)">
            <summary>
            Processes a Bindings modifier
            </summary>
            <param name="b">Bindings</param>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryAlgebraProcessor`2.ProcessDistinct(VDS.RDF.Query.Algebra.Distinct,`1)">
            <summary>
            Processes a Distinct modifier
            </summary>
            <param name="distinct">Distinct modifier</param>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryAlgebraProcessor`2.ProcessExistsJoin(VDS.RDF.Query.Algebra.IExistsJoin,`1)">
            <summary>
            Processes an Exists Join
            </summary>
            <param name="existsJoin">Exists Join</param>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryAlgebraProcessor`2.ProcessExtend(VDS.RDF.Query.Algebra.Extend,`1)">
            <summary>
            Processes an Extend
            </summary>
            <param name="extend">Extend</param>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryAlgebraProcessor`2.ProcessFilter(VDS.RDF.Query.Algebra.IFilter,`1)">
            <summary>
            Processes a Filter
            </summary>
            <param name="filter">Filter</param>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryAlgebraProcessor`2.ProcessGraph(VDS.RDF.Query.Algebra.Graph,`1)">
            <summary>
            Processes a Graph
            </summary>
            <param name="graph">Graph</param>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryAlgebraProcessor`2.ProcessGroupBy(VDS.RDF.Query.Algebra.GroupBy,`1)">
            <summary>
            Processes a Group By
            </summary>
            <param name="groupBy">Group By</param>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryAlgebraProcessor`2.ProcessHaving(VDS.RDF.Query.Algebra.Having,`1)">
            <summary>
            Processes a Having
            </summary>
            <param name="having">Having</param>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryAlgebraProcessor`2.ProcessJoin(VDS.RDF.Query.Algebra.IJoin,`1)">
            <summary>
            Processes a Join
            </summary>
            <param name="join">Join</param>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryAlgebraProcessor`2.ProcessLeftJoin(VDS.RDF.Query.Algebra.ILeftJoin,`1)">
            <summary>
            Processes a LeftJoin
            </summary>
            <param name="leftJoin">Left Join</param>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryAlgebraProcessor`2.ProcessMinus(VDS.RDF.Query.Algebra.IMinus,`1)">
            <summary>
            Processes a Minus
            </summary>
            <param name="minus">Minus</param>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryAlgebraProcessor`2.ProcessNegatedPropertySet(VDS.RDF.Query.Algebra.NegatedPropertySet,`1)">
            <summary>
            Processes a Negated Property Set
            </summary>
            <param name="negPropSet">Negated Property Set</param>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryAlgebraProcessor`2.ProcessNullOperator(VDS.RDF.Query.Algebra.NullOperator,`1)">
            <summary>
            Processes a Null Operator
            </summary>
            <param name="nullOp">Null Operator</param>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryAlgebraProcessor`2.ProcessOneOrMorePath(VDS.RDF.Query.Algebra.OneOrMorePath,`1)">
            <summary>
            Processes a One or More Path
            </summary>
            <param name="path">Path</param>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryAlgebraProcessor`2.ProcessOrderBy(VDS.RDF.Query.Algebra.OrderBy,`1)">
            <summary>
            Processes an Order By
            </summary>
            <param name="orderBy"></param>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryAlgebraProcessor`2.ProcessPropertyPath(VDS.RDF.Query.Algebra.PropertyPath,`1)">
            <summary>
            Processes a Property Path
            </summary>
            <param name="path">Path</param>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryAlgebraProcessor`2.ProcessReduced(VDS.RDF.Query.Algebra.Reduced,`1)">
            <summary>
            Processes a Reduced modifier
            </summary>
            <param name="reduced">Reduced modifier</param>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryAlgebraProcessor`2.ProcessSelect(VDS.RDF.Query.Algebra.Select,`1)">
            <summary>
            Processes a Select
            </summary>
            <param name="select">Select</param>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryAlgebraProcessor`2.ProcessSelectDistinctGraphs(VDS.RDF.Query.Algebra.SelectDistinctGraphs,`1)">
            <summary>
            Processes a Select Distinct Graphs
            </summary>
            <param name="selDistGraphs">Select Distinct Graphs</param>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryAlgebraProcessor`2.ProcessService(VDS.RDF.Query.Algebra.Service,`1)">
            <summary>
            Processes a Service
            </summary>
            <param name="service">Service</param>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryAlgebraProcessor`2.ProcessSlice(VDS.RDF.Query.Algebra.Slice,`1)">
            <summary>
            Processes a Slice modifier
            </summary>
            <param name="slice">Slice modifier</param>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryAlgebraProcessor`2.ProcessSubQuery(VDS.RDF.Query.Algebra.SubQuery,`1)">
            <summary>
            Processes a subquery
            </summary>
            <param name="subquery">Subquery</param>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryAlgebraProcessor`2.ProcessUnion(VDS.RDF.Query.Algebra.IUnion,`1)">
            <summary>
            Processes a Union
            </summary>
            <param name="union">Union</param>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryAlgebraProcessor`2.ProcessUnknownOperator(VDS.RDF.Query.Algebra.ISparqlAlgebra,`1)">
            <summary>
            Processes an Unknown Operator
            </summary>
            <param name="algebra">Algebra</param>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryAlgebraProcessor`2.ProcessZeroLengthPath(VDS.RDF.Query.Algebra.ZeroLengthPath,`1)">
            <summary>
            Processes a Zero Length Path
            </summary>
            <param name="path">Path</param>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.ISparqlQueryAlgebraProcessor`2.ProcessZeroOrMorePath(VDS.RDF.Query.Algebra.ZeroOrMorePath,`1)">
            <summary>
            Processes a Zero or More Path
            </summary>
            <param name="path">Path</param>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.#ctor(VDS.RDF.IInMemoryQueryableStore)">
            <summary>
            Creates a new Leviathan Query Processor
            </summary>
            <param name="store">Triple Store</param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.#ctor(VDS.RDF.Query.Datasets.ISparqlDataset)">
            <summary>
            Creates a new Leviathan Query Processor
            </summary>
            <param name="data">SPARQL Dataset</param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessQuery(VDS.RDF.Query.SparqlQuery)">
            <summary>
            Processes a SPARQL Query
            </summary>
            <param name="query">SPARQL Query</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessQuery(VDS.RDF.IRdfHandler,VDS.RDF.ISparqlResultsHandler,VDS.RDF.Query.SparqlQuery)">
            <summary>
            Processes a SPARQL Query sending the results to a RDF/SPARQL Results handler as appropriate
            </summary>
            <param name="rdfHandler">RDF Handler</param>
            <param name="resultsHandler">Results Handler</param>
            <param name="query">SPARQL Query</param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessQuery(VDS.RDF.Query.SparqlQuery,VDS.RDF.GraphCallback,VDS.RDF.SparqlResultsCallback,System.Object)">
            <summary>
            Processes a SPARQL Query asynchronously invoking the relevant callback when the query completes
            </summary>
            <param name="query">SPARQL QUery</param>
            <param name="rdfCallback">Callback for queries that return a Graph</param>
            <param name="resultsCallback">Callback for queries that return a Result Set</param>
            <param name="state">State to pass to the callback</param>
            <remarks>
            In the event of a success the appropriate callback will be invoked, if there is an error both callbacks will be invoked and passed an instance of <see cref="T:VDS.RDF.AsyncError"/> which contains details of the error and the original state information passed in.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessQuery(VDS.RDF.IRdfHandler,VDS.RDF.ISparqlResultsHandler,VDS.RDF.Query.SparqlQuery,VDS.RDF.QueryCallback,System.Object)">
            <summary>
            Processes a SPARQL Query asynchronously passing the results to the relevant handler and invoking the callback when the query completes
            </summary>
            <param name="rdfHandler">RDF Handler</param>
            <param name="resultsHandler">Results Handler</param>
            <param name="query">SPARQL Query</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
            <remarks>
            In the event of a success the callback will be invoked, if there is an error the callback will be invoked and passed an instance of <see cref="T:VDS.RDF.AsyncError"/> which contains details of the error and the original state information passed in.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.GetContext">
            <summary>
            Creates a new Evaluation Context
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.GetContext(VDS.RDF.Query.SparqlQuery)">
            <summary>
            Creates a new Evaluation Context for the given Query
            </summary>
            <param name="q">Query</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.GetProcessorForContext">
            <summary>
            Gets the Query Processor for a Context
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessAlgebra(VDS.RDF.Query.Algebra.ISparqlAlgebra,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes SPARQL Algebra
            </summary>
            <param name="algebra">Algebra</param>
            <param name="context">SPARQL Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessAsk(VDS.RDF.Query.Algebra.Ask,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes an Ask
            </summary>
            <param name="ask">Ask</param>
            <param name="context">SPARQL Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessBgp(VDS.RDF.Query.Algebra.IBgp,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes a BGP
            </summary>
            <param name="bgp">BGP</param>
            <param name="context">SPARQL Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessBindings(VDS.RDF.Query.Algebra.Bindings,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes a Bindings modifier
            </summary>
            <param name="b">Bindings</param>
            <param name="context">SPARQL Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessDistinct(VDS.RDF.Query.Algebra.Distinct,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes a Distinct modifier
            </summary>
            <param name="distinct">Distinct modifier</param>
            <param name="context">SPARQL Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessExtend(VDS.RDF.Query.Algebra.Extend,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes an Extend
            </summary>
            <param name="extend">Extend</param>
            <param name="context">SPARQL Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessExistsJoin(VDS.RDF.Query.Algebra.IExistsJoin,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes an Exists Join
            </summary>
            <param name="existsJoin">Exists Join</param>
            <param name="context">SPARQL Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessFilter(VDS.RDF.Query.Algebra.IFilter,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes a Filter
            </summary>
            <param name="filter">Filter</param>
            <param name="context">SPARQL Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessGraph(VDS.RDF.Query.Algebra.Graph,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes a Graph
            </summary>
            <param name="graph">Graph</param>
            <param name="context">SPARQL Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessGroupBy(VDS.RDF.Query.Algebra.GroupBy,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes a Group By
            </summary>
            <param name="groupBy">Group By</param>
            <param name="context">SPARQL Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessHaving(VDS.RDF.Query.Algebra.Having,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes a Having
            </summary>
            <param name="having">Having</param>
            <param name="context">SPARQL Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessJoin(VDS.RDF.Query.Algebra.IJoin,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes a Join
            </summary>
            <param name="join">Join</param>
            <param name="context">SPARQL Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessLeftJoin(VDS.RDF.Query.Algebra.ILeftJoin,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes a LeftJoin
            </summary>
            <param name="leftJoin">Left Join</param>
            <param name="context">SPARQL Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessMinus(VDS.RDF.Query.Algebra.IMinus,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes a Minus
            </summary>
            <param name="minus">Minus</param>
            <param name="context">SPARQL Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessNegatedPropertySet(VDS.RDF.Query.Algebra.NegatedPropertySet,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes a Negated Property Set
            </summary>
            <param name="negPropSet">Negated Property Set</param>
            <param name="context">SPARQL Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessNullOperator(VDS.RDF.Query.Algebra.NullOperator,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes a Null Operator
            </summary>
            <param name="nullOp">Null Operator</param>
            <param name="context">SPARQL Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessOneOrMorePath(VDS.RDF.Query.Algebra.OneOrMorePath,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes a One or More Path
            </summary>
            <param name="path">Path</param>
            <param name="context">SPARQL Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessOrderBy(VDS.RDF.Query.Algebra.OrderBy,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes an Order By
            </summary>
            <param name="orderBy"></param>
            <param name="context">SPARQL Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessPropertyPath(VDS.RDF.Query.Algebra.PropertyPath,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes a Property Path
            </summary>
            <param name="path">Path</param>
            <param name="context">SPARQL Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessReduced(VDS.RDF.Query.Algebra.Reduced,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes a Reduced modifier
            </summary>
            <param name="reduced">Reduced modifier</param>
            <param name="context">SPARQL Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessSelect(VDS.RDF.Query.Algebra.Select,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes a Select
            </summary>
            <param name="select">Select</param>
            <param name="context">SPARQL Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessSelectDistinctGraphs(VDS.RDF.Query.Algebra.SelectDistinctGraphs,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes a Select Distinct Graphs
            </summary>
            <param name="selDistGraphs">Select Distinct Graphs</param>
            <param name="context">SPARQL Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessService(VDS.RDF.Query.Algebra.Service,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes a Service
            </summary>
            <param name="service">Service</param>
            <param name="context">SPARQL Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessSlice(VDS.RDF.Query.Algebra.Slice,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes a Slice modifier
            </summary>
            <param name="slice">Slice modifier</param>
            <param name="context">SPARQL Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessSubQuery(VDS.RDF.Query.Algebra.SubQuery,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes a Subquery
            </summary>
            <param name="subquery">Subquery</param>
            <param name="context">SPARQL Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessUnion(VDS.RDF.Query.Algebra.IUnion,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes a Union
            </summary>
            <param name="union">Union</param>
            <param name="context">SPARQL Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessUnknownOperator(VDS.RDF.Query.Algebra.ISparqlAlgebra,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes a Unknown Operator
            </summary>
            <param name="algebra">Unknown Operator</param>
            <param name="context">SPARQL Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessZeroLengthPath(VDS.RDF.Query.Algebra.ZeroLengthPath,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes a Zero Length Path
            </summary>
            <param name="path">Path</param>
            <param name="context">SPARQL Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.LeviathanQueryProcessor.ProcessZeroOrMorePath(VDS.RDF.Query.Algebra.ZeroOrMorePath,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes a Zero or More Path
            </summary>
            <param name="path">Path</param>
            <param name="context">SPARQL Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.LeviathanQueryProcessor.ProcessQueryAsync">
            <summary>
            Delegate used for asychronous execution
            </summary>
            <param name="rdfHandler">RDF Handler</param>
            <param name="resultsHandler">Results Handler</param>
            <param name="query">SPARQL Query</param>
        </member>
        <member name="M:VDS.RDF.Query.ExplainQueryProcessor.#ctor(VDS.RDF.Query.Datasets.ISparqlDataset)">
            <summary>
            Creates a new Explain Query Processor that will use the Default Explanation Level
            </summary>
            <param name="dataset">Dataset</param>
        </member>
        <member name="M:VDS.RDF.Query.ExplainQueryProcessor.#ctor(VDS.RDF.Query.Datasets.ISparqlDataset,VDS.RDF.Query.ExplanationLevel)">
            <summary>
            Creates a new Explain Query Processor with the desired Explanation Level
            </summary>
            <param name="dataset">Dataset</param>
            <param name="level">Explanation Level</param>
        </member>
        <member name="M:VDS.RDF.Query.ExplainQueryProcessor.#ctor(VDS.RDF.IInMemoryQueryableStore)">
            <summary>
            Creates a new Explain Query Processor that will use the Default Explanation Level
            </summary>
            <param name="store">Triple Store</param>
        </member>
        <member name="M:VDS.RDF.Query.ExplainQueryProcessor.#ctor(VDS.RDF.IInMemoryQueryableStore,VDS.RDF.Query.ExplanationLevel)">
            <summary>
            Creates a new Explain Query Processor with the desired Explanation Level
            </summary>
            <param name="store">Triple Store</param>
            <param name="level">Explanation Level</param>
        </member>
        <member name="M:VDS.RDF.Query.ExplainQueryProcessor.HasFlag(VDS.RDF.Query.ExplanationLevel)">
            <summary>
            Determines whether a given Flag is present
            </summary>
            <param name="flag">Flag</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.ExplainQueryProcessor.PrintAnalysis(VDS.RDF.Query.Algebra.ISparqlAlgebra,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Prints Analysis
            </summary>
            <param name="algebra">Algebra</param>
            <param name="context">SPARQL Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.ExplainQueryProcessor.PrintBgpAnalysis(VDS.RDF.Query.Algebra.IBgp)">
            <summary>
            Prints BGP Analysis
            </summary>
            <param name="bgp">Analysis</param>
        </member>
        <member name="M:VDS.RDF.Query.ExplainQueryProcessor.PrintJoinAnalysis(VDS.RDF.Query.Algebra.IAbstractJoin)">
            <summary>
            Prints Join Analysis
            </summary>
            <param name="join">Join</param>
        </member>
        <member name="M:VDS.RDF.Query.ExplainQueryProcessor.PrintExplanations(System.Text.StringBuilder)">
            <summary>
            Prints Expalantions
            </summary>
            <param name="output">StringBuilder to output to</param>
        </member>
        <member name="M:VDS.RDF.Query.ExplainQueryProcessor.PrintExplanations(System.String)">
            <summary>
            Prints Explanations
            </summary>
            <param name="output">String to output</param>
        </member>
        <member name="M:VDS.RDF.Query.ExplainQueryProcessor.ExplainEvaluationStart(VDS.RDF.Query.Algebra.ISparqlAlgebra,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Explains the start of evaluating some algebra operator
            </summary>
            <param name="algebra">Algebra</param>
            <param name="context">Context</param>
        </member>
        <member name="M:VDS.RDF.Query.ExplainQueryProcessor.ExplainEvaluationAction(VDS.RDF.Query.Algebra.ISparqlAlgebra,VDS.RDF.Query.SparqlEvaluationContext,System.String)">
            <summary>
            Explains the evaluation of some action
            </summary>
            <param name="algebra">Algebra</param>
            <param name="context">Context</param>
            <param name="action">Action</param>
        </member>
        <member name="M:VDS.RDF.Query.ExplainQueryProcessor.ExplainEvaluationEnd(VDS.RDF.Query.Algebra.ISparqlAlgebra,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Explains the end of evaluating some algebra operator
            </summary>
            <param name="algebra">Algebra</param>
            <param name="context">Context</param>
        </member>
        <member name="M:VDS.RDF.Query.ExplainQueryProcessor.ExplainAndEvaluate``1(``0,VDS.RDF.Query.SparqlEvaluationContext,System.Func{``0,VDS.RDF.Query.SparqlEvaluationContext,VDS.RDF.Query.Algebra.BaseMultiset})">
            <summary>
            Explains and evaluates some algebra operator
            </summary>
            <typeparam name="T">Algebra Operator Type</typeparam>
            <param name="algebra">Algebra</param>
            <param name="context">Context</param>
            <param name="evaluator">Evaluator Function</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.ExplainQueryProcessor.ProcessAsk(VDS.RDF.Query.Algebra.Ask,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes an Ask
            </summary>
            <param name="ask">Ask</param>
            <param name="context">SPARQL Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.ExplainQueryProcessor.ProcessBgp(VDS.RDF.Query.Algebra.IBgp,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes a BGP
            </summary>
            <param name="bgp">BGP</param>
            <param name="context">SPARQL Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.ExplainQueryProcessor.ProcessBindings(VDS.RDF.Query.Algebra.Bindings,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes a Bindings modifier
            </summary>
            <param name="b">Bindings</param>
            <param name="context">SPARQL Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.ExplainQueryProcessor.ProcessDistinct(VDS.RDF.Query.Algebra.Distinct,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes a Distinct modifier
            </summary>
            <param name="distinct">Distinct modifier</param>
            <param name="context">SPARQL Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.ExplainQueryProcessor.ProcessExistsJoin(VDS.RDF.Query.Algebra.IExistsJoin,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes an Exists Join
            </summary>
            <param name="existsJoin">Exists Join</param>
            <param name="context">SPARQL Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.ExplainQueryProcessor.ProcessExtend(VDS.RDF.Query.Algebra.Extend,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes an Extend
            </summary>
            <param name="extend">Extend</param>
            <param name="context">SPARQL Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.ExplainQueryProcessor.ProcessFilter(VDS.RDF.Query.Algebra.IFilter,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes a Filter
            </summary>
            <param name="filter">Filter</param>
            <param name="context">SPARQL Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.ExplainQueryProcessor.ProcessGraph(VDS.RDF.Query.Algebra.Graph,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes a Graph
            </summary>
            <param name="graph">Graph</param>
            <param name="context">SPARQL Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.ExplainQueryProcessor.ProcessGroupBy(VDS.RDF.Query.Algebra.GroupBy,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes a Group By
            </summary>
            <param name="groupBy">Group By</param>
            <param name="context">SPARQL Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.ExplainQueryProcessor.ProcessHaving(VDS.RDF.Query.Algebra.Having,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes a Having
            </summary>
            <param name="having">Having</param>
            <param name="context">SPARQL Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.ExplainQueryProcessor.ProcessJoin(VDS.RDF.Query.Algebra.IJoin,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes a Join
            </summary>
            <param name="join">Join</param>
            <param name="context">SPARQL Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.ExplainQueryProcessor.ProcessLeftJoin(VDS.RDF.Query.Algebra.ILeftJoin,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes a LeftJoin
            </summary>
            <param name="leftJoin">Left Join</param>
            <param name="context">SPARQL Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.ExplainQueryProcessor.ProcessMinus(VDS.RDF.Query.Algebra.IMinus,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes a Minus
            </summary>
            <param name="minus">Minus</param>
            <param name="context">SPARQL Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.ExplainQueryProcessor.ProcessNegatedPropertySet(VDS.RDF.Query.Algebra.NegatedPropertySet,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes a Negated Property Set
            </summary>
            <param name="negPropSet">Negated Property Set</param>
            <param name="context">SPARQL Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.ExplainQueryProcessor.ProcessNullOperator(VDS.RDF.Query.Algebra.NullOperator,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes a Null Operator
            </summary>
            <param name="nullOp">Null Operator</param>
            <param name="context">SPARQL Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.ExplainQueryProcessor.ProcessOneOrMorePath(VDS.RDF.Query.Algebra.OneOrMorePath,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes a One or More Path
            </summary>
            <param name="path">Path</param>
            <param name="context">SPARQL Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.ExplainQueryProcessor.ProcessOrderBy(VDS.RDF.Query.Algebra.OrderBy,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes an Order By
            </summary>
            <param name="orderBy"></param>
            <param name="context">SPARQL Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.ExplainQueryProcessor.ProcessPropertyPath(VDS.RDF.Query.Algebra.PropertyPath,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes a Property Path
            </summary>
            <param name="path">Path</param>
            <param name="context">SPARQL Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.ExplainQueryProcessor.ProcessReduced(VDS.RDF.Query.Algebra.Reduced,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes a Reduced modifier
            </summary>
            <param name="reduced">Reduced modifier</param>
            <param name="context">SPARQL Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.ExplainQueryProcessor.ProcessSelect(VDS.RDF.Query.Algebra.Select,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes a Select
            </summary>
            <param name="select">Select</param>
            <param name="context">SPARQL Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.ExplainQueryProcessor.ProcessSelectDistinctGraphs(VDS.RDF.Query.Algebra.SelectDistinctGraphs,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes a Select Distinct Graphs
            </summary>
            <param name="selDistGraphs">Select Distinct Graphs</param>
            <param name="context">SPARQL Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.ExplainQueryProcessor.ProcessService(VDS.RDF.Query.Algebra.Service,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes a Service
            </summary>
            <param name="service">Service</param>
            <param name="context">SPARQL Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.ExplainQueryProcessor.ProcessSlice(VDS.RDF.Query.Algebra.Slice,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes a Slice modifier
            </summary>
            <param name="slice">Slice modifier</param>
            <param name="context">SPARQL Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.ExplainQueryProcessor.ProcessSubQuery(VDS.RDF.Query.Algebra.SubQuery,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes a Subquery
            </summary>
            <param name="subquery">Subquery</param>
            <param name="context">SPARQL Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.ExplainQueryProcessor.ProcessUnion(VDS.RDF.Query.Algebra.IUnion,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes a Union
            </summary>
            <param name="union">Union</param>
            <param name="context">SPARQL Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.ExplainQueryProcessor.ProcessUnknownOperator(VDS.RDF.Query.Algebra.ISparqlAlgebra,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes a Unknown Operator
            </summary>
            <param name="algebra">Unknown Operator</param>
            <param name="context">SPARQL Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.ExplainQueryProcessor.ProcessZeroLengthPath(VDS.RDF.Query.Algebra.ZeroLengthPath,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes a Zero Length Path
            </summary>
            <param name="path">Path</param>
            <param name="context">SPARQL Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.ExplainQueryProcessor.ProcessZeroOrMorePath(VDS.RDF.Query.Algebra.ZeroOrMorePath,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Processes a Zero or More Path
            </summary>
            <param name="path">Path</param>
            <param name="context">SPARQL Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.ExplainQueryProcessor.ExplanationLevel">
            <summary>
            Gets/Sets the Explanation Level
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Arithmetic.AdditionExpression">
            <summary>
            Class representing Arithmetic Addition expressions
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.BaseBinaryExpression">
            <summary>
            Abstract base class for Binary Expressions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.BaseBinaryExpression._leftExpr">
            <summary>
            The sub-expressions of this Expression
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.BaseBinaryExpression._rightExpr">
            <summary>
            The sub-expressions of this Expression
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.BaseBinaryExpression.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Base Binary Expression
            </summary>
            <param name="leftExpr">Left Expression</param>
            <param name="rightExpr">Right Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.BaseBinaryExpression.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.BaseBinaryExpression.ToString">
            <summary>
            Gets the String representation of the Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.BaseBinaryExpression.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the arguments of the expression using the given transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.BaseBinaryExpression.Variables">
            <summary>
            Gets an enumeration of all the Variables used in this expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.BaseBinaryExpression.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.BaseBinaryExpression.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.BaseBinaryExpression.Arguments">
            <summary>
            Gets the Arguments of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.BaseBinaryExpression.CanParallelise">
            <summary>
            Gets whether an expression can safely be evaluated in parallel
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Arithmetic.AdditionExpression.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Addition Expression
            </summary>
            <param name="leftExpr">Left Hand Expression</param>
            <param name="rightExpr">Right Hand Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Arithmetic.AdditionExpression.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Calculates the Numeric Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Arithmetic.AdditionExpression.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Arithmetic.AdditionExpression.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Arithmetic.AdditionExpression.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Arithmetic.AdditionExpression.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Arithmetic.DivisionExpression">
            <summary>
            Class representing Arithmetic Division expressions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Arithmetic.DivisionExpression.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Division Expression
            </summary>
            <param name="leftExpr">Left Hand Expression</param>
            <param name="rightExpr">Right Hand Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Arithmetic.DivisionExpression.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Calculates the Numeric Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Arithmetic.DivisionExpression.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Arithmetic.DivisionExpression.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Arithmetic.DivisionExpression.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Arithmetic.DivisionExpression.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Arithmetic.MinusExpression">
            <summary>
            Class representing Unary Minus expressions (sign of numeric expression is reversed)
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.BaseUnaryExpression">
            <summary>
            Abstract base class for Unary Expressions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.BaseUnaryExpression._expr">
            <summary>
            The sub-expression of this Expression
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.BaseUnaryExpression.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Base Unary Expression
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.BaseUnaryExpression.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluuation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.BaseUnaryExpression.ToString">
            <summary>
            Gets the String representation of the Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.BaseUnaryExpression.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the arguments of the expression using the given transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.BaseUnaryExpression.Variables">
            <summary>
            Gets an enumeration of all the Variables used in this expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.BaseUnaryExpression.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.BaseUnaryExpression.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.BaseUnaryExpression.Arguments">
            <summary>
            Gets the Arguments of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.BaseUnaryExpression.CanParallelise">
            <summary>
            Gets whether an expression can safely be evaluated in parallel
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Arithmetic.MinusExpression.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Unary Minus Expression
            </summary>
            <param name="expr">Expression to apply the Minus operator to</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Arithmetic.MinusExpression.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Calculates the Numeric Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Arithmetic.MinusExpression.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Arithmetic.MinusExpression.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Arithmetic.MinusExpression.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Arithmetic.MinusExpression.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Arithmetic.MultiplicationExpression">
            <summary>
            Class representing Arithmetic Multiplication expressions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Arithmetic.MultiplicationExpression.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Multiplication Expression
            </summary>
            <param name="leftExpr">Left Hand Expression</param>
            <param name="rightExpr">Right Hand Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Arithmetic.MultiplicationExpression.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Calculates the Numeric Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Arithmetic.MultiplicationExpression.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Arithmetic.MultiplicationExpression.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Arithmetic.MultiplicationExpression.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Arithmetic.MultiplicationExpression.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Arithmetic.SubtractionExpression">
            <summary>
            Class representing Arithmetic Subtraction expressions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Arithmetic.SubtractionExpression.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Subtraction Expression
            </summary>
            <param name="leftExpr">Left Hand Expression</param>
            <param name="rightExpr">Right Hand Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Arithmetic.SubtractionExpression.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Calculates the Numeric Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Arithmetic.SubtractionExpression.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Arithmetic.SubtractionExpression.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Arithmetic.SubtractionExpression.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Arithmetic.SubtractionExpression.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Comparison.EqualsExpression">
            <summary>
            Class representing Relational Equality expressions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Comparison.EqualsExpression.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Equality Expression
            </summary>
            <param name="leftExpr">Left Hand Expression</param>
            <param name="rightExpr">Right Hand Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Comparison.EqualsExpression.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Comparison.EqualsExpression.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Comparison.EqualsExpression.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Comparison.EqualsExpression.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Comparison.EqualsExpression.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Comparison.GreaterThanExpression">
            <summary>
            Class representing Relational Greater Than Expressions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Comparison.GreaterThanExpression.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Greater Than Relational Expression
            </summary>
            <param name="leftExpr">Left Hand Expression</param>
            <param name="rightExpr">Right Hand Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Comparison.GreaterThanExpression.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Comparison.GreaterThanExpression.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Comparison.GreaterThanExpression.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Comparison.GreaterThanExpression.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Comparison.GreaterThanExpression.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Comparison.GreaterThanOrEqualToExpression">
            <summary>
            Class representing Relational Greater Than or Equal To Expressions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Comparison.GreaterThanOrEqualToExpression.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Greater Than or Equal To Relational Expression
            </summary>
            <param name="leftExpr">Left Hand Expression</param>
            <param name="rightExpr">Right Hand Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Comparison.GreaterThanOrEqualToExpression.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Comparison.GreaterThanOrEqualToExpression.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Comparison.GreaterThanOrEqualToExpression.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Comparison.GreaterThanOrEqualToExpression.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Comparison.GreaterThanOrEqualToExpression.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Comparison.LessThanExpression">
            <summary>
            Class representing Relational Less Than Expressions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Comparison.LessThanExpression.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Less Than Relational Expression
            </summary>
            <param name="leftExpr">Left Hand Expression</param>
            <param name="rightExpr">Right Hand Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Comparison.LessThanExpression.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Comparison.LessThanExpression.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Comparison.LessThanExpression.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Comparison.LessThanExpression.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Comparison.LessThanExpression.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Comparison.LessThanOrEqualToExpression">
            <summary>
            Class representing Relational Less Than or Equal To Expressions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Comparison.LessThanOrEqualToExpression.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Less Than or Equal To Relational Expression
            </summary>
            <param name="leftExpr">Left Hand Expression</param>
            <param name="rightExpr">Right Hand Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Comparison.LessThanOrEqualToExpression.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Comparison.LessThanOrEqualToExpression.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Comparison.LessThanOrEqualToExpression.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Comparison.LessThanOrEqualToExpression.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Comparison.LessThanOrEqualToExpression.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Comparison.NotEqualsExpression">
            <summary>
            Class representing Relational Non-Equality expressions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Comparison.NotEqualsExpression.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Non-Equality Expression
            </summary>
            <param name="leftExpr">Left Hand Expression</param>
            <param name="rightExpr">Right Hand Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Comparison.NotEqualsExpression.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Comparison.NotEqualsExpression.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Comparison.NotEqualsExpression.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Comparison.NotEqualsExpression.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Comparison.NotEqualsExpression.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Conditional.AndExpression">
            <summary>
            Class representing Conditional And expressions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Conditional.AndExpression.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Conditional And Expression
            </summary>
            <param name="leftExpr">Left Hand Expression</param>
            <param name="rightExpr">Right Hand Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Conditional.AndExpression.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Conditional.AndExpression.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Conditional.AndExpression.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Conditional.AndExpression.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Conditional.AndExpression.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Conditional.NotExpression">
            <summary>
            Class representing logical Not Expressions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Conditional.NotExpression.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Negation Expression
            </summary>
            <param name="expr">Expression to Negate</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Conditional.NotExpression.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Conditional.NotExpression.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Conditional.NotExpression.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Conditional.NotExpression.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Conditional.NotExpression.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Conditional.OrExpression">
            <summary>
            Class representing Conditional Or expressions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Conditional.OrExpression.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Conditional Or Expression
            </summary>
            <param name="leftExpr">Left Hand Expression</param>
            <param name="rightExpr">Right Hand Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Conditional.OrExpression.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Conditional.OrExpression.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Conditional.OrExpression.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Conditional.OrExpression.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Conditional.OrExpression.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Arq.BNodeFunction">
            <summary>
            Represents the ARQ afn:bnode() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.BNodeFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new ARQ afn:bnode() function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.BNodeFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the value of the function in the given Evaluation Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.BNodeFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.BNodeFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.BNodeFunction.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.BNodeFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.BNodeFunction.CanParallelise">
            <summary>
            Gets whether the expression can be parallelized
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.BNodeFunction.Arguments">
            <summary>
            Gets the arguments of the expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.BNodeFunction.Variables">
            <summary>
            Gets the variables in the expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Arq.EFunction">
            <summary>
            Represents the ARQ e() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.EFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Evaluates the function
            </summary>
            <param name="context">Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.EFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.EFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Applies a transformer to the expressions arguments
            </summary>
            <param name="transformer">Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.EFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.EFunction.Variables">
            <summary>
            Gets the Variables used
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.EFunction.Type">
            <summary>
            Gets the type of the expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.EFunction.Arguments">
            <summary>
            Gets the arguments of the expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.EFunction.CanParallelise">
            <summary>
            Gets whether an expression can safely be evaluated in parallel
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Arq.LocalNameFunction">
            <summary>
            Represents the ARQ afn:localname() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.LocalNameFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new ARQ Local Name function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.LocalNameFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the value of the function in the given Evaluation Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.LocalNameFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.LocalNameFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.LocalNameFunction.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.LocalNameFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Arq.MaxFunction">
            <summary>
            Represents the ARQ max() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.MaxFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new ARQ max() function
            </summary>
            <param name="arg1">First Argument</param>
            <param name="arg2">Second Argument</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.MaxFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the numeric value of the function in the given Evaluation Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.MaxFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.MaxFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.MaxFunction.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.MaxFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Arq.MinFunction">
            <summary>
            Represents the ARQ min() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.MinFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new ARQ min() function
            </summary>
            <param name="arg1">First Argument</param>
            <param name="arg2">Second Argument</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.MinFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the numeric value of the function in the given Evaluation Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.MinFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.MinFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.MinFunction.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.MinFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Arq.NamespaceFunction">
            <summary>
            Represents the ARQ namespace() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.NamespaceFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new ARQ Namespace function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.NamespaceFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the value of the function in the given Evaluation Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.NamespaceFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.NamespaceFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.NamespaceFunction.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.NamespaceFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Arq.NowFunction">
            <summary>
            Represents the ARQ afn:now() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.NowFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the value of the function in the given Evaluation Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns>
            Returns a constant Literal Node which is a Date Time typed Literal
            </returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.NowFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.NowFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Returns the expression as there are no arguments to be transformed
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.NowFunction.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.NowFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.NowFunction.CanParallelise">
            <summary>
            Gets whether an expression can safely be evaluated in parallel
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.NowFunction.Variables">
            <summary>
            Gets the variables in the expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.NowFunction.Arguments">
            <summary>
            Gets the arguments of the expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Arq.PiFunction">
            <summary>
            Represents the ARQ pi() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.PiFunction.#ctor">
            <summary>
            Creates a new ARQ Pi function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.PiFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.PiFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.PiFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Returns the expression as there are no arguments to be transformed
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.PiFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.PiFunction.Variables">
            <summary>
            Gets the variables in the expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.PiFunction.CanParallelise">
            <summary>
            Gets whether an expression can safely be evaluated in parallel
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.PiFunction.Type">
            <summary>
            Gets the type of the expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.PiFunction.Arguments">
            <summary>
            Gets the arguments of the expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Arq.Sha1Function">
            <summary>
            Represents the ARQ afn:sha1sum() function
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Hash.BaseHashFunction">
            <summary>
            Abstract base class for Hash Functions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Hash.BaseHashFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,System.Security.Cryptography.HashAlgorithm)">
            <summary>
            Creates a new Hash function
            </summary>
            <param name="expr">Expression</param>
            <param name="hash">Hash Algorithm to use</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Hash.BaseHashFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the value of the function in the given Evaluation Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Hash.BaseHashFunction.Hash(System.String)">
            <summary>
            Computes Hashes
            </summary>
            <param name="input">Input String</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Hash.BaseHashFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Hash.BaseHashFunction.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.Sha1Function.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new ARQ SHA1 Sum function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.Sha1Function.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.Sha1Function.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.Sha1Function.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Arq.StringJoinFunction">
            <summary>
            Represents the ARQ afn:strjoin() function which is a string concatenation function with a separator
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.StringJoinFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,System.Collections.Generic.IEnumerable{VDS.RDF.Query.Expressions.ISparqlExpression})">
            <summary>
            Creates a new ARQ String Join function
            </summary>
            <param name="sepExpr">Separator Expression</param>
            <param name="expressions">Expressions to concatentate</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.StringJoinFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the value of the function in the given Evaluation Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.StringJoinFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.StringJoinFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.StringJoinFunction.Variables">
            <summary>
            Gets the Variables used in the function
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.StringJoinFunction.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.StringJoinFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.StringJoinFunction.Arguments">
            <summary>
            Gets the Arguments of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.StringJoinFunction.CanParallelise">
            <summary>
            Gets whether an expression can safely be evaluated in parallel
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Arq.SubstringFunction">
            <summary>
            Represents the ARQ afn:substring() function which is a sub-string with Java semantics
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.SubstringFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new ARQ substring function
            </summary>
            <param name="stringExpr">Expression</param>
            <param name="startExpr">Expression giving an index at which to start the substring</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.SubstringFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new ARQ substring function
            </summary>
            <param name="stringExpr">Expression</param>
            <param name="startExpr">Expression giving an index at which to start the substring</param>
            <param name="endExpr">Expression giving an index at which to end the substring</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.SubstringFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the value of the function in the given Evaluation Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.SubstringFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Arq.SubstringFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.SubstringFunction.Variables">
            <summary>
            Gets the Variables used in the function
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.SubstringFunction.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.SubstringFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.SubstringFunction.Arguments">
            <summary>
            Gets the Arguments of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Arq.SubstringFunction.CanParallelise">
            <summary>
            Gets whether an expression can safely be evaluated in parallel
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Hash.Sha256HashFunction">
            <summary>
            Represents the Leviathan lfn:sha256hash() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Hash.Sha256HashFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan SHA 256 Hash function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Hash.Sha256HashFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Hash.Sha256HashFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Hash.Sha256HashFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.CubeFunction">
            <summary>
            Represents the Leviathan lfn:cube() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.CubeFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan Cube Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.CubeFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.CubeFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.CubeFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.CubeFunction.Type">
            <summary>
            Gets the Type of this expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.CubeFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.EFunction">
            <summary>
            Represents the Leviathan lfn:e() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.EFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan E Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.EFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID"></param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.EFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.EFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.EFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.EFunction.Type">
            <summary>
            Gets the type of the expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.FactorialFunction">
            <summary>
            Represents the Leviathan lfn:factorial() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.FactorialFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan Factorial Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.FactorialFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.FactorialFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.FactorialFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.FactorialFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.FactorialFunction.Type">
            <summary>
            Gets the type of the expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.LogFunction">
            <summary>
            Represents the Leviathan lfn:log() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.LogFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan Log Function
            </summary>
            <param name="arg">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.LogFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan Log Function
            </summary>
            <param name="arg">Expression</param>
            <param name="logBase">Log Base Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.LogFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.LogFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.LogFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.LogFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.LogFunction.Type">
            <summary>
            Gets the type of the expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.LeviathanNaturalLogFunction">
            <summary>
            Represents the Leviathan lfn:ln() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.LeviathanNaturalLogFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan Natural Logarithm Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.LeviathanNaturalLogFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.LeviathanNaturalLogFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.LeviathanNaturalLogFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.LeviathanNaturalLogFunction.Type">
            <summary>
            Gets the Type of this expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.LeviathanNaturalLogFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.PowerFunction">
            <summary>
            Represents the Leviathan lfn:pow() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.PowerFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan Power Function
            </summary>
            <param name="arg1">First Argument</param>
            <param name="arg2">Second Argument</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.PowerFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.PowerFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.PowerFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.PowerFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.PowerFunction.Type">
            <summary>
            Gets the type of the expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.PythagoreanDistanceFunction">
            <summary>
            Represents the Leviathan lfn:pythagoras() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.PythagoreanDistanceFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan Pythagorean Distance Function
            </summary>
            <param name="arg1">First Argument</param>
            <param name="arg2">Second Argument</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.PythagoreanDistanceFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.PythagoreanDistanceFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.PythagoreanDistanceFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.PythagoreanDistanceFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.PythagoreanDistanceFunction.Type">
            <summary>
            Gets the type of the expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.RandomFunction">
            <summary>
            Represents the Leviathan lfn:rnd() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.RandomFunction.#ctor">
            <summary>
            Creates a new Leviathan Random Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.RandomFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan Random Function
            </summary>
            <param name="max">Maximum</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.RandomFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan Random Function
            </summary>
            <param name="min">Minumum</param>
            <param name="max">Maximum</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.RandomFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.RandomFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.RandomFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.RandomFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.RandomFunction.Type">
            <summary>
            Gets the type of the expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.ReciprocalFunction">
            <summary>
            Represents the Leviathan lfn:reciprocal() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.ReciprocalFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan Reciprocal Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.ReciprocalFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.ReciprocalFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.ReciprocalFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.ReciprocalFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.ReciprocalFunction.Type">
            <summary>
            Gets the type of the expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.RootFunction">
            <summary>
            Represents the Leviathan lfn:root() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.RootFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan Root Function
            </summary>
            <param name="arg1">First Argument</param>
            <param name="arg2">Second Argument</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.RootFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.RootFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.RootFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.RootFunction.Type">
            <summary>
            Gets the Type of this expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.RootFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.SquareFunction">
            <summary>
            Represents the Leviathan lfn:sq() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.SquareFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan Square Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.SquareFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Evaluates this expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.SquareFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.SquareFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.SquareFunction.Type">
            <summary>
            Gets the Type of this expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.SquareFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.SquareRootFunction">
            <summary>
            Represents the Leviathan lfn:sqrt() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.SquareRootFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan Square Root Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.SquareRootFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.SquareRootFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.SquareRootFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.SquareRootFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.SquareRootFunction.Type">
            <summary>
            Gets the type of the expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.TenFunction">
            <summary>
            Represents the Leviathan lfn:ten() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.TenFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan Ten Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.TenFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.TenFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.TenFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.TenFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.TenFunction.Type">
            <summary>
            Gets the type of the expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.BaseTrigonometricFunction">
            <summary>
            Abstract Base Class for Unary Trigonometric Functions in the Leviathan Function Library
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.BaseTrigonometricFunction._func">
            <summary>
            Trigonometric function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.BaseTrigonometricFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Unary Trigonometric Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.BaseTrigonometricFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,System.Func{System.Double,System.Double})">
            <summary>
            Creates a new Unary Trigonometric Function
            </summary>
            <param name="expr">Expression</param>
            <param name="func">Trigonometric Function</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.BaseTrigonometricFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.BaseTrigonometricFunction.ToString">
            <summary>
            Gets the string representation of the Function
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.BaseTrigonometricFunction.Type">
            <summary>
            Gets the expression type
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.CosecantFunction">
            <summary>
            Represents the Leviathan lfn:cosec() or lfn:cosec-1 function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.CosecantFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan Cosecant Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.CosecantFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,System.Boolean)">
            <summary>
            Creates a new Leviathan Cosecant Function
            </summary>
            <param name="expr">Expression</param>
            <param name="inverse">Whether this should be the inverse function</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.CosecantFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.CosecantFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.CosecantFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.CosineFunction">
            <summary>
            Represents the Leviathan lfn:cos() or lfn:cos-1 function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.CosineFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan Cosine Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.CosineFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,System.Boolean)">
            <summary>
            Creates a new Leviathan Cosine Function
            </summary>
            <param name="expr">Expression</param>
            <param name="inverse">Whether this should be the inverse function</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.CosineFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.CosineFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.CosineFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.CotangentFunction">
            <summary>
            Represents the Leviathan lfn:cot() or lfn:cot-1 function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.CotangentFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan Cotangent Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.CotangentFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,System.Boolean)">
            <summary>
            Creates a new Leviathan Cotangent Function
            </summary>
            <param name="expr">Expression</param>
            <param name="inverse">Whether this should be the inverse function</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.CotangentFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.CotangentFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.CotangentFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.DegreesToRadiansFunction">
            <summary>
            Represents the Leviathan lfn:degrees-to-radians() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.DegreesToRadiansFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan Degrees to Radians Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.DegreesToRadiansFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.DegreesToRadiansFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.DegreesToRadiansFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.DegreesToRadiansFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.DegreesToRadiansFunction.Type">
            <summary>
            Gets the Type of this expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.RadiansToDegreesFunction">
            <summary>
            Represents the Leviathan lfn:radians-to-degrees() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.RadiansToDegreesFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan Radians to Degrees Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.RadiansToDegreesFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.RadiansToDegreesFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.RadiansToDegreesFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.RadiansToDegreesFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.RadiansToDegreesFunction.Type">
            <summary>
            Gets the type of the expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.SecantFunction">
            <summary>
            Represents the Leviathan lfn:sec() or lfn:sec-1 function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.SecantFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan Secant Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.SecantFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,System.Boolean)">
            <summary>
            Creates a new Leviathan Secant Function
            </summary>
            <param name="expr">Expression</param>
            <param name="inverse">Whether this should be the inverse function</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.SecantFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.SecantFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.SecantFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.SineFunction">
            <summary>
            Represents the Leviathan lfn:sin() or lfn:sin-1 function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.SineFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan Sine Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.SineFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,System.Boolean)">
            <summary>
            Creates a new Leviathan Sine Function
            </summary>
            <param name="expr">Expression</param>
            <param name="inverse">Whether this should be the inverse function</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.SineFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.SineFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.SineFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.TangentFunction">
            <summary>
            Represents the Leviathan lfn:tan() or lfn:tan-1 function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.TangentFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Leviathan Tangent Function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.TangentFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,System.Boolean)">
            <summary>
            Creates a new Leviathan Tangent Function
            </summary>
            <param name="expr">Expression</param>
            <param name="inverse">Whether this should be the inverse function</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.TangentFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.TangentFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.TangentFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Numeric.AbsFunction">
            <summary>
            Represents the SPARQL ABS() Function
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.AbsFunction">
            <summary>
            Represents the XPath fn:abs() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.AbsFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Absolute function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.AbsFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Numeric Value of the function as evaluated in the given Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.AbsFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.AbsFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.AbsFunction.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.AbsFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Numeric.AbsFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new SPARQL ABS() Function
            </summary>
            <param name="expr">Argument Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Numeric.AbsFunction.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Numeric.AbsFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Numeric.AbsFunction.Functor">
            <summary>
            Gets the Functor of this Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.String.BaseBinaryStringFunction">
            <summary>
            Abstract Base Class for SPARQL String Testing functions which take two arguments
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.BaseBinaryStringFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Base Binary SPARQL String Function
            </summary>
            <param name="stringExpr">String Expression</param>
            <param name="argExpr">Argument Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.BaseBinaryStringFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.BaseBinaryStringFunction.ValueInternal(VDS.RDF.ILiteralNode,VDS.RDF.ILiteralNode)">
            <summary>
            Abstract method that child classes must implement to 
            </summary>
            <param name="stringLit"></param>
            <param name="argLit"></param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.BaseBinaryStringFunction.IsValidArgumentPair(VDS.RDF.ILiteralNode,VDS.RDF.ILiteralNode)">
            <summary>
            Determines whether the Arguments are valid
            </summary>
            <param name="stringLit">String Literal</param>
            <param name="argLit">Argument Literal</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.BaseBinaryStringFunction.Type">
            <summary>
            Gets the Expression Type
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Numeric.CeilFunction">
            <summary>
            Represents the SPARQL CEIL() Function
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.CeilingFunction">
            <summary>
            Represents the XPath fn:ceiling() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.CeilingFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Ceiling function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.CeilingFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Numeric Value of the function as evaluated in the given Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.CeilingFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.CeilingFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.CeilingFunction.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.CeilingFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Numeric.CeilFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new SPARQL CEIL() Function
            </summary>
            <param name="expr">Argument Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Numeric.CeilFunction.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Numeric.CeilFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Numeric.CeilFunction.Functor">
            <summary>
            Gets the Functor of this Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.String.ConcatFunction">
            <summary>
            Represents the SPARQL CONCAT function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.ConcatFunction.#ctor(System.Collections.Generic.IEnumerable{VDS.RDF.Query.Expressions.ISparqlExpression})">
            <summary>
            Creates a new SPARQL Concatenation function
            </summary>
            <param name="expressions">Enumeration of expressions</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.ConcatFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Value of the function as evaluated in the given Context for the given Binding ID
            </summary>
            <param name="context">Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.ConcatFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.ConcatFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.ConcatFunction.Arguments">
            <summary>
            Gets the Arguments the function applies to
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.ConcatFunction.CanParallelise">
            <summary>
            Gets whether an expression can safely be evaluated in parallel
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.ConcatFunction.Variables">
            <summary>
            Gets the Variables used in the function
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.ConcatFunction.Type">
            <summary>
            Gets the Type of the SPARQL Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.ConcatFunction.Functor">
            <summary>
            Gets the Functor of the expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.String.ContainsFunction">
            <summary>
            Represents the SPARQL CONTAINS function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.ContainsFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new SPARQL CONTAINS function
            </summary>
            <param name="stringExpr">String Expression</param>
            <param name="searchExpr">Search Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.ContainsFunction.ValueInternal(VDS.RDF.ILiteralNode,VDS.RDF.ILiteralNode)">
            <summary>
            Determines whether the String contains the given Argument
            </summary>
            <param name="stringLit">String Literal</param>
            <param name="argLit">Argument Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.ContainsFunction.ToString">
            <summary>
            Gets the String representation of the Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.ContainsFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.ContainsFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.String.EncodeForUriFunction">
            <summary>
            Represents the SPARQL ENCODE_FOR_URI Function
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.String.BaseUnaryStringFunction">
            <summary>
            Abstract Base Class for XPath Unary String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Functions.XPath.String.BaseUnaryStringFunction._expr">
            <summary>
            Expression the function applies over
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.BaseUnaryStringFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Unary String function
            </summary>
            <param name="stringExpr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.BaseUnaryStringFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Value of the function as evaluated in the given Context for the given Binding ID
            </summary>
            <param name="context">Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.BaseUnaryStringFunction.ValueInternal(VDS.RDF.ILiteralNode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.BaseUnaryStringFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.BaseUnaryStringFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.BaseUnaryStringFunction.Variables">
            <summary>
            Gets the Variables used in the function
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.BaseUnaryStringFunction.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.BaseUnaryStringFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.BaseUnaryStringFunction.Arguments">
            <summary>
            Gets the Arguments of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.BaseUnaryStringFunction.CanParallelise">
            <summary>
            Gets whether an expression can safely be evaluated in parallel
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.EncodeForUriFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Encode for URI function
            </summary>
            <param name="stringExpr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.EncodeForUriFunction.ValueInternal(VDS.RDF.ILiteralNode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.EncodeForUriFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.EncodeForUriFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.EncodeForUriFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Numeric.FloorFunction">
            <summary>
            Represents the SPARQL FLOOR() Function
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.FloorFunction">
            <summary>
            Represents the XPath fn:floor() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.FloorFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Floor function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.FloorFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Numeric Value of the function as evaluated in the given Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.FloorFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.FloorFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.FloorFunction.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.FloorFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Numeric.FloorFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new SPARQL FLOOR() Function
            </summary>
            <param name="expr">Argument Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Numeric.FloorFunction.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Numeric.FloorFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Numeric.FloorFunction.Functor">
            <summary>
            Gets the Functor of this Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsNumericFunction">
            <summary>
            Represents the SPARQL ISNUMERIC() Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsNumericFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new SPARQL ISNUMERIC() Function
            </summary>
            <param name="expr">Argument Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsNumericFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context"></param>
            <param name="bindingID"></param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsNumericFunction.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsNumericFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsNumericFunction.Type">
            <summary>
            Gets the Type of this Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsNumericFunction.Functor">
            <summary>
            Gets the Functor of this Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.String.LCaseFunction">
            <summary>
            Represents the SPARQL LCASE Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.LCaseFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new LCASE function
            </summary>
            <param name="expr">Argument Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.LCaseFunction.ValueInternal(VDS.RDF.ILiteralNode)">
            <summary>
            Calculates
            </summary>
            <param name="stringLit"></param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.LCaseFunction.ToString">
            <summary>
            Gets the String representation of the Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.LCaseFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.LCaseFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Numeric.RandFunction">
            <summary>
            Represents the SPARQL RAND() Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Numeric.RandFunction.#ctor">
            <summary>
            Creates a new SPARQL RAND() Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Numeric.RandFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Numeric.RandFunction.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Numeric.RandFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Numeric.RandFunction.Variables">
            <summary>
            Gets the Variables used in this Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Numeric.RandFunction.Type">
            <summary>
            Gets the Type of this Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Numeric.RandFunction.Arguments">
            <summary>
            Gets the Arguments of this Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Numeric.RandFunction.CanParallelise">
            <summary>
            Gets whether an expression can safely be evaluated in parallel
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Numeric.RandFunction.Functor">
            <summary>
            Gets the Functor of this Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.String.ReplaceFunction">
            <summary>
            Represents the XPath fn:replace() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.ReplaceFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new SPARQL Replace function
            </summary>
            <param name="text">Text Expression</param>
            <param name="find">Search Expression</param>
            <param name="replace">Replace Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.ReplaceFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new SPARQL Replace function
            </summary>
            <param name="text">Text Expression</param>
            <param name="find">Search Expression</param>
            <param name="replace">Replace Expression</param>
            <param name="options">Options Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.ReplaceFunction.ConfigureOptions(VDS.RDF.INode,System.Boolean)">
            <summary>
            Configures the Options for the Regular Expression
            </summary>
            <param name="n">Node detailing the Options</param>
            <param name="throwErrors">Whether errors should be thrown or suppressed</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.ReplaceFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Returns the value of the Expression as evaluated for a given Binding as a Literal Node
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.ReplaceFunction.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.ReplaceFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.ReplaceFunction.Variables">
            <summary>
            Gets the enumeration of Variables involved in this Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.ReplaceFunction.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.ReplaceFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.ReplaceFunction.Arguments">
            <summary>
            Gets the Arguments of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.ReplaceFunction.CanParallelise">
            <summary>
            Gets whether an expression can safely be evaluated in parallel
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Numeric.RoundFunction">
            <summary>
            Represents the SPARQL ROUND() Function
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.RoundFunction">
            <summary>
            Represents the XPath fn:round() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.RoundFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Round function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.RoundFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Numeric Value of the function as evaluated in the given Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.RoundFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.RoundFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.RoundFunction.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.RoundFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Numeric.RoundFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new SPARQL ROUND() Function
            </summary>
            <param name="expr">Argument Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Numeric.RoundFunction.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Numeric.RoundFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Numeric.RoundFunction.Functor">
            <summary>
            Gets the Functor of this Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Set.BaseSetFunction">
            <summary>
            Abstract base class for SPARQL Functions which operate on Sets
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Functions.Sparql.Set.BaseSetFunction._expr">
            <summary>
            Variable Expression Term that the Set function applies to
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Functions.Sparql.Set.BaseSetFunction._expressions">
            <summary>
            Set that is used in the function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Set.BaseSetFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,System.Collections.Generic.IEnumerable{VDS.RDF.Query.Expressions.ISparqlExpression})">
            <summary>
            Creates a new SPARQL Set function
            </summary>
            <param name="expr">Expression</param>
            <param name="set">Set</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Set.BaseSetFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the value of the function as evaluated for a given Binding in the given Context
            </summary>
            <param name="context">SPARQL Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Set.BaseSetFunction.ToString">
            <summary>
            Gets the String representation of the Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Set.BaseSetFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Set.BaseSetFunction.Variables">
            <summary>
            Gets the Variable the function applies to
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Set.BaseSetFunction.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Set.BaseSetFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Set.BaseSetFunction.Arguments">
            <summary>
            Gets the Arguments of the Exception
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Set.BaseSetFunction.CanParallelise">
            <summary>
            Gets whether an expression can safely be evaluated in parallel
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.BNodeFunction">
            <summary>
            Class representing the SPARQL BNODE() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.BNodeFunction.#ctor">
            <summary>
            Creates a new BNode Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.BNodeFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new BNode Function
            </summary>
            <param name="expr">Argument Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.BNodeFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the value of the expression as evaluated in a given Context for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.BNodeFunction.ToString">
            <summary>
            Gets the String representation of the Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.BNodeFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.BNodeFunction.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.BNodeFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.BNodeFunction.Variables">
            <summary>
            Gets the Variables used in the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.BNodeFunction.Arguments">
            <summary>
            Gets the Arguments of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.BNodeFunction.CanParallelise">
            <summary>
            Gets whether the expression can be parallelised
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.BoundFunction">
            <summary>
            Class representing the SPARQL BOUND() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.BoundFunction.#ctor(VDS.RDF.Query.Expressions.Primary.VariableTerm)">
            <summary>
            Creates a new Bound() function expression
            </summary>
            <param name="varExpr">Variable Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.BoundFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.BoundFunction.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.BoundFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.BoundFunction.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.BoundFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.String.DataTypeFunction">
            <summary>
            Class representing the SPARQL Datatype() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.DataTypeFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Datatype() function expression
            </summary>
            <param name="expr">Expression to apply the function to</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.DataTypeFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Returns the value of the Expression as evaluated for a given Binding as a Literal Node
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.DataTypeFunction.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.DataTypeFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.DataTypeFunction.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.DataTypeFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.String.DataType11Function">
            <summary>
            Class representing the SPARQL Datatype() function in SPARQL 1.1
            </summary>
            <remarks>
            This is required because the changes to the function in SPARQL 1.1 are not backwards compatible with SPARQL 1.0
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.DataType11Function.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new DataType function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.DataType11Function.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Returns the value of the Expression as evaluated for a given Binding as a Literal Node
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.DayFunction">
            <summary>
            Represents the SPARQL DAY() Function
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.DayFromDateTimeFunction">
            <summary>
            Represents the XPath day-from-dateTime() function
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.BaseUnaryDateTimeFunction">
            <summary>
            Abstract Base Class for functions which are Unary functions applied to Date Time objects in the XPath function library
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.BaseUnaryDateTimeFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Unary XPath Date Time function
            </summary>
            <param name="expr"></param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.BaseUnaryDateTimeFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the numeric value of the function in the given Evaluation Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.BaseUnaryDateTimeFunction.ValueInternal(System.DateTimeOffset)">
            <summary>
            Abstract method which derived classes must implement to generate the actual numeric value for the function
            </summary>
            <param name="dateTime">Date Time</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.BaseUnaryDateTimeFunction.ToString">
            <summary>
            Gets the String representation of the Function
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.BaseUnaryDateTimeFunction.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.DayFromDateTimeFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Day from Date Time function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.DayFromDateTimeFunction.ValueInternal(System.DateTimeOffset)">
            <summary>
            Calculates the numeric value of the function from the given Date Time
            </summary>
            <param name="dateTime">Date Time</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.DayFromDateTimeFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.DayFromDateTimeFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.DayFromDateTimeFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.DayFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new SPARQL DAY() Function
            </summary>
            <param name="expr">Argument Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.DayFunction.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.DayFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.DayFunction.Functor">
            <summary>
            Gets the Functor of this Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.HoursFunction">
            <summary>
            Represents the SPARQL HOURS() Function
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.HoursFromDateTimeFunction">
            <summary>
            Represents the XPath hours-from-dateTime() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.HoursFromDateTimeFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Hours from Date Time function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.HoursFromDateTimeFunction.ValueInternal(System.DateTimeOffset)">
            <summary>
            Calculates the numeric value of the function from the given Date Time
            </summary>
            <param name="dateTime">Date Time</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.HoursFromDateTimeFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.HoursFromDateTimeFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.HoursFromDateTimeFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.HoursFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new SPARQL HOURS() Function
            </summary>
            <param name="expr">Argument Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.HoursFunction.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.HoursFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.HoursFunction.Functor">
            <summary>
            Gets the Functor of this Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Set.InFunction">
            <summary>
            Class representing the SPARQL IN set function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Set.InFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,System.Collections.Generic.IEnumerable{VDS.RDF.Query.Expressions.ISparqlExpression})">
            <summary>
            Creates a new SPARQL IN function
            </summary>
            <param name="expr">Expression</param>
            <param name="set">Set</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Set.InFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Set.InFunction.ToString">
            <summary>
            Gets the String representation of the Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Set.InFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Set.InFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.IriFunction">
            <summary>
            Class representing the SPARQL IRI() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.IriFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new IRI() function expression
            </summary>
            <param name="expr">Expression to apply the function to</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.IriFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Returns the value of the Expression as evaluated for a given Binding as a Literal Node
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.IriFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.IriFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.IriFunction.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.IriFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsBlankFunction">
            <summary>
            Class representing the Sparql IsBlank() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsBlankFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new IsBlank() function expression
            </summary>
            <param name="expr">Expression to apply the function to</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsBlankFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Computes the Effective Boolean Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsBlankFunction.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsBlankFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsBlankFunction.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsBlankFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsIriFunction">
            <summary>
            Class representing the Sparql IsIRI() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsIriFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new IsIRI() function expression
            </summary>
            <param name="expr">Expression to apply the function to</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsIriFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Computes the Effective Boolean Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsIriFunction.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsIriFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsIriFunction.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsIriFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsUriFunction">
            <summary>
            Class representing the Sparql IsURI() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsUriFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new IsURI() function expression
            </summary>
            <param name="expr">Expression to apply the function to</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsUriFunction.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsUriFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsUriFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsLiteralFunction">
            <summary>
            Class representing the Sparql IsLiteral() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsLiteralFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new IsLiteral() function expression
            </summary>
            <param name="expr">Expression to apply the function to</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsLiteralFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Computes the Effective Boolean Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsLiteralFunction.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsLiteralFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsLiteralFunction.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.IsLiteralFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.String.LangFunction">
            <summary>
            Class representing the Sparql Lang() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.LangFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Lang() function expression
            </summary>
            <param name="expr">Expression to apply the function to</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.LangFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Returns the value of the Expression as evaluated for a given Binding as a Literal Node
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.LangFunction.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.LangFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.LangFunction.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.LangFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.LangMatchesFunction">
            <summary>
            Class representing the Sparql LangMatches() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.LangMatchesFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new LangMatches() function expression
            </summary>
            <param name="term">Expression to obtain the Language of</param>
            <param name="langRange">Expression representing the Language Range to match</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.LangMatchesFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Computes the Effective Boolean Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.LangMatchesFunction.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.LangMatchesFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.LangMatchesFunction.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.LangMatchesFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.MinutesFunction">
            <summary>
            Represents the SPARQL MINUTES() Function
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.MinutesFromDateTimeFunction">
            <summary>
            Represents the XPath minutes-from-dateTime() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.MinutesFromDateTimeFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Minutes from Date Time function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.MinutesFromDateTimeFunction.ValueInternal(System.DateTimeOffset)">
            <summary>
            Calculates the numeric value of the function from the given Date Time
            </summary>
            <param name="dateTime">Date Time</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.MinutesFromDateTimeFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.MinutesFromDateTimeFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.MinutesFromDateTimeFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.MinutesFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new SPARQL MINUTES() Function
            </summary>
            <param name="expr">Argument Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.MinutesFunction.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.MinutesFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.MinutesFunction.Functor">
            <summary>
            Gets the Functor of this Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.MonthFunction">
            <summary>
            Represents the SPARQL MONTH() Function
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.MonthFromDateTimeFunction">
            <summary>
            Represents the XPath month-from-dateTime() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.MonthFromDateTimeFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Month from Date Time function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.MonthFromDateTimeFunction.ValueInternal(System.DateTimeOffset)">
            <summary>
            Calculates the numeric value of the function from the given Date Time
            </summary>
            <param name="dateTime">Date Time</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.MonthFromDateTimeFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.MonthFromDateTimeFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.MonthFromDateTimeFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.MonthFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new SPARQL YEAR() Function
            </summary>
            <param name="expr">Argument Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.MonthFunction.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.MonthFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.MonthFunction.Functor">
            <summary>
            Gets the Functor of this Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Set.NotInFunction">
            <summary>
            Class representing the SPARQL NOT IN set function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Set.NotInFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,System.Collections.Generic.IEnumerable{VDS.RDF.Query.Expressions.ISparqlExpression})">
            <summary>
            Creates a new SPARQL NOT IN function
            </summary>
            <param name="expr">Expression</param>
            <param name="set">Set</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Set.NotInFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Set.NotInFunction.ToString">
            <summary>
            Gets the String representation of the Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Set.NotInFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Set.NotInFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.NowFunction">
            <summary>
            Represents the SPARQL NOW() Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.NowFunction.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.NowFunction.Functor">
            <summary>
            Gets the Functor of this Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction">
            <summary>
            Class representing the SPARQL REGEX function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Regex() function expression
            </summary>
            <param name="text">Text to apply the Regular Expression to</param>
            <param name="pattern">Regular Expression Pattern</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Regex() function expression
            </summary>
            <param name="text">Text to apply the Regular Expression to</param>
            <param name="pattern">Regular Expression Pattern</param>
            <param name="options">Regular Expression Options</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction.ConfigureOptions(VDS.RDF.INode,System.Boolean)">
            <summary>
            Configures the Options for the Regular Expression
            </summary>
            <param name="n">Node detailing the Options</param>
            <param name="throwErrors">Whether errors should be thrown or suppressed</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction.Variables">
            <summary>
            Gets the enumeration of Variables involved in this Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction.Arguments">
            <summary>
            Gets the Arguments of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.RegexFunction.CanParallelise">
            <summary>
            Gets whether an expression can safely be evaluated in parallel
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.SameTermFunction">
            <summary>
            Class representing the Sparql SameTerm() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.SameTermFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new SameTerm() function expression
            </summary>
            <param name="term1">First Term</param>
            <param name="term2">Second Term</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.SameTermFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Computes the Effective Boolean Value of this Expression as evaluated for a given Binding
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.SameTermFunction.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.SameTermFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.SameTermFunction.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.SameTermFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.SecondsFunction">
            <summary>
            Represents the SPARQL SECONDS() Function
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.SecondsFromDateTimeFunction">
            <summary>
            Represents the XPath seconds-from-dateTime() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.SecondsFromDateTimeFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Seconds from Date Time function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.SecondsFromDateTimeFunction.ValueInternal(System.DateTimeOffset)">
            <summary>
            Calculates the numeric value of the function from the given Date Time
            </summary>
            <param name="dateTime">Date Time</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.SecondsFromDateTimeFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.SecondsFromDateTimeFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.SecondsFromDateTimeFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.SecondsFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new SPARQL SECONDS() Function
            </summary>
            <param name="expr">Argument Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.SecondsFunction.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.SecondsFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.SecondsFunction.Functor">
            <summary>
            Gets the Functor of this Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Hash.Sha1HashFunction">
            <summary>
            Represents the SPARQL SHA1() Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Hash.Sha1HashFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new SHA1() Function
            </summary>
            <param name="expr">Argument Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Hash.Sha1HashFunction.ToString">
            <summary>
            Gets the String representation of the Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Hash.Sha1HashFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Hash.Sha1HashFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Hash.Sha256HashFunction">
            <summary>
            Represents the SPARQL SHA256() Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Hash.Sha256HashFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new SHA256() Function
            </summary>
            <param name="expr">Argument Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Hash.Sha256HashFunction.ToString">
            <summary>
            Gets the String representation of the Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Hash.Sha256HashFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Hash.Sha256HashFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrAfterFunction">
            <summary>
            Represents the SPARQL STRAFTER Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrAfterFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new STRAFTER Function
            </summary>
            <param name="stringExpr">String Expression</param>
            <param name="startsExpr">Starts Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrAfterFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Returns the value of the Expression as evaluated for a given Binding as a Literal Node
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrAfterFunction.IsValidArgumentPair(VDS.RDF.ILiteralNode,VDS.RDF.ILiteralNode)">
            <summary>
            Determines whether the Arguments are valid
            </summary>
            <param name="stringLit">String Literal</param>
            <param name="argLit">Argument Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrAfterFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrAfterFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrAfterFunction.Variables">
            <summary>
            Gets the Variables used in the function
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrAfterFunction.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrAfterFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrAfterFunction.Arguments">
            <summary>
            Gets the Arguments of the Function
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrAfterFunction.CanParallelise">
            <summary>
            Gets whether an expression can safely be evaluated in parallel
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrBeforeFunction">
            <summary>
            Represents the SPARQL STRBEFORE function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrBeforeFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new STRBEFORE Function
            </summary>
            <param name="stringExpr">String Expression</param>
            <param name="startsExpr">Starts Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrBeforeFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Returns the value of the Expression as evaluated for a given Binding as a Literal Node
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrBeforeFunction.IsValidArgumentPair(VDS.RDF.ILiteralNode,VDS.RDF.ILiteralNode)">
            <summary>
            Determines whether the Arguments are valid
            </summary>
            <param name="stringLit">String Literal</param>
            <param name="argLit">Argument Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrBeforeFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrBeforeFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrBeforeFunction.Variables">
            <summary>
            Gets the Variables used in the function
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrBeforeFunction.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrBeforeFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrBeforeFunction.Arguments">
            <summary>
            Gets the Arguments of the Function
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrBeforeFunction.CanParallelise">
            <summary>
            Gets whether an expression can safely be evaluated in parallel
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.StrDtFunction">
            <summary>
            Class representing the Sparql StrDt() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.StrDtFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new STRDT() function expression
            </summary>
            <param name="stringExpr">String Expression</param>
            <param name="dtExpr">Datatype Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.StrDtFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Returns the value of the Expression as evaluated for a given Binding as a Literal Node
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.StrDtFunction.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.StrDtFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.StrDtFunction.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.StrDtFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrEndsFunction">
            <summary>
            Represents the SPARQL STRENDS Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrEndsFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new STRENDS() function
            </summary>
            <param name="stringExpr">String Expression</param>
            <param name="endsExpr">Argument Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrEndsFunction.ValueInternal(VDS.RDF.ILiteralNode,VDS.RDF.ILiteralNode)">
            <summary>
            Determines whether the given String Literal ends with the given Argument Literal
            </summary>
            <param name="stringLit">String Literal</param>
            <param name="argLit">Argument Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrEndsFunction.ToString">
            <summary>
            Gets the String representation of the Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrEndsFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrEndsFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrFunction">
            <summary>
            Class representing the Sparql Str() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Str() function expression
            </summary>
            <param name="expr">Expression to apply the function to</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Returns the value of the Expression as evaluated for a given Binding as a Literal Node
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrFunction.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrFunction.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.StrLangFunction">
            <summary>
            Class representing the Sparql StrDt() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.StrLangFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new STRLANG() function expression
            </summary>
            <param name="stringExpr">String Expression</param>
            <param name="langExpr">Language Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.StrLangFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Returns the value of the Expression as evaluated for a given Binding as a Literal Node
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.StrLangFunction.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.StrLangFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.StrLangFunction.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.StrLangFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrLenFunction">
            <summary>
            Represents the SPARQL STRLEN Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrLenFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new STRLEN() function
            </summary>
            <param name="expr">Argument Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrLenFunction.ValueInternal(VDS.RDF.ILiteralNode)">
            <summary>
            Determines the Length of the given String Literal
            </summary>
            <param name="stringLit">String Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrLenFunction.ToString">
            <summary>
            Gets the String representation of the Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrLenFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrLenFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrStartsFunction">
            <summary>
            Represents the SPARQL STRSTARTS Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrStartsFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new STRSTARTS() function
            </summary>
            <param name="stringExpr">String Expression</param>
            <param name="startsExpr">Argument Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrStartsFunction.ValueInternal(VDS.RDF.ILiteralNode,VDS.RDF.ILiteralNode)">
            <summary>
            Determines whether the given String Literal starts with the given Argument Literal
            </summary>
            <param name="stringLit">String Literal</param>
            <param name="argLit">Argument Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrStartsFunction.ToString">
            <summary>
            Gets the String representation of the Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrStartsFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.StrStartsFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.String.SubStrFunction">
            <summary>
            Represents the SPARQL SUBSTR Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.SubStrFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Substring function
            </summary>
            <param name="stringExpr">Expression</param>
            <param name="startExpr">Start</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.SubStrFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Substring function
            </summary>
            <param name="stringExpr">Expression</param>
            <param name="startExpr">Start</param>
            <param name="lengthExpr">Length</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.SubStrFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Returns the value of the Expression as evaluated for a given Binding as a Literal Node
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.SubStrFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.SubStrFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.SubStrFunction.Variables">
            <summary>
            Gets the Variables used in the function
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.SubStrFunction.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.SubStrFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.SubStrFunction.Arguments">
            <summary>
            Gets the Arguments of the Function
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.SubStrFunction.CanParallelise">
            <summary>
            Gets whether an expression can safely be evaluated in parallel
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.TimezoneFunction">
            <summary>
            Represents the SPARQL TIMEZONE() Function
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.TimezoneFromDateTimeFunction">
            <summary>
            Represents the XPath timezone-from-dateTime() function
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.TimezoneFromDateTimeFunction._expr">
            <summary>
            Expression that the Function applies to
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.TimezoneFromDateTimeFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Timezone from Date Time function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.TimezoneFromDateTimeFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Calculates the value of the function in the given Evaluation Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.TimezoneFromDateTimeFunction.EffectiveBooleanValue(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Calculates the effective boolean value of the function in the given Evaluation Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.TimezoneFromDateTimeFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.TimezoneFromDateTimeFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.TimezoneFromDateTimeFunction.Variables">
            <summary>
            Gets the Variables used in the function
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.TimezoneFromDateTimeFunction.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.TimezoneFromDateTimeFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.TimezoneFromDateTimeFunction.Arguments">
            <summary>
            Gets the Arguments of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.TimezoneFromDateTimeFunction.CanParallelise">
            <summary>
            Gets whether an expression can safely be evaluated in parallel
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.TimezoneFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new SPARQL TIMEZONE() Function
            </summary>
            <param name="expr">Argument Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.TimezoneFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Timezone of the Argument Expression as evaluated for the given Binding in the given Context
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.TimezoneFunction.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.TimezoneFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.TimezoneFunction.Functor">
            <summary>
            Gets the Functor of this Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.TZFunction">
            <summary>
            Represents the SPARQL TZ() Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.TZFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new SPARQL TZ() Function
            </summary>
            <param name="expr">Argument Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.TZFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Timezone of the Argument Expression as evaluated for the given Binding in the given Context
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.TZFunction.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.TZFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.TZFunction.Type">
            <summary>
            Gets the Type of this Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.TZFunction.Functor">
            <summary>
            Gets the Functor of this Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.String.UCaseFunction">
            <summary>
            Represents the SPARQL UCASE Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.UCaseFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new UCASE() function
            </summary>
            <param name="expr">Argument Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.UCaseFunction.ValueInternal(VDS.RDF.ILiteralNode)">
            <summary>
            Converts the given String Literal to upper case
            </summary>
            <param name="stringLit">String Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.UCaseFunction.ToString">
            <summary>
            Gets the String representation of the Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.String.UCaseFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.String.UCaseFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.YearFunction">
            <summary>
            Represents the SPARQL YEAR() Function
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.YearFromDateTimeFunction">
            <summary>
            Represents the XPath year-from-dateTime() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.YearFromDateTimeFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Year from Date Time function
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.YearFromDateTimeFunction.ValueInternal(System.DateTimeOffset)">
            <summary>
            Calculates the numeric value of the function from the given Date Time
            </summary>
            <param name="dateTime">Date Time</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.YearFromDateTimeFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.YearFromDateTimeFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.YearFromDateTimeFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.YearFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new SPARQL YEAR() Function
            </summary>
            <param name="expr">Argument Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.YearFunction.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.YearFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.YearFunction.Functor">
            <summary>
            Gets the Functor of this Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.String.CompareFunction">
            <summary>
            Represents the XPath fn:compare() function
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.String.BaseBinaryStringFunction">
            <summary>
            Abstract Base class for XPath Binary String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Functions.XPath.String.BaseBinaryStringFunction._expr">
            <summary>
            Expression the function applies over
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Functions.XPath.String.BaseBinaryStringFunction._arg">
            <summary>
            Argument expression
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Functions.XPath.String.BaseBinaryStringFunction._allowNullArgument">
            <summary>
            Whether the argument can be null
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Functions.XPath.String.BaseBinaryStringFunction._argumentTypeValidator">
            <summary>
            Type validation function for the argument
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.BaseBinaryStringFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression,System.Boolean,System.Func{System.Uri,System.Boolean})">
            <summary>
            Creates a new XPath Binary String function
            </summary>
            <param name="stringExpr">Expression</param>
            <param name="argExpr">Argument</param>
            <param name="allowNullArgument">Whether the argument may be null</param>
            <param name="argumentTypeValidator">Type validator for the argument</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.BaseBinaryStringFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Value of the function as evaluated in the given Context for the given Binding ID
            </summary>
            <param name="context">Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.BaseBinaryStringFunction.ValueInternal(VDS.RDF.ILiteralNode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.BaseBinaryStringFunction.ValueInternal(VDS.RDF.ILiteralNode,VDS.RDF.ILiteralNode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal and Argument
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <param name="arg">Argument</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.BaseBinaryStringFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.BaseBinaryStringFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.BaseBinaryStringFunction.Variables">
            <summary>
            Gets the Variables used in the function
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.BaseBinaryStringFunction.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.BaseBinaryStringFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.BaseBinaryStringFunction.Arguments">
            <summary>
            Gets the Arguments of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.BaseBinaryStringFunction.CanParallelise">
            <summary>
            Gets whether an expression can safely be evaluated in parallel
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.CompareFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Compare function
            </summary>
            <param name="a">First Comparand</param>
            <param name="b">Second Comparand</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.CompareFunction.ValueInternal(VDS.RDF.ILiteralNode,VDS.RDF.ILiteralNode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal and Argument
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <param name="arg">Argument</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.CompareFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.CompareFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.CompareFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.Cast.BaseCast">
            <summary>
            Abstract Expression class used as the base class for implementation of XPath Casting Function expressions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Functions.XPath.Cast.BaseCast._expr">
            <summary>
            Expression to be Cast by the Cast Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Cast.BaseCast.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Base XPath Cast Expression
            </summary>
            <param name="expr">Expression to be Cast</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Cast.BaseCast.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the value of casting the result of the inner expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Cast.BaseCast.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Cast.BaseCast.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.Cast.BaseCast.Variables">
            <summary>
            Gets the enumeration of Variables involved in this expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.Cast.BaseCast.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.Cast.BaseCast.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.Cast.BaseCast.Arguments">
            <summary>
            Gets the Arguments of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.Cast.BaseCast.CanParallelise">
            <summary>
            Gets whether an expression can safely be evaluated in parallel
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.String.ConcatFunction">
            <summary>
            Represents the XPath fn:concat() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.ConcatFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Concatenation function
            </summary>
            <param name="first">First Expression</param>
            <param name="second">Second Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.ConcatFunction.#ctor(System.Collections.Generic.IEnumerable{VDS.RDF.Query.Expressions.ISparqlExpression})">
            <summary>
            Creates a new XPath Concatenation function
            </summary>
            <param name="expressions">Enumeration of expressions</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.ConcatFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Value of the function as evaluated in the given Context for the given Binding ID
            </summary>
            <param name="context">Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.ConcatFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.ConcatFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.ConcatFunction.Arguments">
            <summary>
            Gets the Arguments the function applies to
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.ConcatFunction.CanParallelise">
            <summary>
            Gets whether an expression can safely be evaluated in parallel
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.ConcatFunction.Variables">
            <summary>
            Gets the Variables used in the function
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.ConcatFunction.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.ConcatFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.String.EncodeForUriFunction">
            <summary>
            Represents the XPath fn:encode-for-uri() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.EncodeForUriFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Encode for URI function
            </summary>
            <param name="stringExpr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.EncodeForUriFunction.ValueInternal(VDS.RDF.ILiteralNode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.EncodeForUriFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.EncodeForUriFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.EncodeForUriFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.String.EndsWithFunction">
            <summary>
            Represents the XPath fn:ends-with() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.EndsWithFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Ends With function
            </summary>
            <param name="stringExpr">Expression</param>
            <param name="suffixExpr">Suffix Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.EndsWithFunction.ValueInternal(VDS.RDF.ILiteralNode,VDS.RDF.ILiteralNode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal and Argument
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <param name="arg">Argument</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.EndsWithFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.EndsWithFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.EndsWithFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.String.EscapeHtmlUriFunction">
            <summary>
            Represents the XPath fn:escape-html-uri() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.EscapeHtmlUriFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Escape HTML for URI function
            </summary>
            <param name="stringExpr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.EscapeHtmlUriFunction.ValueInternal(VDS.RDF.ILiteralNode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.EscapeHtmlUriFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.EscapeHtmlUriFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.EscapeHtmlUriFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.String.LowerCaseFunction">
            <summary>
            Represents the XPath fn:lower-case() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.LowerCaseFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Lower Case function
            </summary>
            <param name="stringExpr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.LowerCaseFunction.ValueInternal(VDS.RDF.ILiteralNode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.LowerCaseFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.LowerCaseFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.LowerCaseFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.String.NormalizeSpaceFunction">
            <summary>
            Represents the XPath fn:normalize-space() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.NormalizeSpaceFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Normalize Space function
            </summary>
            <param name="stringExpr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.NormalizeSpaceFunction.ValueInternal(VDS.RDF.ILiteralNode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.NormalizeSpaceFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.NormalizeSpaceFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.NormalizeSpaceFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.Cast.BooleanCast">
            <summary>
            Class representing an XPath Boolean Cast Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Cast.BooleanCast.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Boolean Cast Function Expression
            </summary>
            <param name="expr">Expression to be cast</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Cast.BooleanCast.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Casts the value of the inner Expression to a Boolean
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Cast.BooleanCast.ToString">
            <summary>
            Gets the String representation of the Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Cast.BooleanCast.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.Cast.BooleanCast.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.Cast.DateTimeCast">
            <summary>
            Class representing an XPath Date Time Cast Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Cast.DateTimeCast.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Date Time Cast Function Expression
            </summary>
            <param name="expr">Expression to be cast</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Cast.DateTimeCast.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Casts the value of the inner Expression to a Date Time
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Cast.DateTimeCast.ToString">
            <summary>
            Gets the String representation of the Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Cast.DateTimeCast.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.Cast.DateTimeCast.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.Cast.DecimalCast">
            <summary>
            Class representing an XPath Decimal Cast Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Cast.DecimalCast.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Decimal Cast Function Expression
            </summary>
            <param name="expr">Expression to be cast</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Cast.DecimalCast.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Casts the Value of the inner Expression to a Decimal
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Cast.DecimalCast.ToString">
            <summary>
            Gets the String representation of the Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Cast.DecimalCast.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.Cast.DecimalCast.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.Cast.DoubleCast">
            <summary>
            Class representing an XPath Double Cast Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Cast.DoubleCast.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Double Cast Function Expression
            </summary>
            <param name="expr">Expression to be cast</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Cast.DoubleCast.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Casts the value of the inner Expression to a Double
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Cast.DoubleCast.ToString">
            <summary>
            Gets the String representation of the Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Cast.DoubleCast.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.Cast.DoubleCast.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.Cast.FloatCast">
            <summary>
            Class representing an XPath Float Cast Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Cast.FloatCast.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Float Cast Function Expression
            </summary>
            <param name="expr">Expression to be cast</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Cast.FloatCast.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Casts the value of the inner Expression to a Float
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Vinding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Cast.FloatCast.ToString">
            <summary>
            Gets the String representation of the Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Cast.FloatCast.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.Cast.FloatCast.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.Cast.IntegerCast">
            <summary>
            Class representing an XPath Integer Cast Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Cast.IntegerCast.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Integer Cast Function Expression
            </summary>
            <param name="expr">Expression to be cast</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Cast.IntegerCast.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Casts the value of the inner Expression to an Integer
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Cast.IntegerCast.ToString">
            <summary>
            Gets the String representation of the Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Cast.IntegerCast.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.Cast.IntegerCast.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.Cast.StringCast">
            <summary>
            Class representing an XPath String Cast Function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Cast.StringCast.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath String Cast Function Expression
            </summary>
            <param name="expr">Expression to be cast</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Cast.StringCast.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Casts the results of the inner expression to a Literal Node typed xsd:string
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Cast.StringCast.ToString">
            <summary>
            Gets the String representation of the Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.Cast.StringCast.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.Cast.StringCast.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.String.ReplaceFunction">
            <summary>
            Represents the XPath fn:replace() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.ReplaceFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Replace function
            </summary>
            <param name="text">Text Expression</param>
            <param name="find">Search Expression</param>
            <param name="replace">Replace Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.ReplaceFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Replace function
            </summary>
            <param name="text">Text Expression</param>
            <param name="find">Search Expression</param>
            <param name="replace">Replace Expression</param>
            <param name="options">Options Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.ReplaceFunction.ConfigureOptions(VDS.RDF.Nodes.IValuedNode,System.Boolean)">
            <summary>
            Configures the Options for the Regular Expression
            </summary>
            <param name="n">Node detailing the Options</param>
            <param name="throwErrors">Whether errors should be thrown or suppressed</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.ReplaceFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Returns the value of the Expression as evaluated for a given Binding as a Literal Node
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.ReplaceFunction.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.ReplaceFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.ReplaceFunction.Variables">
            <summary>
            Gets the enumeration of Variables involved in this Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.ReplaceFunction.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.ReplaceFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.ReplaceFunction.Arguments">
            <summary>
            Gets the Arguments of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.ReplaceFunction.CanParallelise">
            <summary>
            Gets whether an expression can safely be evaluated in parallel
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.String.StartsWithFunction">
            <summary>
            Represents the XPath fn:starts-with() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.StartsWithFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Starts With function
            </summary>
            <param name="stringExpr">Expression</param>
            <param name="prefixExpr">Prefix Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.StartsWithFunction.ValueInternal(VDS.RDF.ILiteralNode,VDS.RDF.ILiteralNode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal and Argument
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <param name="arg">Argument</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.StartsWithFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.StartsWithFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.StartsWithFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.String.StringLengthFunction">
            <summary>
            Represents the XPath fn:string-length() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.StringLengthFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath String Length function
            </summary>
            <param name="stringExpr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.StringLengthFunction.ValueInternal(VDS.RDF.ILiteralNode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.StringLengthFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.StringLengthFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.StringLengthFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.String.ContainsFunction">
            <summary>
            Represents the XPath fn:contains() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.ContainsFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Contains function
            </summary>
            <param name="stringExpr">Expression</param>
            <param name="searchExpr">Search Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.ContainsFunction.ValueInternal(VDS.RDF.ILiteralNode,VDS.RDF.ILiteralNode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal and Argument
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <param name="arg">Argument</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.ContainsFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.ContainsFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.ContainsFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.String.SubstringAfterFunction">
            <summary>
            Represents the XPath fn:substring-after() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.SubstringAfterFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Substring After function
            </summary>
            <param name="stringExpr">Expression</param>
            <param name="findExpr">Search Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.SubstringAfterFunction.ValueInternal(VDS.RDF.ILiteralNode,VDS.RDF.ILiteralNode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal and Argument
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <param name="arg">Argument</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.SubstringAfterFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.SubstringAfterFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.SubstringAfterFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.String.SubstringBeforeFunction">
            <summary>
            Represents the XPath fn:substring-before() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.SubstringBeforeFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Substring Before function
            </summary>
            <param name="stringExpr">Expression</param>
            <param name="findExpr">Search Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.SubstringBeforeFunction.ValueInternal(VDS.RDF.ILiteralNode,VDS.RDF.ILiteralNode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal and Argument
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <param name="arg">Argument</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.SubstringBeforeFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.SubstringBeforeFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.SubstringBeforeFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.String.SubstringFunction">
            <summary>
            Represents the XPath fn:substring() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.SubstringFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Substring function
            </summary>
            <param name="stringExpr">Expression</param>
            <param name="startExpr">Start</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.SubstringFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Substring function
            </summary>
            <param name="stringExpr">Expression</param>
            <param name="startExpr">Start</param>
            <param name="lengthExpr">Length</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.SubstringFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Returns the value of the Expression as evaluated for a given Binding as a Literal Node
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.SubstringFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.SubstringFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.SubstringFunction.Variables">
            <summary>
            Gets the Variables used in the function
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.SubstringFunction.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.SubstringFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.SubstringFunction.Arguments">
            <summary>
            Gets the Arguments of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.SubstringFunction.CanParallelise">
            <summary>
            Gets whether an expression can safely be evaluated in parallel
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.String.UpperCaseFunction">
            <summary>
            Represents the XPath fn:upper-case() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.UpperCaseFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Upper Case function
            </summary>
            <param name="stringExpr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.UpperCaseFunction.ValueInternal(VDS.RDF.ILiteralNode)">
            <summary>
            Gets the Value of the function as applied to the given String Literal
            </summary>
            <param name="stringLit">Simple/String typed Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.UpperCaseFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.String.UpperCaseFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.String.UpperCaseFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Nodes.BooleanNode">
            <summary>
            Valued Node representing boolean values
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.BooleanNode.#ctor(VDS.RDF.IGraph,System.Boolean,System.String)">
            <summary>
            Creates a new boolean valued node
            </summary>
            <param name="g">Graph the node belong to</param>
            <param name="value">Boolean Value</param>
            <param name="lexicalValue">Lexical Value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.BooleanNode.#ctor(VDS.RDF.IGraph,System.Boolean)">
            <summary>
            Creates a new boolean valued node
            </summary>
            <param name="g">Graph the node belongs to</param>
            <param name="value">Boolean Value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.BooleanNode.AsString">
            <summary>
            Gets the string value of the boolean
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BooleanNode.AsInteger">
            <summary>
            Throws an error as booleans cannot be cast to integers
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BooleanNode.AsDecimal">
            <summary>
            Throws an error as booleans cannot be cast to decimals
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BooleanNode.AsFloat">
            <summary>
            Throws an error as booleans cannot be cast to floats
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BooleanNode.AsDouble">
            <summary>
            Throws an error as booleans cannot be cast to doubles
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BooleanNode.AsBoolean">
            <summary>
            Gets the boolean value
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BooleanNode.AsDateTime">
            <summary>
            Throws an error as booleans cannot be cast to date times
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BooleanNode.AsDateTimeOffset">
            <summary>
            Throws an error as booleans cannot be cast to date times
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BooleanNode.AsTimeSpan">
            <summary>
            Throws an error as booleans cannot be cast to a time span
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Nodes.BooleanNode.EffectiveType">
            <summary>
            Gets the URI of the datatype this valued node represents as a String
            </summary>
        </member>
        <member name="P:VDS.RDF.Nodes.BooleanNode.NumericType">
            <summary>
            Gets the numeric type of the node
            </summary>
        </member>
        <member name="T:VDS.RDF.Nodes.ByteNode">
            <summary>
            Valued node representing a byte (8-bit unsigned integer)
            </summary>
        </member>
        <member name="T:VDS.RDF.Nodes.NumericNode">
            <summary>
            A Valued Node with a numeric value
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.NumericNode.#ctor(VDS.RDF.IGraph,System.String,System.Uri,VDS.RDF.Query.Expressions.SparqlNumericType)">
            <summary>
            Creates a new numeric valued node
            </summary>
            <param name="g">Graph the node belongs to</param>
            <param name="value">Lexical Value</param>
            <param name="datatype">Datatype URI</param>
            <param name="numType">SPARQL Numeric Type</param>
        </member>
        <member name="M:VDS.RDF.Nodes.NumericNode.AsString">
            <summary>
            Gets the string value of the node
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.NumericNode.AsInteger">
            <summary>
            Gets the integer value
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.NumericNode.AsDecimal">
            <summary>
            Gets the decimal value
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.NumericNode.AsFloat">
            <summary>
            Gets the float value
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.NumericNode.AsDouble">
            <summary>
            Gets the double value
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.NumericNode.AsBoolean">
            <summary>
            Gets the boolean value
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.NumericNode.AsDateTime">
            <summary>
            Throws an error as numerics cannot be converted to date times
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.NumericNode.AsDateTimeOffset">
            <summary>
            Throws an error as numerics cannot be converted to date times
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.NumericNode.AsTimeSpan">
            <summary>
            Throws an error as numerics cannot be cast to a time span
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Nodes.NumericNode.EffectiveType">
            <summary>
            Gets the URI of the datatype this valued node represents as a String
            </summary>
        </member>
        <member name="P:VDS.RDF.Nodes.NumericNode.NumericType">
            <summary>
            Gets the numeric type of the node
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.ByteNode.#ctor(VDS.RDF.IGraph,System.Byte,System.String)">
            <summary>
            Creates a new byte valued node
            </summary>
            <param name="g">Graph the node belongs to</param>
            <param name="value">Byte value</param>
            <param name="lexicalValue">Lexical value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.ByteNode.#ctor(VDS.RDF.IGraph,System.Byte)">
            <summary>
            Creates a new byte valued node
            </summary>
            <param name="g">Graph the node belongs to</param>
            <param name="value">Byte value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.ByteNode.AsInteger">
            <summary>
            Gets the integer value of the byte
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.ByteNode.AsDecimal">
            <summary>
            Gets the decimal value of the byte
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.ByteNode.AsFloat">
            <summary>
            Gets the float value of the byte
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.ByteNode.AsDouble">
            <summary>
            Gets the float value of the double
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Nodes.SignedByteNode">
            <summary>
            Value node representing a signed byte (8-bit signed integer)
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.SignedByteNode.#ctor(VDS.RDF.IGraph,System.SByte,System.String)">
            <summary>
            Creates a new signed byte node
            </summary>
            <param name="g">Graph the node belongs to</param>
            <param name="value">Signed Byte value</param>
            <param name="lexicalValue">Lexical value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.SignedByteNode.#ctor(VDS.RDF.IGraph,System.SByte)">
            <summary>
            Creates a new signed byte node
            </summary>
            <param name="g">Graph the node belongs to</param>
            <param name="value">Signed Byte value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.SignedByteNode.AsInteger">
            <summary>
            Gets the integer value of the signed byte
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.SignedByteNode.AsDecimal">
            <summary>
            Gets the decimal value of the signed byte
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.SignedByteNode.AsFloat">
            <summary>
            Gets the float value of the signed byte
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.SignedByteNode.AsDouble">
            <summary>
            Gets the double value of the signed byte
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Nodes.DateTimeNode">
            <summary>
            Valued Node representing a Date Time value
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.DateTimeNode.#ctor(VDS.RDF.IGraph,System.DateTimeOffset,System.String,System.Uri)">
            <summary>
            Creates a new Date Time valued node
            </summary>
            <param name="g">Graph the node belongs to</param>
            <param name="value">Date Time value</param>
            <param name="lexicalValue">Lexical Value</param>
            <param name="datatype">Datatype URI</param>
        </member>
        <member name="M:VDS.RDF.Nodes.DateTimeNode.#ctor(VDS.RDF.IGraph,System.DateTime,System.String,System.Uri)">
            <summary>
            Creates a new Date Time valued node
            </summary>
            <param name="g">Graph the node belongs to</param>
            <param name="value">Date Time value</param>
            <param name="lexicalValue">Lexical Value</param>
            <param name="datatype">Datatype URI</param>
        </member>
        <member name="M:VDS.RDF.Nodes.DateTimeNode.#ctor(VDS.RDF.IGraph,System.DateTimeOffset,System.Uri)">
            <summary>
            Creates a new Date Time valued node
            </summary>
            <param name="g">Graph the node belongs to</param>
            <param name="value">Date Time value</param>
            <param name="datatype">Datatype URI</param>
        </member>
        <member name="M:VDS.RDF.Nodes.DateTimeNode.#ctor(VDS.RDF.IGraph,System.DateTime,System.Uri)">
            <summary>
            Creates a new Date Time valued node
            </summary>
            <param name="g">Graph the node belongs to</param>
            <param name="value">Date Time value</param>
            <param name="datatype">Datatype URI</param>
        </member>
        <member name="M:VDS.RDF.Nodes.DateTimeNode.#ctor(VDS.RDF.IGraph,System.DateTimeOffset)">
            <summary>
            Creates a new Date Time valued node
            </summary>
            <param name="g">Graph the node belongs to</param>
            <param name="value">Date Time value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.DateTimeNode.#ctor(VDS.RDF.IGraph,System.DateTime)">
            <summary>
            Creates a new Date Time valued node
            </summary>
            <param name="g">Graph the node belongs to</param>
            <param name="value">Date Time value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.DateTimeNode.#ctor(VDS.RDF.IGraph,System.DateTimeOffset,System.String)">
            <summary>
            Creates a new Date Time valued node
            </summary>
            <param name="g">Graph the node belongs to</param>
            <param name="value">Date Time value</param>
            <param name="lexicalValue">Lexical Value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.DateTimeNode.#ctor(VDS.RDF.IGraph,System.DateTime,System.String)">
            <summary>
            Creates a new Date Time valued node
            </summary>
            <param name="g">Graph the node belongs to</param>
            <param name="value">Date Time value</param>
            <param name="lexicalValue">Lexical Value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.DateTimeNode.#ctor(VDS.RDF.IGraph,System.DateTime,System.DateTimeOffset,System.String)">
            <summary>
            Creates a new Date Time valued node
            </summary>
            <param name="g">Graph the node belongs to</param>
            <param name="value">Date Time value</param>
            <param name="offsetValue">Date Time offset value</param>
            <param name="lexicalValue">Lexical Value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.DateTimeNode.#ctor(VDS.RDF.IGraph,System.DateTime,System.DateTimeOffset,System.String,System.Uri)">
            <summary>
            Creates a new Date Time valued node
            </summary>
            <param name="g">Graph the node belongs to</param>
            <param name="value">Date Time value</param>
            <param name="offsetValue">Date Time offset value</param>
            <param name="lexicalValue">Lexical Value</param>
            <param name="datatype">Data Type URI</param>
        </member>
        <member name="M:VDS.RDF.Nodes.DateTimeNode.GetStringForm(System.DateTimeOffset,System.Uri)">
            <summary>
            Gets the String form of the Date Time
            </summary>
            <param name="value">Value</param>
            <param name="datatype">Datatype URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.DateTimeNode.GetStringForm(System.DateTime,System.Uri)">
            <summary>
            Gets the String form of the Date Time
            </summary>
            <param name="value">Value</param>
            <param name="datatype">Datatype URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.DateTimeNode.AsString">
            <summary>
            Gets the date time value as a string
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.DateTimeNode.AsInteger">
            <summary>
            Throws an error as date times cannot be converted to integers
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.DateTimeNode.AsDecimal">
            <summary>
            Throws an error as date times cannot be converted to decimals
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.DateTimeNode.AsFloat">
            <summary>
            Throws an error as date times cannot be converted to floats
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.DateTimeNode.AsDouble">
            <summary>
            Throws an error as date times cannot be converted to doubles
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.DateTimeNode.AsBoolean">
            <summary>
            Throws an error as date times cannot be converted to booleans
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.DateTimeNode.AsDateTime">
            <summary>
            Gets the date time value of the node
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.DateTimeNode.AsDateTimeOffset">
            <summary>
            Gets the date time value of the node
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.DateTimeNode.AsTimeSpan">
            <summary>
            Throws an error as date times cannot be cast to a time span
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Nodes.DateTimeNode.EffectiveType">
            <summary>
            Gets the URI of the datatype this valued node represents as a String
            </summary>
        </member>
        <member name="P:VDS.RDF.Nodes.DateTimeNode.NumericType">
            <summary>
            Gets the numeric type of the node
            </summary>
        </member>
        <member name="T:VDS.RDF.Nodes.DateNode">
            <summary>
            Valued Node representing a Date value
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.DateNode.#ctor(VDS.RDF.IGraph,System.DateTimeOffset)">
            <summary>
            Creates a new Date valued node
            </summary>
            <param name="g">Graph the node belongs to</param>
            <param name="value">Date Time value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.DateNode.#ctor(VDS.RDF.IGraph,System.DateTimeOffset,System.String)">
            <summary>
            Creates a new Date valued node
            </summary>
            <param name="g">Graph the node belongs to</param>
            <param name="value">Date Time value</param>
            <param name="lexicalValue">Lexical Value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.DateNode.#ctor(VDS.RDF.IGraph,System.DateTime)">
            <summary>
            Creates a new Date valued node
            </summary>
            <param name="g">Graph the node belongs to</param>
            <param name="value">Date Time value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.DateNode.#ctor(VDS.RDF.IGraph,System.DateTime,System.String)">
            <summary>
            Creates a new Date valued node
            </summary>
            <param name="g">Graph the node belongs to</param>
            <param name="value">Date Time value</param>
            <param name="lexicalValue">Lexical Value</param>
        </member>
        <member name="T:VDS.RDF.Nodes.DecimalNode">
            <summary>
            A Valued Node representing decimal nodes
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.DecimalNode.#ctor(VDS.RDF.IGraph,System.Decimal,System.String)">
            <summary>
            Creates a new decimal valued node
            </summary>
            <param name="g">Graph the node belongs to</param>
            <param name="value">Decimal value</param>
            <param name="lexicalValue">Lexical value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.DecimalNode.#ctor(VDS.RDF.IGraph,System.Decimal)">
            <summary>
            Creates a new decimal valued node
            </summary>
            <param name="g">Graph the node belongs to</param>
            <param name="value">Decimal value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.DecimalNode.AsInteger">
            <summary>
            Gets the integer value of the decimal
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.DecimalNode.AsDecimal">
            <summary>
            Gets the decimal value
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.DecimalNode.AsFloat">
            <summary>
            Gets the float value of the decimal
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.DecimalNode.AsDouble">
            <summary>
            Gets the double value of the decimal
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Nodes.DoubleNode">
            <summary>
            A Valued Node representing double values
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.DoubleNode.#ctor(VDS.RDF.IGraph,System.Double,System.String)">
            <summary>
            Creates a new double valued node
            </summary>
            <param name="g">Graph the node belongs to</param>
            <param name="value">Double value</param>
            <param name="lexicalValue">Lexical value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.DoubleNode.#ctor(VDS.RDF.IGraph,System.Double)">
            <summary>
            Creates a new double valued node
            </summary>
            <param name="g">Graph the node belongs to</param>
            <param name="value">Double value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.DoubleNode.AsInteger">
            <summary>
            Gets the integer value of the double
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.DoubleNode.AsDecimal">
            <summary>
            Gets the decimal value of the double
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.DoubleNode.AsFloat">
            <summary>
            Gets the float value of the double
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.DoubleNode.AsDouble">
            <summary>
            Gets the double value
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Nodes.ValuedNodeExtensions">
            <summary>
            Extension Methods related to valued nodes
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.ValuedNodeExtensions.AsValuedNode(VDS.RDF.INode)">
            <summary>
            Takes a <see cref="T:VDS.RDF.INode">INode</see> and converts it to a <see cref="T:VDS.RDF.Nodes.IValuedNode">IValuedNode</see> if it is not already an instance that implements the interface
            </summary>
            <param name="n">Node</param>
            <returns>Valued Node</returns>
        </member>
        <member name="M:VDS.RDF.Nodes.ValuedNodeExtensions.AsSafeBoolean(VDS.RDF.Nodes.IValuedNode)">
            <summary>
            Tries to get the result of calling <see cref="M:VDS.RDF.Nodes.IValuedNode.AsBoolean">AsBoolean()</see> on a node throwing an error if the node is null
            </summary>
            <param name="n">Node</param>
            <exception cref="T:VDS.RDF.Query.RdfQueryException">Thrown if the input is null of the specific valued node cannot be cast to a boolean</exception>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Nodes.FloatNode">
            <summary>
            A Valued Node representing float values
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.FloatNode.#ctor(VDS.RDF.IGraph,System.Single,System.String)">
            <summary>
            Creates a new Float valued node
            </summary>
            <param name="g">Graph the node belongs to</param>
            <param name="value">Float value</param>
            <param name="lexicalValue">Lexical value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.FloatNode.#ctor(VDS.RDF.IGraph,System.Single)">
            <summary>
            Creates a new Float valued node
            </summary>
            <param name="g">Graph the node belongs to</param>
            <param name="value">Float value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.FloatNode.AsInteger">
            <summary>
            Gets the integer value of the float
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.FloatNode.AsDecimal">
            <summary>
            Gets the decimal value of the float
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.FloatNode.AsFloat">
            <summary>
            Gets the float value
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.FloatNode.AsDouble">
            <summary>
            Gets the double value of the float
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Nodes.LongNode">
            <summary>
            A Valued Node with a Long value
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.LongNode.#ctor(VDS.RDF.IGraph,System.Int64,System.String)">
            <summary>
            Creates a new long valued node
            </summary>
            <param name="g">Graph the node belongs to</param>
            <param name="value">Long value</param>
            <param name="lexicalValue">Lexical Value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.LongNode.#ctor(VDS.RDF.IGraph,System.Int64,System.String,System.Uri)">
            <summary>
            Creates a new long valued node
            </summary>
            <param name="g">Graph the node belongs to</param>
            <param name="value">Long value</param>
            <param name="lexicalValue">Lexical Value</param>
            <param name="datatype">Datatype URI</param>
        </member>
        <member name="M:VDS.RDF.Nodes.LongNode.#ctor(VDS.RDF.IGraph,System.Int64)">
            <summary>
            Creates a new long valued node
            </summary>
            <param name="g">Graph the node belongs to</param>
            <param name="value">Long value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.LongNode.AsInteger">
            <summary>
            Gets the long value
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.LongNode.AsDecimal">
            <summary>
            Gets the decimal value of the long
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.LongNode.AsFloat">
            <summary>
            Gets the float value of the long
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.LongNode.AsDouble">
            <summary>
            Gets the double value of the long
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Nodes.UnsignedLongNode">
            <summary>
            A Valued Node with a unsigned long value
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.UnsignedLongNode.#ctor(VDS.RDF.IGraph,System.UInt64,System.String)">
            <summary>
            Creates a new unsigned long valued node
            </summary>
            <param name="g">Graph the node belongs to</param>
            <param name="value">Unsigned Long value</param>
            <param name="lexicalValue">Lexical Value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.UnsignedLongNode.#ctor(VDS.RDF.IGraph,System.UInt64,System.String,System.Uri)">
            <summary>
            Creates a new unsigned long valued node
            </summary>
            <param name="g">Graph the node belongs to</param>
            <param name="value">Unsigned Long value</param>
            <param name="lexicalValue">Lexical Value</param>
            <param name="datatype">Datatype URI</param>
        </member>
        <member name="M:VDS.RDF.Nodes.UnsignedLongNode.#ctor(VDS.RDF.IGraph,System.UInt64)">
            <summary>
            Creates a new usigned long valued node
            </summary>
            <param name="g">Graph the node belongs to</param>
            <param name="value">Unsigned Long value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.UnsignedLongNode.AsInteger">
            <summary>
            Gets the long value of the ulong
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.UnsignedLongNode.AsDecimal">
            <summary>
            Gets the decimal value of the ulong
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.UnsignedLongNode.AsFloat">
            <summary>
            Gets the float value of the ulong
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.UnsignedLongNode.AsDouble">
            <summary>
            Gets the double value of the ulong
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Nodes.StringNode">
            <summary>
            Valued node whose value is a string or can only be converted to a string
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.StringNode.#ctor(VDS.RDF.IGraph,System.String,System.Uri)">
            <summary>
            Creates a new String Node
            </summary>
            <param name="g">Graph the Node belongs to</param>
            <param name="value">String value</param>
            <param name="datatype">Datatype URI</param>
        </member>
        <member name="M:VDS.RDF.Nodes.StringNode.#ctor(VDS.RDF.IGraph,System.String,System.String)">
            <summary>
            Creates a new String Node
            </summary>
            <param name="g">Graph the Node belongs to</param>
            <param name="value">String value</param>
            <param name="lang">Language Specifier</param>
        </member>
        <member name="M:VDS.RDF.Nodes.StringNode.#ctor(VDS.RDF.IGraph,System.String)">
            <summary>
            Creates a new String Node
            </summary>
            <param name="g">Graph the Node belongs to</param>
            <param name="value">String value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.StringNode.AsString">
            <summary>
            Gets the string value
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.StringNode.AsInteger">
            <summary>
            Throws an error as the string cannot be cast to an integer
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.StringNode.AsDecimal">
            <summary>
            Throws an error as the string cannot be cast to a decimal
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.StringNode.AsFloat">
            <summary>
            Throws an error as the string cannot be cast to a float
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.StringNode.AsDouble">
            <summary>
            Throws an error as the string cannot be cast to a double
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.StringNode.AsBoolean">
            <summary>
            Gets the boolean value of the string
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.StringNode.AsDateTime">
            <summary>
            Throws an error as the string cannot be cast to a date time
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.StringNode.AsDateTimeOffset">
            <summary>
            Throws an error as the string cannot be cast to a date time
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.StringNode.AsTimeSpan">
            <summary>
            Throws an error as the string cannot be cast to a time span
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Nodes.StringNode.EffectiveType">
            <summary>
            Gets the URI of the datatype this valued node represents as a String
            </summary>
        </member>
        <member name="P:VDS.RDF.Nodes.StringNode.NumericType">
            <summary>
            Gets the numeric type of the expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Primary.AggregateTerm">
            <summary>
            Class for representing Aggregate Expressions which have Numeric Results
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Primary.AggregateTerm.#ctor(VDS.RDF.Query.Aggregates.ISparqlAggregate)">
            <summary>
            Creates a new Aggregate Expression Term that uses the given Aggregate
            </summary>
            <param name="aggregate">Aggregate</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Primary.AggregateTerm.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Evaluates the aggregate expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Primary.AggregateTerm.ToString">
            <summary>
            Gets the String representation of the Aggregate Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Primary.AggregateTerm.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Primary.AggregateTerm.Aggregate">
            <summary>
            Gets the Aggregate this Expression represents
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Primary.AggregateTerm.Variables">
            <summary>
            Gets the enumeration of variables that are used in the the aggregate expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Primary.AggregateTerm.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Primary.AggregateTerm.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Primary.AggregateTerm.Arguments">
            <summary>
            Gets the Arguments of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Primary.AggregateTerm.CanParallelise">
            <summary>
            Gets whether the expression can be parallelised
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Primary.AllModifier">
            <summary>
            Class for representing the All Modifier
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Primary.AllModifier.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Throws a <see cref="T:System.NotImplementedException">NotImplementedException</see> since this class is a placeholder and only used in parsing
            </summary>
            <param name="context">SPARQL Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Primary.AllModifier.ToString">
            <summary>
            Gets the String representation of the Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Primary.AllModifier.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Primary.AllModifier.Variables">
            <summary>
            Returns an empty enumerable
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Primary.AllModifier.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Primary.AllModifier.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Primary.AllModifier.Arguments">
            <summary>
            Gets the Arguments of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Primary.AllModifier.CanParallelise">
            <summary>
            Gets whether an expression can safely be evaluated in parallel
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Primary.ConstantTerm">
            <summary>
            Class for representing constant terms
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.Primary.ConstantTerm._node">
            <summary>
            Node this Term represents
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Primary.ConstantTerm.#ctor(VDS.RDF.Nodes.IValuedNode)">
            <summary>
            Creates a new Constant
            </summary>
            <param name="n">Valued Node</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Primary.ConstantTerm.#ctor(VDS.RDF.INode)">
            <summary>
            Creates a new Constant
            </summary>
            <param name="n">Node</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Primary.ConstantTerm.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Primary.ConstantTerm.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Primary.ConstantTerm.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Primary.ConstantTerm.Variables">
            <summary>
            Gets an Empty Enumerable since a Node Term does not use variables
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Primary.ConstantTerm.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Primary.ConstantTerm.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Primary.ConstantTerm.Arguments">
            <summary>
            Gets the Arguments of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Primary.ConstantTerm.CanParallelise">
            <summary>
            Gets whether an expression can safely be evaluated in parallel
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Primary.ConstantTerm.Node">
            <summary>
            Node this Term represents
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Primary.DistinctModifier">
            <summary>
            Class for representing the Distinct Modifier
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Primary.DistinctModifier.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Throws a <see cref="T:System.NotImplementedException">NotImplementedException</see> since this class is a placeholder and only used in parsing
            </summary>
            <param name="context">SPARQL Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Primary.DistinctModifier.ToString">
            <summary>
            Gets the String representation of the Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Primary.DistinctModifier.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Primary.DistinctModifier.Variables">
            <summary>
            Returns an empty enumerable
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Primary.DistinctModifier.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Primary.DistinctModifier.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Primary.DistinctModifier.Arguments">
            <summary>
            Gets the Arguments of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Primary.DistinctModifier.CanParallelise">
            <summary>
            Gets whether an expression can safely be evaluated in parallel
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Primary.GraphPatternTerm">
            <summary>
            Class for representing Graph Pattern Terms (as used in EXISTS/NOT EXISTS)
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Primary.GraphPatternTerm.#ctor(VDS.RDF.Query.Patterns.GraphPattern)">
            <summary>
            Creates a new Graph Pattern Term
            </summary>
            <param name="pattern">Graph Pattern</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Primary.GraphPatternTerm.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the value of this Term as evaluated for the given Bindings in the given Context
            </summary>
            <param name="context"></param>
            <param name="bindingID"></param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Primary.GraphPatternTerm.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Primary.GraphPatternTerm.Pattern">
            <summary>
            Gets the Graph Pattern this term represents
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Primary.GraphPatternTerm.Variables">
            <summary>
            Gets the Variables used in the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Primary.GraphPatternTerm.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Primary.GraphPatternTerm.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Primary.GraphPatternTerm.Arguments">
            <summary>
            Gets the Arguments of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Primary.GraphPatternTerm.CanParallelise">
            <summary>
            Gets whether an expression can safely be evaluated in parallel
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Primary.VariableTerm">
            <summary>
            Class representing Variable value expressions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Primary.VariableTerm.#ctor(System.String)">
            <summary>
            Creates a new Variable Expression
            </summary>
            <param name="name">Variable Name</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Primary.VariableTerm.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Primary.VariableTerm.ToString">
            <summary>
            Gets the String representation of this Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Primary.VariableTerm.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Primary.VariableTerm.Variables">
            <summary>
            Gets the enumeration containing the single variable that this expression term represents
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Primary.VariableTerm.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Primary.VariableTerm.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Primary.VariableTerm.Arguments">
            <summary>
            Gets the Arguments of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Primary.VariableTerm.CanParallelise">
            <summary>
            Gets whether an expression can safely be evaluated in parallel
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Optimisation.BaseAlgebraOptimiser">
            <summary>
            Abstract Base Class for Algebra Transformers where the Transformer may care about the depth of the Algebra in the Algebra Tree
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.BaseAlgebraOptimiser.Optimise(VDS.RDF.Query.Algebra.ISparqlAlgebra)">
            <summary>
            Attempts to optimise an Algebra to another more optimal form
            </summary>
            <param name="algebra">Algebra</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.BaseAlgebraOptimiser.OptimiseInternal(VDS.RDF.Query.Algebra.ISparqlAlgebra,System.Int32)">
            <summary>
            Transforms the Algebra to another form tracking the depth in the Algebra tree
            </summary>
            <param name="algebra">Algebra</param>
            <param name="depth">Depth</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.BaseAlgebraOptimiser.IsApplicable(VDS.RDF.Query.SparqlQuery)">
            <summary>
            Determines whether the Optimiser can be applied to a given Query
            </summary>
            <param name="q">Query</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.BaseAlgebraOptimiser.IsApplicable(VDS.RDF.Update.SparqlUpdateCommandSet)">
            <summary>
            Determines whether the Optimiser can be applied to a given Update Command Set
            </summary>
            <param name="cmds">Command Set</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Optimisation.BaseQueryOptimiser">
            <summary>
            A basic abstract implementation of a Query Optimiser
            </summary>
            <remarks>
            <para>
            Derived implementations may use override the virtual properties to control what forms of optimisation are used.  Derived implementations must override the <see cref="M:VDS.RDF.Query.Optimisation.BaseQueryOptimiser.GetRankingComparer">GetRankingComparer()</see> method, optimisers which do not wish to change the order of Triple Patterns should return the <see cref="T:VDS.RDF.Query.Optimisation.NoReorderComparer">NoReorderCompaper</see> in their implementation as a basic sort of Triple Patterns is done even if <see cref="P:VDS.RDF.Query.Optimisation.BaseQueryOptimiser.ShouldReorder">ShouldReorder</see> is overridden to return false
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.Optimisation.IQueryOptimiser">
            <summary>
            A Query Optimiser is a class which optimises Graph Patterns in a Query by reordering Graph Patterns
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.IQueryOptimiser.Optimise(VDS.RDF.Query.Patterns.GraphPattern,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Attempts to optimise the given Graph Pattern
            </summary>
            <param name="gp">Graph Pattern</param>
            <param name="vars">Variables that are present prior to the pattern</param>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.BaseQueryOptimiser.Optimise(VDS.RDF.Query.Patterns.GraphPattern,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Causes the Graph Pattern to be optimised if it isn't already
            </summary>
            <param name="gp">Graph Pattern</param>
            <param name="variables">Variables that have occurred prior to this Pattern</param>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.BaseQueryOptimiser.GetRankingComparer">
            <summary>
            Gets a comparer on Triple Patterns that is used to rank Triple Patterns
            </summary>
            <returns></returns>
            <remarks>
            By overriding this in derived classes you can change how the Optimiser weights different patterns and thus the resultant ordering of Triple Patterns
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.BaseQueryOptimiser.TryReorderPatterns(VDS.RDF.Query.Patterns.GraphPattern,System.Collections.Generic.List{System.String},System.Int32,System.Int32)">
            <summary>
            Tries to reorder patterns when the initial ordering is considered poor
            </summary>
            <param name="gp">Graph Pattern</param>
            <param name="desiredVariables">Variables that are desired</param>
            <param name="start">Point at which to start looking for better matches</param>
            <param name="end">Point at which to move the better match to</param>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.BaseQueryOptimiser.TryPlaceFilter(VDS.RDF.Query.Patterns.GraphPattern,VDS.RDF.Query.Filters.ISparqlFilter)">
            <summary>
            Tries to place filters at the earliest point possible i.e. the first point after which all required variables have occurred
            </summary>
            <param name="gp">Graph Pattern</param>
            <param name="filter">Filter to place</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.BaseQueryOptimiser.TryPlaceAssignment(VDS.RDF.Query.Patterns.GraphPattern,VDS.RDF.Query.Patterns.IAssignmentPattern)">
            <summary>
            Tries to place assignments at the earliest point possible i.e. the first point after which all required variables have occurred
            </summary>
            <param name="gp">Graph Pattern</param>
            <param name="assignment">Assignment (LET/BIND)</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Optimisation.BaseQueryOptimiser.ShouldReorder">
            <summary>
            Controls whether the Optimiser will attempt to reorder Triple Patterns
            </summary>
            <remarks>
            It is recommended that derived classes do not change this setting as this may hurt performance.  If you want to control the optimisation process in detail we suggest you implement <see cref="T:VDS.RDF.Query.Optimisation.IQueryOptimiser">IQueryOptimiser</see> directly in your own class and not derive from this implementation.
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.Optimisation.BaseQueryOptimiser.ShouldSplitFilters">
            <summary>
            Controls whether the Optimiser will split Filters
            </summary>
            <remarks>
            <para>
            If a Filter contains an and expression it may be split into its constituent parts and applied separately.  This option only applies if filter placement also applies.
            </para>
            <para>
            Defaults to false since it is unclear if this actually benefits performance
            </para>
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.Optimisation.BaseQueryOptimiser.ShouldPlaceFilters">
            <summary>
            Controls whether the Optimiser will place Filters
            </summary>
            <remarks>
            It is recommended that derived classes do not change this setting as this may hurt performance.  If you want to control the optimisation process in detail we suggest you implement <see cref="T:VDS.RDF.Query.Optimisation.IQueryOptimiser">IQueryOptimiser</see> directly in your own class and not derive from this implementation.
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.Optimisation.BaseQueryOptimiser.ShouldPlaceAssignments">
            <summary>
            Controls whether the Optimiser will place Assignments
            </summary>
            <remarks>
            It is recommended that derived classes do not change this setting as this may hurt performance.  If you want to control the optimisation process in detail we suggest you implement <see cref="T:VDS.RDF.Query.Optimisation.IQueryOptimiser">IQueryOptimiser</see> directly in your own class and not derive from this implementation.
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.Optimisation.LazyBgpOptimiser">
            <summary>
            An Algebra Optimiser that optimises Algebra to use <see cref="T:VDS.RDF.Query.Algebra.LazyBgp">LazyBgp</see>'s wherever possible
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.LazyBgpOptimiser.OptimiseInternal(VDS.RDF.Query.Algebra.ISparqlAlgebra,System.Int32)">
            <summary>
            Optimises an Algebra to a form that uses <see cref="T:VDS.RDF.Query.Algebra.LazyBgp">LazyBgp</see> where possible
            </summary>
            <param name="algebra">Algebra</param>
            <param name="depth">Depth</param>
            <returns></returns>
            <remarks>
            <para>
            By transforming a query to use <see cref="T:VDS.RDF.Query.Algebra.LazyBgp">LazyBgp</see> we can achieve much more efficient processing of some forms of queries
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.LazyBgpOptimiser.IsApplicable(VDS.RDF.Query.SparqlQuery)">
            <summary>
            Determines whether the query can be optimised for lazy evaluation
            </summary>
            <param name="q">Query</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.LazyBgpOptimiser.IsApplicable(VDS.RDF.Update.SparqlUpdateCommandSet)">
            <summary>
            Returns that the optimiser does not apply to SPARQL Updates
            </summary>
            <param name="cmds">Updates</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Optimisation.AskBgpOptimiser">
            <summary>
            An Algebra Optimiser that optimises Algebra to use <see cref="T:VDS.RDF.Query.Algebra.AskBgp">AskBgp</see>'s wherever possible
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.AskBgpOptimiser.OptimiseInternal(VDS.RDF.Query.Algebra.ISparqlAlgebra,System.Int32)">
            <summary>
            Optimises an Algebra to a form that uses <see cref="T:VDS.RDF.Query.Algebra.AskBgp">AskBgp</see> where possible
            </summary>
            <param name="algebra">Algebra</param>
            <param name="depth">Depth</param>
            <returns></returns>
            <remarks>
            <para>
            By transforming a query to use <see cref="T:VDS.RDF.Query.Algebra.AskBgp">AskBgp</see> we can achieve much more efficient processing of some forms of queries
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.AskBgpOptimiser.IsApplicable(VDS.RDF.Query.SparqlQuery)">
            <summary>
            Determines whether the query can be optimised for ASK evaluation
            </summary>
            <param name="q">Query</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.AskBgpOptimiser.IsApplicable(VDS.RDF.Update.SparqlUpdateCommandSet)">
            <summary>
            Returns that the optimiser does not apply to SPARQL Updates
            </summary>
            <param name="cmds">Updates</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.Minus">
            <summary>
            Represents the Minus join
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Minus.#ctor(VDS.RDF.Query.Algebra.ISparqlAlgebra,VDS.RDF.Query.Algebra.ISparqlAlgebra)">
            <summary>
            Creates a new Minus join
            </summary>
            <param name="lhs">LHS Pattern</param>
            <param name="rhs">RHS Pattern</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Minus.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates the Minus join by evaluating the LHS and RHS and substracting the RHS results from the LHS
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Minus.ToString">
            <summary>
            Gets the string representation of the Algebra
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Minus.ToQuery">
            <summary>
            Converts the Algebra back to a SPARQL Query
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Minus.ToGraphPattern">
            <summary>
            Converts the Minus() back to a MINUS Graph Pattern
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Minus.Transform(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Transforms both sides of the Join using the given Optimiser
            </summary>
            <param name="optimiser">Optimser</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Minus.TransformLhs(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Transforms the LHS of the Join using the given Optimiser
            </summary>
            <param name="optimiser">Optimser</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Minus.TransformRhs(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Transforms the RHS of the Join using the given Optimiser
            </summary>
            <param name="optimiser">Optimser</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Minus.Variables">
            <summary>
            Gets the Variables used in the Algebra
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Minus.FloatingVariables">
            <summary>
            Gets the enumeration of floating variables in the algebra i.e. variables that are not guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Minus.FixedVariables">
            <summary>
            Gets the enumeration of fixed variables in the algebra i.e. variables that are guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Minus.Lhs">
            <summary>
            Gets the LHS of the Join
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Minus.Rhs">
            <summary>
            Gets the RHS of the Join
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.NullMultiset">
            <summary>
            Represents a Multiset when there are no possible Solutions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.NullMultiset.Join(VDS.RDF.Query.Algebra.BaseMultiset)">
            <summary>
            Joins another Multiset to this Null Mutliset
            </summary>
            <param name="other">Other Multiset</param>
            <returns>
            Results in this Null Multiset since Null joined to anything is Null
            </returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.NullMultiset.LeftJoin(VDS.RDF.Query.Algebra.BaseMultiset,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Left Joins another Multiset to this Null Mutliset
            </summary>
            <param name="other">Other Multiset</param>
            <param name="expr">Expression the join is predicate upon</param>
            <returns>
            Results in this Null Multiset since Null joined to anything is Null
            </returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.NullMultiset.ExistsJoin(VDS.RDF.Query.Algebra.BaseMultiset,System.Boolean)">
            <summary>
            Exists Joins another Multiset to this Null Mutliset
            </summary>
            <param name="other">Other Multiset</param>
            <param name="mustExist">Whether joinable solutions must exist in the other Multiset for joins to be made</param>
            <returns>
            Results in this Null Multiset since Null joined to anything is Null
            </returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.NullMultiset.MinusJoin(VDS.RDF.Query.Algebra.BaseMultiset)">
            <summary>
            Minus Joins this Multiset to another Multiset
            </summary>
            <param name="other">Other Multiset</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.NullMultiset.Product(VDS.RDF.Query.Algebra.BaseMultiset)">
            <summary>
            Computes the Product of this Multiset and another Multiset
            </summary>
            <param name="other">Other Multiset</param>
            <returns>
            Results in the Other Multiset since for Product we consider this Multiset to contain a single empty Set
            </returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.NullMultiset.Union(VDS.RDF.Query.Algebra.BaseMultiset)">
            <summary>
            Unions this Multiset with another Multiset
            </summary>
            <param name="other">Other Multiset</param>
            <returns>
            Results in the Other Multiset as this is an empty Multiset
            </returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.NullMultiset.ContainsValue(System.String,VDS.RDF.INode)">
            <summary>
            Returns false since the Null Multiset contains no values
            </summary>
            <param name="var">Variable</param>
            <param name="n">Value</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.NullMultiset.ContainsVariable(System.String)">
            <summary>
            Returns false since the Null Multiset contains no variables
            </summary>
            <param name="var">Variable</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.NullMultiset.IsDisjointWith(VDS.RDF.Query.Algebra.BaseMultiset)">
            <summary>
            Returns true since the Null Multiset is disjoint with all Multisets
            </summary>
            <param name="other">Other Multiset</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.NullMultiset.Add(VDS.RDF.Query.Algebra.ISet)">
            <summary>
            Adds a Set to this Multiset
            </summary>
            <param name="s">Set</param>
            <exception cref="T:VDS.RDF.Query.RdfQueryException">Thrown since the operation is invalid on a Null Multiset</exception>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.NullMultiset.AddVariable(System.String)">
            <summary>
            Adds a Variable to this Multiset
            </summary>
            <param name="variable">Variable</param>
            <exception cref="T:VDS.RDF.Query.RdfQueryException">Thrown since the operation is invalid on a Null Multiset</exception>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.NullMultiset.SetVariableOrder(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Sets the variable ordering for the multiset
            </summary>
            <param name="variables">Variable Ordering</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.NullMultiset.Remove(System.Int32)">
            <summary>
            Removes a Set from a Multiset
            </summary>
            <param name="id">Set ID</param>
            <exception cref="T:VDS.RDF.Query.RdfQueryException">Thrown since the operation is invalid on a Null Multiset</exception>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.NullMultiset.IsEmpty">
            <summary>
            Returns true since the Null Multiset is always empty
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.NullMultiset.Variables">
            <summary>
            Returns an empty enumerable as the Null Multiset contains no Variables
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.NullMultiset.Sets">
            <summary>
            Returns an empty enumerable as the Null Multiset contains no Sets
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.NullMultiset.SetIDs">
            <summary>
            Returns an empty enumerable as the Null Multiset contains no Sets
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.NullMultiset.Item(System.Int32)">
            <summary>
            Gets the Set with the given ID
            </summary>
            <param name="index">Set ID</param>
            <returns></returns>
            <exception cref="T:VDS.RDF.Query.RdfQueryException">Thrown since the Null Multiset contains no Sets</exception>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.OrderBy">
            <summary>
            Represents an Order By clause
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.OrderBy.#ctor(VDS.RDF.Query.Algebra.ISparqlAlgebra,VDS.RDF.Query.Ordering.ISparqlOrderBy)">
            <summary>
            Creates a new Order By clause
            </summary>
            <param name="pattern">Pattern</param>
            <param name="ordering">Ordering</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.OrderBy.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates the Order By clause
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.OrderBy.ToString">
            <summary>
            Gets the String representation of the Algebra
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.OrderBy.ToQuery">
            <summary>
            Converts the Algebra back to a SPARQL Query
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.OrderBy.ToGraphPattern">
            <summary>
            Throws an error since an OrderBy() cannot be converted back to a Graph Pattern
            </summary>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">Thrown since an OrderBy() cannot be converted back to a Graph Pattern</exception>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.OrderBy.Transform(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Transforms the Inner Algebra using the given Optimiser
            </summary>
            <param name="optimiser">Optimiser</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.OrderBy.Variables">
            <summary>
            Gets the Variables used in the Algebra
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.OrderBy.FloatingVariables">
            <summary>
            Gets the enumeration of floating variables in the algebra i.e. variables that are not guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.OrderBy.FixedVariables">
            <summary>
            Gets the enumeration of fixed variables in the algebra i.e. variables that are guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.OrderBy.InnerAlgebra">
            <summary>
            Gets the Inner Algebra
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.OrderBy.Ordering">
            <summary>
            Gets the Ordering that is used
            </summary>
            <remarks>
            If the Query supplied in the <see cref="T:VDS.RDF.Query.SparqlEvaluationContext">SparqlEvaluationContext</see> is non-null and has an ORDER BY clause then that is applied rather than the ordering with which the OrderBy algebra is instantiated
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.Select">
            <summary>
            Represents the Selection step of Query Evaluation
            </summary>
            <remarks>
            Selection trims variables from the Multiset that are not needed in the final output.  This is separate from <see cref="!:Project">Project</see> so that all Variables are available for Ordering and Having clauses
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Select.#ctor(VDS.RDF.Query.Algebra.ISparqlAlgebra,System.Boolean,System.Collections.Generic.IEnumerable{VDS.RDF.Query.SparqlVariable})">
            <summary>
            Creates a new Select
            </summary>
            <param name="pattern">Inner Pattern</param>
            <param name="selectAll">Whether we are selecting all variables</param>
            <param name="variables">Variables to Select</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Select.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Trims the Results of evaluating the inner pattern to remove Variables which are not Result Variables
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Select.ToString">
            <summary>
            Gets the String representation of the Algebra
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Select.ToQuery">
            <summary>
            Converts the Algebra back to a SPARQL Query
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Select.ToGraphPattern">
            <summary>
            Throws an error as a Select() cannot be converted back to a Graph Pattern
            </summary>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">Thrown since a Select() cannot be converted back to a Graph Pattern</exception>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Select.Transform(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Transforms the Inner Algebra using the given Optimiser
            </summary>
            <param name="optimiser">Optimiser</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Select.IsSelectAll">
            <summary>
            Does this operator select all variables?
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Select.InnerAlgebra">
            <summary>
            Gets the Inner Algebra
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Select.Variables">
            <summary>
            Gets the Variables used in the Algebra
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Select.FloatingVariables">
            <summary>
            Gets the enumeration of floating variables in the algebra i.e. variables that are not guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Select.FixedVariables">
            <summary>
            Gets the enumeration of fixed variables in the algebra i.e. variables that are guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Select.SparqlVariables">
            <summary>
            Gets the SPARQL Variables used
            </summary>
            <remarks>
            If the Query supplied in the <see cref="T:VDS.RDF.Query.SparqlEvaluationContext">SparqlEvaluationContext</see> is non-null then it's Variables are used rather than these
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.Ask">
            <summary>
            Represents the Ask step of Query Evaluation
            </summary>
            <remarks>
            Used only for ASK queries.  Turns the final Multiset into either an <see cref="T:VDS.RDF.Query.Algebra.IdentityMultiset">IdentityMultiset</see> if the ASK succeeds or a <see cref="T:VDS.RDF.Query.Algebra.NullMultiset">NullMultiset</see> if the ASK fails
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Ask.#ctor(VDS.RDF.Query.Algebra.ISparqlAlgebra)">
            <summary>
            Creates a new ASK
            </summary>
            <param name="pattern">Inner Pattern</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Ask.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates the ASK by turning the Results of evaluating the Inner Pattern to either an Identity/Null Multiset depending on whether there were any Results
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Ask.ToString">
            <summary>
            Gets the String representation of the Ask
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Ask.ToQuery">
            <summary>
            Converts the Algebra back to a SPARQL Query
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Ask.ToGraphPattern">
            <summary>
            Throws an exception since an Ask() cannot be converted to a Graph Pattern
            </summary>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">Thrown since an Ask() cannot be converted to a Graph Pattern</exception>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Ask.Transform(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Transforms the Inner Algebra using the given Optimiser
            </summary>
            <param name="optimiser">Optimiser</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Ask.InnerAlgebra">
            <summary>
            Gets the Inner Algebra
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Ask.Variables">
            <summary>
            Gets the Variables used in the Algebra
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Ask.FloatingVariables">
            <summary>
            Gets the enumeration of floating variables in the algebra i.e. variables that are not guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Ask.FixedVariables">
            <summary>
            Gets the enumeration of fixed variables in the algebra i.e. variables that are guaranteed to have a bound value
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.Service">
            <summary>
            Represents a Service Clause
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Service.#ctor(VDS.RDF.Parsing.Tokens.IToken,VDS.RDF.Query.Patterns.GraphPattern,System.Boolean)">
            <summary>
            Creates a new Service clause with the given Endpoint Specifier and Graph Pattern
            </summary>
            <param name="endpointSpecifier">Endpoint Specifier</param>
            <param name="pattern">Graph Pattern</param>
            <param name="silent">Whether Evaluation Errors are suppressed</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Service.#ctor(VDS.RDF.Parsing.Tokens.IToken,VDS.RDF.Query.Patterns.GraphPattern)">
            <summary>
            Creates a new Service clause with the given Endpoint Specifier and Graph Pattern
            </summary>
            <param name="endpointSpecifier">Endpoint Specifier</param>
            <param name="pattern">Graph Pattern</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Service.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates the Service Clause by generating instance(s) of <see cref="T:VDS.RDF.Query.SparqlRemoteEndpoint">SparqlRemoteEndpoint</see> as required and issuing the query to the remote endpoint(s)
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Service.ToString">
            <summary>
            Gets the String representation of the Algebra
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Service.ToQuery">
            <summary>
            Converts the Algebra back to a SPARQL Query
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Service.ToGraphPattern">
            <summary>
            Converts the Algebra into a Graph Pattern
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Service.Variables">
            <summary>
            Gets the Variables used in the Algebra
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Service.FloatingVariables">
            <summary>
            Gets the enumeration of floating variables in the algebra i.e. variables that are not guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Service.FixedVariables">
            <summary>
            Gets the enumeration of fixed variables in the algebra i.e. variables that are guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Service.EndpointSpecifier">
            <summary>
            Gets the Endpoint Specifier
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Service.Pattern">
            <summary>
            Gets the Graph Pattern
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.Set">
            <summary>
            Represents one possible set of values which is a solution to the query
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Set.#ctor">
            <summary>
            Creates a new Set
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Set.#ctor(VDS.RDF.Query.Algebra.ISet,VDS.RDF.Query.Algebra.ISet)">
            <summary>
            Creates a new Set which is the Join of the two Sets
            </summary>
            <param name="x">A Set</param>
            <param name="y">A Set</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Set.#ctor(VDS.RDF.Query.Algebra.ISet)">
            <summary>
            Creates a new Set which is a copy of an existing Set
            </summary>
            <param name="x">Set to copy</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Set.#ctor(VDS.RDF.Query.SparqlResult)">
            <summary>
            Creates a new Set from a SPARQL Result
            </summary>
            <param name="result">Result</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Set.#ctor(VDS.RDF.Query.Patterns.BindingTuple)">
            <summary>
            Creates a new Set from a Binding Tuple
            </summary>
            <param name="tuple">Tuple</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Set.Add(System.String,VDS.RDF.INode)">
            <summary>
            Adds a Value for a Variable to the Set
            </summary>
            <param name="variable">Variable</param>
            <param name="value">Value</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Set.Remove(System.String)">
            <summary>
            Removes a Value for a Variable from the Set
            </summary>
            <param name="variable">Variable</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Set.ContainsVariable(System.String)">
            <summary>
            Checks whether the Set contains a given Variable
            </summary>
            <param name="variable">Variable</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Set.IsCompatibleWith(VDS.RDF.Query.Algebra.ISet,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Gets whether the Set is compatible with a given set based on the given variables
            </summary>
            <param name="s">Set</param>
            <param name="vars">Variables</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Set.IsMinusCompatibleWith(VDS.RDF.Query.Algebra.ISet,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Gets whether the Set is minus compatible with a given set based on the given variables
            </summary>
            <param name="s">Set</param>
            <param name="vars">Variables</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Set.Join(VDS.RDF.Query.Algebra.ISet)">
            <summary>
            Joins the set to another set
            </summary>
            <param name="other">Other Set</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Set.Copy">
            <summary>
            Copies the Set
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Set.Equals(VDS.RDF.Query.Algebra.Set)">
            <summary>
            Gets whether the Set is equal to another set
            </summary>
            <param name="other">Set to compare with</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Set.Item(System.String)">
            <summary>
            Retrieves the Value in this set for the given Variable
            </summary>
            <param name="variable">Variable</param>
            <returns>Either a Node or a null</returns>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Set.Variables">
            <summary>
            Gets the Variables in the Set
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Set.Values">
            <summary>
            Gets the Values in the Set
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.Slice">
            <summary>
            Represents the Slice Operation in the SPARQL Algebra
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Slice.#ctor(VDS.RDF.Query.Algebra.ISparqlAlgebra)">
            <summary>
            Creates a new Slice modifier which will detect LIMIT and OFFSET from the query
            </summary>
            <param name="pattern">Pattern</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Slice.#ctor(VDS.RDF.Query.Algebra.ISparqlAlgebra,System.Int32,System.Int32)">
            <summary>
            Creates a new Slice modifier which uses a specific LIMIT and OFFSET
            </summary>
            <param name="pattern">Pattern</param>
            <param name="limit">Limit</param>
            <param name="offset">Offset</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Slice.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates the Slice by applying the appropriate LIMIT and OFFSET to the Results
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Slice.ToString">
            <summary>
            Gets the String representation of the Algebra
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Slice.ToQuery">
            <summary>
            Converts the Algebra back to a SPARQL Query
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Slice.ToGraphPattern">
            <summary>
            Throws an exception since a Slice() cannot be converted back to a Graph Pattern
            </summary>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">Thrown since a Slice() cannot be converted to a Graph Pattern</exception>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.Slice.Transform(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Transforms the Inner Algebra using the given Optimiser
            </summary>
            <param name="optimiser">Optimiser</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Slice.Variables">
            <summary>
            Gets the Variables used in the Algebra
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Slice.FloatingVariables">
            <summary>
            Gets the enumeration of floating variables in the algebra i.e. variables that are not guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Slice.FixedVariables">
            <summary>
            Gets the enumeration of fixed variables in the algebra i.e. variables that are guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Slice.Limit">
            <summary>
            Gets the Limit in use (-1 indicates no Limit)
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Slice.Offset">
            <summary>
            Gets the Offset in use (0 indicates no Offset)
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Slice.DetectFromQuery">
            <summary>
            Gets whether the Algebra will detect the Limit and Offset to use from the provided query
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.Slice.InnerAlgebra">
            <summary>
            Gets the Inner Algebra
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.SelectDistinctGraphs">
            <summary>
            Special Algebra Construct for optimising queries of the form SELECT DISTINCT ?g WHERE {GRAPH ?g {?s ?p ?o}}
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.SelectDistinctGraphs.#ctor(System.String)">
            <summary>
            Creates a new Select Distinct algebra
            </summary>
            <param name="graphVar">Graph Variable to bind Graph URIs to</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.SelectDistinctGraphs.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates the Select Distinct Graphs optimisation
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.SelectDistinctGraphs.ToString">
            <summary>
            Gets the String representation of the Algebra
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.SelectDistinctGraphs.ToQuery">
            <summary>
            Converts the Algebra back to a SPARQL Query
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.SelectDistinctGraphs.ToGraphPattern">
            <summary>
            Converts the Algebra to a Graph Pattern
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.SelectDistinctGraphs.Variables">
            <summary>
            Gets the Variables used in the Algebra
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.SelectDistinctGraphs.FloatingVariables">
            <summary>
            Gets the enumeration of floating variables in the algebra i.e. variables that are not guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.SelectDistinctGraphs.FixedVariables">
            <summary>
            Gets the enumeration of fixed variables in the algebra i.e. variables that are guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.SelectDistinctGraphs.GraphVariable">
            <summary>
            Gets the Graph Variable to which Graph URIs are bound
            </summary>
            <remarks>
            If the Query supplied in the <see cref="T:VDS.RDF.Query.SparqlEvaluationContext">SparqlEvaluationContext</see> is non-null then the Variable Name from the Query is used rather than this
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.AskAnyTriples">
            <summary>
            Special Algebra Construct for optimising queries of the form ASK WHERE {?s ?p ?o}
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.AskAnyTriples.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evalutes the Ask Any Triples optimisation
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.AskAnyTriples.ToString">
            <summary>
            Gets the String representation of the Algebra
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.AskAnyTriples.ToQuery">
            <summary>
            Converts the Algebra back to a SPARQL Query
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.AskAnyTriples.ToGraphPattern">
            <summary>
            Converts the Algebra to a Graph Pattern
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.AskAnyTriples.Variables">
            <summary>
            Gets the Variables used in the Algebra
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.AskAnyTriples.FloatingVariables">
            <summary>
            Gets the enumeration of floating variables in the algebra i.e. variables that are not guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Algebra.AskAnyTriples.FixedVariables">
            <summary>
            Gets the enumeration of fixed variables in the algebra i.e. variables that are guaranteed to have a bound value
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Construct.ConstructContext">
            <summary>
            Context used for Constructing Triples in SPARQL Query/Update
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Construct.ConstructContext.#ctor(VDS.RDF.IGraph,VDS.RDF.Query.Algebra.ISet,System.Boolean)">
            <summary>
            Creates a new Construct Context
            </summary>
            <param name="g">Graph to construct Triples in</param>
            <param name="s">Set to construct from</param>
            <param name="preserveBNodes">Whether Blank Nodes bound to variables should be preserved as-is</param>
            <remarks>
            <para>
            Either the <paramref name="s">Set</paramref>  or <paramref name="g">Graph</paramref> parameters may be null if required
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Construct.ConstructContext.#ctor(VDS.RDF.INodeFactory,VDS.RDF.Query.Algebra.ISet,System.Boolean)">
            <summary>
            Creates a new Construct Context
            </summary>
            <param name="factory">Factory to create nodes with</param>
            <param name="s">Set to construct from</param>
            <param name="preserveBNodes">Whether Blank Nodes bound to variables should be preserved as-is</param>
            <remarks>
            <para>
            Either the <paramref name="s">Set</paramref>  or <paramref name="factory">Factory</paramref> parameters may be null if required
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Construct.ConstructContext.GetBlankNode(System.String)">
            <summary>
            Creates a new Blank Node for this Context
            </summary>
            <param name="id">ID</param>
            <returns></returns>
            <remarks>
            <para>
            If the same Blank Node ID is used multiple times in this Context you will always get the same Blank Node for that ID
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Construct.ConstructContext.GetNode(VDS.RDF.INode)">
            <summary>
            Creates a Node for the Context
            </summary>
            <param name="n">Node</param>
            <returns></returns>
            <remarks>
            <para>
            In effect all this does is ensure that all Nodes end up in the same Graph which may occassionally not happen otherwise when Graph wrappers are involved
            </para>
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.Construct.ConstructContext.Set">
            <summary>
            Gets the Set that this Context pertains to
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Construct.ConstructContext.Graph">
            <summary>
            Gets the Graph that Triples should be constructed in
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Construct.ConstructContext.PreserveBlankNodes">
            <summary>
            Gets whether Blank Nodes bound to variables should be preserved
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Datasets.BaseDataset">
            <summary>
            Abstract Base Class for Datasets which provides implementation of Active and Default Graph management
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Datasets.BaseDataset._activeGraph">
            <summary>
            Reference to the Active Graph being used for executing a SPARQL Query
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Datasets.BaseDataset._defaultGraph">
            <summary>
            Default Graph for executing SPARQL Queries against
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Datasets.BaseDataset._defaultGraphs">
            <summary>
            Stack of Default Graph References used for executing a SPARQL Query when a Query may choose to change the Default Graph from the Dataset defined one
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Datasets.BaseDataset._activeGraphs">
            <summary>
            Stack of Active Graph References used for executing a SPARQL Query when there are nested GRAPH Clauses
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseDataset.#ctor">
            <summary>
            Creates a new Dataset
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseDataset.#ctor(System.Boolean)">
            <summary>
            Creates a new Dataset with the given Union Default Graph setting
            </summary>
            <param name="unionDefaultGraph">Whether to use a Union Default Graph</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseDataset.#ctor(System.Uri)">
            <summary>
            Creates a new Dataset with a fixed Default Graph and without a Union Default Graph
            </summary>
            <param name="defaultGraphUri"></param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseDataset.SetDefaultGraphInternal(VDS.RDF.IGraph)">
            <summary>
            Sets the Default Graph for the SPARQL Query
            </summary>
            <param name="g"></param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseDataset.SetDefaultGraph(System.Uri)">
            <summary>
            Sets the Default Graph
            </summary>
            <param name="graphUri">Graph URI</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseDataset.SetDefaultGraph(System.Collections.Generic.IEnumerable{System.Uri})">
            <summary>
            Sets the Default Graph
            </summary>
            <param name="graphUris">Graph URIs</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseDataset.SetActiveGraphInternal(VDS.RDF.IGraph)">
            <summary>
            Sets the Active Graph for the SPARQL Query
            </summary>
            <param name="g">Active Graph</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseDataset.SetActiveGraph(System.Uri)">
            <summary>
            Sets the Active Graph for the SPARQL query
            </summary>
            <param name="graphUri">Uri of the Active Graph</param>
            <remarks>
            Helper function used primarily in the execution of GRAPH Clauses
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseDataset.SetActiveGraph(System.Collections.Generic.IEnumerable{System.Uri})">
            <summary>
            Sets the Active Graph for the SPARQL query
            </summary>
            <param name="graphUris">URIs of the Graphs which form the Active Graph</param>
            <remarks>Helper function used primarily in the execution of GRAPH Clauses</remarks>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseDataset.ResetActiveGraph">
            <summary>
            Sets the Active Graph for the SPARQL query to be the previous Active Graph
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseDataset.ResetDefaultGraph">
            <summary>
            Sets the Default Graph for the SPARQL Query to be the previous Default Graph
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseDataset.AddGraph(VDS.RDF.IGraph)">
            <summary>
            Adds a Graph to the Dataset
            </summary>
            <param name="g">Graph</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseDataset.RemoveGraph(System.Uri)">
            <summary>
            Removes a Graph from the Dataset
            </summary>
            <param name="graphUri">Graph URI</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseDataset.RemoveGraphInternal(System.Uri)">
            <summary>
            Removes a Graph from the Dataset
            </summary>
            <param name="graphUri">Graph URI</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseDataset.HasGraph(System.Uri)">
            <summary>
            Gets whether a Graph with the given URI is the Dataset
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseDataset.HasGraphInternal(System.Uri)">
            <summary>
            Determines whether a given Graph exists in the Dataset
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseDataset.GetGraphInternal(System.Uri)">
            <summary>
            Gets the given Graph from the Dataset
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseDataset.GetModifiableGraph(System.Uri)">
            <summary>
            Gets the Graph with the given URI from the Dataset
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
            <remarks>
            <para>
            Graphs returned from this method must be modifiable and the Dataset must guarantee that when it is Flushed or Disposed of that any changes to the Graph are persisted
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseDataset.ContainsTriple(VDS.RDF.Triple)">
            <summary>
            Gets whether the Dataset contains a specific Triple
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseDataset.ContainsTripleInternal(VDS.RDF.Triple)">
            <summary>
            Determines whether the Dataset contains a specific Triple
            </summary>
            <param name="t">Triple to search for</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseDataset.GetAllTriples">
            <summary>
            Abstract method that concrete implementations must implement to return an enumerable of all the Triples in the Dataset
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseDataset.GetTriplesWithSubject(VDS.RDF.INode)">
            <summary>
            Gets all the Triples in the Dataset with the given Subject
            </summary>
            <param name="subj">Subject</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseDataset.GetTriplesWithSubjectInternal(VDS.RDF.INode)">
            <summary>
            Gets all the Triples in the Dataset with the given Subject
            </summary>
            <param name="subj">Subject</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseDataset.GetTriplesWithPredicate(VDS.RDF.INode)">
            <summary>
            Gets all the Triples in the Dataset with the given Predicate
            </summary>
            <param name="pred">Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseDataset.GetTriplesWithPredicateInternal(VDS.RDF.INode)">
            <summary>
            Gets all the Triples in the Dataset with the given Predicate
            </summary>
            <param name="pred">Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseDataset.GetTriplesWithObject(VDS.RDF.INode)">
            <summary>
            Gets all the Triples in the Dataset with the given Object
            </summary>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseDataset.GetTriplesWithObjectInternal(VDS.RDF.INode)">
            <summary>
            Gets all the Triples in the Dataset with the given Object
            </summary>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseDataset.GetTriplesWithSubjectPredicate(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets all the Triples in the Dataset with the given Subject and Predicate
            </summary>
            <param name="subj">Subject</param>
            <param name="pred">Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseDataset.GetTriplesWithSubjectPredicateInternal(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets all the Triples in the Dataset with the given Subject and Predicate
            </summary>
            <param name="subj">Subject</param>
            <param name="pred">Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseDataset.GetTriplesWithSubjectObject(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets all the Triples in the Dataset with the given Subject and Object
            </summary>
            <param name="subj">Subject</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseDataset.GetTriplesWithSubjectObjectInternal(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets all the Triples in the Dataset with the given Subject and Object
            </summary>
            <param name="subj">Subject</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseDataset.GetTriplesWithPredicateObject(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets all the Triples in the Dataset with the given Predicate and Object
            </summary>
            <param name="pred">Predicate</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseDataset.GetTriplesWithPredicateObjectInternal(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets all the Triples in the Dataset with the given Predicate and Object
            </summary>
            <param name="pred">Predicate</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseDataset.Flush">
            <summary>
            Ensures that any changes to the Dataset (if any) are flushed to the underlying Storage
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseDataset.Discard">
            <summary>
            Ensures that any changes to the Dataset (if any) are discarded
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Datasets.BaseDataset.InternalDefaultGraph">
            <summary>
            Gets a reference to the actual <see cref="T:VDS.RDF.IGraph">IGraph</see> that is currently treated as the default graph
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Datasets.BaseDataset.DefaultGraphUris">
            <summary>
            Gets the Default Graph URIs
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Datasets.BaseDataset.ActiveGraphUris">
            <summary>
            Gets the Active Graph URIs
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Datasets.BaseDataset.UsesUnionDefaultGraph">
            <summary>
            Gets whether the Default Graph is treated as being the union of all Graphs in the dataset when no Default Graph is otherwise set
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Datasets.BaseDataset.Graphs">
            <summary>
            Gets all the Graphs in the Dataset
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Datasets.BaseDataset.GraphUris">
            <summary>
            Gets all the URIs of Graphs in the Dataset
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Datasets.BaseDataset.Item(System.Uri)">
            <summary>
            Gets the Graph with the given URI from the Dataset
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
            <remarks>
            <para>
            This property need only return a read-only view of the Graph, code which wishes to modify Graphs should use the <see cref="M:VDS.RDF.Query.Datasets.ISparqlDataset.GetModifiableGraph(System.Uri)">GetModifiableGraph()</see> method to guarantee a Graph they can modify and will be persisted to the underlying storage
            </para>
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.Datasets.BaseDataset.HasTriples">
            <summary>
            Gets whether the Dataset has any Triples
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Datasets.BaseDataset.Triples">
            <summary>
            Gets all the Triples in the Dataset
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Datasets.BaseImmutableDataset">
            <summary>
            Abstract Base Class for Immutable Datasets
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseImmutableDataset.AddGraph(VDS.RDF.IGraph)">
            <summary>
            Throws an exception since Immutable Datasets cannot be altered
            </summary>
            <param name="g">Graph to add</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseImmutableDataset.RemoveGraph(System.Uri)">
            <summary>
            Throws an exception since Immutable Datasets cannot be altered
            </summary>
            <param name="graphUri">Graph URI</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseImmutableDataset.GetModifiableGraph(System.Uri)">
            <summary>
            Throws an exception since Immutable Datasets cannot be altered
            </summary>
            <param name="graphUri">Graph URI</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseImmutableDataset.Flush">
            <summary>
            Ensures that any changes to the Dataset (if any) are flushed to the underlying Storage
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseImmutableDataset.Discard">
            <summary>
            Ensures that any changes to the Dataset (if any) are discarded
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Datasets.BaseTransactionalDataset">
            <summary>
            Abstract Base Class for Mutable Datasets that support Transactions
            </summary>
            <remarks>
            <para>
            The Transaction implementation of dotNetRDF is based upon a MRSW concurrency model, since only one writer may be active changes are immediately pushed to the dataset and visible within the transaction and they are committed or rolled back when <see cref="M:VDS.RDF.Query.Datasets.BaseTransactionalDataset.Flush">Flush()</see> or <see cref="M:VDS.RDF.Query.Datasets.BaseTransactionalDataset.Discard">Discard()</see> are called.
            </para>
            <para>
            So in practical terms it is perfectly OK for the storage to be updated during a transaction because if the transaction fails the changes will be rolled back because all changes are stored in-memory until the end of the transaction.  This may not be an ideal transaction model for all scenarios so you may wish to implement your own version of transactions or code your implementations of the abstract methods accordingly to limit actual persistence to the end of a transaction.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseTransactionalDataset.#ctor">
            <summary>
            Creates a new Transactional Dataset
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseTransactionalDataset.#ctor(System.Boolean)">
            <summary>
            Creates a new Transactional Dataset with the given Union Default Graph setting
            </summary>
            <param name="unionDefaultGraph">Whether to use a Union Default Graph</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseTransactionalDataset.#ctor(System.Uri)">
            <summary>
            Creates a new Transactional Dataset with a fixed Default Graph and no Union Default Graph
            </summary>
            <param name="defaultGraphUri">Default Graph URI</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseTransactionalDataset.AddGraph(VDS.RDF.IGraph)">
            <summary>
            Adds a Graph to the Dataset
            </summary>
            <param name="g">Graph to add</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseTransactionalDataset.AddGraphInternal(VDS.RDF.IGraph)">
            <summary>
            Adds a Graph to the Dataset
            </summary>
            <param name="g">Graph to add</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseTransactionalDataset.RemoveGraph(System.Uri)">
            <summary>
            Removes a Graph from the Dataset
            </summary>
            <param name="graphUri">Graph URI</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseTransactionalDataset.GetModifiableGraph(System.Uri)">
            <summary>
            Gets a Graph from the Dataset that can be modified
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseTransactionalDataset.GetModifiableGraphInternal(System.Uri)">
            <summary>
            Gets a Graph from the Dataset that can be modified transactionally
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseTransactionalDataset.Flush">
            <summary>
            Ensures that any changes to the Dataset (if any) are flushed to the underlying Storage
            </summary>
            <remarks>
            Commits the Active Transaction
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseTransactionalDataset.Discard">
            <summary>
            Ensures that any changes to the Dataset (if any) are discarded
            </summary>
            <remarks>
            Rollsback the Active Transaction
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseTransactionalDataset.FlushInternal">
            <summary>
            Allows the derived dataset to take any post-Flush() actions required
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.BaseTransactionalDataset.DiscardInternal">
            <summary>
            Allows the derived dataset to take any post-Discard() actions required
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Datasets.BaseTransactionalDataset.Item(System.Uri)">
            <summary>
            Gets a Graph from the Dataset
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
            <remarks>
            If the Graph has been modified during the active Transaction the modified version is returned rather than the original version
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.Datasets.DatasetGraphCollection">
            <summary>
            A Graph Collection which wraps an <see cref="T:VDS.RDF.Query.Datasets.ISparqlDataset">ISparqlDataset</see> implementation so it can be used as if it was a Graph Collection
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.DatasetGraphCollection.#ctor(VDS.RDF.Query.Datasets.ISparqlDataset)">
            <summary>
            Creates a new Dataset Graph collection
            </summary>
            <param name="dataset">SPARQL Dataset</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.DatasetGraphCollection.Contains(System.Uri)">
            <summary>
            Gets whether the Collection contains a Graph with the given URI
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.DatasetGraphCollection.Add(VDS.RDF.IGraph,System.Boolean)">
            <summary>
            Adds a Graph to the Collection
            </summary>
            <param name="g">Graph to add</param>
            <param name="mergeIfExists">Whether to merge the given Graph with any existing Graph with the same URI</param>
            <exception cref="T:VDS.RDF.RdfException">Thrown if a Graph with the given URI already exists and the <paramref name="mergeIfExists">mergeIfExists</paramref> is set to false</exception>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.DatasetGraphCollection.Remove(System.Uri)">
            <summary>
            Removes a Graph from the Collection
            </summary>
            <param name="graphUri">URI of the Graph to removed</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.DatasetGraphCollection.Dispose">
            <summary>
            Disposes of the Graph Collection
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.DatasetGraphCollection.GetEnumerator">
            <summary>
            Gets the enumeration of Graphs in this Collection
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Datasets.DatasetGraphCollection.Count">
            <summary>
            Gets the number of Graphs in the Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Datasets.DatasetGraphCollection.GraphUris">
            <summary>
            Gets the URIs of Graphs in the Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Datasets.DatasetGraphCollection.Item(System.Uri)">
            <summary>
            Gets the Graph with the given URI
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Datasets.InMemoryDataset">
            <summary>
            Represents an in-memory dataset (i.e. a <see cref="T:VDS.RDF.IInMemoryQueryableStore">InMemoryQueryableStore</see>) for querying and updating using SPARQL
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.InMemoryDataset.#ctor">
            <summary>
            Creates a new in-memory dataset using the default in-memory <see cref="T:VDS.RDF.TripleStore">TripleStore</see> as the underlying storage
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.InMemoryDataset.#ctor(System.Boolean)">
            <summary>
            Creates a new in-memory dataset using the default in-memory <see cref="T:VDS.RDF.TripleStore">TripleStore</see> as the underlying storage
            </summary>
            <param name="unionDefaultGraph">Whether the Default Graph when no Active/Default Graph is explicitly set should be the union of all Graphs in the Dataset</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.InMemoryDataset.#ctor(VDS.RDF.IGraph)">
            <summary>
            Creates a new in-memory dataset containing initially just the given graph and treating the given graph as the default graph of the dataset
            </summary>
            <param name="g">Graph</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.InMemoryDataset.#ctor(VDS.RDF.IInMemoryQueryableStore)">
            <summary>
            Creates a new In-Memory dataset
            </summary>
            <param name="store">In-Memory queryable store</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.InMemoryDataset.#ctor(VDS.RDF.IInMemoryQueryableStore,System.Boolean)">
            <summary>
            Creates a new In-Memory dataset
            </summary>
            <param name="store">In-Memory queryable store</param>
            <param name="unionDefaultGraph">Whether the Default Graph when no Active/Default Graph is explicitly set should be the union of all Graphs in the Dataset</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.InMemoryDataset.#ctor(VDS.RDF.IInMemoryQueryableStore,System.Uri)">
            <summary>
            Creates a new In-Memory dataset
            </summary>
            <param name="store">In-Memory queryable store</param>
            <param name="defaultGraphUri">Default Graph URI</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.InMemoryDataset.AddGraphInternal(VDS.RDF.IGraph)">
            <summary>
            Adds a Graph to the Dataset merging it with any existing Graph with the same URI
            </summary>
            <param name="g">Graph</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.InMemoryDataset.RemoveGraphInternal(System.Uri)">
            <summary>
            Removes a Graph from the Dataset
            </summary>
            <param name="graphUri">Graph URI</param>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.InMemoryDataset.HasGraphInternal(System.Uri)">
            <summary>
            Gets whether a Graph with the given URI is the Dataset
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.InMemoryDataset.GetGraphInternal(System.Uri)">
            <summary>
            Gets the Graph with the given URI from the Dataset
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
            <remarks>
            <para>
            For In-Memory datasets the Graph returned from this property is no different from the Graph returned by the <see cref="M:VDS.RDF.Query.Datasets.InMemoryDataset.GetModifiableGraphInternal(System.Uri)">GetModifiableGraphInternal()</see> method
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.InMemoryDataset.GetModifiableGraphInternal(System.Uri)">
            <summary>
            Gets a Modifiable wrapper around a Graph in the Dataset
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.InMemoryDataset.ContainsTripleInternal(VDS.RDF.Triple)">
            <summary>
            Gets whether the Dataset contains a specific Triple
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.InMemoryDataset.GetAllTriples">
            <summary>
            Gets all the Triples in the underlying in-memory store
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.InMemoryDataset.GetTriplesWithSubjectInternal(VDS.RDF.INode)">
            <summary>
            Gets all the Triples in the Dataset with the given Subject
            </summary>
            <param name="subj">Subject</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.InMemoryDataset.GetTriplesWithPredicateInternal(VDS.RDF.INode)">
            <summary>
            Gets all the Triples in the Dataset with the given Predicate
            </summary>
            <param name="pred">Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.InMemoryDataset.GetTriplesWithObjectInternal(VDS.RDF.INode)">
            <summary>
            Gets all the Triples in the Dataset with the given Object
            </summary>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.InMemoryDataset.GetTriplesWithSubjectPredicateInternal(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets all the Triples in the Dataset with the given Subject and Predicate
            </summary>
            <param name="subj">Subject</param>
            <param name="pred">Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.InMemoryDataset.GetTriplesWithSubjectObjectInternal(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets all the Triples in the Dataset with the given Subject and Object
            </summary>
            <param name="subj">Subject</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.InMemoryDataset.GetTriplesWithPredicateObjectInternal(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets all the Triples in the Dataset with the given Predicate and Object
            </summary>
            <param name="pred">Predicate</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Datasets.InMemoryDataset.FlushInternal">
            <summary>
            If there have been changes made to the Dataset and the underlying in-memory store is a <see cref="T:VDS.RDF.ITransactionalStore">ITransactionalStore</see> ensures the underlying store is notified to flush those changes
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Datasets.InMemoryDataset.Graphs">
            <summary>
            Gets all the Graphs in the Dataset
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Datasets.InMemoryDataset.GraphUris">
            <summary>
            Gets all the URIs of Graphs in the Dataset
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Describe.BaseDescribeAlgorithm">
            <summary>
            Abstract Base Class for SPARQL Describe Algorithms which provides BNode rewriting functionality
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Describe.ISparqlDescribe">
            <summary>
            Interface for classes that implement the DESCRIBE functionality of SPARQL
            </summary>
            <remarks>
            <para>
            This is designed so that developers can introduce their own DESCRIBE algorithms as required
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Describe.ISparqlDescribe.Describe(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Generates a Graph which is the description of the resources resulting from the Query
            </summary>
            <param name="context">SPARQL Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Describe.ISparqlDescribe.Describe(VDS.RDF.IRdfHandler,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Generates the Description Graph based on the Query Results from the given Evaluation Context passing the resulting Triples to the given RDF Handler
            </summary>
            <param name="handler">RDF Handler</param>
            <param name="context">SPARQL Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.Describe.BaseDescribeAlgorithm.Describe(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Gets the Description Graph based on the Query Results from the given Evaluation Context
            </summary>
            <param name="context">SPARQL Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Describe.BaseDescribeAlgorithm.Describe(VDS.RDF.IRdfHandler,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Gets the Description Graph based on the Query Results from the given Evaluation Context passing the resulting Triples to the given RDF Handler
            </summary>
            <param name="handler">RDF Handler</param>
            <param name="context">SPARQL Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.Describe.BaseDescribeAlgorithm.DescribeInternal(VDS.RDF.IRdfHandler,VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.IEnumerable{VDS.RDF.INode})">
            <summary>
            Generates the Description for each of the Nodes to be described
            </summary>
            <param name="handler">RDF Handler</param>
            <param name="context">SPARQL Evaluation Context</param>
            <param name="nodes">Nodes to be described</param>
        </member>
        <member name="M:VDS.RDF.Query.Describe.BaseDescribeAlgorithm.GetNodes(VDS.RDF.INodeFactory,VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Gets the Nodes that the algorithm should generate the descriptions for
            </summary>
            <param name="factory">Factory to create Nodes in</param>
            <param name="context">SPARQL Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Describe.BaseDescribeAlgorithm.RewriteDescribeBNodes(VDS.RDF.Triple,System.Collections.Generic.Dictionary{System.String,VDS.RDF.INode},VDS.RDF.INodeFactory)">
            <summary>
            Helper method which rewrites Blank Node IDs for Describe Queries
            </summary>
            <param name="t">Triple</param>
            <param name="mapping">Mapping of IDs to new Blank Nodes</param>
            <param name="factory">Factory to create Nodes in</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Describe.ConciseBoundedDescription">
            <summary>
            Computes a Concise Bounded Description for all the Values resulting from the Query
            </summary>
            <remarks>
            <para>
            The Description returned is all the Triples for which a Value is a Subject and with any Blank Nodes expanded to include Triples with the Blank Node as the Subject
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Describe.ConciseBoundedDescription.DescribeInternal(VDS.RDF.IRdfHandler,VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.IEnumerable{VDS.RDF.INode})">
            <summary>
            Generates the Description for each of the Nodes to be described
            </summary>
            <param name="handler">RDF Handler</param>
            <param name="context">SPARQL Evaluation Context</param>
            <param name="nodes">Nodes to be described</param>
        </member>
        <member name="T:VDS.RDF.Query.Describe.LabelledDescription">
            <summary>
            Computes a Labelled Description for all the Values resulting from the Query
            </summary>
            <remarks>
            <para>
            The Description returned is all the Triples for which a Value is a Subject and with any Blank Nodes expanded to include their rdfs:label property if present
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Describe.LabelledDescription.DescribeInternal(VDS.RDF.IRdfHandler,VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.IEnumerable{VDS.RDF.INode})">
            <summary>
            Generates the Description for each of the Nodes to be described
            </summary>
            <param name="handler">RDF Handler</param>
            <param name="context">SPARQL Evaluation Context</param>
            <param name="nodes">Nodes to be described</param>
        </member>
        <member name="T:VDS.RDF.Query.Describe.MinimalSpanningGraph">
            <summary>
            Computes the merge of the Minimal Spanning Graphs for all the Values resulting from the Query
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Describe.MinimalSpanningGraph.DescribeInternal(VDS.RDF.IRdfHandler,VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.IEnumerable{VDS.RDF.INode})">
            <summary>
            Generates the Description for each of the Nodes to be described
            </summary>
            <param name="handler">RDF Handler</param>
            <param name="context">SPARQL Evaluation Context</param>
            <param name="nodes">Nodes to be described</param>
        </member>
        <member name="T:VDS.RDF.Query.Describe.SymmetricConciseBoundedDescription">
            <summary>
            Computes a Symmetric Concise Bounded Description for all the Values resulting from the Query
            </summary>
            <remarks>
            <para>
            The Description returned is all the Triples for which a Value is a Subject/Object and with any Blank Nodes expanded to include Triples with the Blank Node as the Subject
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Describe.SymmetricConciseBoundedDescription.DescribeInternal(VDS.RDF.IRdfHandler,VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.IEnumerable{VDS.RDF.INode})">
            <summary>
            Generates the Description for each of the Nodes to be described
            </summary>
            <param name="handler">RDF Handler</param>
            <param name="context">SPARQL Evaluation Context</param>
            <param name="nodes">Nodes to be described</param>
        </member>
        <member name="T:VDS.RDF.Query.Describe.SimpleSubjectObjectDescription">
            <summary>
            Computes a Simple Subject Object Description for all Values resulting from the Query
            </summary>
            <remarks>
            <para>
            The Description returned is all the Triples for which a Value is the Subject or Object - this description does not expand any Blank Nodes
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Describe.SimpleSubjectObjectDescription.DescribeInternal(VDS.RDF.IRdfHandler,VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.IEnumerable{VDS.RDF.INode})">
            <summary>
            Generates the Description for each of the Nodes to be described
            </summary>
            <param name="handler">RDF Handler</param>
            <param name="context">SPARQL Evaluation Context</param>
            <param name="nodes">Nodes to be described</param>
        </member>
        <member name="T:VDS.RDF.Query.Describe.NamedGraphDescription">
            <summary>
            Computes a Description for all the results such that the description is the merge of all the Graphs named with a resulting URI
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Describe.NamedGraphDescription.DescribeInternal(VDS.RDF.IRdfHandler,VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.IEnumerable{VDS.RDF.INode})">
            <summary>
            Generates the Description for each of the Nodes to be described
            </summary>
            <param name="handler">RDF Handler</param>
            <param name="context">SPARQL Evaluation Context</param>
            <param name="nodes">Nodes to be described</param>
        </member>
        <member name="T:VDS.RDF.Query.Describe.SimpleSubjectDescription">
            <summary>
            Computes a Simple Subject Description for all Values resulting from the Query
            </summary>
            <remarks>
            <para>
            The Description returned is all the Triples for which a Value is the Subject - this description does not expand any Blank Nodes
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Describe.SimpleSubjectDescription.DescribeInternal(VDS.RDF.IRdfHandler,VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.IEnumerable{VDS.RDF.INode})">
            <summary>
            Generates the Description for each of the Nodes to be described
            </summary>
            <param name="handler">RDF Handler</param>
            <param name="context">SPARQL Evaluation Context</param>
            <param name="nodes">Nodes to be described</param>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.ArqFunctionFactory">
            <summary>
            Expression Factory which generates ARQ Function expressions
            </summary>
            <remarks>
            <para>
            Designed to help provide feature parity with the ARQ query engine contained in Jena
            </para>
            </remarks>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.ArqFunctionFactory.ArqFunctionsNamespace">
            <summary>
            ARQ Function Namespace
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.ArqFunctionFactory.Max">
            <summary>
            Constants for ARQ Numeric functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.ArqFunctionFactory.Min">
            <summary>
            Constants for ARQ Numeric functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.ArqFunctionFactory.Pi">
            <summary>
            Constants for ARQ Numeric functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.ArqFunctionFactory.E">
            <summary>
            Constants for ARQ Numeric functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.ArqFunctionFactory.BNode">
            <summary>
            Constants for ARQ Graph functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.ArqFunctionFactory.LocalName">
            <summary>
            Constants for ARQ Graph functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.ArqFunctionFactory.Namespace">
            <summary>
            Constants for ARQ Graph functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.ArqFunctionFactory.Substr">
            <summary>
            Constants for ARQ String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.ArqFunctionFactory.Substring">
            <summary>
            Constants for ARQ String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.ArqFunctionFactory.StrJoin">
            <summary>
            Constants for ARQ String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.ArqFunctionFactory.Sha1Sum">
            <summary>
            Constants for ARQ Miscellaneous functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.ArqFunctionFactory.Now">
            <summary>
            Constants for ARQ Miscellaneous functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.ArqFunctionFactory.FunctionUris">
            <summary>
            Array of Extension Function URIs
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.ArqFunctionFactory.TryCreateExpression(System.Uri,System.Collections.Generic.List{VDS.RDF.Query.Expressions.ISparqlExpression},System.Collections.Generic.Dictionary{System.String,VDS.RDF.Query.Expressions.ISparqlExpression},VDS.RDF.Query.Expressions.ISparqlExpression@)">
            <summary>
            Tries to create an ARQ Function expression if the function Uri correseponds to a supported ARQ Function
            </summary>
            <param name="u">Function Uri</param>
            <param name="args">Function Arguments</param>
            <param name="scalarArgs">Scalar Arguments</param>
            <param name="expr">Generated Expression</param>
            <returns>Whether an expression was successfully generated</returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.ArqFunctionFactory.AvailableExtensionFunctions">
            <summary>
            Gets the Extension Function URIs supported by this Factory
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.ArqFunctionFactory.AvailableExtensionAggregates">
            <summary>
            Gets the Extension Aggregate URIs supported by this Factory
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.CartesianFunction">
            <summary>
            Represents the Leviathan lfn:cartesian() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.CartesianFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new 2D Cartesian Function
            </summary>
            <param name="x1">Expression for X Coordinate of 1st point</param>
            <param name="y1">Expression for Y Coordinate of 1st point</param>
            <param name="x2">Expression for X Coordinate of 2nd point</param>
            <param name="y2">Expression for Y Coordinate of 2nd point</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.CartesianFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new 3D Cartesian Function
            </summary>
            <param name="x1">Expression for X Coordinate of 1st point</param>
            <param name="y1">Expression for Y Coordinate of 1st point</param>
            <param name="z1">Expression for Z Coordiante of 1st point</param>
            <param name="x2">Expression for X Coordinate of 2nd point</param>
            <param name="y2">Expression for Y Coordinate of 2nd point</param>
            <param name="z2">Expression for Z Coordinate of 2nd point</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.CartesianFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.CartesianFunction.CartesianDistance2D(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Internal helper for calculating 2D Cartesian Distance
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.CartesianFunction.CartesianDistance3D(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Internal helper for calculating 3D Cartesian Distance
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.CartesianFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.CartesianFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.CartesianFunction.Variables">
            <summary>
            Gets the Variables used in the function
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.CartesianFunction.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.CartesianFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.CartesianFunction.Arguments">
            <summary>
            Gets the Arguments of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.CartesianFunction.CanParallelise">
            <summary>
            Gets whether an expression can safely be evaluated in parallel
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.CoalesceFunction">
            <summary>
            Class representing the SPARQL COALESCE() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.CoalesceFunction.#ctor(System.Collections.Generic.IEnumerable{VDS.RDF.Query.Expressions.ISparqlExpression})">
            <summary>
            Creates a new COALESCE function with the given expressions as its arguments
            </summary>
            <param name="expressions">Argument expressions</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.CoalesceFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the value of the expression as evaluated in the given Context for the given Binding ID
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.CoalesceFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.CoalesceFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.CoalesceFunction.Variables">
            <summary>
            Gets the Variables used in all the argument expressions of this function
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.CoalesceFunction.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.CoalesceFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.CoalesceFunction.Arguments">
            <summary>
            Gets the Arguments of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.CoalesceFunction.CanParallelise">
            <summary>
            Gets whether an expression can safely be evaluated in parallel
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.ExistsFunction">
            <summary>
            Represents an EXIST/NOT EXISTS clause used as a Function in an Expression
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.ExistsFunction.#ctor(VDS.RDF.Query.Patterns.GraphPattern,System.Boolean)">
            <summary>
            Creates a new EXISTS/NOT EXISTS function
            </summary>
            <param name="pattern">Graph Pattern</param>
            <param name="mustExist">Whether this is an EXIST</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.ExistsFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the Value of this function which is a Boolean as a Literal Node
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.ExistsFunction.EvaluateInternal(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Internal method which evaluates the Graph Pattern
            </summary>
            <param name="origContext">Evaluation Context</param>
            <remarks>
            We only ever need to evaluate the Graph Pattern once to get the Results
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.ExistsFunction.ToString">
            <summary>
            Gets the String representation of the Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.ExistsFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.ExistsFunction.Variables">
            <summary>
            Gets the Variables used in this Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.ExistsFunction.CanParallelise">
            <summary>
            Gets whether an expression can safely be evaluated in parallel
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.ExistsFunction.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.ExistsFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.ExistsFunction.Arguments">
            <summary>
            Gets the Arguments of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.IfElseFunction">
            <summary>
            Class representing the SPARQL IF function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.IfElseFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new IF function
            </summary>
            <param name="condition">Condition</param>
            <param name="ifBranch">Expression to evaluate if condition evaluates to true</param>
            <param name="elseBranch">Expression to evalaute if condition evaluates to false/error</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.IfElseFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gets the value of the expression as evaluated in the given Context for the given Binding ID
            </summary>
            <param name="context">SPARQL Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.IfElseFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.Sparql.IfElseFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.IfElseFunction.Variables">
            <summary>
            Gets the enumeration of variables used in the expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.IfElseFunction.Type">
            <summary>
            Gets the Expression Type
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.IfElseFunction.Functor">
            <summary>
            Gets the Functor for the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.IfElseFunction.Arguments">
            <summary>
            Gets the Arguments of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.Sparql.IfElseFunction.CanParallelise">
            <summary>
            Gets whether an expression can safely be evaluated in parallel
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.UnknownFunction">
            <summary>
            Represents an Unknown Function that is not supported by dotNetRDF
            </summary>
            <remarks>
            <para>
            This exists as a placeholder class so users may choose to parse Unknown Functions and have them appear in queries even if they cannot be evaluated.  This is useful when you wish to parse a query locally to check syntactic validity before passing it to an external query processor which may understand how to evaluate the function.  Using this placeholder also allows queries containing Unknown Functions to still be formatted properly.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.UnknownFunction.#ctor(System.Uri)">
            <summary>
            Creates a new Unknown Function that has no Arguments
            </summary>
            <param name="funcUri">Function URI</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.UnknownFunction.#ctor(System.Uri,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Unknown Function that has a Single Argument
            </summary>
            <param name="funcUri">Function URI</param>
            <param name="expr">Argument Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.UnknownFunction.#ctor(System.Uri,System.Collections.Generic.IEnumerable{VDS.RDF.Query.Expressions.ISparqlExpression})">
            <summary>
            Creates a new Unknown Function that has multiple Arguments
            </summary>
            <param name="funcUri">Function URI</param>
            <param name="exprs">Argument Expressions</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.UnknownFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Gives null as the Value since dotNetRDF does not know how to evaluate Unknown Functions
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.UnknownFunction.ToString">
            <summary>
            Gets the String representation of the Expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.UnknownFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.UnknownFunction.Variables">
            <summary>
            Gets the Variables used in the Function
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.UnknownFunction.Type">
            <summary>
            Gets the Expression Type
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.UnknownFunction.Functor">
            <summary>
            Gets the Function URI of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.UnknownFunction.Arguments">
            <summary>
            Gets the Arguments of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.UnknownFunction.CanParallelise">
            <summary>
            Gets whether an expression can safely be evaluated in parallel
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.LeviathanFunctionFactory">
            <summary>
            Expression Factory which generates Leviathan Function expressions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.LeviathanFunctionsNamespace">
            <summary>
            Leviathan Function Namespace
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.MD5Hash">
            <summary>
            Constants for Leviathan String Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.Sha256Hash">
            <summary>
            Constants for Leviathan String Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.Random">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.TrigSin">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.TrigSinInv">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.TrigCos">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.TrigCosInv">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.TrigTan">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.TrigTanInv">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.TrigSec">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.TrigSecInv">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.TrigCosec">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.TrigCosecInv">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.TrigCotan">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.TrigCotanInv">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.DegreesToRadians">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.RadiansToDegrees">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.Log">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.Ln">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.E">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.Ten">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.Power">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.Square">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.Cube">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.SquareRoot">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.Root">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.Pythagoras">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.Cartesian">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.Factorial">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.Reciprocal">
            <summary>
            Constants for Leviathan Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.All">
            <summary>
            Constants for Leviathan Boolean Aggregates
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.Any">
            <summary>
            Constants for Leviathan Boolean Aggregates
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.None">
            <summary>
            Constants for Leviathan Boolean Aggregates
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.NumericMin">
            <summary>
            Constants for Leviathan Numeric Aggregates
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.NumericMax">
            <summary>
            Constants for Leviathan Numeric Aggregates
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.Mode">
            <summary>
            Constants for other Leviathan Aggregate
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.Median">
            <summary>
            Constants for other Leviathan Aggregate
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.FunctionUris">
            <summary>
            Array of Extension Function URIs
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.AggregateUris">
            <summary>
            Array of Extension Aggregate URIs
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.TryCreateExpression(System.Uri,System.Collections.Generic.List{VDS.RDF.Query.Expressions.ISparqlExpression},System.Collections.Generic.Dictionary{System.String,VDS.RDF.Query.Expressions.ISparqlExpression},VDS.RDF.Query.Expressions.ISparqlExpression@)">
            <summary>
            Tries to create an Leviathan Function expression if the function Uri correseponds to a supported Leviathan Function
            </summary>
            <param name="u">Function Uri</param>
            <param name="args">Function Arguments</param>
            <param name="scalarArgs">Scalar Arguments</param>
            <param name="expr">Generated Expression</param>
            <returns>Whether an expression was successfully generated</returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.AvailableExtensionFunctions">
            <summary>
            Gets the Extension Function URIs supported by this Factory
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.LeviathanFunctionFactory.AvailableExtensionAggregates">
            <summary>
            Gets the Extension Aggregate URIs supported by this Factory
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.BooleanFunction">
            <summary>
            Represents the XPath boolean() function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.BooleanFunction.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new XPath Boolean Function
            </summary>
            <param name="expr">Expression to compute the Effective Boolean Value of</param>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.BooleanFunction.Evaluate(VDS.RDF.Query.SparqlEvaluationContext,System.Int32)">
            <summary>
            Evaluates the expression
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="bindingID">Binding ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.BooleanFunction.ToString">
            <summary>
            Gets the String representation of the function
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.Functions.XPath.BooleanFunction.Transform(VDS.RDF.Query.Expressions.IExpressionTransformer)">
            <summary>
            Transforms the Expression using the given Transformer
            </summary>
            <param name="transformer">Expression Transformer</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.BooleanFunction.Functor">
            <summary>
            Gets the Functor of the Expression
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.Functions.XPath.BooleanFunction.Type">
            <summary>
            Gets the Type of the Expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.SparqlBuiltInFunctionFactory">
            <summary>
            Expression Factory which generates SPARQL Function expressions
            </summary>
            <remarks>
            This supports the requirement of SPARQL 1.1 that all functions can be accessed via URI as well as by keyword.  This also means that SPARQL 1.1 functions can be used in SPARQL 1.0 mode by using their URIs instead of their keywords and they are then treated simply as extension functions
            </remarks>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.SparqlBuiltInFunctionFactory.SparqlFunctionsNamespace">
            <summary>
            Namespace Uri for SPARQL Built In Functions Namespace
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.SparqlBuiltInFunctionFactory.TryCreateExpression(System.Uri,System.Collections.Generic.List{VDS.RDF.Query.Expressions.ISparqlExpression},System.Collections.Generic.Dictionary{System.String,VDS.RDF.Query.Expressions.ISparqlExpression},VDS.RDF.Query.Expressions.ISparqlExpression@)">
            <summary>
            Tries to create a SPARQL Function expression if the function Uri correseponds to a supported SPARQL Function
            </summary>
            <param name="u">Function Uri</param>
            <param name="args">Function Arguments</param>
            <param name="scalarArguments">Scalar Arguments</param>
            <param name="expr">Generated Expression</param>
            <returns>Whether an expression was successfully generated</returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.SparqlBuiltInFunctionFactory.AvailableExtensionFunctions">
            <summary>
            Gets the URIs of available SPARQL Functions
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.SparqlBuiltInFunctionFactory.AvailableExtensionAggregates">
            <summary>
            Gets the URIs of available SPARQL Aggregates
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Inference.OwlHelper">
            <summary>
            Helper class containing constants and methods for use in implementing OWL support
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.OwlHelper.OwlNothing">
            <summary>
            OWL Class and Property Constants
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Inference.OwlHelper.OwlExtractMode">
            <summary>
            Class containing Extraction Mode constants
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.OwlHelper.OwlExtractMode.DefaultStatements">
            <summary>
            OWL Extraction Mode constants
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.OwlHelper.OwlExtractMode.AllClass">
            <summary>
            OWL Extraction Mode constants
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.OwlHelper.OwlExtractMode.AllIndividual">
            <summary>
            OWL Extraction Mode constants
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.OwlHelper.OwlExtractMode.AllProperty">
            <summary>
            OWL Extraction Mode constants
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.OwlHelper.OwlExtractMode.AllStatements">
            <summary>
            OWL Extraction Mode constants
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.OwlHelper.OwlExtractMode.AllStatementsIncludingJena">
            <summary>
            OWL Extraction Mode constants
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.OwlHelper.OwlExtractMode.ClassAssertion">
            <summary>
            OWL Extraction Mode constants
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.OwlHelper.OwlExtractMode.ComplementOf">
            <summary>
            OWL Extraction Mode constants
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.OwlHelper.OwlExtractMode.DataPropertyAssertion">
            <summary>
            OWL Extraction Mode constants
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.OwlHelper.OwlExtractMode.DifferentIndividuals">
            <summary>
            OWL Extraction Mode constants
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.OwlHelper.OwlExtractMode.DirectClassAssertion">
            <summary>
            OWL Extraction Mode constants
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.OwlHelper.OwlExtractMode.DirectSubClassOf">
            <summary>
            OWL Extraction Mode constants
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.OwlHelper.OwlExtractMode.DirectSubPropertyOf">
            <summary>
            OWL Extraction Mode constants
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.OwlHelper.OwlExtractMode.DisjointClasses">
            <summary>
            OWL Extraction Mode constants
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.OwlHelper.OwlExtractMode.DisjointProperties">
            <summary>
            OWL Extraction Mode constants
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.OwlHelper.OwlExtractMode.EquivalentClasses">
            <summary>
            OWL Extraction Mode constants
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.OwlHelper.OwlExtractMode.EquivalentProperties">
            <summary>
            OWL Extraction Mode constants
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.OwlHelper.OwlExtractMode.InverseProperties">
            <summary>
            OWL Extraction Mode constants
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.OwlHelper.OwlExtractMode.ObjectPropertyAssertion">
            <summary>
            OWL Extraction Mode constants
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.OwlHelper.OwlExtractMode.PropertyAssertion">
            <summary>
            OWL Extraction Mode constants
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.OwlHelper.OwlExtractMode.SameIndividual">
            <summary>
            OWL Extraction Mode constants
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.OwlHelper.OwlExtractMode.SubClassOf">
            <summary>
            OWL Extraction Mode constants
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.OwlHelper.OwlExtractMode.SubPropertyOf">
            <summary>
            OWL Extraction Mode constants
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Inference.IOwlReasoner">
            <summary>
            Proposed interface for OWL Reasoners - currently incomplete
            </summary>
            <remarks>
            <para>
            <strong>Important:</strong> This interface is specifically designed so that it does not require the provision of a Graph to methods unless the method does not make sense without taking an <see cref="T:VDS.RDF.IGraph">IGraph</see> as a parameter.  This is because we envisage the use of this interface for connecting to reasoners which have their own access to the data over which they are reasoning and do not need it providing explicitly to them.
            </para>
            <para>
            Reasoner implementations may throw <see cref="T:System.NotSupportedException">NotSupportedException</see> for operations they don't support and may throw any other appropriate exceptions as appropriate for operations that encounter errors.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Inference.IOwlReasoner.Add(VDS.RDF.IGraph)">
            <summary>
            Adds a Graph to the reasoners knowledge base
            </summary>
            <param name="g">Graph</param>
            <remarks>
            <para>
            A reasoner may choose to do nothing in this method if that reasoner especially if it operates using some pre-defined, remote or otherwise immutable knowledge base.
            </para>
            </remarks>
            <exception cref="T:System.NotSupportedException">May be thrown if the Reasoner does not support such an operation</exception>
        </member>
        <member name="M:VDS.RDF.Query.Inference.IOwlReasoner.Extract(VDS.RDF.IGraph,VDS.RDF.INode)">
            <summary>
            Extract a reasoning enhanced sub-graph from the given Graph rooted at the given Node
            </summary>
            <param name="g">Graph</param>
            <param name="n">Root Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Inference.IOwlReasoner.Extract(System.String)">
            <summary>
            Extracts all possible triples using the given extraction mode
            </summary>
            <param name="mode">Extraction Mode</param>
            <returns></returns>
            <remarks>
            The <paramref name="mode">mode</paramref> permits for the specification of an extraction mode for reasoners that can extract specific subsets of reasoning.  Where this is not supported the reasoner should simply extract all triples that can be inferred by reasoning
            </remarks>
            <exception cref="T:System.NotSupportedException">May be thrown if the Reasoner does not support such an operation</exception>
        </member>
        <member name="M:VDS.RDF.Query.Inference.IOwlReasoner.Extract(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Extracts all possible triples using the given extraction modes
            </summary>
            <param name="modes">Extraction Modes</param>
            <returns></returns>
            <remarks>
            The <paramref name="modes">modes</paramref> permits for the specification of an extraction mode for reasoners that can extract specific subsets of reasoning.  Where this is not supported the reasoner should simply extract all triples that can be inferred by reasoning
            </remarks>
            <exception cref="T:System.NotSupportedException">May be thrown if the Reasoner does not support such an operation</exception>
        </member>
        <member name="M:VDS.RDF.Query.Inference.IOwlReasoner.Classify">
            <summary>
            Extracts the triples which comprise the class hierarchy
            </summary>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">May be thrown if the Reasoner does not support such an operation</exception>
        </member>
        <member name="M:VDS.RDF.Query.Inference.IOwlReasoner.Realize">
            <summary>
            Extracts the triples which comprise the class hierarchy and individuals of those classes
            </summary>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">May be thrown if the Reasoner does not support such an operation</exception>
        </member>
        <member name="M:VDS.RDF.Query.Inference.IOwlReasoner.IsConsistent">
            <summary>
            Returns whether the underlying knowledge base is consistent
            </summary>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">May be thrown if the Reasoner does not support such an operation</exception>
        </member>
        <member name="M:VDS.RDF.Query.Inference.IOwlReasoner.IsConsistent(VDS.RDF.IGraph)">
            <summary>
            Returns whether the given Graph is consistent with the underlying knowledge base
            </summary>
            <param name="g">Graph</param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">May be thrown if the Reasoner does not support such an operation</exception>
        </member>
        <member name="P:VDS.RDF.Query.Inference.IOwlReasoner.Unsatisfiable">
            <summary>
            Returns the enumeration of unsatisfiable classes
            </summary>
            <exception cref="T:System.NotSupportedException">May be thrown if the Reasoner does not support such an operation</exception>
        </member>
        <member name="T:VDS.RDF.Query.Inference.IQueryableOwlReasoner">
            <summary>
            Interface for OWL Reasoners which have access to their own SPARQL implementations
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Inference.IQueryableOwlReasoner.ExecuteQuery(System.String)">
            <summary>
            Executes a SPARQL Query using the reasoners SPARQL implementation
            </summary>
            <param name="sparqlQuery">SPARQL Query</param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">May be thrown if the Reasoner does not support such an operation</exception>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.Services.ClusterService">
            <summary>
            Represents the Cluster Service provided by a Pellet Knowledge Base
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.PelletService">
            <summary>
            Class representing Services provided by a Pellet Server Knowledge Base
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.PelletService.#ctor(System.String,Newtonsoft.Json.Linq.JObject)">
            <summary>
            Creates a new Pellet Service instance
            </summary>
            <param name="name">Service Name</param>
            <param name="obj">JSON Object representing the Service</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.PelletService.CreateService(Newtonsoft.Json.Linq.JToken)">
            <summary>
            Factory method for generating concrete Pellet Service instances representing different Pellet Services
            </summary>
            <param name="t">JSON Object representing the Service</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Inference.Pellet.PelletService.Name">
            <summary>
            Gets the Name of the Service
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Inference.Pellet.PelletService.Endpoint">
            <summary>
            Gets the Endpoint for this Service
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Inference.Pellet.PelletService.MimeTypes">
            <summary>
            Gets the Response MIME Types supported by the Service
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.ClusterService.Cluster(System.Int32,VDS.RDF.Query.Inference.Pellet.PelletClusterServiceCallback,System.Object)">
            <summary>
            Gets a list of lists expressing clusters within the Knowledge Base
            </summary>
            <param name="number">Number of Clusters</param>
            <param name="callback">Callback to be invoked when the operation completes</param>
            <param name="state">State to be passed to the callback</param>
            <remarks>
            If the operation succeeds the callback will be invoked normally, if there is an error the callback will be invoked with a instance of <see cref="T:VDS.RDF.AsyncError"/> passed as the state which provides access to the error message and the original state passed in.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.ClusterService.Cluster(System.Int32,System.String,VDS.RDF.Query.Inference.Pellet.PelletClusterServiceCallback,System.Object)">
            <summary>
            Gets a list of lists expressing clusters within the Knowledge Base
            </summary>
            <param name="number">Number of Clusters</param>
            <param name="type">QName of a Type to cluster around</param>
            <param name="callback">Callback to be invoked when the operation completes</param>
            <param name="state">State to be passed to the callback</param>
            <remarks>
            If the operation succeeds the callback will be invoked normally, if there is an error the callback will be invoked with a instance of <see cref="T:VDS.RDF.AsyncError"/> passed as the state which provides access to the error message and the original state passed in.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.ClusterService.ClusterRaw(System.Int32,VDS.RDF.GraphCallback,System.Object)">
            <summary>
            Gets the raw Cluster Graph for the Knowledge Base
            </summary>
            <param name="number">Number of Clusters</param>
            <param name="callback">Callback to be invoked when the operation completes</param>
            <param name="state">State to be passed to the callback</param>
            <remarks>
            If the operation succeeds the callback will be invoked normally, if there is an error the callback will be invoked with a instance of <see cref="T:VDS.RDF.AsyncError"/> passed as the state which provides access to the error message and the original state passed in.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.ClusterService.ClusterRaw(System.Int32,System.String,VDS.RDF.GraphCallback,System.Object)">
            <summary>
            Gets the raw Cluster Graph for the Knowledge Base
            </summary>
            <param name="number">Number of Clusters</param>
            <param name="type">QName of a Type to Cluster around</param>
            <param name="callback">Callback to be invoked when the operation completes</param>
            <param name="state">State to be passed to the callback</param>
            <remarks>
            If the operation succeeds the callback will be invoked normally, if there is an error the callback will be invoked with a instance of <see cref="T:VDS.RDF.AsyncError"/> passed as the state which provides access to the error message and the original state passed in.
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.Services.SimilarityService">
            <summary>
            Represents the Similarity Service provided by a Pellet Knowledge Base
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.SimilarityService.#ctor(System.String,Newtonsoft.Json.Linq.JObject)">
            <summary>
            Creates a new Similarity Service for a Pellet Knowledge Base
            </summary>
            <param name="serviceName">Service Name</param>
            <param name="obj">JSON Object</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.SimilarityService.Similarity(System.Int32,System.String,VDS.RDF.Query.Inference.Pellet.PelletSimilarityServiceCallback,System.Object)">
            <summary>
            Gets a list of key value pairs listing Similar Individuals and their Similarity scores
            </summary>
            <param name="number">Number of Similar Individuals</param>
            <param name="individual">QName of a Individual to find Similar Individuals to</param>
            <param name="callback">Callback to invoke when the operation completes</param>
            <param name="state">State to pass to the callback</param>
            <remarks>
            If the operation succeeds the callback will be invoked normally, if there is an error the callback will be invoked with a instance of <see cref="T:VDS.RDF.AsyncError"/> passed as the state which provides access to the error message and the original state passed in.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.SimilarityService.SimilarityRaw(System.Int32,System.String,VDS.RDF.GraphCallback,System.Object)">
            <summary>
            Gets the raw Similarity Graph for the Knowledge Base
            </summary>
            <param name="number">Number of Similar Individuals</param>
            <param name="individual">QName of a Individual to find Similar Individuals to</param>
            <param name="callback">Callback to invoke when the operation completes</param>
            <param name="state">State to pass to the callback</param>
            <remarks>
            If the operation succeeds the callback will be invoked normally, if there is an error the callback will be invoked with a instance of <see cref="T:VDS.RDF.AsyncError"/> passed as the state which provides access to the error message and the original state passed in.
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.Services.IntegrityConstraintValidationService">
            <summary>
            Represents the Integrity Constraint Validation Service provided by a Pellet Knowledge Base
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.IntegrityConstraintValidationService.#ctor(System.String,Newtonsoft.Json.Linq.JObject)">
            <summary>
            Creates a new Integrity Constraint Validation Service
            </summary>
            <param name="name">Service Name</param>
            <param name="obj">JSON Object</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.IntegrityConstraintValidationService.Validate(VDS.RDF.TripleStoreCallback,System.Object)">
            <summary>
            Extracts an RDF Dataset which details the Constraints violated (if any) and whether Constraints are satisified
            </summary>
            <param name="callback">Callback to invoke when the operation completes</param>
            <param name="state">State to pass to the callback</param>
            <remarks>
            If the operation succeeds the callback will be invoked normally, if there is an error the callback will be invoked with a instance of <see cref="T:VDS.RDF.AsyncError"/> passed as the state which provides access to the error message and the original state passed in.
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.Services.PredictService">
            <summary>
            Represents the Predict Service of a Pellet Knowledge Base
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.PredictService.#ctor(System.String,Newtonsoft.Json.Linq.JObject)">
            <summary>
            Creates a new Predict Service for a Pellet Knowledge Base
            </summary>
            <param name="serviceName">Service Name</param>
            <param name="obj">JSON Object</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.PredictService.Predict(System.String,System.String,VDS.RDF.NodeListCallback,System.Object)">
            <summary>
            Gets the list of Predictions for the given Individual and Property
            </summary>
            <param name="individual">QName of an Inidividual</param>
            <param name="property">QName of a Property</param>
            <param name="callback">Callback to invoke when the operation completes</param>
            <param name="state">State to pass to the callback</param>
            <remarks>
            If the operation succeeds the callback will be invoked normally, if there is an error the callback will be invoked with a instance of <see cref="T:VDS.RDF.AsyncError"/> passed as the state which provides access to the error message and the original state passed in.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.PredictService.PredictRaw(System.String,System.String,VDS.RDF.GraphCallback,System.Object)">
            <summary>
            Gets the Raw Predictions Graph from the Knowledge Base
            </summary>
            <param name="individual">QName of an Individual</param>
            <param name="property">QName of a Property</param>
            <param name="callback">Callback to invoke when the operation completes</param>
            <param name="state">State to pass to the callback</param>
            <remarks>
            If the operation succeeds the callback will be invoked normally, if there is an error the callback will be invoked with a instance of <see cref="T:VDS.RDF.AsyncError"/> passed as the state which provides access to the error message and the original state passed in.
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.Inference.SimpleN3RulesReasoner">
            <summary>
            An Inference Engine that supports simple N3 rules
            </summary>
            <remarks>
            <para>
            This reasoner should be initialised with a Graph that contains simple N3 rules such as the following:
            </para>
            <code>
            { ?x a ?type } => { ?type a rdfs:Class }.
            </code>
            <para>
            When initialised the reasoner takes account of variables declared with <em>@forAll</em> and <em>@forSome</em> directives though no guarantees that scoping will be correct if you've got multiple <em>@forAll</em> and <em>@forSome</em> directives.
            </para>
            <para>
            When the reasoner is applied to a Graph rules are implemented by generating a SPARQL Update INSERT command like the following and executing it on the given Graph
            </para>
            <code>
            INSERT
            {
              ?type a rdfs:Class .
            }
            WHERE
            {
              ?x a ?type .
            }
            </code>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.Inference.IInferenceEngine">
            <summary>
            Interfaces for Inference Engines
            </summary>
            <remarks>
            <para>
            An Inference Engine is a class that given a Graph can infer extra information from that Graph based on fixed rules or rules computed from the Graphs it is performing inference on
            </para>
            <para>
            In general terms an implementation of an Inference Engine typically provides some form of forward chaining reasoner though implementations may do more advanced reasoning or wrap other kinds of reasoner.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Inference.IInferenceEngine.Apply(VDS.RDF.IGraph)">
            <summary>
            Applies inference to the given Graph and outputs the inferred information to that Graph
            </summary>
            <param name="g">Graph</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.IInferenceEngine.Apply(VDS.RDF.IGraph,VDS.RDF.IGraph)">
            <summary>
            Applies inference to the Input Graph and outputs the inferred information to the Output Graph
            </summary>
            <param name="input">Graph to apply inference to</param>
            <param name="output">Graph inferred information is output to</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.IInferenceEngine.Initialise(VDS.RDF.IGraph)">
            <summary>
            Initialises the Inference Engine using the given Graph
            </summary>
            <param name="g">Graph to initialise from</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.SimpleN3RulesReasoner.Apply(VDS.RDF.IGraph)">
            <summary>
            Applies reasoning to the given Graph materialising the generated Triples in the same Graph
            </summary>
            <param name="g">Graph</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.SimpleN3RulesReasoner.Apply(VDS.RDF.IGraph,VDS.RDF.IGraph)">
            <summary>
            Applies reasoning on the Input Graph materialising the generated Triples in the Output Graph
            </summary>
            <param name="input">Input Graph</param>
            <param name="output">Output Graph</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.SimpleN3RulesReasoner.Initialise(VDS.RDF.IGraph)">
            <summary>
            Initialises the Reasoner
            </summary>
            <param name="g">Rules Graph</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.SimpleN3RulesReasoner.TryCreateRule(VDS.RDF.Triple)">
            <summary>
            Tries to create a Rule
            </summary>
            <param name="t">Triple</param>
        </member>
        <member name="T:VDS.RDF.Query.Inference.StaticOwlReasonerWrapper">
            <summary>
            Wrapper around an <see cref="T:VDS.RDF.Query.Inference.IOwlReasoner">IOwlReasoner</see> to make it appear like a forward-chaining reasoner
            </summary>
            <remarks>
            Essentially all this class does is extract all triples which the underlying reasoner can infer.  Currently the input graph and any graph passed to the <see cref="M:VDS.RDF.Query.Inference.IInferenceEngine.Initialise(VDS.RDF.IGraph)">Initialise()</see> method have no effect on the output of the reasoner
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Inference.StaticOwlReasonerWrapper.#ctor(VDS.RDF.Query.Inference.IOwlReasoner)">
            <summary>
            Creates a new OWL Reasoner Wrapper around the given OWL Reasoner
            </summary>
            <param name="reasoner">OWL Reasoner</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.StaticOwlReasonerWrapper.Apply(VDS.RDF.IGraph)">
            <summary>
            Applies the reasoner to the given Graph outputting inferences into the same Graph
            </summary>
            <param name="g">Graph</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.StaticOwlReasonerWrapper.Apply(VDS.RDF.IGraph,VDS.RDF.IGraph)">
            <summary>
            Applies the reasoner to the given input Graph outputting inferences into the output Graph
            </summary>
            <param name="input">Input Graph</param>
            <param name="output">Output Graph</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.StaticOwlReasonerWrapper.Initialise(VDS.RDF.IGraph)">
            <summary>
            Initialises the reasoner
            </summary>
            <param name="g">Graph to initialise with</param>
        </member>
        <member name="T:VDS.RDF.Query.Inference.OwlReasonerWrapper">
            <summary>
            Wrapper around an <see cref="T:VDS.RDF.Query.Inference.IOwlReasoner">IOwlReasoner</see> to make it appear like a forward-chaining reasoner
            </summary>
            <remarks>
            Effectively equivalent to <see cref="T:VDS.RDF.Query.Inference.StaticOwlReasonerWrapper">StaticOwlReasonerWrapper</see> except that every Graph reasoning is applied to is added to the reasoners knowledge base (unless the reasoner uses a fixed knowledge base)
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Inference.OwlReasonerWrapper.#ctor(VDS.RDF.Query.Inference.IOwlReasoner)">
            <summary>
            Creates a new OWL Reasoner Wrapper around the given OWL Reasoner
            </summary>
            <param name="reasoner">OWL Reasoner</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.OwlReasonerWrapper.Apply(VDS.RDF.IGraph)">
            <summary>
            Applies the reasoner to the given Graph outputting inferences into the same Graph
            </summary>
            <param name="g">Graph</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.OwlReasonerWrapper.Apply(VDS.RDF.IGraph,VDS.RDF.IGraph)">
            <summary>
            Applies the reasoner to the given input Graph outputting inferences into the output Graph
            </summary>
            <param name="input">Input Graph</param>
            <param name="output">Output Graph</param>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.Services.NamespaceService">
            <summary>
            Represents the Namespace Service provided by a Pellet Server knowledge base
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.NamespaceService.#ctor(System.String,Newtonsoft.Json.Linq.JObject)">
            <summary>
            Creates a new Namespace Service
            </summary>
            <param name="name">Service Name</param>
            <param name="obj">JSON Object</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.NamespaceService.GetNamespaces(VDS.RDF.NamespaceCallback,System.Object)">
            <summary>
            Gets the Namespaces used in the Knowledge Base
            </summary>
            <param name="callback">Callback to invoke when the operation completes</param>
            <param name="state">State to be passed to the callback</param>
            <remarks>
            If the operation succeeds the callback will be invoked normally, if there is an error the callback will be invoked with a instance of <see cref="T:VDS.RDF.AsyncError"/> passed as the state which provides access to the error message and the original state passed in.
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.Optimisation.IdentityFilterOptimiser">
            <summary>
            An Algebra Optimiser which implements the Identity Filter optimisation
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.IdentityFilterOptimiser.Optimise(VDS.RDF.Query.Algebra.ISparqlAlgebra)">
            <summary>
            Optimises the Algebra to use Identity Filters where applicable
            </summary>
            <param name="algebra">Algebra</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.IdentityFilterOptimiser.IsIdentityExpression(VDS.RDF.Query.Expressions.ISparqlExpression,System.String@,VDS.RDF.INode@,System.Boolean@)">
            <summary>
            Determines whether an expression is an Identity Expression
            </summary>
            <param name="expr">Expression</param>
            <param name="var">Variable</param>
            <param name="term">Term</param>
            <param name="equals">Whether it is an equals expression (true) or a same term expression (false)</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.IdentityFilterOptimiser.IsApplicable(VDS.RDF.Query.SparqlQuery)">
            <summary>
            Returns that this optimiser is applicable to all queries
            </summary>
            <param name="q">Query</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.IdentityFilterOptimiser.IsApplicable(VDS.RDF.Update.SparqlUpdateCommandSet)">
            <summary>
            Returns that this optimiser is applicable to all updates
            </summary>
            <param name="cmds">Updates</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Optimisation.ParallelEvaluationOptimiser">
            <summary>
            An Algebra Optimiser which looks for unions and joins that can be evaluated in parallel to improve query evaluation speed in some cases
            </summary>
            <remarks>
            <para>
            Using this feature allows you to use experimental parallel SPARQL evaluation optimisations which may improve query evaluation speed for some queries.  A query must either use UNION or have joins which are disjoint in order for any parallel evaluation to take place.
            </para>
            <para>
            Users should be aware that using this optimiser may actually increase evaluation speed in some cases e.g. where either side of a disjoint join will return empty especially when it is the left hand side that will do so.
            </para>
            <para>
            Also note that while use of this optimiser should not cause queries to return incorrect results as it does not change the semantics of the evaluation as it only parallelises independent operators we cannot guarantee that all parallelised queries will return identical results to their non-parallelised counterparts.  If you find a query that you believe is giving incorrect results when used with this optimiser please test without the optimiser enabled to check that the apparent incorrect result is not an artifact of this optimisation.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.ParallelEvaluationOptimiser.Optimise(VDS.RDF.Query.Algebra.ISparqlAlgebra)">
            <summary>
            Optimises the algebra to use parallelised variants of <see cref="T:VDS.RDF.Query.Algebra.Join">Join</see> and <see cref="T:VDS.RDF.Query.Algebra.Union">Union</see> where possible
            </summary>
            <param name="algebra">Algebra</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.ParallelEvaluationOptimiser.IsApplicable(VDS.RDF.Query.SparqlQuery)">
            <summary>
            Returns that the optimser is applicable to all queries
            </summary>
            <param name="q">Query</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.ParallelEvaluationOptimiser.IsApplicable(VDS.RDF.Update.SparqlUpdateCommandSet)">
            <summary>
            Returns that the optimiser is not applicable to updates
            </summary>
            <param name="cmds">Updates</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Optimisation.DefaultOptimiser">
            <summary>
            Default SPARQL Query Optimiser
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.DefaultOptimiser.GetRankingComparer">
            <summary>
            Gets the Default Comparer for Triple Patterns to rank them
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Optimisation.NoReorderOptimiser">
            <summary>
            SPARQL Query Optimiser which does no reordering
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.NoReorderOptimiser.GetRankingComparer">
            <summary>
            Gets a comparer which does not change the order of Triple Patterns
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Optimisation.NoReorderOptimiser.ShouldReorder">
            <summary>
            Gets that Triple Patterns should not be reordered
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Optimisation.NoReorderComparer">
            <summary>
            A Comparer which ranks all Triple Patterns as equal
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.NoReorderComparer.Compare(VDS.RDF.Query.Patterns.ITriplePattern,VDS.RDF.Query.Patterns.ITriplePattern)">
            <summary>
            Compares two Triple Patterns are always returns that they are ranking equal
            </summary>
            <param name="x">First Triple Pattern</param>
            <param name="y">Second Triple Pattern</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Optimisation.SparqlOptimiser">
            <summary>
            Static Helper class which provides global registry of Algebra Optimisers and the global Query Optimiser
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Optimisation.SparqlOptimiser.OptimiserStatsNamespace">
            <summary>
            Namespace URI for the Optimiser Statistics vocabulary
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.SparqlOptimiser.AddOptimiser(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Adds a new Algebra Optimiser
            </summary>
            <param name="optimiser">Optimiser</param>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.SparqlOptimiser.RemoveOptimiser(VDS.RDF.Query.Optimisation.IAlgebraOptimiser)">
            <summary>
            Removes an Algebra Optimiser
            </summary>
            <param name="optimiser"></param>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.SparqlOptimiser.ResetOptimisers">
            <summary>
            Resets Optimisers to default settings
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Optimisation.SparqlOptimiser.QueryOptimiser">
            <summary>
            Gets/Sets the global Query Optimiser that is used by default
            </summary>
            <remarks>
            <para>
            <strong>Note:</strong> May be overridden by the Optimiser setting on a SparqlQueryParser
            </para>
            <para>
            Unlike previous releases a Query may be reoptimised using a different optimiser if desired by calling the <see cref="M:VDS.RDF.Query.SparqlQuery.Optimise">Optimise()</see> method again and providing a different Optimiser.  This may not always fully reoptimise the query since the first optimisation will have caused any Filters and Assignments to be placed in the Triple Pattern
            </para>
            <para>
            <em>Warning:</em> Setting this to null has no effect, to disable automatic optimisation use the global property <see cref="P:VDS.RDF.Options.QueryOptimisation">Options.QueryOptimisation</see>.  Even with this option disabled a Query can still be optimised manually by calling its <see cref="M:VDS.RDF.Query.SparqlQuery.Optimise">Optimise()</see> method.
            </para>
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.Optimisation.SparqlOptimiser.AlgebraOptimisers">
            <summary>
            Gets the global Algebra Optimisers that are in use
            </summary>
            <remarks>
            <para>
            Unlike Query Optimisation multiple Algebra Optimisations may apply.  Algebra optimisers may also be specified and apply locally by the use of the relevant properties on the <see cref="T:VDS.RDF.Parsing.SparqlQueryParser">SparqlQueryParser</see> and <see cref="T:VDS.RDF.Query.SparqlQuery">SparqlQuery</see> classes.  Those specified on a parser will automatically be passed through to all queries parsed by the parser.  Locally specified optimisers apply prior to globally specified ones.
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.Optimisation.StrictAlgebraOptimiser">
            <summary>
            The Strict Algebra Optimiser is an optimiser that takes our BGPs which typically contain placed FILTERs and BINDs and transforms them into their strict algebra form using Filter() and Extend()
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.StrictAlgebraOptimiser.Optimise(VDS.RDF.Query.Algebra.ISparqlAlgebra)">
            <summary>
            Optimises BGPs in the Algebra to use Filter() and Extend() rather than the embedded FILTER and BIND
            </summary>
            <param name="algebra">Algebra to optimise</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.StrictAlgebraOptimiser.IsApplicable(VDS.RDF.Query.SparqlQuery)">
            <summary>
            Returns that the optimiser is applicable to all queries
            </summary>
            <param name="q">Query</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.StrictAlgebraOptimiser.IsApplicable(VDS.RDF.Update.SparqlUpdateCommandSet)">
            <summary>
            Returns that the optimiser is applicable to all updates
            </summary>
            <param name="cmds">Updates</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Optimisation.VirtualAlgebraOptimiser`2">
            <summary>
            Abstract implementation of an algebra optimiser and expression transformer which optimises the algebra to replace any Node terms with Virtual Node terms for more efficient querying of virtualised RDF data
            </summary>
            <typeparam name="TNodeID">Node ID Type</typeparam>
            <typeparam name="TGraphID">Graph ID Type</typeparam>
        </member>
        <member name="F:VDS.RDF.Query.Optimisation.VirtualAlgebraOptimiser`2._provider">
            <summary>
            Virtual RDF Provider
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.VirtualAlgebraOptimiser`2.#ctor(VDS.RDF.Storage.Virtualisation.IVirtualRdfProvider{`0,`1})">
            <summary>
            Creates a new Virtual Algebra Optimiser
            </summary>
            <param name="provider">Virtual RDF Provider</param>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.VirtualAlgebraOptimiser`2.Optimise(VDS.RDF.Query.Algebra.ISparqlAlgebra)">
            <summary>
            Optimises the algebra so that all Node terms are virtualised
            </summary>
            <param name="algebra">Algebra</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.VirtualAlgebraOptimiser`2.Transform(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Transforms an expression so Node terms are virtualised
            </summary>
            <param name="expr">Expression</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.VirtualAlgebraOptimiser`2.SubstitutePrimaryExpression(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Substitutes a primary expression which is a Node term for a virtual Node term
            </summary>
            <param name="expr">Expression</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.VirtualAlgebraOptimiser`2.CreateVirtualNode(`0,VDS.RDF.INode)">
            <summary>
            Creates a virtual Node based on a given Value
            </summary>
            <param name="id">Node ID</param>
            <param name="value">Value</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.VirtualAlgebraOptimiser`2.IsApplicable(VDS.RDF.Query.SparqlQuery)">
            <summary>
            Returns that the optimiser is applicable to all queries
            </summary>
            <param name="q">Query</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.VirtualAlgebraOptimiser`2.IsApplicable(VDS.RDF.Update.SparqlUpdateCommandSet)">
            <summary>
            Returns that the optimiser is applicable to all updates
            </summary>
            <param name="cmds">Updates</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Optimisation.SimpleVirtualAlgebraOptimiser">
            <summary>
            A concrete implementation of a Virtual Algebra Optimiser where the virtual IDs are simply integers
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.SimpleVirtualAlgebraOptimiser.#ctor(VDS.RDF.Storage.Virtualisation.IVirtualRdfProvider{System.Int32,System.Int32})">
            <summary>
            Creates a new Simple Virtual Algebra Optimiser
            </summary>
            <param name="provider">Virtual RDF provider</param>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.SimpleVirtualAlgebraOptimiser.CreateVirtualNode(System.Int32,VDS.RDF.INode)">
            <summary>
            Creates a new Virtual Node using the virtual RDF provider this optimiser was instantiated with
            </summary>
            <param name="id">Virtual Node ID</param>
            <param name="value">Node Value</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Optimisation.WeightedOptimiser">
            <summary>
            The Weighted Optimiser is a Query Optimiser that orders Triple Patterns based on weighting computed calculated against
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Optimisation.WeightedOptimiser.DefaultSubjectWeight">
            <summary>
            Default Weight for Subject Terms
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Optimisation.WeightedOptimiser.DefaultPredicateWeight">
            <summary>
            Default Weight for Predicate Terms
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Optimisation.WeightedOptimiser.DefaultObjectWeight">
            <summary>
            Default Weight for Object Terms
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Optimisation.WeightedOptimiser.DefaultVariableWeight">
            <summary>
            Default Weight for Variables
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.WeightedOptimiser.#ctor">
            <summary>
            Creates a new Weighted Optimiser
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.WeightedOptimiser.#ctor(VDS.RDF.IGraph)">
            <summary>
            Creates a new Weighted Optimiser which reads weights from the given RDF Graph
            </summary>
            <param name="g">Graph</param>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.WeightedOptimiser.#ctor(VDS.RDF.IGraph,System.Double,System.Double,System.Double)">
            <summary>
            Creates a new Weighted Optimiser which reads weights from the given RDF Graph
            </summary>
            <param name="g">Graph</param>
            <param name="subjWeight">Default Subject Weight</param>
            <param name="predWeight">Default Predicate Weight</param>
            <param name="objWeight">Default Object Weight</param>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.WeightedOptimiser.GetRankingComparer">
            <summary>
            Gets the comparer used to order the Triple Patterns based on their computed weightings
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Optimisation.Weightings">
            <summary>
            Represents Weightings for the <see cref="T:VDS.RDF.Query.Optimisation.WeightedOptimiser">WeightedOptimiser</see>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Paths.NegatedSet">
            <summary>
            Represents a Negated Property Set
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Paths.ISparqlPath">
            <summary>
            Represents a Path expression in SPARQL
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.ISparqlPath.ToAlgebra(VDS.RDF.Query.Paths.PathTransformContext)">
            <summary>
            Converts a Path into its Algebra Form
            </summary>
            <param name="context">Path Transformation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Paths.ISparqlPath.ToString">
            <summary>
            Gets the String representation of a Path
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Paths.NegatedSet.#ctor(System.Collections.Generic.IEnumerable{VDS.RDF.Query.Paths.Property},System.Collections.Generic.IEnumerable{VDS.RDF.Query.Paths.Property})">
            <summary>
            Creates a new Negated Property Set
            </summary>
            <param name="properties">Negated Properties</param>
            <param name="inverseProperties">Inverse Negated Properties</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.NegatedSet.ToAlgebra(VDS.RDF.Query.Paths.PathTransformContext)">
            <summary>
            Converts a Path into its Algebra Form
            </summary>
            <param name="context">Path Transformation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Paths.NegatedSet.ToString">
            <summary>
            Gets the String representation of the Path
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Paths.NegatedSet.Properties">
            <summary>
            Gets the Negated Properties
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.NegatedSet.InverseProperties">
            <summary>
            Gets the Inverse Negated Properties
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Patterns.BindPattern">
            <summary>
            Class for representing BIND assignments in SPARQL Queries
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Patterns.IAssignmentPattern">
            <summary>
            Interface for Triple Patterns that represent Assignment operators
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.IAssignmentPattern.AssignExpression">
            <summary>
            Gets the Assignment Expression that is used
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.IAssignmentPattern.VariableName">
            <summary>
            Name of the Variable which is assigned to
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.BindPattern.#ctor(System.String,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new BIND Pattern
            </summary>
            <param name="var">Variable to assign to</param>
            <param name="expr">Expression which generates a value which will be assigned to the variable</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.BindPattern.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates a BIND assignment in the given Evaluation Context
            </summary>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.BindPattern.ToString">
            <summary>
            Gets the string representation of the LET assignment
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.BindPattern.CompareTo(VDS.RDF.Query.Patterns.BindPattern)">
            <summary>
            Compares this Bind to another Bind
            </summary>
            <param name="other">Bind to compare to</param>
            <returns>Just calls the base compare method since that implements all the logic we need</returns>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.BindPattern.CompareTo(VDS.RDF.Query.Patterns.IAssignmentPattern)">
            <summary>
            Compares this Bind to another Bind
            </summary>
            <param name="other">Bind to compare to</param>
            <returns>Just calls the base compare method since that implements all the logic we need</returns>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.BindPattern.PatternType">
            <summary>
            Gets the Pattern Type
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.BindPattern.IsAcceptAll">
            <summary>
            Returns that this is not an accept all since it is a BIND assignment
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.BindPattern.AssignExpression">
            <summary>
            Gets the Expression that is used to generate values to be assigned
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.BindPattern.VariableName">
            <summary>
            Gets the Name of the Variable to which values will be assigned
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.BindPattern.FixedVariables">
            <summary>
            Returns an empty enumeration as any evaluation error will result in an unbound value so we can't guarantee any variables are bound
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.BindPattern.FloatingVariables">
            <summary>
            Returns the variable being assigned to as any evaluation error will result in an unbound value so we can't guarantee it is bound
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.BindPattern.UsesDefaultDataset">
            <summary>
            Gets whether the Pattern uses the Default Dataset
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.BindPattern.HasNoBlankVariables">
            <summary>
            Returns true as a BIND can never contain a Blank Variable
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Patterns.BlankNodePattern">
            <summary>
            Pattern which matches temporary variables
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.BlankNodePattern.#ctor(System.String)">
            <summary>
            Creates a new Pattern representing a Blank Node
            </summary>
            <param name="name">Blank Node ID</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.BlankNodePattern.#ctor(System.String,System.Boolean)">
            <summary>
            Creates a new Pattern representing a Blank Node
            </summary>
            <param name="name">Blank Node ID</param>
            <param name="rigorousEvaluation">Whether to force rigorous evaluation</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.BlankNodePattern.Accepts(VDS.RDF.Query.SparqlEvaluationContext,VDS.RDF.INode)">
            <summary>
            Checks whether the given Node is a valid value for the Temporary Variable
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="obj">Node to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.BlankNodePattern.Construct(VDS.RDF.Query.Construct.ConstructContext)">
            <summary>
            Constructs a Node based on the given Set
            </summary>
            <param name="context">Construct Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.BlankNodePattern.ToString">
            <summary>
            Gets the String representation of this Pattern
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.BlankNodePattern.ID">
            <summary>
            Gets the Blank Node ID
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.BlankNodePattern.VariableName">
            <summary>
            Gets the Temporary Variable Name of this Pattern
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Patterns.FixedBlankNodePattern">
            <summary>
            Pattern which matches the Blank Node with the given Internal ID regardless of the Graph the nodes come from
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.FixedBlankNodePattern.#ctor(System.String)">
            <summary>
            Creates a new Fixed Blank Node Pattern
            </summary>
            <param name="id">ID</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.FixedBlankNodePattern.Accepts(VDS.RDF.Query.SparqlEvaluationContext,VDS.RDF.INode)">
            <summary>
            Checks whether the pattern accepts the given Node
            </summary>
            <param name="context">SPARQL Evaluation Context</param>
            <param name="obj">Node to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.FixedBlankNodePattern.Construct(VDS.RDF.Query.Construct.ConstructContext)">
            <summary>
            Returns a Blank Node with a fixed ID scoped to whichever graph is provided
            </summary>
            <param name="context">Construct Context</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.FixedBlankNodePattern.ToString">
            <summary>
            Gets the String representation of the Pattern Item
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.FixedBlankNodePattern.InternalID">
            <summary>
            Gets the Blank Node ID
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Patterns.NodeMatchPattern">
            <summary>
            Pattern which matches specific Nodes
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.NodeMatchPattern.#ctor(VDS.RDF.INode)">
            <summary>
            Creates a new Node Match Pattern
            </summary>
            <param name="n">Exact Node to match</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.NodeMatchPattern.#ctor(VDS.RDF.INode,System.Boolean)">
            <summary>
            Creates a new Node Match Pattern
            </summary>
            <param name="n">Exact Node to match</param>
            <param name="rigorousEvaluation">Whether to force rigorous evaluation regardless of the global setting</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.NodeMatchPattern.Accepts(VDS.RDF.Query.SparqlEvaluationContext,VDS.RDF.INode)">
            <summary>
            Checks whether the given Node matches the Node this pattern was instantiated with
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="obj">Node to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.NodeMatchPattern.Construct(VDS.RDF.Query.Construct.ConstructContext)">
            <summary>
            Constructs a Node based on the given Set
            </summary>
            <param name="context">Construct Context</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.NodeMatchPattern.ToString">
            <summary>
            Gets a String representation of the Node
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.NodeMatchPattern.Node">
            <summary>
            Gets the Node that this Pattern matches
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Patterns.VariablePattern">
            <summary>
            Pattern which matches Variables
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.VariablePattern.#ctor(System.String)">
            <summary>
            Creates a new Variable Pattern
            </summary>
            <param name="name">Variable name</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.VariablePattern.#ctor(System.String,System.Boolean)">
            <summary>
            Creates a new Variable Pattern
            </summary>
            <param name="name">Variable name</param>
            <param name="rigorousEvaluation">Whether to force rigorous evaluation</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.VariablePattern.Accepts(VDS.RDF.Query.SparqlEvaluationContext,VDS.RDF.INode)">
            <summary>
            Checks whether the given Node is a valid value for the Variable in the current Binding Context
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="obj">Node to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.VariablePattern.Construct(VDS.RDF.Query.Construct.ConstructContext)">
            <summary>
            Constructs a Node based on the given Set
            </summary>
            <param name="context">Construct Context</param>
            <returns>The Node which is bound to this Variable in this Solution</returns>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.VariablePattern.ToString">
            <summary>
            Gets the String representation of this pattern
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.VariablePattern.VariableName">
            <summary>
            Gets the Name of the Variable this Pattern matches
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.PelletQueryProcessor">
            <summary>
            A SPARQL Query Processor which processes queries by parsing them to the SPARQL Query Service of a Knowledge Base on a Pellet Server
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.PelletQueryProcessor.#ctor(VDS.RDF.Query.Inference.Pellet.PelletServer,System.String)">
            <summary>
            Creates a new Pellet Query Processor
            </summary>
            <param name="server">Pellet Server</param>
            <param name="kbName">Knowledge Base Name</param>
        </member>
        <member name="M:VDS.RDF.Query.PelletQueryProcessor.ProcessQuery(VDS.RDF.Query.SparqlQuery)">
            <summary>
            Processes a SPARQL Query
            </summary>
            <param name="query">SPARQL Query</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.PelletQueryProcessor.ProcessQuery(VDS.RDF.IRdfHandler,VDS.RDF.ISparqlResultsHandler,VDS.RDF.Query.SparqlQuery)">
            <summary>
            Processes a SPARQL Query passing the results to the RDF or Results handler as appropriate
            </summary>
            <param name="rdfHandler">RDF Handler</param>
            <param name="resultsHandler">Results Handler</param>
            <param name="query">SPARQL Query</param>
        </member>
        <member name="M:VDS.RDF.Query.PelletQueryProcessor.ProcessQuery(VDS.RDF.Query.SparqlQuery,VDS.RDF.GraphCallback,VDS.RDF.SparqlResultsCallback,System.Object)">
            <summary>
            Processes a SPARQL Query asynchronously invoking the relevant callback when the query completes
            </summary>
            <param name="query">SPARQL QUery</param>
            <param name="rdfCallback">Callback for queries that return a Graph</param>
            <param name="resultsCallback">Callback for queries that return a Result Set</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Query.PelletQueryProcessor.ProcessQuery(VDS.RDF.IRdfHandler,VDS.RDF.ISparqlResultsHandler,VDS.RDF.Query.SparqlQuery,VDS.RDF.QueryCallback,System.Object)">
            <summary>
            Processes a SPARQL Query asynchronously passing the results to the relevant handler and invoking the callback when the query completes
            </summary>
            <param name="rdfHandler">RDF Handler</param>
            <param name="resultsHandler">Results Handler</param>
            <param name="query">SPARQL Query</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.ServiceEndpoint">
            <summary>
            Represents the Service Endpoint for a Service provided by a Pellet Server
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.ServiceEndpoint.#ctor(Newtonsoft.Json.Linq.JObject)">
            <summary>
            Creates a new Service Endpoint instance
            </summary>
            <param name="obj">JSON Object representing the Endpoint</param>
        </member>
        <member name="P:VDS.RDF.Query.Inference.Pellet.ServiceEndpoint.Uri">
            <summary>
            Gets the URI of the Endpoint
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Inference.Pellet.ServiceEndpoint.HttpMethods">
            <summary>
            Gets the HTTP Methods supported by the Endpoint
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.KnowledgeBase">
            <summary>
            Represents a Knowledge Base on a Pellet Server
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.KnowledgeBase.#ctor(Newtonsoft.Json.Linq.JToken)">
            <summary>
            Creates a new Knowledge Base
            </summary>
            <param name="t">JSON Token for the Object that represents the Service</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.KnowledgeBase.SupportsService(System.Type)">
            <summary>
            Gets whether a Service is supported by the Knowledge Base
            </summary>
            <param name="t">Service Type</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.KnowledgeBase.SupportsService``1">
            <summary>
            Gets whether a Service is supported by the Knowledge Base
            </summary>
            <typeparam name="T">Service Type</typeparam>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.KnowledgeBase.SupportsService(System.String)">
            <summary>
            Gets whether a Service is supported by the Knowledge Base
            </summary>
            <param name="name">Service Name</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.KnowledgeBase.GetService(System.Type)">
            <summary>
            Gets the first available implementation of the given Service Type for this Knowledge Base
            </summary>
            <param name="t">Service Type</param>
            <returns>
            Either the Service or a Null if the Knowledge Base does not expose a Service of the given Type
            </returns>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.KnowledgeBase.GetService``1">
            <summary>
            Gets the first available implementation of the desired Service Type
            </summary>
            <typeparam name="T">Desired Service Type</typeparam>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.KnowledgeBase.GetService(System.String)">
            <summary>
            Gets the first available Service with the given name for this Knowledge Base
            </summary>
            <param name="name">Service Name</param>
            <returns>
            Either the Service or a Null if the Knowledge Base does not expose a Service with the given name
            </returns>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.KnowledgeBase.GetServices(System.Type)">
            <summary>
            Gets all the available implementations of the given Service Type for this Knowledge Base
            </summary>
            <param name="t">Service Type</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.KnowledgeBase.GetServices(System.String)">
            <summary>
            Gets all the available services with the given name for this Knowledge Base
            </summary>
            <param name="name">Service Name</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Inference.Pellet.KnowledgeBase.Name">
            <summary>
            Gets the Name of the Knowledge Base
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Inference.Pellet.KnowledgeBase.Services">
            <summary>
            Gets the Services provided by this Knowledge Base
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.PelletHelper">
            <summary>
            Helper class provided constants and helper methods for use with Pellet Server
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.Pellet.PelletHelper.ServiceServerDescription">
            <summary>
            Constants for Service Names for Services that may be provided by a Pellet Server
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.Pellet.PelletHelper.ServiceKBDescription">
            <summary>
            Constants for Service Names for Services that may be provided by a Pellet Server
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.Pellet.PelletHelper.ServiceRealize">
            <summary>
            Constants for Service Names for Services that may be provided by a Pellet Server
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.Pellet.PelletHelper.ServiceNamespaces">
            <summary>
            Constants for Service Names for Services that may be provided by a Pellet Server
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.Pellet.PelletHelper.ServiceQuery">
            <summary>
            Constants for Service Names for Services that may be provided by a Pellet Server
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.Pellet.PelletHelper.ServiceConsistency">
            <summary>
            Constants for Service Names for Services that may be provided by a Pellet Server
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.Pellet.PelletHelper.ServiceExplainUnsat">
            <summary>
            Constants for Service Names for Services that may be provided by a Pellet Server
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.Pellet.PelletHelper.ServiceExplainInstance">
            <summary>
            Constants for Service Names for Services that may be provided by a Pellet Server
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.Pellet.PelletHelper.ServiceClassify">
            <summary>
            Constants for Service Names for Services that may be provided by a Pellet Server
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.Pellet.PelletHelper.ServiceSearch">
            <summary>
            Constants for Service Names for Services that may be provided by a Pellet Server
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.Pellet.PelletHelper.ServiceExplainSubclass">
            <summary>
            Constants for Service Names for Services that may be provided by a Pellet Server
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.Pellet.PelletHelper.ServiceExplainInconsistent">
            <summary>
            Constants for Service Names for Services that may be provided by a Pellet Server
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.Pellet.PelletHelper.ServiceExplain">
            <summary>
            Constants for Service Names for Services that may be provided by a Pellet Server
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.Pellet.PelletHelper.ServiceExplainProperty">
            <summary>
            Constants for Service Names for Services that may be provided by a Pellet Server
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.Pellet.PelletHelper.ServiceIntegrityConstraintValidation">
            <summary>
            Constants for Service Names for Services that may be provided by a Pellet Server
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.Pellet.PelletHelper.ServicePredict">
            <summary>
            Constants for Service Names for Services that may be provided by a Pellet Server
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.Pellet.PelletHelper.ServiceCluster">
            <summary>
            Constants for Service Names for Services that may be provided by a Pellet Server
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.Pellet.PelletHelper.ServiceSimilarity">
            <summary>
            Constants for Service Names for Services that may be provided by a Pellet Server
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.PelletServer">
            <summary>
            Represents a Connection to a Pellet Server
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.Pellet.PelletServer.ServerDescriptionFormat">
            <summary>
            Preferred MIME Type for the format to retrieve the Server Description in
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.PelletServer.Connect(System.Uri,VDS.RDF.Query.Inference.Pellet.PelletServerReadyCallback,System.Object)">
            <summary>
            Connects to a Pellet Server instance asynchronously invoking the callback when the connection is ready
            </summary>
            <param name="serverUri">Server URI</param>
            <param name="callback">Callback to invoke when the connection is ready</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.PelletServer.Connect(System.String,VDS.RDF.Query.Inference.Pellet.PelletServerReadyCallback,System.Object)">
            <summary>
            Connects to a Pellet Server instance asynchronously invoking the callback when the connection is ready
            </summary>
            <param name="serverUri">Server URI</param>
            <param name="callback">Callback to invoke when the connection is ready</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.PelletServer.#ctor(System.Uri,VDS.RDF.Query.Inference.Pellet.PelletServerReadyCallback,System.Object)">
            <summary>
            Creates a new connection to a Pellet Server
            </summary>
            <param name="serverUri">Server URI</param>
            <param name="callback">Callback to invoke when the connection is ready</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.PelletServer.#ctor(System.String,VDS.RDF.Query.Inference.Pellet.PelletServerReadyCallback,System.Object)">
            <summary>
            Creates a new connection to a Pellet Server
            </summary>
            <param name="serverUri">Server URI</param>
            <param name="callback">Callback to invoke when the connection is ready</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.PelletServer.Discover(VDS.RDF.Query.Inference.Pellet.PelletServerReadyCallback,System.Object)">
            <summary>
            Discovers the Knowledge Bases on a Server asynchronously
            </summary>
            <param name="callback">Callback to invoke when the operation completes</param>
            <param name="state"></param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.PelletServer.HasKnowledgeBase(System.String)">
            <summary>
            Gets whether the Server has a Knowledge Base with the given Name
            </summary>
            <param name="name">Knowledge Base Name</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.PelletServer.HasKnowledgeBase(System.Type)">
            <summary>
            Gets whether the Server has a Knowledge Base which supports the given Service Type
            </summary>
            <param name="t">Service Type</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.PelletServer.GetKnowledgeBase(System.String)">
            <summary>
            Gets the Knowledge Base with the given Name
            </summary>
            <param name="name">Knowledge Base Name</param>
            <returns>
            </returns>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.PelletServer.GetKnowledgeBases(System.Type)">
            <summary>
            Gets all the Knowledge Bases which support a given Server
            </summary>
            <param name="t">Service Type</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Inference.Pellet.PelletServer.KnowledgeBases">
            <summary>
            Gets the Knowledge Bases available from this Pellet Server
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.Services.ClassifyService">
            <summary>
            Represents the Classify Service provided by a Pellet Server
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.ClassifyService.#ctor(System.String,Newtonsoft.Json.Linq.JObject)">
            <summary>
            Creates a new Classify Service
            </summary>
            <param name="name">Service Name</param>
            <param name="obj">JSON Object</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.ClassifyService.Classify(VDS.RDF.GraphCallback,System.Object)">
            <summary>
            Extracts the Graph which comprises the class hierarchy
            </summary>
            <param name="callback">Callback for when the operation completes</param>
            <param name="state">State to be passed to the callback</param>
            <remarks>
            If the operation succeeds the callback will be invoked normally, if there is an error the callback will be invoked with a instance of <see cref="T:VDS.RDF.AsyncError"/> passed as the state which provides access to the error message and the original state passed in.
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.Services.ConsistencyService">
            <summary>
            Represents the Consistency Service provided by a Pellet Server
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.ConsistencyService.#ctor(System.String,Newtonsoft.Json.Linq.JObject)">
            <summary>
            Creates a new Consistency Service
            </summary>
            <param name="name">Service Name</param>
            <param name="obj">JSON Object</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.ConsistencyService.IsConsistent(VDS.RDF.Query.Inference.Pellet.PelletConsistencyCallback,System.Object)">
            <summary>
            Determines whether the Knowledge Base is consistent
            </summary>
            <param name="callback">Callback to invoke when the operation completes</param>
            <param name="state">State to be passed to the callback</param>
            <remarks>
            If the operation succeeds the callback will be invoked normally, if there is an error the callback will be invoked with a instance of <see cref="T:VDS.RDF.AsyncError"/> passed as the state which provides access to the error message and the original state passed in.
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.Services.ExplainService">
            <summary>
            Represents the Explain Service provided by a Pellet Server
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Inference.Pellet.Services.ExplainService._baseQuery">
            <summary>
            Base Query for use with the Explain Service
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.ExplainService.#ctor(System.String,Newtonsoft.Json.Linq.JObject)">
            <summary>
            Creates a new Explain Service
            </summary>
            <param name="name">Service Name</param>
            <param name="obj">JSON Object</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.ExplainService.Explain(System.String,VDS.RDF.GraphCallback,System.Object)">
            <summary>
            Gets a Graph explaining the result of the SPARQL Query
            </summary>
            <param name="sparqlQuery">SPARQL Query</param>
            <param name="callback">Callback to invoke when the operation completes</param>
            <param name="state">State to pass to the callback</param>
            <remarks>
            If the operation succeeds the callback will be invoked normally, if there is an error the callback will be invoked with a instance of <see cref="T:VDS.RDF.AsyncError"/> passed as the state which provides access to the error message and the original state passed in.
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.Services.ExplainUnsatService">
            <summary>
            Represents the Explan Unsatisfiable Service provided by a Pellet Server
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.ExplainUnsatService.#ctor(System.String,Newtonsoft.Json.Linq.JObject)">
            <summary>
            Creates a new Explain Unsatisfiable Service
            </summary>
            <param name="name">Service Name</param>
            <param name="obj">JSON Object</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.ExplainUnsatService.ExplainUnsatisfiable(VDS.RDF.INode,VDS.RDF.GraphCallback,System.Object)">
            <summary>
            Gets a Graph explaining why a Class is unsatisfiable
            </summary>
            <param name="cls">Class</param>
            <param name="callback">Callback to invoke when the operation completes</param>
            <param name="state">State to pass to the callback</param>
            <remarks>
            If the operation succeeds the callback will be invoked normally, if there is an error the callback will be invoked with a instance of <see cref="T:VDS.RDF.AsyncError"/> passed as the state which provides access to the error message and the original state passed in.
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.Services.ExplainInstanceService">
            <summary>
            Represents the Explain Instance Service provided by a Pellet Server
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.ExplainInstanceService.#ctor(System.String,Newtonsoft.Json.Linq.JObject)">
            <summary>
            Creates a new Explain Instance Service
            </summary>
            <param name="name">Service Name</param>
            <param name="obj">JSON Object</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.ExplainInstanceService.ExplainInstance(VDS.RDF.INode,VDS.RDF.INode,VDS.RDF.GraphCallback,System.Object)">
            <summary>
            Gets a Graph explaining why an Instance is of the given Class
            </summary>
            <param name="instance">Instance</param>
            <param name="cls">Class</param>
            <param name="callback">Callback to invoke when the operation completes</param>
            <param name="state">State to pass to the callback</param>
            <remarks>
            If the operation succeeds the callback will be invoked normally, if there is an error the callback will be invoked with a instance of <see cref="T:VDS.RDF.AsyncError"/> passed as the state which provides access to the error message and the original state passed in.
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.Services.ExplainSubclassService">
            <summary>
            Represents the Explain Subclass Service provided by a Pellet Server
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.ExplainSubclassService.#ctor(System.String,Newtonsoft.Json.Linq.JObject)">
            <summary>
            Creates a new Explain Subclass Service
            </summary>
            <param name="name">Service Name</param>
            <param name="obj">JSON Object</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.ExplainSubclassService.ExplainSubclass(VDS.RDF.INode,VDS.RDF.INode,VDS.RDF.GraphCallback,System.Object)">
            <summary>
            Gets a Graph explaining why the given Class is a subclass of the given Super Class
            </summary>
            <param name="subclass">Class</param>
            <param name="superclass">Super Class</param>
            <param name="callback">Callback to invoke when the operation completes</param>
            <param name="state">State to pass to the callback</param>
            <remarks>
            If the operation succeeds the callback will be invoked normally, if there is an error the callback will be invoked with a instance of <see cref="T:VDS.RDF.AsyncError"/> passed as the state which provides access to the error message and the original state passed in.
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.Services.ExplainInconsistentService">
            <summary>
            Represents the Explain Inconsistent Service provided by a Pellet Server
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.ExplainInconsistentService.#ctor(System.String,Newtonsoft.Json.Linq.JObject)">
            <summary>
            Creates a new Explain Inconsistent Service
            </summary>
            <param name="name">Service Name</param>
            <param name="obj">JSON Object</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.ExplainInconsistentService.ExplainInconsistent(VDS.RDF.GraphCallback,System.Object)">
            <summary>
            Gets a Graph explaining why the Knowledge Base is inconsistent
            </summary>
            <param name="callback">Callback to invoke when the operation completes</param>
            <param name="state">State to pass to the callback</param>
            <remarks>
            If the operation succeeds the callback will be invoked normally, if there is an error the callback will be invoked with a instance of <see cref="T:VDS.RDF.AsyncError"/> passed as the state which provides access to the error message and the original state passed in.
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.Services.ExplainPropertyService">
            <summary>
            Represents the Explain Property Service provided by a Pellet Server
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.ExplainPropertyService.#ctor(System.String,Newtonsoft.Json.Linq.JObject)">
            <summary>
            Creates a new Explain Property Service
            </summary>
            <param name="name">Service Name</param>
            <param name="obj">JSON Object</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.ExplainPropertyService.ExplainProperty(VDS.RDF.INode,VDS.RDF.INode,VDS.RDF.INode,VDS.RDF.GraphCallback,System.Object)">
            <summary>
            Gets a Graph explaining why the given Triple was derived
            </summary>
            <param name="subj">Subject</param>
            <param name="pred">Predicate</param>
            <param name="obj">Object</param>
            <param name="callback">Callback to invoke when the operation completes</param>
            <param name="state">State to pass to the callback</param>
            <remarks>
            If the operation succeeds the callback will be invoked normally, if there is an error the callback will be invoked with a instance of <see cref="T:VDS.RDF.AsyncError"/> passed as the state which provides access to the error message and the original state passed in.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.ExplainPropertyService.ExplainProprety(VDS.RDF.Triple,VDS.RDF.GraphCallback,System.Object)">
            <summary>
            Gets a Graph explaining why the given Triple was derived
            </summary>
            <param name="t">Triple</param>
            <param name="callback">Callback to invoke when the operation completes</param>
            <param name="state">State to pass to the callback</param>
            <remarks>
            If the operation succeeds the callback will be invoked normally, if there is an error the callback will be invoked with a instance of <see cref="T:VDS.RDF.AsyncError"/> passed as the state which provides access to the error message and the original state passed in.
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.Services.QueryService">
            <summary>
            Represents the SPARQL Query Service provided by a Pellet Server knowledge base
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.QueryService.#ctor(System.String,Newtonsoft.Json.Linq.JObject)">
            <summary>
            Creates a new SPARQL Query Service
            </summary>
            <param name="name">Service Name</param>
            <param name="obj">JSON Object</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.QueryService.Query(System.String,VDS.RDF.GraphCallback,VDS.RDF.SparqlResultsCallback,System.Object)">
            <summary>
            Makes a SPARQL Query against the Knowledge Base
            </summary>
            <param name="sparqlQuery">SPARQL Query</param>
            <param name="graphCallback">Callback to invoke for queries that return a Graph</param>
            <param name="resultsCallback">Callback to invoke for queries that return a Result Set</param>
            <param name="state">State to pass to whichever callback function is invoked</param>
            <remarks>
            If the operation succeeds the callback will be invoked normally, if there is an error the callback will be invoked with a instance of <see cref="T:VDS.RDF.AsyncError"/> passed as the state which provides access to the error message and the original state passed in.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.QueryService.Query(VDS.RDF.IRdfHandler,VDS.RDF.ISparqlResultsHandler,System.String,VDS.RDF.QueryCallback,System.Object)">
            <summary>
            Processes a SPARQL Query against the Knowledge Base passing the results to the RDF or Results handler as appropriate
            </summary>
            <param name="rdfHandler">RDF Handler</param>
            <param name="resultsHandler">Results Handler</param>
            <param name="sparqlQuery">SPARQL Query</param>
            <param name="callback">Callback to invoke once handling of results has completed</param>
            <param name="state">State to pass to the callback</param>
            <remarks>
            If the operation succeeds the callback will be invoked normally, if there is an error the callback will be invoked with a instance of <see cref="T:VDS.RDF.AsyncError"/> passed as the state which provides access to the error message and the original state passed in.
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.Services.RealizeService">
            <summary>
            Represents the Realize Service provided by a Pellet Server
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.RealizeService.#ctor(System.String,Newtonsoft.Json.Linq.JObject)">
            <summary>
            Creates a new Realize Service
            </summary>
            <param name="name">Service Name</param>
            <param name="obj">JSON Object</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.RealizeService.Realize(VDS.RDF.GraphCallback,System.Object)">
            <summary>
            Gets the Graph which comprises the class hierarchy and individuals of those classes
            </summary>
            <param name="callback">Callback to invoke when the operation completes</param>
            <param name="state">State to pass to the callback</param>
            <remarks>
            If the operation succeeds the callback will be invoked normally, if there is an error the callback will be invoked with a instance of <see cref="T:VDS.RDF.AsyncError"/> passed as the state which provides access to the error message and the original state passed in.
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.Services.SearchService">
            <summary>
            Represents the Search Service provided by a Pellet Server
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.SearchService.#ctor(System.String,Newtonsoft.Json.Linq.JObject)">
            <summary>
            Creates a new Search Service
            </summary>
            <param name="name">Service Name</param>
            <param name="obj">JSON Object</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.SearchService.Search(System.String,VDS.RDF.Query.Inference.Pellet.PelletSearchServiceCallback,System.Object)">
            <summary>
            Gets the list of Search Results which match the given search term
            </summary>
            <param name="text">Search Term</param>
            <param name="callback">Callback to invoke when the operation completes</param>
            <param name="state">State to pass to the callback</param>
            <remarks>
            If the operation succeeds the callback will be invoked normally, if there is an error the callback will be invoked with a instance of <see cref="T:VDS.RDF.AsyncError"/> passed as the state which provides access to the error message and the original state passed in.
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.Services.SearchServiceResult">
            <summary>
            Represents a Search Result returned from the
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.SearchServiceResult.#ctor(VDS.RDF.INode,System.Double)">
            <summary>
            Creates a new Search Service Result
            </summary>
            <param name="node">Result Node</param>
            <param name="score">Result Score</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.SearchServiceResult.ToString">
            <summary>
            Gets the String representation of the Result
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Inference.Pellet.Services.SearchServiceResult.Node">
            <summary>
            Gets the Node for this Result
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Inference.Pellet.Services.SearchServiceResult.Score">
            <summary>
            Gets the Score for this Result
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.Services.UnsupportedService">
            <summary>
            Represents some Service provided by a Pellet Server which the library does not explicitly support
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Inference.Pellet.Services.UnsupportedService.#ctor(System.String,Newtonsoft.Json.Linq.JObject)">
            <summary>
            Creates a new Unsupported Service
            </summary>
            <param name="name">Service Name</param>
            <param name="obj">JSON Object</param>
        </member>
        <member name="T:VDS.RDF.Query.Paths.AlternativePath">
            <summary>
            Represents Alternative Paths
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Paths.BaseBinaryPath">
            <summary>
            Abstract Base Class for Binary Path operators
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Paths.BaseBinaryPath._lhs">
            <summary>
            Parts of the Path
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Paths.BaseBinaryPath._rhs">
            <summary>
            Parts of the Path
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.BaseBinaryPath.#ctor(VDS.RDF.Query.Paths.ISparqlPath,VDS.RDF.Query.Paths.ISparqlPath)">
            <summary>
            Creates a new Binary Path
            </summary>
            <param name="lhs">LHS Path</param>
            <param name="rhs">RHS Path</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.BaseBinaryPath.ToAlgebra(VDS.RDF.Query.Paths.PathTransformContext)">
            <summary>
            Converts a Path into its Algebra Form
            </summary>
            <param name="context">Path Transformation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Paths.BaseBinaryPath.ToString">
            <summary>
            Gets the String representation of the Path
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Paths.BaseBinaryPath.LhsPath">
            <summary>
            Gets the LHS Path component
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.BaseBinaryPath.RhsPath">
            <summary>
            Gets the RHS Path component
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.AlternativePath.#ctor(VDS.RDF.Query.Paths.ISparqlPath,VDS.RDF.Query.Paths.ISparqlPath)">
            <summary>
            Creates a new Alternative Path
            </summary>
            <param name="lhs">LHS Path</param>
            <param name="rhs">RHS Path</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.AlternativePath.ToString">
            <summary>
            Gets the String representation of the Path
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Paths.AlternativePath.ToAlgebra(VDS.RDF.Query.Paths.PathTransformContext)">
            <summary>
            Converts a Path into its Algebra Form
            </summary>
            <param name="context">Path Transformation Context</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Paths.BaseUnaryPath">
            <summary>
            Abstract Base Class for Unary Path operators
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Paths.BaseUnaryPath._path">
            <summary>
            Path
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.BaseUnaryPath.#ctor(VDS.RDF.Query.Paths.ISparqlPath)">
            <summary>
            Creates a new Unary Path
            </summary>
            <param name="path">Path</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.BaseUnaryPath.ToAlgebra(VDS.RDF.Query.Paths.PathTransformContext)">
            <summary>
            Converts a Path into its Algebra Form
            </summary>
            <param name="context">Path Transformation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Paths.BaseUnaryPath.ToString">
            <summary>
            Gets the String representation of the Path
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Paths.BaseUnaryPath.Path">
            <summary>
            Gets the Inner Path
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Paths.Cardinality">
            <summary>
            Represents a Cardinality restriction on a Path
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.Cardinality.#ctor(VDS.RDF.Query.Paths.ISparqlPath)">
            <summary>
            Creates a new Cardinality Restriction
            </summary>
            <param name="path">Path</param>
        </member>
        <member name="P:VDS.RDF.Query.Paths.Cardinality.MinCardinality">
            <summary>
            Gets the Minimum Cardinality of the Path
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.Cardinality.MaxCardinality">
            <summary>
            Gets the Maximum Cardinality of the Path
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Paths.FixedCardinality">
            <summary>
            Represents a Fixed Cardinality restriction on a Path
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.FixedCardinality.#ctor(VDS.RDF.Query.Paths.ISparqlPath,System.Int32)">
            <summary>
            Creates a new Fixed Cardinality restriction
            </summary>
            <param name="path">Path</param>
            <param name="n">N</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.FixedCardinality.ToAlgebra(VDS.RDF.Query.Paths.PathTransformContext)">
            <summary>
            Converts a Path into its Algebra Form
            </summary>
            <param name="context">Path Transformation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Paths.FixedCardinality.ToString">
            <summary>
            Gets the String representation of the Path
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Paths.FixedCardinality.MaxCardinality">
            <summary>
            Gets the Maximum Cardinality of the Path
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.FixedCardinality.MinCardinality">
            <summary>
            Gets the Minimum Cardinality of the Path
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Paths.ZeroOrMore">
            <summary>
            Represents a Zero or More cardinality restriction on a Path
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.ZeroOrMore.#ctor(VDS.RDF.Query.Paths.ISparqlPath)">
            <summary>
            Creates a new Zero or More cardinality restriction
            </summary>
            <param name="path">Path</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.ZeroOrMore.ToString">
            <summary>
            Gets the String representation of the Path
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Paths.ZeroOrMore.ToAlgebra(VDS.RDF.Query.Paths.PathTransformContext)">
            <summary>
            Converts a Path into its Algebra Form
            </summary>
            <param name="context">Path Transformation Context</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Paths.ZeroOrMore.MaxCardinality">
            <summary>
            Gets the Maximum Cardinality of the Path
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.ZeroOrMore.MinCardinality">
            <summary>
            Gets the Minimum Cardinality of the Path
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Paths.ZeroOrOne">
            <summary>
            Represents a Zero or One cardinality restriction on a Path
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.ZeroOrOne.#ctor(VDS.RDF.Query.Paths.ISparqlPath)">
            <summary>
            Creates a new Zero or One cardinality restriction
            </summary>
            <param name="path">Path</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.ZeroOrOne.ToString">
            <summary>
            Gets the String representation of the Path
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Paths.ZeroOrOne.ToAlgebra(VDS.RDF.Query.Paths.PathTransformContext)">
            <summary>
            Converts a Path into its Algebra Form
            </summary>
            <param name="context">Path Transformation Context</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Paths.ZeroOrOne.MaxCardinality">
            <summary>
            Gets the Maximum Cardinality of the Path
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.ZeroOrOne.MinCardinality">
            <summary>
            Gets the Minimum Cardinality of the Path
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Paths.OneOrMore">
            <summary>
            Represents a One or More cardinality restriction on a Path
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.OneOrMore.#ctor(VDS.RDF.Query.Paths.ISparqlPath)">
            <summary>
            Creates a new One or More cardinality restriction
            </summary>
            <param name="path">Path</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.OneOrMore.ToString">
            <summary>
            Gets the String representation of the Path
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Paths.OneOrMore.ToAlgebra(VDS.RDF.Query.Paths.PathTransformContext)">
            <summary>
            Converts a Path into its Algebra Form
            </summary>
            <param name="context">Path Transformation Context</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Paths.OneOrMore.MaxCardinality">
            <summary>
            Gets the Maximum Cardinality of the Path
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.OneOrMore.MinCardinality">
            <summary>
            Gets the Minimum Cardinality of the Path
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Paths.NOrMore">
            <summary>
            Represents a N or More cardinality restriction on a Path
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.NOrMore.#ctor(VDS.RDF.Query.Paths.ISparqlPath,System.Int32)">
            <summary>
            Creates a new N or More cardinality restriction
            </summary>
            <param name="path">Path</param>
            <param name="n">Minimum Cardinality</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.NOrMore.ToString">
            <summary>
            Gets the String representation of the Path
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Paths.NOrMore.ToAlgebra(VDS.RDF.Query.Paths.PathTransformContext)">
            <summary>
            Converts a Path into its Algebra Form
            </summary>
            <param name="context">Path Transformation Context</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Paths.NOrMore.MaxCardinality">
            <summary>
            Gets the Maximum Cardinality of the Path
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.NOrMore.MinCardinality">
            <summary>
            Gets the Minimum Cardinality of the Path
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Paths.ZeroToN">
            <summary>
            Represents a Zero to N cardinality restriction on a Path
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.ZeroToN.#ctor(VDS.RDF.Query.Paths.ISparqlPath,System.Int32)">
            <summary>
            Creates a new Zero to N cardinality restriction
            </summary>
            <param name="path">Path</param>
            <param name="n">Maximum Cardinality</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.ZeroToN.ToString">
            <summary>
            Gets the String representation of the Path
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Paths.ZeroToN.ToAlgebra(VDS.RDF.Query.Paths.PathTransformContext)">
            <summary>
            Converts a Path into its Algebra Form
            </summary>
            <param name="context">Path Transformation Context</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Paths.ZeroToN.MaxCardinality">
            <summary>
            Gets the Maximum Cardinality of the Path
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.ZeroToN.MinCardinality">
            <summary>
            Gets the Minimum Cardinality of the Path
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Paths.NToM">
            <summary>
            Represents a N to M cardinality restriction on a Path
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.NToM.#ctor(VDS.RDF.Query.Paths.ISparqlPath,System.Int32,System.Int32)">
            <summary>
            Creates a new N to M cardinality restriction
            </summary>
            <param name="path">Path</param>
            <param name="n">Minimum Cardinality</param>
            <param name="m">Maximum Cardinality</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.NToM.ToString">
            <summary>
            Gets the String representation of the Path
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Paths.NToM.ToAlgebra(VDS.RDF.Query.Paths.PathTransformContext)">
            <summary>
            Converts a Path into its Algebra Form
            </summary>
            <param name="context">Path Transformation Context</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Paths.NToM.MaxCardinality">
            <summary>
            Gets the Maximum Cardinality of the Path
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.NToM.MinCardinality">
            <summary>
            Gets the Minimum Cardinality of the Path
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Paths.InversePath">
            <summary>
            Represents an Inverse Path
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.InversePath.#ctor(VDS.RDF.Query.Paths.ISparqlPath)">
            <summary>
            Creates a new Inverse Path
            </summary>
            <param name="path">Path</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.InversePath.ToString">
            <summary>
            Gets the String representation of the Path
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Paths.InversePath.ToAlgebra(VDS.RDF.Query.Paths.PathTransformContext)">
            <summary>
            Converts a Path into its Algebra Form
            </summary>
            <param name="context">Path Transformation Context</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Paths.PotentialPath">
            <summary>
            Class representing a potential path used during the evaluation of complex property paths
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.PotentialPath.#ctor(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Creates a new Potential Path
            </summary>
            <param name="start">Start Point of the Path</param>
            <param name="current">Current Point on the Path</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.PotentialPath.#ctor(VDS.RDF.Query.Paths.PotentialPath)">
            <summary>
            Creates a new Potential Path which is a copy of an existing Path
            </summary>
            <param name="p">Potentuak Path</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.PotentialPath.GetHashCode">
            <summary>
            Gets the Hash Code for the potential path
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Paths.PotentialPath.Equals(System.Object)">
            <summary>
            Checks whether the other object is an equivalent potential path
            </summary>
            <param name="obj">Object to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Paths.PotentialPath.ToString">
            <summary>
            Gets the String representation of the path
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Paths.PotentialPath.Start">
            <summary>
            Gets the Start of the Path
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.PotentialPath.Current">
            <summary>
            Gets/Sets the Current Point of the Path - in the case of a complete Path this is the end of the Path
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.PotentialPath.IsComplete">
            <summary>
            Gets/Sets whether the Path is complete
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.PotentialPath.IsDeadEnd">
            <summary>
            Gets/Sets whether the Path is a dead-end
            </summary>
            <remarks>
            <para>
            This may be useful information as it can help stop us uneccessarily regenerating partial paths which are dead ends
            </para>
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.Paths.PotentialPath.IsPartial">
            <summary>
            Gets/Sets whether the Path is Partial
            </summary>
            <remarks>
            While this may seem something of a misnomer what this represents is that the path is only part of the overall path so in the case of a sequence path we'll make all incomplete paths from the first part of the sequence as partial so they can't be themselves completed but they can be used to form complete paths
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.Paths.PotentialPath.Length">
            <summary>
            Gets/Sets the Length of the Path
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Paths.PathEvaluationContext">
            <summary>
            Evaluation Context for evaluating complex property paths in SPARQL
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.PathEvaluationContext.#ctor(VDS.RDF.Query.SparqlEvaluationContext,VDS.RDF.Query.Patterns.PatternItem,VDS.RDF.Query.Patterns.PatternItem)">
            <summary>
            Creates a new Path Evaluation Context
            </summary>
            <param name="context">SPARQL Evaluation Context</param>
            <param name="end">Start point of the Path</param>
            <param name="start">End point of the Path</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.PathEvaluationContext.#ctor(VDS.RDF.Query.Paths.PathEvaluationContext)">
            <summary>
            Creates a new Path Evaluation Context copied from the given Context
            </summary>
            <param name="context">Path Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.PathEvaluationContext.AddPath(VDS.RDF.Query.Paths.PotentialPath)">
            <summary>
            Adds a new path to the list of current incomplete paths
            </summary>
            <param name="p">Path</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.PathEvaluationContext.AddCompletePath(VDS.RDF.Query.Paths.PotentialPath)">
            <summary>
            Adds a new path to the list of complete paths
            </summary>
            <param name="p">Path</param>
        </member>
        <member name="P:VDS.RDF.Query.Paths.PathEvaluationContext.SparqlContext">
            <summary>
            Gets the SPARQL Evaluation Context
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.PathEvaluationContext.IsFirst">
            <summary>
            Gets/Sets whether this is the first part of the Path to be evaluated
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.PathEvaluationContext.IsLast">
            <summary>
            Gets/Sets whether this is the last part of the Path to be evaluated
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.PathEvaluationContext.IsReversed">
            <summary>
            Gets/Sets whether the Path is currently reversed
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.PathEvaluationContext.Paths">
            <summary>
            Gets the hash set of incomplete paths generated so far
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.PathEvaluationContext.CompletePaths">
            <summary>
            Gets the hash set of complete paths generated so far
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.PathEvaluationContext.PathStart">
            <summary>
            Gets the pattern which is the start of the path
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.PathEvaluationContext.PathEnd">
            <summary>
            Gets the pattern which is the end of the path
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.PathEvaluationContext.CanAbortEarly">
            <summary>
            Gets whether pattern evaluation can be aborted early
            </summary>
            <remarks>
            Useful when both the start and end of the path are fixed (non-variables) which means that we can stop evaluating once we find the path (if it exists)
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.Paths.PathEvaluationContext.PermitsNewPaths">
            <summary>
            Gets/Sets whether new paths can be introduced when not evaluating the first part of the path
            </summary>
            <remarks>
            <para>
            This is required when we have a path like ?x foaf:knows* /foaf:knows ?y and ?x is not bound prior to the path being executed.  Since we permit zero-length paths we should return the names of everyone even if they don't know anyone
            </para>
            <para>
            The cases where ?x is already bound are handled elsewhere as we can just introduce zero-length paths for every existing binding for ?x
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.Paths.PathTransformContext">
            <summary>
            Transform Context class that is used in the Path to Algebra Transformation process
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.PathTransformContext.#ctor(VDS.RDF.Query.Patterns.PatternItem,VDS.RDF.Query.Patterns.PatternItem)">
            <summary>
            Creates a new Path Transform Context
            </summary>
            <param name="start">Subject that is the start of the Path</param>
            <param name="end">Object that is the end of the Path</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.PathTransformContext.#ctor(VDS.RDF.Query.Paths.PathTransformContext)">
            <summary>
            Creates a new Path Transform Context from an existing context
            </summary>
            <param name="context">Context</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.PathTransformContext.ToAlgebra">
            <summary>
            Returns the BGP that the Path Transform produces
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Paths.PathTransformContext.GetNextTemporaryVariable">
            <summary>
            Gets the next available temporary variable
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Paths.PathTransformContext.AddTriplePattern(VDS.RDF.Query.Patterns.ITriplePattern)">
            <summary>
            Adds a Triple Pattern to the Path Transform
            </summary>
            <param name="p">Triple Pattern</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.PathTransformContext.ResetObject">
            <summary>
            Resets the current Object to be the end Object of the Path
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.PathTransformContext.GetTriplePattern(VDS.RDF.Query.Patterns.PatternItem,VDS.RDF.Query.Paths.ISparqlPath,VDS.RDF.Query.Patterns.PatternItem)">
            <summary>
            Creates a Triple Pattern
            </summary>
            <param name="subj">Subject</param>
            <param name="path">Property Path</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Paths.PathTransformContext.NextID">
            <summary>
            Gets the Next ID to be used
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.PathTransformContext.Subject">
            <summary>
            Gets/Sets the Subject of the Triple Pattern at this point in the Path Transformation
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.PathTransformContext.Object">
            <summary>
            Gets/Sets the Object of the Triple Pattern at this point in the Path Transformation
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.PathTransformContext.End">
            <summary>
            Gets/Sets the Object at the end of the Pattern
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Paths.PathTransformContext.Top">
            <summary>
            Gets/Sets whether this is the Top Level Pattern
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Paths.Property">
            <summary>
            Represents a Predicate which is part of a Path
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.Property.#ctor(VDS.RDF.INode)">
            <summary>
            Creates a new Property
            </summary>
            <param name="predicate">Predicate</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.Property.Evaluate(VDS.RDF.Query.Paths.PathEvaluationContext)">
            <summary>
            Evaluates the Path using the given Path Evaluation Context
            </summary>
            <param name="context">Path Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.Property.ToString">
            <summary>
            Gets the String representation of the Path
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Paths.Property.ToAlgebra(VDS.RDF.Query.Paths.PathTransformContext)">
            <summary>
            Converts a Path into its Algebra Form
            </summary>
            <param name="context">Path Transformation Context</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Paths.Property.Predicate">
            <summary>
            Gets the Predicate this part of the Path represents
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Paths.SequencePath">
            <summary>
            Represents a standard forwards path
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Paths.SequencePath.#ctor(VDS.RDF.Query.Paths.ISparqlPath,VDS.RDF.Query.Paths.ISparqlPath)">
            <summary>
            Creates a new Sequence Path
            </summary>
            <param name="lhs">LHS Path</param>
            <param name="rhs">RHS Path</param>
        </member>
        <member name="M:VDS.RDF.Query.Paths.SequencePath.ToString">
            <summary>
            Gets the String representation of the Path
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Paths.SequencePath.ToAlgebra(VDS.RDF.Query.Paths.PathTransformContext)">
            <summary>
            Converts a Path into its Algebra Form
            </summary>
            <param name="context">Path Transformation Context</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Patterns.BindingsPattern">
            <summary>
            Represents a set of Bindings for a SPARQL Query or part thereof i.e. represents the VALUES clause
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.BindingsPattern.#ctor">
            <summary>
            Creates a new Empty Bindings Pattern
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.BindingsPattern.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a new Bindings Pattern
            </summary>
            <param name="vars">Variables</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.BindingsPattern.AddTuple(VDS.RDF.Query.Patterns.BindingTuple)">
            <summary>
            Adds a Tuple to the Bindings pattern
            </summary>
            <param name="t"></param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.BindingsPattern.ToMultiset">
            <summary>
            Converts a Bindings Clause to a Multiset
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.BindingsPattern.ToString">
            <summary>
            Gets the String representation of the Pattern
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.BindingsPattern.Variables">
            <summary>
            Gets the enumeration of Variables
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.BindingsPattern.FixedVariables">
            <summary>
            Get the enumeration of fixed variables i.e. those guaranteed to be bound
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.BindingsPattern.FloatingVariables">
            <summary>
            Gets the enumeration of floating variables i.e. those not guaranteed to be bound
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.BindingsPattern.Tuples">
            <summary>
            Gets the enumeration of Tuples
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Patterns.BindingTuple">
            <summary>
            Represents a Tuple in a BINDINGS clause
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.BindingTuple.#ctor(System.Collections.Generic.List{System.String},System.Collections.Generic.List{VDS.RDF.Query.Patterns.PatternItem})">
            <summary>
            Creates a new Binding Tuple
            </summary>
            <param name="variables">Variables</param>
            <param name="values">Values</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.BindingTuple.IsBound(System.String)">
            <summary>
            Gets whether the given variable is bound for this tuple i.e. is not UNDEF
            </summary>
            <param name="var">Variable</param>
            <returns>True if the variable exists in the tuple and is bound, false otherwise</returns>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.BindingTuple.ToString">
            <summary>
            Gets the String representation of the Tuple
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.BindingTuple.Values">
            <summary>
            Gets the enumeration of Variable-Value pairs
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.BindingTuple.Item(System.String)">
            <summary>
            Gets the Value for a Variable
            </summary>
            <param name="var">Variable</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.BindingTuple.IsEmpty">
            <summary>
            Gets whether this is an empty tuple
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.BindingTuple.IsComplete">
            <summary>
            Gets whether the Tuple is complete i.e. has no undefined entries
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Patterns.FilterPattern">
            <summary>
            Class for representing Filter Patterns in SPARQL Queries
            </summary>
            <remarks>
            A Filter Pattern is any FILTER clause that can be executed during the process of executing Triple Patterns rather than after all the Triple Patterns and Child Graph Patterns have been executed
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.Patterns.IFilterPattern">
            <summary>
            Interface for Triple Patterns that apply filters
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.IFilterPattern.Filter">
            <summary>
            Gets the filter to apply
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.FilterPattern.#ctor(VDS.RDF.Query.Filters.ISparqlFilter)">
            <summary>
            Creates a new Filter Pattern with the given Filter
            </summary>
            <param name="filter">Filter</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.FilterPattern.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates a Filter in the given Evaluation Context
            </summary>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.FilterPattern.CompareTo(VDS.RDF.Query.Patterns.FilterPattern)">
            <summary>
            Compares a filter pattern to another
            </summary>
            <param name="other">Pattern</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.FilterPattern.CompareTo(VDS.RDF.Query.Patterns.IFilterPattern)">
            <summary>
            Compares a filter pattern to another
            </summary>
            <param name="other">Pattern</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.FilterPattern.ToString">
            <summary>
            Returns the string representation of the Pattern
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.FilterPattern.PatternType">
            <summary>
            Gets the Pattern Type
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.FilterPattern.IsAcceptAll">
            <summary>
            Returns that the Pattern is not an accept all (since it's a Filter)
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.FilterPattern.Filter">
            <summary>
            Gets the Filter that this Pattern uses
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.FilterPattern.FixedVariables">
            <summary>
            Returns the empty enumerable as don't know which variables will be bound
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.FilterPattern.FloatingVariables">
            <summary>
            Returns the empty enumerable as don't know which variables will be bound
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.FilterPattern.UsesDefaultDataset">
            <summary>
            Gets whether the Pattern uses the Default Dataset
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.FilterPattern.HasNoBlankVariables">
            <summary>
            Returns true as a FILTER cannot contain blank variables
            </summary>
            <remarks>
            Technically blank nodes may appear in a FILTER as part of an EXISTS/NOT EXISTS clause but in that case they would not be visible outside of the FILTER and so are not relevant
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.Patterns.ISubQueryPattern">
            <summary>
            Interface for Triple Patterns that do sub-queries
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.ISubQueryPattern.SubQuery">
            <summary>
            Gets the sub-query
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Patterns.IPropertyPathPattern">
            <summary>
            Interface for Triple Patterns that do property paths
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.IPropertyPathPattern.Subject">
            <summary>
            Gets the Subject of the Pattern
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.IPropertyPathPattern.Path">
            <summary>
            Gets the property path
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.IPropertyPathPattern.Object">
            <summary>
            Gets the Object of the Pattern
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Patterns.LetPattern">
            <summary>
            Class for representing LET Patterns in SPARQL Queries
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.LetPattern.#ctor(System.String,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new LET Pattern
            </summary>
            <param name="var">Variable to assign to</param>
            <param name="expr">Expression which generates a value which will be assigned to the variable</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.LetPattern.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates a LET assignment in the given Evaluation Context
            </summary>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.LetPattern.ToString">
            <summary>
            Gets the string representation of the LET assignment
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.LetPattern.CompareTo(VDS.RDF.Query.Patterns.LetPattern)">
            <summary>
            Compares this Let to another Let
            </summary>
            <param name="other">Let to compare to</param>
            <returns>Just calls the base compare method since that implements all the logic we need</returns>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.LetPattern.CompareTo(VDS.RDF.Query.Patterns.IAssignmentPattern)">
            <summary>
            Compares this Let to another Let
            </summary>
            <param name="other">Let to compare to</param>
            <returns>Just calls the base compare method since that implements all the logic we need</returns>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.LetPattern.PatternType">
            <summary>
            Gets the Pattern Type
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.LetPattern.IsAcceptAll">
            <summary>
            Returns that this is not an accept all since it is a LET assignment
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.LetPattern.AssignExpression">
            <summary>
            Gets the Expression that is used to generate values to be assigned
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.LetPattern.VariableName">
            <summary>
            Gets the Name of the Variable to which values will be assigned
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.LetPattern.FixedVariables">
            <summary>
            Returns an empty enumeration as any evaluation error will result in an unbound value so we can't guarantee any variables are bound
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.LetPattern.FloatingVariables">
            <summary>
            Returns the variable being assigned to as any evaluation error will result in an unbound value so we can't guarantee it is bound
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.LetPattern.UsesDefaultDataset">
            <summary>
            Gets whether the Pattern uses the Default Dataset
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.LetPattern.HasNoBlankVariables">
            <summary>
            Returns true as a LET can never contain Blank Nodes
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Patterns.PropertyPathPattern">
            <summary>
            Class for representing property patterns in SPARQL Queries
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.PropertyPathPattern.#ctor(VDS.RDF.Query.Patterns.PatternItem,VDS.RDF.Query.Paths.ISparqlPath,VDS.RDF.Query.Patterns.PatternItem)">
            <summary>
            Creates a new Property Path Pattern
            </summary>
            <param name="subj">Subject</param>
            <param name="path">Property Path</param>
            <param name="obj">Object</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.PropertyPathPattern.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates a property path pattern
            </summary>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.PropertyPathPattern.CompareTo(VDS.RDF.Query.Patterns.PropertyPathPattern)">
            <summary>
            Compares a property path pattern to another
            </summary>
            <param name="other">Pattern</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.PropertyPathPattern.CompareTo(VDS.RDF.Query.Patterns.IPropertyPathPattern)">
            <summary>
            Compares a property path pattern to another
            </summary>
            <param name="other">Pattern</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.PropertyPathPattern.ToString">
            <summary>
            Gets the String representation of the Pattern
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.PropertyPathPattern.PatternType">
            <summary>
            Gets the pattern type
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.PropertyPathPattern.Subject">
            <summary>
            Gets the Subject of the Property Path
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.PropertyPathPattern.Path">
            <summary>
            Gets the Property Path
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.PropertyPathPattern.Object">
            <summary>
            Gets the Object of the Property Path
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.PropertyPathPattern.IsAcceptAll">
            <summary>
            Gets whether the Pattern accepts all Triple Patterns
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.PropertyPathPattern.HasNoBlankVariables">
            <summary>
            Returns false a property path may always contain implicit blank variables
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Patterns.SubQueryPattern">
            <summary>
            Class for representing Sub-queries which occur as part of a SPARQL query
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.SubQueryPattern.#ctor(VDS.RDF.Query.SparqlQuery)">
            <summary>
            Creates a new Sub-query pattern which represents the given sub-query
            </summary>
            <param name="subquery">Sub-query</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.SubQueryPattern.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Evaluates a Sub-query in the given Evaluation Context
            </summary>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.SubQueryPattern.CompareTo(VDS.RDF.Query.Patterns.SubQueryPattern)">
            <summary>
            Compares a sub-query pattern to another
            </summary>
            <param name="other">Pattern</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.SubQueryPattern.CompareTo(VDS.RDF.Query.Patterns.ISubQueryPattern)">
            <summary>
            Compares a sub-query pattern to another
            </summary>
            <param name="other">Pattern</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Patterns.SubQueryPattern.ToString">
            <summary>
            Gets the string representation of the sub-query
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.SubQueryPattern.SubQuery">
            <summary>
            Gets the Sub-Query
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.SubQueryPattern.FloatingVariables">
            <summary>
            Gets the enumeration of floating variables in the algebra i.e. variables that are not guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.SubQueryPattern.FixedVariables">
            <summary>
            Gets the enumeration of fixed variables in the algebra i.e. variables that are guaranteed to have a bound value
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.SubQueryPattern.PatternType">
            <summary>
            Gets the pattern type
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.SubQueryPattern.IsAcceptAll">
            <summary>
            Returns that the Pattern is not an accept all since it is a Sub-query
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.SubQueryPattern.UsesDefaultDataset">
            <summary>
            Gets whether the Sub-query is Thread Safe
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Patterns.SubQueryPattern.HasNoBlankVariables">
            <summary>
            Returns true as while a sub-query may contain blank node variables they will not be in scope here
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.XPathFunctionFactory">
            <summary>
            Expression Factory which generates XPath Function expressions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.XPathFunctionsNamespace">
            <summary>
            Namespace Uri for XPath Functions Namespace
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.Not">
            <summary>
            Constant representing the XPath boolean functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.Boolean">
            <summary>
            Constant representing the XPath boolean functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.Matches">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.Contains">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.StartsWith">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.EndsWith">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.StringLength">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.Concat">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.Substring">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.NormalizeSpace">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.NormalizeUnicode">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.UpperCase">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.LowerCase">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.EncodeForURI">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.SubstringBefore">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.SubstringAfter">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.Replace">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.Translate">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.Compare">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.StringJoin">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.EscapeHtmlURI">
            <summary>
            Constants representing the names of XPath String functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.True">
            <summary>
            Constants representing the XPath Boolean constructor functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.False">
            <summary>
            Constants representing the XPath Boolean constructor functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.Absolute">
            <summary>
            Constants representing the XPath Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.Ceiling">
            <summary>
            Constants representing the XPath Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.Floor">
            <summary>
            Constants representing the XPath Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.Round">
            <summary>
            Constants representing the XPath Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.RoundHalfToEven">
            <summary>
            Constants representing the XPath Numeric Functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.YearFromDateTime">
            <summary>
            Constants representing the XPath Date Time functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.MonthFromDateTime">
            <summary>
            Constants representing the XPath Date Time functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.DayFromDateTime">
            <summary>
            Constants representing the XPath Date Time functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.HoursFromDateTime">
            <summary>
            Constants representing the XPath Date Time functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.MinutesFromDateTime">
            <summary>
            Constants representing the XPath Date Time functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.SecondsFromDateTime">
            <summary>
            Constants representing the XPath Date Time functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.TimezoneFromDateTime">
            <summary>
            Constants representing the XPath Date Time functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.AdjustDateTimeToTimezone">
            <summary>
            Constants representing the XPath Date Time functions
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.XPathUnicodeNormalizationFormC">
            <summary>
            Constants representing the Normalization Form values supported by the XPath normalize-unicode() function
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.XPathUnicodeNormalizationFormD">
            <summary>
            Constants representing the Normalization Form values supported by the XPath normalize-unicode() function
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.XPathUnicodeNormalizationFormKC">
            <summary>
            Constants representing the Normalization Form values supported by the XPath normalize-unicode() function
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.XPathUnicodeNormalizationFormKD">
            <summary>
            Constants representing the Normalization Form values supported by the XPath normalize-unicode() function
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.XPathUnicodeNormalizationFormFull">
            <summary>
            Constants representing the Normalization Form values supported by the XPath normalize-unicode() function
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.AcceptStringArguments">
            <summary>
            Argument Type Validator for validating that a Literal either has no datatype or is a String
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.AcceptIntegerArguments">
            <summary>
            Argument Type Validator for validating that a Literal has an Integer datatype
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.XPathFunctionFactory.AcceptNumericArguments">
            <summary>
            Argument Type Validator for validating that a Literal has a Numeric datatype
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Expressions.XPathFunctionFactory.TryCreateExpression(System.Uri,System.Collections.Generic.List{VDS.RDF.Query.Expressions.ISparqlExpression},System.Collections.Generic.Dictionary{System.String,VDS.RDF.Query.Expressions.ISparqlExpression},VDS.RDF.Query.Expressions.ISparqlExpression@)">
            <summary>
            Tries to create an XPath Function expression if the function Uri correseponds to a supported XPath Function
            </summary>
            <param name="u">Function Uri</param>
            <param name="args">Function Arguments</param>
            <param name="scalarArgs">Scalar Arguments</param>
            <param name="expr">Generated Expression</param>
            <returns>Whether an expression was successfully generated</returns>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.XPathFunctionFactory.AvailableExtensionFunctions">
            <summary>
            Gets the Extension Function URIs supported by this Factory
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Expressions.XPathFunctionFactory.AvailableExtensionAggregates">
            <summary>
            Gets the Extension Aggregate URIs supported by this Factory
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.QueryExtensions">
            <summary>
            Static Helper class containing extension methods related to queries
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.QueryExtensions.UsesDefaultDataset(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Determines whether an Expresion uses the Default Dataset
            </summary>
            <param name="expr">Expression</param>
            <returns></returns>
            <remarks>
            Almost all Expressions use the Default Dataset.  The only ones that does are EXISTS/NOT EXISTS expressions where the graph pattern does not use the default dataset
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.SimpleQueryProcessor">
            <summary>
            A SPARQL Query Processor where the query is processed by passing it to the <see cref="M:VDS.RDF.INativelyQueryableStore.ExecuteQuery(System.String)">ExecuteQuery()</see> method of an <see cref="T:VDS.RDF.INativelyQueryableStore">INativelyQueryableStore</see>
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SimpleQueryProcessor.#ctor(VDS.RDF.INativelyQueryableStore)">
            <summary>
            Creates a new Simple Query Processor
            </summary>
            <param name="store">Triple Store</param>
        </member>
        <member name="M:VDS.RDF.Query.SimpleQueryProcessor.ProcessQuery(VDS.RDF.Query.SparqlQuery)">
            <summary>
            Processes a SPARQL Query
            </summary>
            <param name="query">SPARQL Query</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SimpleQueryProcessor.ProcessQuery(VDS.RDF.IRdfHandler,VDS.RDF.ISparqlResultsHandler,VDS.RDF.Query.SparqlQuery)">
            <summary>
            Processes a SPARQL Query passing the results to the RDF or Results handler as appropriate
            </summary>
            <param name="rdfHandler">RDF Handler</param>
            <param name="resultsHandler">Results Handler</param>
            <param name="query">SPARQL Query</param>
        </member>
        <member name="M:VDS.RDF.Query.SimpleQueryProcessor.ProcessQuery(VDS.RDF.Query.SparqlQuery,VDS.RDF.GraphCallback,VDS.RDF.SparqlResultsCallback,System.Object)">
            <summary>
            Processes a SPARQL Query asynchronously invoking the relevant callback when the query completes
            </summary>
            <param name="query">SPARQL QUery</param>
            <param name="rdfCallback">Callback for queries that return a Graph</param>
            <param name="resultsCallback">Callback for queries that return a Result Set</param>
            <param name="state">State to pass to the callback</param>
            <remarks>
            In the event of a success the appropriate callback will be invoked, if there is an error both callbacks will be invoked and passed an instance of <see cref="T:VDS.RDF.AsyncError"/> which contains details of the error and the original state information passed in.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.SimpleQueryProcessor.ProcessQuery(VDS.RDF.IRdfHandler,VDS.RDF.ISparqlResultsHandler,VDS.RDF.Query.SparqlQuery,VDS.RDF.QueryCallback,System.Object)">
            <summary>
            Processes a SPARQL Query asynchronously passing the results to the relevant handler and invoking the callback when the query completes
            </summary>
            <param name="rdfHandler">RDF Handler</param>
            <param name="resultsHandler">Results Handler</param>
            <param name="query">SPARQL Query</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
            <remarks>
            In the event of a success the callback will be invoked normally, if there is an error the callback will be invoked and passed an instance of <see cref="T:VDS.RDF.AsyncError"/> which contains details of the error and the original state information passed in.
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.SimpleQueryProcessor.ProcessQueryAsync">
            <summary>
            Delegate used for asychronous execution
            </summary>
            <param name="rdfHandler">RDF Handler</param>
            <param name="resultsHandler">Results Handler</param>
            <param name="query">SPARQL Query</param>
        </member>
        <member name="T:VDS.RDF.Query.GenericQueryProcessor">
            <summary>
            A SPARQL Query Processor where the query is processed by passing it to the <see cref="M:VDS.RDF.Storage.IQueryableStorage.Query(System.String)">Query()</see> method of an <see cref="T:VDS.RDF.Storage.IQueryableStorage">IQueryableStorage</see>
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.GenericQueryProcessor.#ctor(VDS.RDF.Storage.IQueryableStorage)">
            <summary>
            Creates a new Generic Query Processor
            </summary>
            <param name="manager">Generic IO Manager</param>
        </member>
        <member name="M:VDS.RDF.Query.GenericQueryProcessor.ProcessQuery(VDS.RDF.Query.SparqlQuery)">
            <summary>
            Processes a SPARQL Query
            </summary>
            <param name="query">SPARQL Query</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.GenericQueryProcessor.ProcessQuery(VDS.RDF.IRdfHandler,VDS.RDF.ISparqlResultsHandler,VDS.RDF.Query.SparqlQuery)">
            <summary>
            Processes a SPARQL Query passing the results to the RDF or Results handler as appropriate
            </summary>
            <param name="rdfHandler">RDF Handler</param>
            <param name="resultsHandler">Results Handler</param>
            <param name="query">SPARQL Query</param>
        </member>
        <member name="M:VDS.RDF.Query.GenericQueryProcessor.ProcessQuery(VDS.RDF.Query.SparqlQuery,VDS.RDF.GraphCallback,VDS.RDF.SparqlResultsCallback,System.Object)">
            <summary>
            Processes a SPARQL Query asynchronously invoking the relevant callback when the query completes
            </summary>
            <param name="query">SPARQL QUery</param>
            <param name="rdfCallback">Callback for queries that return a Graph</param>
            <param name="resultsCallback">Callback for queries that return a Result Set</param>
            <param name="state">State to pass to the callback</param>
            <remarks>
            In the event of a success the appropriate callback will be invoked, if there is an error both callbacks will be invoked and passed an instance of <see cref="T:VDS.RDF.AsyncError"/> which contains details of the error and the original state information passed in.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.GenericQueryProcessor.ProcessQuery(VDS.RDF.IRdfHandler,VDS.RDF.ISparqlResultsHandler,VDS.RDF.Query.SparqlQuery,VDS.RDF.QueryCallback,System.Object)">
            <summary>
            Processes a SPARQL Query asynchronously passing the results to the relevant handler and invoking the callback when the query completes
            </summary>
            <param name="rdfHandler">RDF Handler</param>
            <param name="resultsHandler">Results Handler</param>
            <param name="query">SPARQL Query</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
            <remarks>
            In the event of a success the callback will be invoked, if there is an error the callback will be invoked and passed an instance of <see cref="T:VDS.RDF.AsyncError"/> which contains details of the error and the original state information passed in.
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.GenericQueryProcessor.ProcessQueryAsync">
            <summary>
            Delegate used for asychronous execution
            </summary>
            <param name="rdfHandler">RDF Handler</param>
            <param name="resultsHandler">Results Handler</param>
            <param name="query">SPARQL Query</param>
        </member>
        <member name="T:VDS.RDF.Query.RemoteQueryProcessor">
            <summary>
            A SPARQL Query Processor where the query is processed by passing it to a remote SPARQL endpoint
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.RemoteQueryProcessor.#ctor(VDS.RDF.Query.SparqlRemoteEndpoint)">
            <summary>
            Creates a new Remote Query Processor
            </summary>
            <param name="endpoint">SPARQL Endpoint</param>
        </member>
        <member name="M:VDS.RDF.Query.RemoteQueryProcessor.ProcessQuery(VDS.RDF.Query.SparqlQuery)">
            <summary>
            Processes a SPARQL Query
            </summary>
            <param name="query">SPARQL Query</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.RemoteQueryProcessor.ProcessQuery(VDS.RDF.IRdfHandler,VDS.RDF.ISparqlResultsHandler,VDS.RDF.Query.SparqlQuery)">
            <summary>
            Processes a SPARQL Query passing the results to the RDF or Results handler as appropriate
            </summary>
            <param name="rdfHandler">RDF Handler</param>
            <param name="resultsHandler">Results Handler</param>
            <param name="query">SPARQL Query</param>
        </member>
        <member name="M:VDS.RDF.Query.RemoteQueryProcessor.ProcessQuery(VDS.RDF.Query.SparqlQuery,VDS.RDF.GraphCallback,VDS.RDF.SparqlResultsCallback,System.Object)">
            <summary>
            Processes a SPARQL Query asynchronously invoking the relevant callback when the query completes
            </summary>
            <param name="query">SPARQL QUery</param>
            <param name="rdfCallback">Callback for queries that return a Graph</param>
            <param name="resultsCallback">Callback for queries that return a Result Set</param>
            <param name="state">State to pass to the callback</param>
            <remarks>
            In the event of a success the appropriate callback will be invoked, if there is an error both callbacks will be invoked and passed an instance of <see cref="T:VDS.RDF.AsyncError"/> which contains details of the error and the original state information passed in.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.RemoteQueryProcessor.ProcessQuery(VDS.RDF.IRdfHandler,VDS.RDF.ISparqlResultsHandler,VDS.RDF.Query.SparqlQuery,VDS.RDF.QueryCallback,System.Object)">
            <summary>
            Processes a SPARQL Query asynchronously passing the results to the relevant handler and invoking the callback when the query completes
            </summary>
            <param name="rdfHandler">RDF Handler</param>
            <param name="resultsHandler">Results Handler</param>
            <param name="query">SPARQL Query</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
            <remarks>
            In the event of a success the callback will be invoked, if there is an error the callback will be invoked and passed an instance of <see cref="T:VDS.RDF.AsyncError"/> which contains details of the error and the original state information passed in.
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.SparqlEvaluationContext">
            <summary>
            Stores information about the Evaluation of a Query during it's evaluation
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SparqlEvaluationContext.#ctor(VDS.RDF.Query.SparqlQuery,VDS.RDF.Query.Datasets.ISparqlDataset)">
            <summary>
            Creates a new Evaluation Context for the given Query over the given Dataset
            </summary>
            <param name="q">Query</param>
            <param name="data">Dataset</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlEvaluationContext.#ctor(VDS.RDF.Query.SparqlQuery,VDS.RDF.Query.Datasets.ISparqlDataset,VDS.RDF.Query.ISparqlQueryAlgebraProcessor{VDS.RDF.Query.Algebra.BaseMultiset,VDS.RDF.Query.SparqlEvaluationContext})">
            <summary>
            Creates a new Evaluation Context for the given Query over the given Dataset using a specific processor
            </summary>
            <param name="q">Query</param>
            <param name="data">Dataset</param>
            <param name="processor">Query Processor</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlEvaluationContext.#ctor(VDS.RDF.Query.SparqlResultBinder)">
            <summary>
            Creates a new Evaluation Context which is a Container for the given Result Binder
            </summary>
            <param name="binder"></param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlEvaluationContext.StartExecution">
            <summary>
            Starts the Execution Timer
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SparqlEvaluationContext.EndExecution">
            <summary>
            Ends the Execution Timer
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SparqlEvaluationContext.CheckTimeout">
            <summary>
            Checks whether Execution should Time out
            </summary>
            <exception cref="T:VDS.RDF.Query.RdfQueryTimeoutException">Thrown if the Query has exceeded the Execution Timeout</exception>
        </member>
        <member name="M:VDS.RDF.Query.SparqlEvaluationContext.Evaluate(VDS.RDF.Query.Algebra.ISparqlAlgebra)">
            <summary>
            Evalutes an Algebra Operator in this Context using the current Query Processor (if any) or the default <see cref="M:VDS.RDF.Query.Algebra.ISparqlAlgebra.Evaluate(VDS.RDF.Query.SparqlEvaluationContext)">Evaluate()</see> method
            </summary>
            <param name="algebra">Algebra</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.SparqlEvaluationContext.Query">
            <summary>
            Gets the Query that is being evaluated
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlEvaluationContext.Data">
            <summary>
            Gets the Dataset the query is over
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlEvaluationContext.Processor">
            <summary>
            Gets the custom query processor that is in use (if any)
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlEvaluationContext.InputMultiset">
            <summary>
            Gets/Sets the Input Multiset
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlEvaluationContext.OutputMultiset">
            <summary>
            Gets/Sets the Output Multiset
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlEvaluationContext.Binder">
            <summary>
            Gets/Sets the Results Binder
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlEvaluationContext.TrimTemporaryVariables">
            <summary>
            Gets/Sets whether BGPs should trim temporary variables
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlEvaluationContext.RemainingTimeout">
            <summary>
            Gets the Remaining Timeout i.e. the Timeout taking into account time already elapsed
            </summary>
            <remarks>
            If there is no timeout then this is always zero, if there is a timeout this is always >= 1 since any operation that wants to respect the timeout must have a non-zero timeout to actually timeout properly.
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.SparqlEvaluationContext.QueryTimeout">
            <summary>
            Gets the Query Timeout used for the Query
            </summary>
            <remarks>
            <para>
            This is taken either from the <see cref="P:VDS.RDF.Query.SparqlQuery.Timeout">Timeout</see> property of the <see cref="T:VDS.RDF.Query.SparqlQuery">SparqlQuery</see> to which this evaluation context pertains (if any) or from the global option <see cref="P:VDS.RDF.Options.QueryExecutionTimeout">Options.QueryExecutionTimeout</see>.  To set the Timeout to be used set whichever of those is appropriate prior to evaluating the query.  If there is a Query present then it's timeout takes precedence unless it is set to zero (no timeout) in which case the global timeout setting is applied.  You cannot set the Query Timeout to be higher than the global timeout unless the global timeout is set to zero (i.e. no global timeout)
            </para>
            </remarks>
        </member>
        <member name="P:VDS.RDF.Query.SparqlEvaluationContext.QueryTime">
            <summary>
            Retrieves the Time in milliseconds the query took to evaluate
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlEvaluationContext.QueryTimeTicks">
            <summary>
            Retrieves the Time in ticks the query took to evaluate
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlEvaluationContext.Item(System.String)">
            <summary>
            Gets/Sets a Object that should be persisted over the entire Evaluation Context
            </summary>
            <param name="key">Key</param>
            <returns></returns>
            <remarks>
            May be used by parts of the Evaluation Process that need to ensure a persistent state across the entire Evaluation Query (e.g. the implementation of the BNODE() function)
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.SparqlNodeComparer">
            <summary>
            Comparer class for implementing the SPARQL semantics for the relational operators
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SparqlNodeComparer.Compare(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Compares two Nodes
            </summary>
            <param name="x">Node</param>
            <param name="y">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlNodeComparer.Compare(VDS.RDF.Nodes.IValuedNode,VDS.RDF.Nodes.IValuedNode)">
            <summary>
            Compares two valued Nodes
            </summary>
            <param name="x">Node</param>
            <param name="y">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlNodeComparer.NumericCompare(VDS.RDF.INode,VDS.RDF.INode,VDS.RDF.Query.Expressions.SparqlNumericType)">
            <summary>
            Compares two Nodes for Numeric Ordering
            </summary>
            <param name="x">Node</param>
            <param name="y">Node</param>
            <param name="type">Numeric Type</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlNodeComparer.NumericCompare(VDS.RDF.Nodes.IValuedNode,VDS.RDF.Nodes.IValuedNode,VDS.RDF.Query.Expressions.SparqlNumericType)">
            <summary>
            Compares two Nodes for Numeric Ordering
            </summary>
            <param name="x">Node</param>
            <param name="y">Node</param>
            <param name="type">Numeric Type</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlNodeComparer.DateTimeCompare(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Compares two Date Times for Date Time ordering
            </summary>
            <param name="x">Node</param>
            <param name="y">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlNodeComparer.DateTimeCompare(VDS.RDF.Nodes.IValuedNode,VDS.RDF.Nodes.IValuedNode)">
            <summary>
            Compares two Date Times for Date Time ordering
            </summary>
            <param name="x">Node</param>
            <param name="y">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlNodeComparer.DateCompare(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Compares two Dates for Date ordering
            </summary>
            <param name="x">Node</param>
            <param name="y">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlNodeComparer.DateCompare(VDS.RDF.Nodes.IValuedNode,VDS.RDF.Nodes.IValuedNode)">
            <summary>
            Compares two Dates for Date ordering
            </summary>
            <param name="x">Node</param>
            <param name="y">Node</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.SparqlOrderingComparer">
            <summary>
            Comparer class for use in SPARQL ORDER BY - implements the Semantics broadly similar to the relational operator but instead of erroring using Node/Lexical ordering where an error would occur it makes an appropriate decision
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SparqlOrderingComparer.Compare(VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Compares two Nodes
            </summary>
            <param name="x">Node</param>
            <param name="y">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlOrderingComparer.Compare(VDS.RDF.Nodes.IValuedNode,VDS.RDF.Nodes.IValuedNode)">
            <summary>
            Compares two Nodes
            </summary>
            <param name="x">Node</param>
            <param name="y">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlOrderingComparer.DateTimeCompare(VDS.RDF.Nodes.IValuedNode,VDS.RDF.Nodes.IValuedNode)">
            <summary>
            Compares two Date Times for Date Time ordering
            </summary>
            <param name="x">Node</param>
            <param name="y">Node</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.SparqlParameterizedString">
            <summary>
            A SPARQL Parameterized String is a String that can contain parameters in the same fashion as a SQL command string
            </summary>
            <remarks>
            <para>
            This is intended for use in applications which may want to dynamically build SPARQL queries/updates where user input may comprise individual values in the triples patterns and the applications want to avoid SPARQL injection attacks which change the meaning of the query/update
            </para>
            <para>
            It works broadly in the same way as a SqlCommand would in that you specify a string with paramters specified in the form <strong>@name</strong> and then use various set methods to set the actual values that should be used.  The values are only substituted for parameters when you actually call the <see cref="M:VDS.RDF.Query.SparqlParameterizedString.ToString">ToString()</see> method to get the final string representation of the command. E.g.
            </para>
            <code>
            SparqlParameterizedString queryString = new SparqlParameterizedString();
            queryString.CommandText = @"SELECT * WHERE
            {
                ?s a @type .
            }";
            queryString.SetUri("type", new Uri("http://example.org/myType"));
            Console.WriteLine(queryString.ToString());
            </code>
            <para>
            Would result in the following being printed to the Console:
            </para>
            <code>
            SELECT * WHERE
            {
                ?s a &lt;http://example.org/myType&gt;
            }
            </code>
            <para>
            Calling a Set method to set a parameter that has already been set changes that value and the new value will be used next time you call <see cref="M:VDS.RDF.Query.SparqlParameterizedString.ToString">ToString()</see> - this may be useful if you plan to execute a series of queries/updates using a series of values since you need not instantiate a completely new parameterized string each time
            </para>
            <para>
            This class was added to a library based on a suggestion by Alexander Sidorov and ideas from slides from <a href="http://www.slideshare.net/Morelab/sparqlrdqlsparul-injection">Slideshare</a> by Almedia et al
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.#ctor">
            <summary>
            Creates a new empty parameterized String
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.#ctor(System.String)">
            <summary>
            Creates a new parameterized String
            </summary>
            <param name="command">Command Text</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.AppendSubQuery(VDS.RDF.Query.SparqlQuery)">
            <summary>
            Appends the given query as a sub-query to the existing command text, any prefixes in the sub-query are moved to the parent query
            </summary>
            <param name="query">Query</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.AppendSubQuery(VDS.RDF.Query.SparqlParameterizedString)">
            <summary>
            Appends the given query as a sub-query to the existing command text, any prefixes in the sub-query are moved to the parent query but any parameter/variable assignments will be lost
            </summary>
            <param name="query">Query</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.Clear">
            <summary>
            Clears all set Parameters and Variables
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.ClearParameters">
            <summary>
            Clears all set Parameters
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.ClearVariables">
            <summary>
            Clears all set Variables
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.SetParameter(System.String,VDS.RDF.INode)">
            <summary>
            Sets the Value of a Parameter 
            </summary>
            <param name="name">Parameter Name</param>
            <param name="value">Value</param>
            <remarks>
            Can be used in derived classes to set the value of parameters if the derived class defines additional methods for adding values for parameters
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.UnsetParameter(System.String)">
            <summary>
            Removes a previously set value for a Parameter
            </summary>
            <param name="name">Parameter Name</param>
            <remarks>
            There is generally no reason to do this since you can just set a parameters value to change it
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.UnsetVariable(System.String)">
            <summary>
            Removes a previously set value for a Variable
            </summary>
            <param name="name">Variable Name</param>
            <remarks>
            May be useful if you have a skeleton query/update into which you sometimes substitute values for variables but don't always do so
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.SetVariable(System.String,VDS.RDF.INode)">
            <summary>
            Sets the Value of a Variable
            </summary>
            <param name="name">Variable Name</param>
            <param name="value">Value</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.SetLiteral(System.String,System.Int32)">
            <summary>
            Sets the Parameter to an Integer Literal
            </summary>
            <param name="name">Parameter</param>
            <param name="value">Integer</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.SetLiteral(System.String,System.Int64)">
            <summary>
            Sets the Parameter to an Integer Literal
            </summary>
            <param name="name">Parameter</param>
            <param name="value">Integer</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.SetLiteral(System.String,System.Int16)">
            <summary>
            Sets the Parameter to an Integer Literal
            </summary>
            <param name="name">Parameter</param>
            <param name="value">Integer</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.SetLiteral(System.String,System.Decimal)">
            <summary>
            Sets the Parameter to a Decimal Literal
            </summary>
            <param name="name">Parameter</param>
            <param name="value">Integer</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.SetLiteral(System.String,System.Single)">
            <summary>
            Sets the Parameter to a Float Literal
            </summary>
            <param name="name">Parameter</param>
            <param name="value">Integer</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.SetLiteral(System.String,System.Double)">
            <summary>
            Sets the Parameter to a Double Literal
            </summary>
            <param name="name">Parameter</param>
            <param name="value">Integer</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.SetLiteral(System.String,System.DateTime)">
            <summary>
            Sets the Parameter to a Date Time Literal
            </summary>
            <param name="name">Parameter</param>
            <param name="value">Integer</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.SetLiteral(System.String,System.DateTime,System.Boolean)">
            <summary>
            Sets the Parameter to a Date Time Literal
            </summary>
            <param name="name">Parameter</param>
            <param name="value">Integer</param>
            <param name="precise">Whether to preserve precisely i.e. include fractional seconds</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.SetLiteral(System.String,System.DateTimeOffset)">
            <summary>
            Sets the Parameter to a Date Time Literal
            </summary>
            <param name="name">Parameter</param>
            <param name="value">Integer</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.SetLiteral(System.String,System.DateTimeOffset,System.Boolean)">
            <summary>
            Sets the Parameter to a Date Time Literal
            </summary>
            <param name="name">Parameter</param>
            <param name="value">Integer</param>
            <param name="precise">Whether to preserve precisely i.e. include fractional seconds</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.SetLiteral(System.String,System.TimeSpan)">
            <summary>
            Sets the Parameter to a Duration Literal
            </summary>
            <param name="name">Parameter</param>
            <param name="value">Integer</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.SetLiteral(System.String,System.Boolean)">
            <summary>
            Sets the Parameter to a Boolean Literal
            </summary>
            <param name="name">Parameter</param>
            <param name="value">Integer</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.SetLiteral(System.String,System.String)">
            <summary>
            Sets the Parameter to an Untyped Literal
            </summary>
            <param name="name">Parameter</param>
            <param name="value">Integer</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.SetLiteral(System.String,System.String,System.Uri)">
            <summary>
            Sets the Parameter to a Typed Literal
            </summary>
            <param name="name">Parameter</param>
            <param name="value">Integer</param>
            <param name="datatype">Datatype URI</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.SetLiteral(System.String,System.String,System.String)">
            <summary>
            Sets the Parameter to a Literal with a Language Specifier
            </summary>
            <param name="name">Parameter</param>
            <param name="value">Integer</param>
            <param name="lang">Language Specifier</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.SetUri(System.String,System.Uri)">
            <summary>
            Sets the Parameter to a URI
            </summary>
            <param name="name">Parameter</param>
            <param name="value">URI</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.SetBlankNode(System.String,System.String)">
            <summary>
            Sets the Parameter to be a Blank Node with the given ID
            </summary>
            <param name="name">Parameter</param>
            <param name="value">Node ID</param>
            <remarks>
            Only guarantees that the Blank Node ID will not clash with any other Blank Nodes added by other calls to this method or it's overload which generates anonymous Blank Nodes.  If the base query text into which you are inserting parameters contains Blank Nodes then the IDs generated here may clash with those IDs.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.SetBlankNode(System.String)">
            <summary>
            Sets the Parameter to be a new anonymous Blank Node
            </summary>
            <param name="name">Parameter</param>
            <remarks>
            Only guarantees that the Blank Node ID will not clash with any other Blank Nodes added by other calls to this method or it's overload which takes an explicit Node ID.  If the base query text into which you are inserting parameters contains Blank Nodes then the IDs generated here may clash with those IDs.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.ExecuteQuery">
            <summary>
            Executes this command as a query
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.ExecuteQuery(VDS.RDF.IRdfHandler,VDS.RDF.ISparqlResultsHandler)">
            <summary>
            Executes this command as a query
            </summary>
            <param name="rdfHandler">RDF Handler</param>
            <param name="resultsHandler">Results Handler</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.ExecuteUpdate">
            <summary>
            Executes this command as an update
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SparqlParameterizedString.ToString">
            <summary>
            Returns the actual Query/Update String with parameter and variable values inserted
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.SparqlParameterizedString.Namespaces">
            <summary>
            Gets/Sets the Namespace Map that is used to prepend PREFIX declarations to the command
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlParameterizedString.BaseUri">
            <summary>
            Gets/Sets the Base URI which will be used to prepend BASE declarations to the command
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlParameterizedString.CommandText">
            <summary>
            Gets/Sets the parameterized Command Text
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlParameterizedString.QueryProcessor">
            <summary>
            Gets/Sets the Query processor which is used when you call the <see cref="M:VDS.RDF.Query.SparqlParameterizedString.ExecuteQuery">ExecuteQuery()</see> method
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlParameterizedString.UpdateProcessor">
            <summary>
            Gets/Sets the Query processor which is used when you call the <see cref="M:VDS.RDF.Query.SparqlParameterizedString.ExecuteUpdate">ExecuteUpdate()</see> method
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlParameterizedString.Variables">
            <summary>
            Gets an enumeration of the Variables for which Values have been set
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.SparqlParameterizedString.Parameters">
            <summary>
            Gets an enumeration of the Parameters for which Values have been set
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.SparqlPathParser">
            <summary>
            Internal class which parses SPARQL Paths into path expressions
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.BaseSparqlView">
            <summary>
            Abstract Base class for SPARQL Views which are Graphs which are generated from SPARQL Queries and get automatically updated when the Store they are attached to changes
            </summary>
            <remarks>
            <para>
            CONSTRUCT, DESCRIBE or SELECT queries can be used to generate a Graph.  If you use a SELECT query the returned variables must contain ?s, ?p and ?o in order to generate a view correctly
            </para>
            </remarks>
        </member>
        <member name="F:VDS.RDF.Query.BaseSparqlView._q">
            <summary>
            SPARQL Query
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.BaseSparqlView._graphs">
            <summary>
            Graphs that are mentioned in the Query
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.BaseSparqlView._store">
            <summary>
            Triple Store the query operates over
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.BaseSparqlView.#ctor(System.String,VDS.RDF.ITripleStore)">
            <summary>
            Creates a new SPARQL View
            </summary>
            <param name="sparqlQuery">SPARQL Query</param>
            <param name="store">Triple Store to query</param>
        </member>
        <member name="M:VDS.RDF.Query.BaseSparqlView.#ctor(VDS.RDF.Query.SparqlParameterizedString,VDS.RDF.ITripleStore)">
            <summary>
            Creates a new SPARQL View
            </summary>
            <param name="sparqlQuery">SPARQL Query</param>
            <param name="store">Triple Store to query</param>
        </member>
        <member name="M:VDS.RDF.Query.BaseSparqlView.#ctor(VDS.RDF.Query.SparqlQuery,VDS.RDF.ITripleStore)">
            <summary>
            Creates a new SPARQL View
            </summary>
            <param name="sparqlQuery">SPARQL Query</param>
            <param name="store">Triple Store to query</param>
        </member>
        <member name="M:VDS.RDF.Query.BaseSparqlView.Initialise">
            <summary>
            Initialises the SPARQL View
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.BaseSparqlView.InvalidateView">
            <summary>
            Invalidates the View causing it to be updated
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.BaseSparqlView.InvalidateViewCompleted(System.IAsyncResult)">
            <summary>
            Callback for when asychronous invalidation completes
            </summary>
            <param name="result">Async call results</param>
        </member>
        <member name="M:VDS.RDF.Query.BaseSparqlView.UpdateView">
            <summary>
            Forces the view to be updated
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.BaseSparqlView.UpdateViewInternal">
            <summary>
            Abstract method that derived classes should implement to update the view
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.BaseSparqlView.LastError">
            <summary>
            Gets the error that occurred during the last update (if any)
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.SparqlView">
            <summary>
            Represents a SPARQL View over an in-memory store
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.SparqlView.#ctor(System.String,VDS.RDF.IInMemoryQueryableStore)">
            <summary>
            Creates a new SPARQL View
            </summary>
            <param name="sparqlQuery">SPARQL Query</param>
            <param name="store">Triple Store to query</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlView.#ctor(VDS.RDF.Query.SparqlParameterizedString,VDS.RDF.IInMemoryQueryableStore)">
            <summary>
            Creates a new SPARQL View
            </summary>
            <param name="sparqlQuery">SPARQL Query</param>
            <param name="store">Triple Store to query</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlView.#ctor(VDS.RDF.Query.SparqlQuery,VDS.RDF.IInMemoryQueryableStore)">
            <summary>
            Creates a new SPARQL View
            </summary>
            <param name="sparqlQuery">SPARQL Query</param>
            <param name="store">Triple Store to query</param>
        </member>
        <member name="M:VDS.RDF.Query.SparqlView.UpdateViewInternal">
            <summary>
            Updates the view by making the SPARQL Query in-memory over the relevant Triple Store
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.NativeSparqlView">
            <summary>
            Represents a SPARQL View over an arbitrary native Triple Store
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.NativeSparqlView.#ctor(System.String,VDS.RDF.INativelyQueryableStore)">
            <summary>
            Creates a new SPARQL View
            </summary>
            <param name="sparqlQuery">SPARQL Query</param>
            <param name="store">Triple Store to query</param>
        </member>
        <member name="M:VDS.RDF.Query.NativeSparqlView.#ctor(VDS.RDF.Query.SparqlParameterizedString,VDS.RDF.INativelyQueryableStore)">
            <summary>
            Creates a new SPARQL View
            </summary>
            <param name="sparqlQuery">SPARQL Query</param>
            <param name="store">Triple Store to query</param>
        </member>
        <member name="M:VDS.RDF.Query.NativeSparqlView.#ctor(VDS.RDF.Query.SparqlQuery,VDS.RDF.INativelyQueryableStore)">
            <summary>
            Creates a new SPARQL View
            </summary>
            <param name="sparqlQuery">SPARQL Query</param>
            <param name="store">Triple Store to query</param>
        </member>
        <member name="M:VDS.RDF.Query.NativeSparqlView.UpdateViewInternal">
            <summary>
            Updates the view by making the query over the Native Store (i.e. the query is handled by the stores SPARQL implementation)
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.BaseAsyncHttpConnector">
            <summary>
            Abstract Base Class for HTTP Based <see cref="T:VDS.RDF.Storage.IAsyncStorageProvider">IAsyncStorageProvider</see> implementations
            </summary>
            <remarks>
            <para>
            It is expected that most classes extending from this will also then implement <see cref="T:VDS.RDF.Storage.IStorageProvider"/> separately for their synchronous communication, this class purely provides partial helper implementations for the asynchronous communication
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.BaseAsyncHttpConnector.#ctor">
            <summary>
            Creates a new Base Async HTTP Connector
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.BaseAsyncHttpConnector.LoadGraph(VDS.RDF.IGraph,System.Uri,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Loads a Graph from the Store asynchronously
            </summary>
            <param name="g">Graph to load into</param>
            <param name="graphUri">URI of the Graph to load</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseAsyncHttpConnector.LoadGraph(VDS.RDF.IGraph,System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Loads a Graph from the Store asynchronously
            </summary>
            <param name="g">Graph to load into</param>
            <param name="graphUri">URI of the Graph to load</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseAsyncHttpConnector.LoadGraph(VDS.RDF.IRdfHandler,System.Uri,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Loads a Graph from the Store asynchronously
            </summary>
            <param name="handler">Handler to load with</param>
            <param name="graphUri">URI of the Graph to load</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseAsyncHttpConnector.LoadGraph(VDS.RDF.IRdfHandler,System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Loads a Graph from the Store asynchronously
            </summary>
            <param name="handler">Handler to load with</param>
            <param name="graphUri">URI of the Graph to load</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseAsyncHttpConnector.LoadGraphAsync(System.Net.HttpWebRequest,VDS.RDF.IRdfHandler,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Helper method for doing async load operations, callers just need to provide an appropriately prepared HTTP request
            </summary>
            <param name="request">HTTP Request</param>
            <param name="handler">Handler to load with</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseAsyncHttpConnector.SaveGraph(VDS.RDF.IGraph,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Saves a Graph to the Store asynchronously
            </summary>
            <param name="g">Graph to save</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseAsyncHttpConnector.SaveGraphAsync(System.Net.HttpWebRequest,VDS.RDF.IRdfWriter,VDS.RDF.IGraph,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Helper method for doing async save operations, callers just need to provide an appropriately perpared HTTP requests and a RDF writer which will be used to write the data to the request body
            </summary>
            <param name="request">HTTP request</param>
            <param name="writer">RDF Writer</param>
            <param name="g">Graph to save</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseAsyncHttpConnector.UpdateGraph(System.Uri,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple},VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Updates a Graph in the Store asychronously
            </summary>
            <param name="graphUri">URI of the Graph to update</param>
            <param name="additions">Triples to be added</param>
            <param name="removals">Triples to be removed</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseAsyncHttpConnector.UpdateGraph(System.String,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple},VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Updates a Graph in the Store asychronously
            </summary>
            <param name="graphUri">URI of the Graph to update</param>
            <param name="additions">Triples to be added</param>
            <param name="removals">Triples to be removed</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseAsyncHttpConnector.UpdateGraphAsync(System.Net.HttpWebRequest,VDS.RDF.IRdfWriter,System.Uri,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Helper method for doing async update operations, callers just need to provide an appropriately prepared HTTP request and a RDF writer which will be used to write the data to the request body
            </summary>
            <param name="request">HTTP Request</param>
            <param name="writer">RDF writer</param>
            <param name="graphUri">URI of the Graph to update</param>
            <param name="ts">Triples</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseAsyncHttpConnector.DeleteGraph(System.Uri,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Deletes a Graph from the Store
            </summary>
            <param name="graphUri">URI of the Graph to delete</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseAsyncHttpConnector.DeleteGraph(System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Deletes a Graph from the Store
            </summary>
            <param name="graphUri">URI of the Graph to delete</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseAsyncHttpConnector.DeleteGraphAsync(System.Net.HttpWebRequest,System.Boolean,System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Helper method for doing async delete operations, callers just need to provide an appropriately prepared HTTP request
            </summary>
            <param name="request">HTTP request</param>
            <param name="allow404">Whether a 404 response counts as success</param>
            <param name="graphUri">URI of the Graph to delete</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseAsyncHttpConnector.ListGraphs(VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Lists the Graphs in the Store asynchronously
            </summary>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseAsyncHttpConnector.Dispose">
            <summary>
            Diposes of the Store
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.BaseAsyncHttpConnector.MakeRequestSequence(System.Collections.Generic.IEnumerable{System.Net.HttpWebRequest},VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Helper method for doing async operations where a sequence of HTTP requests must be run
            </summary>
            <param name="requests">HTTP requests</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="P:VDS.RDF.Storage.BaseAsyncHttpConnector.ParentServer">
            <summary>
            Gets the parent server (if any)
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.BaseAsyncHttpConnector.AsyncParentServer">
            <summary>
            Gets the parent server (if any)
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.BaseAsyncHttpConnector.IsReady">
            <summary>
            Indicates whether the Store is ready to accept requests
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.BaseAsyncHttpConnector.IsReadOnly">
            <summary>
            Gets whether the Store is read only
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.BaseAsyncHttpConnector.IOBehaviour">
            <summary>
            Gets the IO Behaviour of the Store
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.BaseAsyncHttpConnector.UpdateSupported">
            <summary>
            Gets whether the Store supports Triple level updates via the <see cref="M:VDS.RDF.Storage.BaseAsyncHttpConnector.UpdateGraph(System.Uri,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple},VDS.RDF.Storage.AsyncStorageCallback,System.Object)">UpdateGraph()</see> method
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.BaseAsyncHttpConnector.DeleteSupported">
            <summary>
            Gets whether the Store supports Graph deletion via the <see cref="M:VDS.RDF.Storage.BaseAsyncHttpConnector.DeleteGraph(System.Uri,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">DeleteGraph()</see> method
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.BaseAsyncHttpConnector.ListGraphsSupported">
            <summary>
            Gets whether the Store supports listing graphs via the <see cref="M:VDS.RDF.Storage.BaseAsyncHttpConnector.ListGraphs(VDS.RDF.Storage.AsyncStorageCallback,System.Object)">ListGraphs()</see> method
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.IOBehaviour">
            <summary>
            Flags Enumeration which is used to express the IO Behaviours of a specific Store
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.IOBehaviour.IsReadOnly">
            <summary>
            Indicates whether the Store is Read Only i.e. Saving is not supported
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.IOBehaviour.IsTripleStore">
            <summary>
            Indicates that the Store is a Triple Store
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.IOBehaviour.IsQuadStore">
            <summary>
            Indicates that the Store is a Quad (Graph) Store
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.IOBehaviour.HasDefaultGraph">
            <summary>
            Indicates whether the Store has an explicit unnamed default graph
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.IOBehaviour.HasNamedGraphs">
            <summary>
            Indicates whether the Store has named graphs
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.IOBehaviour.AppendTriples">
            <summary>
            Indicates that a Triple Store appends Triples when the SaveGraph() method is used
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.IOBehaviour.OverwriteTriples">
            <summary>
            Indicates that a Triple Store overwrites Triples when the SaveGraph() method is used
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.IOBehaviour.AppendToDefault">
            <summary>
            Indicates that Graph data written to the Default Graph is always appended when the SaveGraph() method is used
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.IOBehaviour.OverwriteDefault">
            <summary>
            Indicates that Graph data written to the Default Graph overwrites existing data when the SaveGraph() method is used
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.IOBehaviour.AppendToNamed">
            <summary>
            Indicates that Graph data written to Named Graphs is always appended when the SaveGraph() method is used
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.IOBehaviour.OverwriteNamed">
            <summary>
            Indicates that Graph data written to Named Graphs overwrites existing data when the SaveGraph() method is used
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.IOBehaviour.CanUpdateAddTriples">
            <summary>
            Indicates a Store that can do Triple Level additions on existing Graphs using the UpdateGraph() method
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.IOBehaviour.CanUpdateDeleteTriples">
            <summary>
            Indicates a Store that can do Triple Level removals on existing Graphs using the UpdateGraph() method
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.IOBehaviour.ExplicitEmptyGraphs">
            <summary>
            Indicates that a Store has a notion of explicit empty graphs
            </summary>
            <remarks>
            For some quad stores the existence of a graph may only be defined in terms of one/more quads being stored in that graph
            </remarks>
        </member>
        <member name="F:VDS.RDF.Storage.IOBehaviour.HasMultipleStores">
            <summary>
            Indicates that the Store is from a system which provides access to multiple stores (such an implementation will usually implement the <see cref="!:IStorageServer">IStorageServer</see> interface) - at a minimum this usually means the store will allow you to list other available stores.  More complex abilities like creating and deleting stores are indicated by other flags.
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.IOBehaviour.CanCreateStores">
            <summary>
            Indicates that the Store provides the means to create additional Stores
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.IOBehaviour.CanDeleteStores">
            <summary>
            Indicates that the Store provides the means to delete Stores
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.IOBehaviour.CanUpdateTriples">
            <summary>
            Indicates a Store that can do Triple Level additions and removals on existing Graphs using the UpdateGraph() method
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.IOBehaviour.ReadOnlyTripleStore">
            <summary>
            Default Behaviour for Read Only Triple Stores
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.IOBehaviour.ReadOnlyGraphStore">
            <summary>
            Default Behaviour for Read Only Quad (Graph) Stores
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.IOBehaviour.TripleStore">
            <summary>
            Default Behaviour for Triple Stores
            </summary>
            <remarks>
            Default Behaviour is considered to be a Triple Store where data is appended
            </remarks>
        </member>
        <member name="F:VDS.RDF.Storage.IOBehaviour.GraphStore">
            <summary>
            Default Behaviour for Quad (Graph) Stores
            </summary>
            <remarks>
            Default Behaviour is considered to be Quad Store with Default and Named Graphs, data is appended to the default graph and overwrites named graphs
            </remarks>
        </member>
        <member name="F:VDS.RDF.Storage.IOBehaviour.StorageServer">
            <summary>
            Behaviour for fully fledged storage servers i.e. multiple stores are supported and can be created and deleted as desired
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.StardogReasoningMode">
            <summary>
            Reasoning modes supported by Stardog
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.StardogReasoningMode.None">
            <summary>
            No Reasoning (default)
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.StardogReasoningMode.QL">
            <summary>
            OWL-QL Reasoning
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.StardogReasoningMode.EL">
            <summary>
            OWL-EL Reasoning
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.StardogReasoningMode.RL">
            <summary>
            OWL-RL Reasoning
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.StardogReasoningMode.DL">
            <summary>
            OWL-DL Reasoning
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.StardogReasoningMode.RDFS">
            <summary>
            RDFS Reasoning
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.StardogReasoningMode.SL">
            <summary>
            RDFS, QL, RL, and EL axioms, plus SWRL rules
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.BaseStardogConnector">
            <summary>
            Abstract implementation of a connector for Stardog that connects using the HTTP protocol
            </summary>
            <remarks>
            <para>
            Has full support for Stardog Transactions, connection is in auto-commit mode by default i.e. all write operations (Delete/Save/Update) will create and use a dedicated transaction for their operation, if the operation fails the transaction will automatically be rolled back.  You can manage Transactions using the <see cref="!:StardogConnector.Begin()">Begin()</see>, <see cref="!:StardogConnector.Commit()">Commit()</see> and <see cref="!:StardogConnector.Rollback()">Rollback()</see> methods.
            </para>
            <para>
            The connector maintains a single transaction which is shared across all threads since Stardog is currently provides only MRSW (Multiple Reader Single Writer) concurrency and does not permit multiple transactions to occur simultaneously.  
            </para>
            </remarks>
        </member>
        <member name="F:VDS.RDF.Storage.BaseStardogConnector.AnonymousUser">
            <summary>
            Constant for the default Anonymous user account and password used by Stardog if you have not supplied a shiro.ini file or otherwise disabled security
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStardogConnector.#ctor(System.String,System.String,VDS.RDF.Storage.StardogReasoningMode)">
            <summary>
            Creates a new connection to a Stardog Store
            </summary>
            <param name="baseUri">Base Uri of the Server</param>
            <param name="kbID">Knowledge Base (i.e. Database) ID</param>
            <param name="reasoning">Reasoning Mode</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStardogConnector.#ctor(System.String,System.String)">
            <summary>
            Creates a new connection to a Stardog Store
            </summary>
            <param name="baseUri">Base Uri of the Server</param>
            <param name="kbID">Knowledge Base (i.e. Database) ID</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStardogConnector.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Creates a new connection to a Stardog Store
            </summary>
            <param name="baseUri">Base Uri of the Server</param>
            <param name="kbID">Knowledge Base (i.e. Database) ID</param>
            <param name="username">Username</param>
            <param name="password">Password</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStardogConnector.#ctor(System.String,System.String,VDS.RDF.Storage.StardogReasoningMode,System.String,System.String)">
            <summary>
            Creates a new connection to a Stardog Store
            </summary>
            <param name="baseUri">Base Uri of the Server</param>
            <param name="kbID">Knowledge Base (i.e. Database) ID</param>
            <param name="username">Username</param>
            <param name="password">Password</param>
            <param name="reasoning">Reasoning Mode</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStardogConnector.SaveGraph(VDS.RDF.IGraph,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Saves a Graph to the Store asynchronously
            </summary>
            <param name="g">Graph to save</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStardogConnector.LoadGraph(VDS.RDF.IRdfHandler,System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Loads a Graph from the Store asynchronously
            </summary>
            <param name="handler">Handler to load with</param>
            <param name="graphUri">URI of the Graph to load</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStardogConnector.UpdateGraph(System.String,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple},VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Updates a Graph in the Store asychronously
            </summary>
            <param name="graphUri">URI of the Graph to update</param>
            <param name="additions">Triples to be added</param>
            <param name="removals">Triples to be removed</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStardogConnector.DeleteGraph(System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Deletes a Graph from the Store
            </summary>
            <param name="graphUri">URI of the Graph to delete</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStardogConnector.Query(System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Queries the store asynchronously
            </summary>
            <param name="query">SPARQL Query</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStardogConnector.Query(VDS.RDF.IRdfHandler,VDS.RDF.ISparqlResultsHandler,System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Queries the store asynchronously
            </summary>
            <param name="query">SPARQL Query</param>
            <param name="rdfHandler">RDF Handler</param>
            <param name="resultsHandler">Results Handler</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStardogConnector.CreateRequest(System.String,System.String,System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Helper method for creating HTTP Requests to the Store
            </summary>
            <param name="servicePath">Path to the Service requested</param>
            <param name="accept">Acceptable Content Types</param>
            <param name="method">HTTP Method</param>
            <param name="requestParams">Querystring Parameters</param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:VDS.RDF.Storage.BaseStardogConnector.AddStardogHeaders(System.Net.HttpWebRequest)" -->
        <member name="M:VDS.RDF.Storage.BaseStardogConnector.Begin(VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Begins a transaction asynchronously
            </summary>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStardogConnector.Commit(VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Commits a transaction asynchronously
            </summary>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStardogConnector.Rollback(VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Rolls back a transaction asynchronously
            </summary>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStardogConnector.Dispose">
            <summary>
            Disposes of the Connector
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStardogConnector.ToString">
            <summary>
            Gets a String which gives details of the Connection
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.BaseStardogConnector.SerializeConfiguration(VDS.RDF.Configuration.ConfigurationSerializationContext)">
            <summary>
            Serializes the connection's configuration
            </summary>
            <param name="context">Configuration Serialization Context</param>
        </member>
        <member name="P:VDS.RDF.Storage.BaseStardogConnector.BaseUri">
            <summary>
            Gets the Base URI of the Stardog server
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.BaseStardogConnector.Reasoning">
            <summary>
            Gets/Sets the reasoning mode to use for queries
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.BaseStardogConnector.IOBehaviour">
            <summary>
            Gets the IO Behaviour of Stardog
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.BaseStardogConnector.ListGraphsSupported">
            <summary>
            Returns that listing Graphs is supported
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.BaseStardogConnector.IsReady">
            <summary>
            Returns that the Connection is ready
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.BaseStardogConnector.IsReadOnly">
            <summary>
            Returns that the Connection is not read-only
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.BaseStardogConnector.UpdateSupported">
            <summary>
            Returns that Updates are supported on Stardog Stores
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.BaseStardogConnector.DeleteSupported">
            <summary>
            Returns that deleting graphs from the Stardog store is not yet supported (due to a .Net specific issue)
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.BaseStardogConnector.AsyncParentServer">
            <summary>
            Gets the parent server
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.StardogV1Connector">
            <summary>
            A Stardog Connector for connecting to Stardog version 1.* servers
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.StardogV1Connector.#ctor(System.String,System.String,VDS.RDF.Storage.StardogReasoningMode)">
            <summary>
            Creates a new connection to a Stardog Store
            </summary>
            <param name="baseUri">Base Uri of the Server</param>
            <param name="kbID">Knowledge Base (i.e. Database) ID</param>
            <param name="reasoning">Reasoning Mode</param>
        </member>
        <member name="M:VDS.RDF.Storage.StardogV1Connector.#ctor(System.String,System.String)">
            <summary>
            Creates a new connection to a Stardog Store
            </summary>
            <param name="baseUri">Base Uri of the Server</param>
            <param name="kbID">Knowledge Base (i.e. Database) ID</param>
        </member>
        <member name="M:VDS.RDF.Storage.StardogV1Connector.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Creates a new connection to a Stardog Store
            </summary>
            <param name="baseUri">Base Uri of the Server</param>
            <param name="kbID">Knowledge Base (i.e. Database) ID</param>
            <param name="username">Username</param>
            <param name="password">Password</param>
        </member>
        <member name="M:VDS.RDF.Storage.StardogV1Connector.#ctor(System.String,System.String,VDS.RDF.Storage.StardogReasoningMode,System.String,System.String)">
            <summary>
            Creates a new connection to a Stardog Store
            </summary>
            <param name="baseUri">Base Uri of the Server</param>
            <param name="kbID">Knowledge Base (i.e. Database) ID</param>
            <param name="username">Username</param>
            <param name="password">Password</param>
            <param name="reasoning">Reasoning Mode</param>
        </member>
        <member name="T:VDS.RDF.Storage.StardogV2Connector">
            <summary>
            A Stardog Connector for connecting to Stardog version 2.* servers
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.StardogV2Connector.#ctor(System.String,System.String,VDS.RDF.Storage.StardogReasoningMode)">
            <summary>
            Creates a new connection to a Stardog Store
            </summary>
            <param name="baseUri">Base Uri of the Server</param>
            <param name="kbID">Knowledge Base (i.e. Database) ID</param>
            <param name="reasoning">Reasoning Mode</param>
        </member>
        <member name="M:VDS.RDF.Storage.StardogV2Connector.#ctor(System.String,System.String)">
            <summary>
            Creates a new connection to a Stardog Store
            </summary>
            <param name="baseUri">Base Uri of the Server</param>
            <param name="kbID">Knowledge Base (i.e. Database) ID</param>
        </member>
        <member name="M:VDS.RDF.Storage.StardogV2Connector.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Creates a new connection to a Stardog Store
            </summary>
            <param name="baseUri">Base Uri of the Server</param>
            <param name="kbID">Knowledge Base (i.e. Database) ID</param>
            <param name="username">Username</param>
            <param name="password">Password</param>
        </member>
        <member name="M:VDS.RDF.Storage.StardogV2Connector.#ctor(System.String,System.String,VDS.RDF.Storage.StardogReasoningMode,System.String,System.String)">
            <summary>
            Creates a new connection to a Stardog Store
            </summary>
            <param name="baseUri">Base Uri of the Server</param>
            <param name="kbID">Knowledge Base (i.e. Database) ID</param>
            <param name="username">Username</param>
            <param name="password">Password</param>
            <param name="reasoning">Reasoning Mode</param>
        </member>
        <member name="M:VDS.RDF.Storage.StardogV2Connector.AddStardogHeaders(System.Net.HttpWebRequest)">
            <summary>
            Adds Stardog specific request headers
            </summary>
            <param name="request"></param>
        </member>
        <member name="M:VDS.RDF.Storage.StardogV2Connector.Update(System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Executes a SPARQL Update against the Stardog store
            </summary>
            <param name="sparqlUpdates">SPARQL Update</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to callback</param>
            <remarks>
            Stardog executes SPARQL update requests in their own self contained transactions which do not interact with normal Stardog transactions that may be managed via this API.  In some cases this can lead to unexpected behaviour, for example if you call <see cref="M:VDS.RDF.Storage.BaseStardogConnector.Begin(VDS.RDF.Storage.AsyncStorageCallback,System.Object)"/>, make an update and then call <see cref="M:VDS.RDF.Storage.BaseStardogConnector.Rollback(VDS.RDF.Storage.AsyncStorageCallback,System.Object)"/> the updates will not be rolled back.
            </remarks>
        </member>
        <member name="T:VDS.RDF.Storage.StardogConnector">
            <summary>
            A Stardog connector for connecting to Stardog servers running the latest version, currently this is version 2.*
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.StardogConnector.#ctor(System.String,System.String,VDS.RDF.Storage.StardogReasoningMode)">
            <summary>
            Creates a new connection to a Stardog Store
            </summary>
            <param name="baseUri">Base Uri of the Server</param>
            <param name="kbID">Knowledge Base (i.e. Database) ID</param>
            <param name="reasoning">Reasoning Mode</param>
        </member>
        <member name="M:VDS.RDF.Storage.StardogConnector.#ctor(System.String,System.String)">
            <summary>
            Creates a new connection to a Stardog Store
            </summary>
            <param name="baseUri">Base Uri of the Server</param>
            <param name="kbID">Knowledge Base (i.e. Database) ID</param>
        </member>
        <member name="M:VDS.RDF.Storage.StardogConnector.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Creates a new connection to a Stardog Store
            </summary>
            <param name="baseUri">Base Uri of the Server</param>
            <param name="kbID">Knowledge Base (i.e. Database) ID</param>
            <param name="username">Username</param>
            <param name="password">Password</param>
        </member>
        <member name="M:VDS.RDF.Storage.StardogConnector.#ctor(System.String,System.String,VDS.RDF.Storage.StardogReasoningMode,System.String,System.String)">
            <summary>
            Creates a new connection to a Stardog Store
            </summary>
            <param name="baseUri">Base Uri of the Server</param>
            <param name="kbID">Knowledge Base (i.e. Database) ID</param>
            <param name="username">Username</param>
            <param name="password">Password</param>
            <param name="reasoning">Reasoning Mode</param>
        </member>
        <member name="T:VDS.RDF.Storage.DatasetFileManager">
            <summary>
            Allows you to treat an RDF Dataset File - NQuads, TriG or TriX - as a read-only generic store
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.DatasetFileManager.Query(System.String)">
            <summary>
            Makes a query against the in-memory copy of the Stores data
            </summary>
            <param name="sparqlQuery">SPARQL Query</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.DatasetFileManager.Query(VDS.RDF.IRdfHandler,VDS.RDF.ISparqlResultsHandler,System.String)">
            <summary>
            Makes a query against the in-memory copy of the Stores data processing the results with one of the given handlers
            </summary>
            <param name="rdfHandler">RDF Handler</param>
            <param name="resultsHandler">Results Handler</param>
            <param name="sparqlQuery">SPARQL Query</param>
        </member>
        <member name="M:VDS.RDF.Storage.DatasetFileManager.LoadGraph(VDS.RDF.IGraph,System.Uri)">
            <summary>
            Loads a Graph from the Dataset
            </summary>
            <param name="g">Graph to load into</param>
            <param name="graphUri">URI of the Graph to load</param>
        </member>
        <member name="M:VDS.RDF.Storage.DatasetFileManager.LoadGraph(VDS.RDF.IRdfHandler,System.Uri)">
            <summary>
            Loads a Graph from the Dataset with the given Handler
            </summary>
            <param name="handler">RDF Handler</param>
            <param name="graphUri">URI of the Graph to load</param>
        </member>
        <member name="M:VDS.RDF.Storage.DatasetFileManager.LoadGraph(VDS.RDF.IGraph,System.String)">
            <summary>
            Loads a Graph from the Dataset
            </summary>
            <param name="g">Graph to load into</param>
            <param name="graphUri">URI of the Graph to load</param>
        </member>
        <member name="M:VDS.RDF.Storage.DatasetFileManager.LoadGraph(VDS.RDF.IRdfHandler,System.String)">
            <summary>
            Loads a Graph from the Dataset with the given Handler
            </summary>
            <param name="handler">RDF Handler</param>
            <param name="graphUri">URI of the Graph to load</param>
        </member>
        <member name="M:VDS.RDF.Storage.DatasetFileManager.SaveGraph(VDS.RDF.IGraph)">
            <summary>
            Throws an error since this Manager is read-only
            </summary>
            <param name="g">Graph to save</param>
            <exception cref="T:VDS.RDF.Storage.RdfStorageException">Always thrown since this Manager provides a read-only connection</exception>
        </member>
        <member name="M:VDS.RDF.Storage.DatasetFileManager.UpdateGraph(System.Uri,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Throws an error since this Manager is read-only
            </summary>
            <param name="graphUri">Graph URI</param>
            <param name="additions">Triples to be added</param>
            <param name="removals">Triples to be removed</param>
        </member>
        <member name="M:VDS.RDF.Storage.DatasetFileManager.UpdateGraph(System.String,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Throws an error since this Manager is read-only
            </summary>
            <param name="graphUri">Graph URI</param>
            <param name="additions">Triples to be added</param>
            <param name="removals">Triples to be removed</param>
        </member>
        <member name="M:VDS.RDF.Storage.DatasetFileManager.DeleteGraph(System.Uri)">
            <summary>
            Throws an error since this connection is read-only
            </summary>
            <param name="graphUri">URI of the Graph to delete</param>
            <exception cref="T:VDS.RDF.Storage.RdfStorageException">Thrown since you cannot delete a Graph from a read-only connection</exception>
        </member>
        <member name="M:VDS.RDF.Storage.DatasetFileManager.DeleteGraph(System.String)">
            <summary>
            Throws an error since this connection is read-only
            </summary>
            <param name="graphUri">URI of the Graph to delete</param>
            <exception cref="T:VDS.RDF.Storage.RdfStorageException">Thrown since you cannot delete a Graph from a read-only connection</exception>
        </member>
        <member name="M:VDS.RDF.Storage.DatasetFileManager.ListGraphs">
            <summary>
            Gets the list of URIs of Graphs in the Store
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.DatasetFileManager.ToString">
            <summary>
            Gets the String representation of the Connection
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.DatasetFileManager.Dispose">
            <summary>
            Disposes of the Manager
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.DatasetFileManager.SerializeConfiguration(VDS.RDF.Configuration.ConfigurationSerializationContext)">
            <summary>
            Serializes the connection's configuration
            </summary>
            <param name="context">Configuration Serialization Context</param>
        </member>
        <member name="P:VDS.RDF.Storage.DatasetFileManager.IOBehaviour">
            <summary>
            Gets the Save Behaviour of the Store
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.DatasetFileManager.UpdateSupported">
            <summary>
            Returns that Updates are not supported since this is a read-only connection
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.DatasetFileManager.DeleteSupported">
            <summary>
            Returns that deleting graphs is not supported
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.DatasetFileManager.IsReady">
            <summary>
            Returns that the Manager is ready if the underlying file has been loaded
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.DatasetFileManager.IsReadOnly">
            <summary>
            Returns that the Manager is read-only
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.DatasetFileManager.ListGraphsSupported">
            <summary>
            Returns that listing graphs is supported
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.DatasetFileManager.SourceFile">
            <summary>
            Gets the Source File this manager represents a read-only view of
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.FusekiConnector">
            <summary>
            Class for connecting to any dataset that can be exposed via Fuseki
            </summary>
            <remarks>
            <para>
            Uses all three Services provided by a Fuseki instance - Query, Update and HTTP Update
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Storage.SparqlHttpProtocolConnector">
            <summary>
            Class for connecting to any store that implements the SPARQL Graph Store HTTP Protocol for Managing Graphs
            </summary>
            <remarks>
            <para>
            The <a href="http://www.w3.org/TR/sparql11-http-rdf-update/">SPARQL Graph Store HTTP Protocol</a> is defined as part of SPARQL 1.1 and is currently a working draft so implementations are not guaranteed to be fully compliant with the draft and the protocol may change in the future.
            </para>
            <para>
            <strong>Note:</strong> While this connector supports the update of a Graph the Graph Store HTTP Protocol only allows for the addition of data to an existing Graph and not the removal of data, therefore any calls to <see cref="!:SparqlHttpProtocolConnector.UpdateGraph(Uri,IEnumerable&lt;Triple&gt;,IEnumerable&lt;Triple&gt;)">UpdateGraph()</see> that would require the removal of Triple(s) will result in an error.
            </para>
            </remarks>
        </member>
        <member name="F:VDS.RDF.Storage.SparqlHttpProtocolConnector._serviceUri">
            <summary>
            URI of the Protocol Server
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.SparqlHttpProtocolConnector.#ctor(System.String)">
            <summary>
            Creates a new SPARQL Graph Store HTTP Protocol Connector
            </summary>
            <param name="serviceUri">URI of the Protocol Server</param>
        </member>
        <member name="M:VDS.RDF.Storage.SparqlHttpProtocolConnector.#ctor(System.Uri)">
            <summary>
            Creates a new SPARQL Graph Store HTTP Protocol Connector
            </summary>
            <param name="serviceUri">URI of the Protocol Server</param>
        </member>
        <member name="M:VDS.RDF.Storage.SparqlHttpProtocolConnector.ListGraphs">
            <summary>
            Throws an exception as listing graphs in a SPARQL Graph Store HTTP Protocol does not support listing graphs
            </summary>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">Thrown since SPARQL Graph Store HTTP Protocol does not support listing graphs</exception>
        </member>
        <member name="M:VDS.RDF.Storage.SparqlHttpProtocolConnector.LoadGraph(VDS.RDF.IGraph,System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Loads a Graph from the Protocol Server
            </summary>
            <param name="g">Graph to load into</param>
            <param name="graphUri">URI of the Graph to load</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.SparqlHttpProtocolConnector.LoadGraph(VDS.RDF.IRdfHandler,System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Loads a Graph from the Protocol Server
            </summary>
            <param name="handler">RDF Handler</param>
            <param name="graphUri">URI of the Graph to load</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.SparqlHttpProtocolConnector.SaveGraph(VDS.RDF.IGraph,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Saves a Graph to the Protocol Server
            </summary>
            <param name="g">Graph to save</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.SparqlHttpProtocolConnector.UpdateGraph(System.String,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple},VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Updates a Graph on the Protocol Server
            </summary>
            <param name="graphUri">URI of the Graph to update</param>
            <param name="additions">Triples to be added</param>
            <param name="removals">Triples to be removed</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
            <remarks>
            <strong>Note:</strong> The SPARQL Graph Store HTTP Protocol for Graph Management only supports the addition of Triples to a Graph and does not support removal of Triples from a Graph.  If you attempt to remove Triples then an <see cref="T:VDS.RDF.Storage.RdfStorageException">RdfStorageException</see> will be thrown
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.SparqlHttpProtocolConnector.ListGraphs(VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Lists the Graphs in the Store asynchronously
            </summary>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.SparqlHttpProtocolConnector.DeleteGraph(System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Deletes a Graph from the store asynchronously
            </summary>
            <param name="graphUri">URI of the graph to delete</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.SparqlHttpProtocolConnector.Dispose">
            <summary>
            Disposes of the Connection
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.SparqlHttpProtocolConnector.ToString">
            <summary>
            Gets a String representation of the connection
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.SparqlHttpProtocolConnector.SerializeConfiguration(VDS.RDF.Configuration.ConfigurationSerializationContext)">
            <summary>
            Serializes the connection's configuration
            </summary>
            <param name="context">Configuration Serialization Context</param>
        </member>
        <member name="P:VDS.RDF.Storage.SparqlHttpProtocolConnector.IOBehaviour">
            <summary>
            Gets the IO Behaviour of SPARQL Graph Store protocol based stores
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.SparqlHttpProtocolConnector.UpdateSupported">
            <summary>
            Gets that Updates are supported
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.SparqlHttpProtocolConnector.DeleteSupported">
            <summary>
            Returns that deleting Graphs is supported
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.SparqlHttpProtocolConnector.ListGraphsSupported">
            <summary>
            Returns that listing Graphs is not supported
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.SparqlHttpProtocolConnector.IsReady">
            <summary>
            Gets that the Store is ready
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.SparqlHttpProtocolConnector.IsReadOnly">
            <summary>
            Gets that the Store is not read-only
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.FusekiConnector.#ctor(System.Uri)">
            <summary>
            Creates a new connection to a Fuseki Server
            </summary>
            <param name="serviceUri">The /data URI of the Fuseki Server</param>
        </member>
        <member name="M:VDS.RDF.Storage.FusekiConnector.#ctor(System.String)">
            <summary>
            Creates a new connection to a Fuseki Server
            </summary>
            <param name="serviceUri">The /data URI of the Fuseki Server</param>
        </member>
        <member name="M:VDS.RDF.Storage.FusekiConnector.Query(System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Makes a SPARQL Query against the underlying store
            </summary>
            <param name="sparqlQuery">SPARQL Query</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
            <returns><see cref="T:VDS.RDF.Query.SparqlResultSet">SparqlResultSet</see> or a <see cref="T:VDS.RDF.Graph">Graph</see> depending on the Sparql Query</returns>
        </member>
        <member name="M:VDS.RDF.Storage.FusekiConnector.Query(VDS.RDF.IRdfHandler,VDS.RDF.ISparqlResultsHandler,System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Executes a SPARQL Query on the Fuseki store processing the results using an appropriate handler from those provided
            </summary>
            <param name="rdfHandler">RDF Handler</param>
            <param name="resultsHandler">Results Handler</param>
            <param name="sparqlQuery">SPARQL Query</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.FusekiConnector.Update(System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Executes SPARQL Updates against the Fuseki store
            </summary>
            <param name="sparqlUpdate">SPARQL Update</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.FusekiConnector.ListGraphs(VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Lists the graph sin the Store asynchronously
            </summary>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.FusekiConnector.UpdateGraph(System.String,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple},VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Updates a Graph on the Fuseki Server
            </summary>
            <param name="graphUri">URI of the Graph to update</param>
            <param name="additions">Triples to be added</param>
            <param name="removals">Triples to be removed</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.FusekiConnector.ToString">
            <summary>
            Gets a String which gives details of the Connection
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.FusekiConnector.SerializeConfiguration(VDS.RDF.Configuration.ConfigurationSerializationContext)">
            <summary>
            Serializes the connection's configuration
            </summary>
            <param name="context">Configuration Serialization Context</param>
        </member>
        <member name="P:VDS.RDF.Storage.FusekiConnector.ListGraphsSupported">
            <summary>
            Returns that Listing Graphs is supported
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.FusekiConnector.IOBehaviour">
            <summary>
            Gets the IO Behaviour of the Store
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.FusekiConnector.UpdateSupported">
            <summary>
            Returns that Triple level updates are supported using Fuseki
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.InMemoryManager">
            <summary>
            Provides a wrapper around an in-memory store
            </summary>
            <remarks>
            <para>
            Useful if you want to test out some code using temporary in-memory data before you run the code against a real store or if you are using some code that requires an <see cref="T:VDS.RDF.Storage.IStorageProvider">IStorageProvider</see> interface but you need the results of that code to be available directly in-memory.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.InMemoryManager.#ctor">
            <summary>
            Creates a new In-Memory Manager which is a wrapper around a new empty in-memory store
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.InMemoryManager.#ctor(VDS.RDF.IInMemoryQueryableStore)">
            <summary>
            Creates a new In-Memory Manager which is a wrapper around an in-memory store
            </summary>
            <param name="store">Triple Store</param>
        </member>
        <member name="M:VDS.RDF.Storage.InMemoryManager.#ctor(VDS.RDF.Query.Datasets.ISparqlDataset)">
            <summary>
            Creates a new In-Memory Manager which is a wrapper around a SPARQL Dataset
            </summary>
            <param name="dataset">Dataset</param>
        </member>
        <member name="M:VDS.RDF.Storage.InMemoryManager.LoadGraph(VDS.RDF.IGraph,System.Uri)">
            <summary>
            Loads a Graph from the Store
            </summary>
            <param name="g">Graph to load into</param>
            <param name="graphUri">Graph URI to load</param>
        </member>
        <member name="M:VDS.RDF.Storage.InMemoryManager.LoadGraph(VDS.RDF.IRdfHandler,System.Uri)">
            <summary>
            Loads a Graph from the Store
            </summary>
            <param name="handler">RDF Handler</param>
            <param name="graphUri">Graph URI to load</param>
        </member>
        <member name="M:VDS.RDF.Storage.InMemoryManager.LoadGraph(VDS.RDF.IGraph,System.String)">
            <summary>
            Loads a Graph from the Store
            </summary>
            <param name="g">Graph to load into</param>
            <param name="graphUri">Graph URI to load</param>
        </member>
        <member name="M:VDS.RDF.Storage.InMemoryManager.LoadGraph(VDS.RDF.IRdfHandler,System.String)">
            <summary>
            Loads a Graph from the Store
            </summary>
            <param name="handler">RDF Handler</param>
            <param name="graphUri">Graph URI to load</param>
        </member>
        <member name="M:VDS.RDF.Storage.InMemoryManager.SaveGraph(VDS.RDF.IGraph)">
            <summary>
            Saves a Graph to the Store
            </summary>
            <param name="g">Graph</param>
        </member>
        <member name="M:VDS.RDF.Storage.InMemoryManager.UpdateGraph(System.Uri,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Updates a Graph in the Store
            </summary>
            <param name="graphUri">URI of the Graph to Update</param>
            <param name="additions">Triples to be added</param>
            <param name="removals">Triples to be removed</param>
        </member>
        <member name="M:VDS.RDF.Storage.InMemoryManager.UpdateGraph(System.String,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Updates a Graph in the Store
            </summary>
            <param name="graphUri">URI of the Graph to Update</param>
            <param name="additions">Triples to be added</param>
            <param name="removals">Triples to be removed</param>
        </member>
        <member name="M:VDS.RDF.Storage.InMemoryManager.DeleteGraph(System.Uri)">
            <summary>
            Deletes a Graph from the Store
            </summary>
            <param name="graphUri">URI of the Graph to delete</param>
        </member>
        <member name="M:VDS.RDF.Storage.InMemoryManager.DeleteGraph(System.String)">
            <summary>
            Deletes a Graph from the Store
            </summary>
            <param name="graphUri">URI of the Graph to delete</param>
        </member>
        <member name="M:VDS.RDF.Storage.InMemoryManager.ListGraphs">
            <summary>
            Lists the URIs of Graphs in the Store
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.InMemoryManager.Query(System.String)">
            <summary>
            Makes a SPARQL Query against the Store
            </summary>
            <param name="sparqlQuery">SPARQL Query</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.InMemoryManager.Query(VDS.RDF.IRdfHandler,VDS.RDF.ISparqlResultsHandler,System.String)">
            <summary>
            Makes a SPARQL Query against the Store processing the results with the appropriate processor from those given
            </summary>
            <param name="rdfHandler">RDF Handler</param>
            <param name="resultsHandler">Results Handler</param>
            <param name="sparqlQuery">SPARQL Query</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.InMemoryManager.Update(System.String)">
            <summary>
            Applies SPARQL Updates to the Store
            </summary>
            <param name="sparqlUpdate">SPARQL Update</param>
        </member>
        <member name="M:VDS.RDF.Storage.InMemoryManager.Query(System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Queries the store asynchronously
            </summary>
            <param name="sparqlQuery">SPARQL Query</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.InMemoryManager.Query(VDS.RDF.IRdfHandler,VDS.RDF.ISparqlResultsHandler,System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Queries the store asynchronously
            </summary>
            <param name="sparqlQuery">SPARQL Query</param>
            <param name="rdfHandler">RDF Handler</param>
            <param name="resultsHandler">Results Handler</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.InMemoryManager.Update(System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Updates the store asynchronously
            </summary>
            <param name="sparqlUpdates">SPARQL Update</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.InMemoryManager.Dispose">
            <summary>
            Disposes of the Manager
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.InMemoryManager.ToString">
            <summary>
            Gets a String representation of the Manager
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.InMemoryManager.SerializeConfiguration(VDS.RDF.Configuration.ConfigurationSerializationContext)">
            <summary>
            Serializes the Configuration of the Manager
            </summary>
            <param name="context">Configuration Serialization Context</param>
        </member>
        <member name="P:VDS.RDF.Storage.InMemoryManager.IOBehaviour">
            <summary>
            Gets the IO Behaviour for In-Memory stores
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.InMemoryManager.UpdateSupported">
            <summary>
            Returns that Triple level updates are supported
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.InMemoryManager.DeleteSupported">
            <summary>
            Returns that Graph Deletion is supported
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.InMemoryManager.ListGraphsSupported">
            <summary>
            Returns that listing graphs is supported
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.InMemoryManager.IsReady">
            <summary>
            Returns that the Store is ready
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.InMemoryManager.IsReadOnly">
            <summary>
            Returns that the Store is not read-only
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.ReadOnlyConnector">
            <summary>
            Provides a Read-Only wrapper that can be placed around another <see cref="T:VDS.RDF.Storage.IStorageProvider">IStorageProvider</see> instance
            </summary>
            <remarks>
            <para>
            This is useful if you want to allow some code read-only access to a mutable store and ensure that it cannot modify the store via the manager instance
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.ReadOnlyConnector.#ctor(VDS.RDF.Storage.IStorageProvider)">
            <summary>
            Creates a new Read-Only connection which is a read-only wrapper around another store
            </summary>
            <param name="manager">Manager for the Store you want to wrap as read-only</param>
        </member>
        <member name="M:VDS.RDF.Storage.ReadOnlyConnector.LoadGraph(VDS.RDF.IGraph,System.Uri)">
            <summary>
            Loads a Graph from the underlying Store
            </summary>
            <param name="g">Graph to load into</param>
            <param name="graphUri">URI of the Graph to load</param>
        </member>
        <member name="M:VDS.RDF.Storage.ReadOnlyConnector.LoadGraph(VDS.RDF.IGraph,System.String)">
            <summary>
            Loads a Graph from the underlying Store
            </summary>
            <param name="g">Graph to load into</param>
            <param name="graphUri">URI of the Graph to load</param>
        </member>
        <member name="M:VDS.RDF.Storage.ReadOnlyConnector.LoadGraph(VDS.RDF.IRdfHandler,System.Uri)">
            <summary>
            Loads a Graph from the underlying Store
            </summary>
            <param name="handler">RDF Handler</param>
            <param name="graphUri">URI of the Graph to load</param>
        </member>
        <member name="M:VDS.RDF.Storage.ReadOnlyConnector.LoadGraph(VDS.RDF.IRdfHandler,System.String)">
            <summary>
            Loads a Graph from the underlying Store
            </summary>
            <param name="handler">RDF Handler</param>
            <param name="graphUri">URI of the Graph to load</param>
        </member>
        <member name="M:VDS.RDF.Storage.ReadOnlyConnector.SaveGraph(VDS.RDF.IGraph)">
            <summary>
            Throws an exception since you cannot save a Graph using a read-only connection
            </summary>
            <param name="g">Graph to save</param>
            <exception cref="T:VDS.RDF.Storage.RdfStorageException">Thrown since you cannot save a Graph using a read-only connection</exception>
        </member>
        <member name="M:VDS.RDF.Storage.ReadOnlyConnector.UpdateGraph(System.Uri,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Throws an exception since you cannot update a Graph using a read-only connection
            </summary>
            <param name="graphUri">URI of the Graph</param>
            <param name="additions">Triples to be added</param>
            <param name="removals">Triples to be removed</param>
            <exception cref="T:VDS.RDF.Storage.RdfStorageException">Thrown since you cannot update a Graph using a read-only connection</exception>
        </member>
        <member name="M:VDS.RDF.Storage.ReadOnlyConnector.UpdateGraph(System.String,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">
            <summary>
            Throws an exception since you cannot update a Graph using a read-only connection
            </summary>
            <param name="graphUri">URI of the Graph</param>
            <param name="additions">Triples to be added</param>
            <param name="removals">Triples to be removed</param>
            <exception cref="T:VDS.RDF.Storage.RdfStorageException">Thrown since you cannot update a Graph using a read-only connection</exception>
        </member>
        <member name="M:VDS.RDF.Storage.ReadOnlyConnector.DeleteGraph(System.Uri)">
            <summary>
            Throws an exception as you cannot delete a Graph using a read-only connection
            </summary>
            <param name="graphUri">URI of the Graph to delete</param>
            <exception cref="T:VDS.RDF.Storage.RdfStorageException">Thrown since you cannot delete a Graph using a read-only connection</exception>
        </member>
        <member name="M:VDS.RDF.Storage.ReadOnlyConnector.DeleteGraph(System.String)">
            <summary>
            Throws an exception as you cannot delete a Graph using a read-only connection
            </summary>
            <param name="graphUri">URI of the Graph to delete</param>
            <exception cref="T:VDS.RDF.Storage.RdfStorageException">Thrown since you cannot delete a Graph using a read-only connection</exception>
        </member>
        <member name="M:VDS.RDF.Storage.ReadOnlyConnector.ListGraphs">
            <summary>
            Gets the list of graphs in the underlying store
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.ReadOnlyConnector.Dispose">
            <summary>
            Disposes of the Store
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.ReadOnlyConnector.ToString">
            <summary>
            Gets the String representation of the Manager
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.ReadOnlyConnector.SerializeConfiguration(VDS.RDF.Configuration.ConfigurationSerializationContext)">
            <summary>
            Serializes the Configuration of the Manager
            </summary>
            <param name="context">Configuration Serialization Context</param>
        </member>
        <member name="P:VDS.RDF.Storage.ReadOnlyConnector.ParentServer">
            <summary>
            Gets the parent server (if any)
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.ReadOnlyConnector.IOBehaviour">
            <summary>
            Gets the IO Behaviour of the read-only connection taking into account the IO Behaviour of the underlying store
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.ReadOnlyConnector.UpdateSupported">
            <summary>
            Returns that Update is not supported
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.ReadOnlyConnector.DeleteSupported">
            <summary>
            Returns that deleting graphs is not supported
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.ReadOnlyConnector.ListGraphsSupported">
            <summary>
            Returns whether listing graphs is supported by the underlying store
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.ReadOnlyConnector.IsReady">
            <summary>
            Returns whether the Store is ready
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.ReadOnlyConnector.IsReadOnly">
            <summary>
            Returns that the Store is read-only
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.QueryableReadOnlyConnector">
            <summary>
            Provides a Read-Only wrapper that can be placed around another <see cref="T:VDS.RDF.Storage.IQueryableStorage">IQueryableStorage</see> instance
            </summary>
            <remarks>
            <para>
            This is useful if you want to allow some code read-only access to a mutable store and ensure that it cannot modify the store via the manager instance
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.QueryableReadOnlyConnector.#ctor(VDS.RDF.Storage.IQueryableStorage)">
            <summary>
            Creates a new Queryable Read-Only connection which is a read-only wrapper around another store
            </summary>
            <param name="manager">Manager for the Store you want to wrap as read-only</param>
        </member>
        <member name="M:VDS.RDF.Storage.QueryableReadOnlyConnector.Query(System.String)">
            <summary>
            Executes a SPARQL Query on the underlying Store
            </summary>
            <param name="sparqlQuery">SPARQL Query</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.QueryableReadOnlyConnector.Query(VDS.RDF.IRdfHandler,VDS.RDF.ISparqlResultsHandler,System.String)">
            <summary>
            Executes a SPARQL Query on the underlying Store processing the results with an appropriate handler from those provided
            </summary>
            <param name="rdfHandler">RDF Handler</param>
            <param name="resultsHandler">Results Handler</param>
            <param name="sparqlQuery">SPARQL Query</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.QueryableReadOnlyConnector.ListGraphs">
            <summary>
            Lists the Graphs in the Store
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Storage.QueryableReadOnlyConnector.ListGraphsSupported">
            <summary>
            Returns that listing Graphs is supported
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.Virtualisation.IVirtualNode`2">
            <summary>
            Interface for Virtual Nodes
            </summary>
            <typeparam name="TNodeID">Node ID Type</typeparam>
            <typeparam name="TGraphID">Graph ID Type</typeparam>
        </member>
        <member name="T:VDS.RDF.Storage.Virtualisation.IVirtualIdComparable">
            <summary>
            Interface for comparing nodes on their VirtualID property
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.IVirtualIdComparable.TryCompareVirtualId(VDS.RDF.INode,System.Int32@)">
            <summary>
            Attempt to compare the VirtualID of this node with the VirtualID of the other node
            </summary>
            <param name="other">The other node to try to compare against</param>
            <param name="comparisonResult">The result of the comparison if it could be performed</param>
            <returns>True if a comparison could be performed, false otherwise.</returns>
        </member>
        <member name="P:VDS.RDF.Storage.Virtualisation.IVirtualNode`2.VirtualID">
            <summary>
            Gets the Node ID
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Virtualisation.IVirtualNode`2.Provider">
            <summary>
            Gets the Virtual Node provider
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Virtualisation.IVirtualNode`2.IsMaterialised">
            <summary>
            Gets whether the Nodes value has been materialised
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Virtualisation.IVirtualNode`2.MaterialisedValue">
            <summary>
            Gets the materialised value forcing it to be materialised if necessary
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.Virtualisation.IVirtualRdfProvider`2">
            <summary>
            A Virtual RDF Provider is a provider that transforms materialised values into virtual ID values.  These virtual values can be used to do much faster term equality checking and to minimise memory usage when accessing out of memory data.
            </summary>
            <typeparam name="TNodeID">Node ID Type</typeparam>
            <typeparam name="TGraphID">Graph ID Type</typeparam>
            <remarks>
            <para>
            An implementation of this is typically in addition to a more general RDF store implementation (such as an <see cref="T:VDS.RDF.Storage.IStorageProvider">IStorageProvider</see>) and was originally designed and intended for use in creating <see cref="T:VDS.RDF.Query.Datasets.ISparqlDataset">ISparqlDataset</see> instances which allow out of memory data to be queried more efficiently.
            </para>
            <para>
            It is expected that most implementations will use a cache to ensure that repeated transformations are as fast as possible
            </para>
            <h3>Important Note re: Blank Nodes</h3>
            <para>
            In order for code that uses this class to function correctly it must be ensured that IDs issued for Blank Nodes are graph scoped, as such a specific method for converting Blank Nodes into Virtual Node IDs is given
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.IVirtualRdfProvider`2.GetValue(VDS.RDF.IGraph,`0)">
            <summary>
            Given a Node ID returns the materialised value in the given Graph
            </summary>
            <param name="g">Graph to create the Node in</param>
            <param name="id">Node ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.IVirtualRdfProvider`2.GetGraphUri(`1)">
            <summary>
            Given a Graph ID returns the value of the Graph URI
            </summary>
            <param name="id">Graph ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.IVirtualRdfProvider`2.GetID(VDS.RDF.INode)">
            <summary>
            Given a non-blank Node returns the Node ID
            </summary>
            <param name="value">Node</param>
            <remarks>
            Should function as equivalent to the two argument version with the <strong>createIfNotExists</strong> parameter set to false
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.IVirtualRdfProvider`2.GetGraphID(VDS.RDF.IGraph)">
            <summary>
            Gets the Graph ID for a Graph
            </summary>
            <param name="g">Graph</param>
            <returns></returns>
            <remarks>
            Should function as equivalent to the two argument version with the <strong>createIfNotExists</strong> parameter set to false
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.IVirtualRdfProvider`2.GetGraphID(VDS.RDF.IGraph,System.Boolean)">
            <summary>
            Gets the Graph ID for a Graph creating it if necessary
            </summary>
            <param name="g">Graph</param>
            <param name="createIfNotExists">Determines whether to create a new Graph ID if there is not already one for the given Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.IVirtualRdfProvider`2.GetGraphID(System.Uri)">
            <summary>
            Gets the Graph ID for a Graph URI
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
            <remarks>
            Should function as equivalent to the two argument version with the <strong>createIfNotExists</strong> parameter set to false
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.IVirtualRdfProvider`2.GetGraphID(System.Uri,System.Boolean)">
            <summary>
            Gets the Graph ID for a Graph URI
            </summary>
            <param name="graphUri">Graph URI</param>
            <param name="createIfNotExists">Determines whether to create a new Graph ID if there is not already one for the given Graph URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.IVirtualRdfProvider`2.GetID(VDS.RDF.INode,System.Boolean)">
            <summary>
            Given a non-blank Node returns the Node ID
            </summary>
            <param name="value">Node</param>
            <param name="createIfNotExists">Determines whether to create a new Node ID if there is not already one for the given value</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.IVirtualRdfProvider`2.GetBlankNodeID(VDS.RDF.IBlankNode,System.Boolean)">
            <summary>
            Given a Blank Node returns a Graph scoped Node ID
            </summary>
            <param name="value">Blank Node</param>
            <param name="createIfNotExists">Determines whether to create a new Node ID if there is not already one for the given value</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.IVirtualRdfProvider`2.GetBlankNodeID(VDS.RDF.IBlankNode)">
            <summary>
            Given a Blank Node returns a Graph scoped Node ID
            </summary>
            <param name="value">Blank Node</param>
            <returns></returns>
            <remarks>
            Should function as equivalent to the two argument version with the <strong>createIfNotExists</strong> parameter set to false
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.IVirtualRdfProvider`2.LoadGraphVirtual(VDS.RDF.IGraph,System.Uri)">
            <summary>
            Loads a Graph creating all the Triples with virtual node values
            </summary>
            <param name="g">Graph to load into</param>
            <param name="graphUri">URI of the Graph to load</param>
        </member>
        <member name="P:VDS.RDF.Storage.Virtualisation.IVirtualRdfProvider`2.NullID">
            <summary>
            Gets the Node ID that is used to indicate that a Node does not exist in the underlying storage
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.Virtualisation.SimpleVirtualBlankNode">
            <summary>
            Simple implementation of a Virtual Blank Node where the virtual IDs are integers
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.Virtualisation.BaseVirtualBlankNode`2">
            <summary>
            Abstract Base implementation of a Virtual Blank Node
            </summary>
            <typeparam name="TNodeID">Node ID Type</typeparam>
            <typeparam name="TGraphID">Graph ID Type</typeparam>
        </member>
        <member name="T:VDS.RDF.Storage.Virtualisation.BaseVirtualNode`2">
            <summary>
            Abstract Base implementation of a Virtual Node which is a Node that is represented only by some ID until such time as its value actually needs materialising
            </summary>
            <typeparam name="TNodeID">Node ID Type</typeparam>
            <typeparam name="TGraphID">Graph ID Type</typeparam>
            <remarks>
            <para>
            As far as possible equality checks are carried out using these IDs and limited comparisons may also be done this way.  More specific implementations may wish to derive from this class in order to override the default comparison implementation to further reduce the number of places where value materialisation is done.
            </para>
            <para>
            Note that this class does not implement any of the specialised Node interfaces and instead relies on the casting of its materialised value to an appropriately typed node to provide the true values to code that needs it
            </para>
            </remarks>
        </member>
        <member name="F:VDS.RDF.Storage.Virtualisation.BaseVirtualNode`2._value">
            <summary>
            The materialised value of the Virtual Node
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualNode`2.#ctor(VDS.RDF.IGraph,VDS.RDF.NodeType,`0,VDS.RDF.Storage.Virtualisation.IVirtualRdfProvider{`0,`1})">
            <summary>
            Creates a new Base Virtual Node
            </summary>
            <param name="g">Graph the Node belongs to</param>
            <param name="type">Type of the node</param>
            <param name="id">Virtual ID</param>
            <param name="provider">Virtual RDF Provider</param>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualNode`2.#ctor(VDS.RDF.IGraph,VDS.RDF.NodeType,`0,VDS.RDF.Storage.Virtualisation.IVirtualRdfProvider{`0,`1},VDS.RDF.INode)">
            <summary>
            Creates a new Base Virtual Node
            </summary>
            <param name="g">Graph the Node belongs to</param>
            <param name="type">Type of the node</param>
            <param name="id">Virtual ID</param>
            <param name="provider">Virtual RDF Provider</param>
            <param name="value">Materialised Value</param>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualNode`2.MaterialiseValue">
            <summary>
            Materialises the Value if it is not already materialised
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualNode`2.OnMaterialise">
            <summary>
            Called after the value is materialised for the first time
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualNode`2.ToString(VDS.RDF.Writing.Formatting.INodeFormatter)">
            <summary>
            Gets the String representation of the Node formatted with the given Node formatter
            </summary>
            <param name="formatter">Formatter</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualNode`2.ToString(VDS.RDF.Writing.Formatting.INodeFormatter,VDS.RDF.Writing.TripleSegment)">
            <summary>
            Gets the String representation of the Node formatted with the given Node formatter
            </summary>
            <param name="formatter">Formatter</param>
            <param name="segment">Triple Segment</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualNode`2.CompareTo(VDS.RDF.Storage.Virtualisation.IVirtualNode{`0,`1})">
            <summary>
            Compares this Node to another Virtual Node
            </summary>
            <param name="other">Other Virtual Node</param>
            <returns></returns>
            <remarks>
            Unless Virtual Equality (equality based on the Virtual RDF Provider and Virtual ID) can be determined or the Nodes are of different types then the Nodes value will have to be materialised in order to perform comparison.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualNode`2.CompareTo(VDS.RDF.Storage.Virtualisation.BaseVirtualNode{`0,`1})">
            <summary>
            Compares this Node to another Virtual Node
            </summary>
            <param name="other">Other Virtual Node</param>
            <returns></returns>
            <remarks>
            Unless Virtual Equality (equality based on the Virtual RDF Provider and Virtual ID) can be determined or the Nodes are of different types then the Nodes value will have to be materialised in order to perform comparison.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualNode`2.CompareTo(VDS.RDF.INode)">
            <summary>
            Compares this Node to another Node
            </summary>
            <param name="other">Other Node</param>
            <returns></returns>
            <remarks>
            Unless Virtual Equality (equality based on the Virtual RDF Provider and Virtual ID) can be determined or the Nodes are of different types then the Nodes value will have to be materialised in order to perform comparison.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualNode`2.CompareTo(VDS.RDF.IBlankNode)">
            <summary>
            Compares this Node to another Blank Node
            </summary>
            <param name="other">Other Blank Node</param>
            <returns></returns>
            <remarks>
            Unless Virtual Equality (equality based on the Virtual RDF Provider and Virtual ID) can be determined or the Nodes are of different types then the Nodes value will have to be materialised in order to perform comparison.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualNode`2.CompareTo(VDS.RDF.IGraphLiteralNode)">
            <summary>
            Compares this Node to another Graph LiteralNode
            </summary>
            <param name="other">Other Graph Literal Node</param>
            <returns></returns>
            <remarks>
            Unless Virtual Equality (equality based on the Virtual RDF Provider and Virtual ID) can be determined or the Nodes are of different types then the Nodes value will have to be materialised in order to perform comparison.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualNode`2.CompareTo(VDS.RDF.ILiteralNode)">
            <summary>
            Compares this Node to another Literal Node
            </summary>
            <param name="other">Other Literal Node</param>
            <returns></returns>
            <remarks>
            Unless Virtual Equality (equality based on the Virtual RDF Provider and Virtual ID) can be determined or the Nodes are of different types then the Nodes value will have to be materialised in order to perform comparison.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualNode`2.CompareTo(VDS.RDF.IUriNode)">
            <summary>
            Compares this Node to another URI Node
            </summary>
            <param name="other">Other URI Node</param>
            <returns></returns>
            <remarks>
            Unless Virtual Equality (equality based on the Virtual RDF Provider and Virtual ID) can be determined or the Nodes are of different types then the Nodes value will have to be materialised in order to perform comparison.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualNode`2.CompareTo(VDS.RDF.IVariableNode)">
            <summary>
            Compares this Node to another Variable Node
            </summary>
            <param name="other">Other Variable Node</param>
            <returns></returns>
            <remarks>
            Unless Virtual Equality (equality based on the Virtual RDF Provider and Virtual ID) can be determined or the Nodes are of different types then the Nodes value will have to be materialised in order to perform comparison.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualNode`2.Equals(System.Object)">
            <summary>
            Checks this Node for equality against another Object
            </summary>
            <param name="obj">Other Object</param>
            <returns></returns>
            <remarks>
            Unless Virtual Equality (equality based on the Virtual RDF Provider and Virtual ID) can be determined or the Nodes are of different types then the Nodes value will have to be materialised in order to perform the equality check.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualNode`2.Equals(VDS.RDF.Storage.Virtualisation.IVirtualNode{`0,`1})">
            <summary>
            Checks this Node for equality against another Virtual Node
            </summary>
            <param name="other">Other Virtual Node</param>
            <returns></returns>
            <remarks>
            Unless Virtual Equality (equality based on the Virtual RDF Provider and Virtual ID) can be determined or the Nodes are of different types then the Nodes value will have to be materialised in order to perform the equality check.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualNode`2.Equals(VDS.RDF.Storage.Virtualisation.BaseVirtualNode{`0,`1})">
            <summary>
            Checks this Node for equality against another Virtual Node
            </summary>
            <param name="other">Other Virtual Node</param>
            <returns></returns>
            <remarks>
            Unless Virtual Equality (equality based on the Virtual RDF Provider and Virtual ID) can be determined or the Nodes are of different types then the Nodes value will have to be materialised in order to perform the equality check.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualNode`2.Equals(VDS.RDF.INode)">
            <summary>
            Checks this Node for equality against another Node
            </summary>
            <param name="other">Other Node</param>
            <returns></returns>
            <remarks>
            Unless Virtual Equality (equality based on the Virtual RDF Provider and Virtual ID) can be determined or the Nodes are of different types then the Nodes value will have to be materialised in order to perform the equality check.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualNode`2.TypedEquality(VDS.RDF.INode)">
            <summary>
            Checks the Node Types and if they are equal invokes the INode based comparison
            </summary>
            <param name="other">Node to compare with for equality</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualNode`2.TryVirtualEquality(VDS.RDF.INode,System.Boolean@)">
            <summary>
            Tries to check for equality using virtual node IDs
            </summary>
            <param name="other">Node to test against</param>
            <param name="areEqual">Whether the virtual nodes are equal</param>
            <returns>
            Whether the virtual equality test was valid, if false then other means must be used to determine equality
            </returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualNode`2.Equals(VDS.RDF.IBlankNode)">
            <summary>
            Checks this Node for equality against another Blank Node
            </summary>
            <param name="other">Other Blank Node</param>
            <returns></returns>
            <remarks>
            Unless Virtual Equality (equality based on the Virtual RDF Provider and Virtual ID) can be determined or the Nodes are of different types then the Nodes value will have to be materialised in order to perform the equality check.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualNode`2.Equals(VDS.RDF.IGraphLiteralNode)">
            <summary>
            Checks this Node for equality against another Graph Literal Node
            </summary>
            <param name="other">Other Graph Literal Node</param>
            <returns></returns>
            <remarks>
            Unless Virtual Equality (equality based on the Virtual RDF Provider and Virtual ID) can be determined or the Nodes are of different types then the Nodes value will have to be materialised in order to perform the equality check.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualNode`2.Equals(VDS.RDF.ILiteralNode)">
            <summary>
            Checks this Node for equality against another Literal Node
            </summary>
            <param name="other">Other Literal Node</param>
            <returns></returns>
            <remarks>
            Unless Virtual Equality (equality based on the Virtual RDF Provider and Virtual ID) can be determined or the Nodes are of different types then the Nodes value will have to be materialised in order to perform the equality check.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualNode`2.Equals(VDS.RDF.IUriNode)">
            <summary>
            Checks this Node for equality against another URI Node
            </summary>
            <param name="other">Other URI Node</param>
            <returns></returns>
            <remarks>
            Unless Virtual Equality (equality based on the Virtual RDF Provider and Virtual ID) can be determined or the Nodes are of different types then the Nodes value will have to be materialised in order to perform the equality check.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualNode`2.Equals(VDS.RDF.IVariableNode)">
            <summary>
            Checks this Node for equality against another Variable Node
            </summary>
            <param name="other">Other Variable Node</param>
            <returns></returns>
            <remarks>
            Unless Virtual Equality (equality based on the Virtual RDF Provider and Virtual ID) can be determined or the Nodes are of different types then the Nodes value will have to be materialised in order to perform the equality check.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualNode`2.CopyNode(VDS.RDF.IGraph)">
            <summary>
            Copies the Virtual Node into another Graph
            </summary>
            <param name="target">Target Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualNode`2.GetHashCode">
            <summary>
            Gets the Hash Code of the Virtual Node
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualNode`2.CompareVirtualId(`0)">
            <summary>
            Method to be implemented in derived classes to provide comparison of VirtualId values
            </summary>
            <param name="other">The other virtual ID value to be compared with this node's virtual ID value.</param>
            <returns>The comparison result.</returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualNode`2.ToString">
            <summary>
            Gets the String representation of the Node
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Storage.Virtualisation.BaseVirtualNode`2.VirtualID">
            <summary>
            Gets the Virtual ID of the Node
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Virtualisation.BaseVirtualNode`2.Provider">
            <summary>
            Gets the Virtual RDF Provider of the Node
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Virtualisation.BaseVirtualNode`2.IsMaterialised">
            <summary>
            Gets whether the Nodes value has been materialised
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Virtualisation.BaseVirtualNode`2.MaterialisedValue">
            <summary>
            Gets the materialised value of the Node forcing it to be materialised if it hasn't already
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Virtualisation.BaseVirtualNode`2.NodeType">
            <summary>
            Gets the Type of the Node
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Virtualisation.BaseVirtualNode`2.Graph">
            <summary>
            Gets the Graph the Node belongs to
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Virtualisation.BaseVirtualNode`2.GraphUri">
            <summary>
            Gets/Sets the Graph URI of the Node
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualBlankNode`2.#ctor(VDS.RDF.IGraph,`0,VDS.RDF.Storage.Virtualisation.IVirtualRdfProvider{`0,`1})">
            <summary>
            Creates a new Virtual Blank Node
            </summary>
            <param name="g">Graph the Node belongs to</param>
            <param name="id">Virtual ID</param>
            <param name="provider">Virtual RDF Provider</param>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualBlankNode`2.#ctor(VDS.RDF.IGraph,`0,VDS.RDF.Storage.Virtualisation.IVirtualRdfProvider{`0,`1},VDS.RDF.IBlankNode)">
            <summary>
            Creates a new Virtual Blank Node
            </summary>
            <param name="g">Graph the Node belongs to</param>
            <param name="id">Virtual ID</param>
            <param name="provider">Virtual RDF Provider</param>
            <param name="value">Materialised Value</param>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualBlankNode`2.OnMaterialise">
            <summary>
            Takes post materialisation actions
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualBlankNode`2.CompareTo(VDS.RDF.IBlankNode)">
            <summary>
            Compares this Node to another Blank Node
            </summary>
            <param name="other">Other Blank Node</param>
            <returns></returns>
            <remarks>
            Unless Virtual Equality (equality based on the Virtual RDF Provider and Virtual ID) can be determined or the Nodes are of different types then the Nodes value will have to be materialised in order to perform comparison.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualBlankNode`2.Equals(VDS.RDF.IBlankNode)">
            <summary>
            Checks this Node for equality against another Blank Node
            </summary>
            <param name="other">Other Blank Node</param>
            <returns></returns>
            <remarks>
            Unless Virtual Equality (equality based on the Virtual RDF Provider and Virtual ID) can be determined or the Nodes are of different types then the Nodes value will have to be materialised in order to perform the equality check.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualBlankNode`2.Equals(VDS.RDF.Storage.Virtualisation.BaseVirtualBlankNode{`0,`1})">
            <summary>
            Checks this Node for equality against another Blank Node
            </summary>
            <param name="other">Other Blank Node</param>
            <returns></returns>
            <remarks>
            Unless Virtual Equality (equality based on the Virtual RDF Provider and Virtual ID) can be determined or the Nodes are of different types then the Nodes value will have to be materialised in order to perform the equality check.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualBlankNode`2.CompareTo(VDS.RDF.Storage.Virtualisation.BaseVirtualBlankNode{`0,`1})">
            <summary>
            Compares this Node to another Blank Node
            </summary>
            <param name="other">Other Blank Node</param>
            <returns></returns>
            <remarks>
            Unless Virtual Equality (equality based on the Virtual RDF Provider and Virtual ID) can be determined or the Nodes are of different types then the Nodes value will have to be materialised in order to perform comparison.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualBlankNode`2.AsString">
            <summary>
            Throws an error as blank nodes cannot be cast to types
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualBlankNode`2.AsInteger">
            <summary>
            Throws an error as blank nodes cannot be cast to types
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualBlankNode`2.AsDecimal">
            <summary>
            Throws an error as blank nodes cannot be cast to types
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualBlankNode`2.AsFloat">
            <summary>
            Throws an error as blank nodes cannot be cast to types
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualBlankNode`2.AsDouble">
            <summary>
            Throws an error as blank nodes cannot be cast to types
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualBlankNode`2.AsBoolean">
            <summary>
            Throws an error as blank nodes cannot be cast to types
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualBlankNode`2.AsDateTime">
            <summary>
            Throws an error as blank nodes cannot be cast to types
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualBlankNode`2.AsDateTimeOffset">
            <summary>
            Throws an error as blank nodes cannot be cast to types
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualBlankNode`2.AsTimeSpan">
            <summary>
            Throws an error as blank nodes cannot be cast to a time span
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Storage.Virtualisation.BaseVirtualBlankNode`2.InternalID">
            <summary>
            Gets the Internal ID of the Blank Node
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Virtualisation.BaseVirtualBlankNode`2.EffectiveType">
            <summary>
            Gets the URI of the datatype this valued node represents as a String
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Virtualisation.BaseVirtualBlankNode`2.NumericType">
            <summary>
            Gets the numeric type of the node
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.SimpleVirtualBlankNode.#ctor(VDS.RDF.IGraph,System.Int32,VDS.RDF.Storage.Virtualisation.IVirtualRdfProvider{System.Int32,System.Int32})">
            <summary>
            Creates a new Virtual Blank Node
            </summary>
            <param name="g">Graph the Node belongs to</param>
            <param name="id">Virtual ID</param>
            <param name="provider">Virtual RDF Provider</param>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.SimpleVirtualBlankNode.#ctor(VDS.RDF.IGraph,System.Int32,VDS.RDF.Storage.Virtualisation.IVirtualRdfProvider{System.Int32,System.Int32},VDS.RDF.IBlankNode)">
            <summary>
            Creates a new Virtual Blank Node
            </summary>
            <param name="g">Graph the Node belongs to</param>
            <param name="id">Virtual ID</param>
            <param name="provider">Virtual RDF Provider</param>
            <param name="value">Materialised Value</param>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.SimpleVirtualBlankNode.Equals(VDS.RDF.Storage.Virtualisation.SimpleVirtualBlankNode)">
            <summary>
            Determines whether this Node is equal to another virtual Blank node
            </summary>
            <param name="other">Other Blank Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.SimpleVirtualBlankNode.CompareTo(VDS.RDF.Storage.Virtualisation.SimpleVirtualBlankNode)">
            <summary>
            Compares this Node to another virtual Blank node
            </summary>
            <param name="other">Other Blank Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.SimpleVirtualBlankNode.CopyNode(VDS.RDF.IGraph)">
            <summary>
            Copies the Node to another Graph
            </summary>
            <param name="target">Target Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.SimpleVirtualBlankNode.CompareVirtualId(System.Int32)">
            <summary>
            Method to be implemented in derived classes to provide comparison of VirtualId values
            </summary>
            <param name="other">The other virtual ID value to be compared with this node's virtual ID value.</param>
            <returns>The comparison result.</returns>
        </member>
        <member name="T:VDS.RDF.Storage.Virtualisation.SimpleVirtualGraphLiteralNode">
            <summary>
            Simple implementation of a Virtual Graph Literal Node where the virtual IDs are integers
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.Virtualisation.BaseVirtualGraphLiteralNode`2">
            <summary>
            Abstract Base implementation of a Virtual Graph Literal Node
            </summary>
            <typeparam name="TNodeID">Node ID Type</typeparam>
            <typeparam name="TGraphID">Graph ID Type</typeparam>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualGraphLiteralNode`2.#ctor(VDS.RDF.IGraph,`0,VDS.RDF.Storage.Virtualisation.IVirtualRdfProvider{`0,`1})">
            <summary>
            Creates a new Virtual Graph Literal Node
            </summary>
            <param name="g">Graph the Node belongs to</param>
            <param name="id">Virtual ID</param>
            <param name="provider">Virtual RDF Provider</param>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualGraphLiteralNode`2.#ctor(VDS.RDF.IGraph,`0,VDS.RDF.Storage.Virtualisation.IVirtualRdfProvider{`0,`1},VDS.RDF.IGraphLiteralNode)">
            <summary>
            Creates a new Virtual Graph Literal Node
            </summary>
            <param name="g">Graph the Node belongs to</param>
            <param name="id">Virtual ID</param>
            <param name="provider">Virtual RDF Provider</param>
            <param name="value">Materialised Value</param>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualGraphLiteralNode`2.OnMaterialise">
            <summary>
            Takes post materialisation actions
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualGraphLiteralNode`2.CompareTo(VDS.RDF.IGraphLiteralNode)">
            <summary>
            Compares this Node to another Graph Literal Node
            </summary>
            <param name="other">Other Graph Literal Node</param>
            <returns></returns>
            <remarks>
            Unless Virtual Equality (equality based on the Virtual RDF Provider and Virtual ID) can be determined or the Nodes are of different types then the Nodes value will have to be materialised in order to perform comparison.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualGraphLiteralNode`2.Equals(VDS.RDF.IGraphLiteralNode)">
            <summary>
            Checks this Node for equality against another Graph Literal Node
            </summary>
            <param name="other">Other Graph Literal Node</param>
            <returns></returns>
            <remarks>
            Unless Virtual Equality (equality based on the Virtual RDF Provider and Virtual ID) can be determined or the Nodes are of different types then the Nodes value will have to be materialised in order to perform the equality check.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualGraphLiteralNode`2.Equals(VDS.RDF.Storage.Virtualisation.BaseVirtualGraphLiteralNode{`0,`1})">
            <summary>
            Checks this Node for equality against another Graph Literal Node
            </summary>
            <param name="other">Other Graph Literal Node</param>
            <returns></returns>
            <remarks>
            Unless Virtual Equality (equality based on the Virtual RDF Provider and Virtual ID) can be determined or the Nodes are of different types then the Nodes value will have to be materialised in order to perform the equality check.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualGraphLiteralNode`2.CompareTo(VDS.RDF.Storage.Virtualisation.BaseVirtualGraphLiteralNode{`0,`1})">
            <summary>
            Compares this Node to another Graph Literal Node
            </summary>
            <param name="other">Other Graph Literal Node</param>
            <returns></returns>
            <remarks>
            Unless Virtual Equality (equality based on the Virtual RDF Provider and Virtual ID) can be determined or the Nodes are of different types then the Nodes value will have to be materialised in order to perform comparison.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualGraphLiteralNode`2.AsString">
            <summary>
            Throws an error as graph literal nodes cannot be cast to types
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualGraphLiteralNode`2.AsInteger">
            <summary>
            Throws an error as graph literal nodes cannot be cast to types
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualGraphLiteralNode`2.AsDecimal">
            <summary>
            Throws an error as graph literal nodes cannot be cast to types
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualGraphLiteralNode`2.AsFloat">
            <summary>
            Throws an error as graph literal nodes cannot be cast to types
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualGraphLiteralNode`2.AsDouble">
            <summary>
            Throws an error as graph literal nodes cannot be cast to types
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualGraphLiteralNode`2.AsBoolean">
            <summary>
            Throws an error as graph literal nodes cannot be cast to types
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualGraphLiteralNode`2.AsDateTime">
            <summary>
            Throws an error as graph literal nodes cannot be cast to types
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualGraphLiteralNode`2.AsDateTimeOffset">
            <summary>
            Throws an error as graph literal nodes cannot be cast to types
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualGraphLiteralNode`2.AsTimeSpan">
            <summary>
            Throws an error as graph literals cannot be cast to a time span
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Storage.Virtualisation.BaseVirtualGraphLiteralNode`2.SubGraph">
            <summary>
            Gets the subgraph this Graph Literal represents
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Virtualisation.BaseVirtualGraphLiteralNode`2.EffectiveType">
            <summary>
            Gets the URI of the datatype this valued node represents as a String
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Virtualisation.BaseVirtualGraphLiteralNode`2.NumericType">
            <summary>
            Gets the numeric type of the node
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.SimpleVirtualGraphLiteralNode.#ctor(VDS.RDF.IGraph,System.Int32,VDS.RDF.Storage.Virtualisation.IVirtualRdfProvider{System.Int32,System.Int32})">
            <summary>
            Creates a new Virtual Graph Literal Node
            </summary>
            <param name="g">Graph the Node belongs to</param>
            <param name="id">Virtual ID</param>
            <param name="provider">Virtual RDF Provider</param>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.SimpleVirtualGraphLiteralNode.#ctor(VDS.RDF.IGraph,System.Int32,VDS.RDF.Storage.Virtualisation.IVirtualRdfProvider{System.Int32,System.Int32},VDS.RDF.IGraphLiteralNode)">
            <summary>
            Creates a new Virtual Graph Literal Node
            </summary>
            <param name="g">Graph the Node belongs to</param>
            <param name="id">Virtual ID</param>
            <param name="provider">Virtual RDF Provider</param>
            <param name="value">Materialised Values</param>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.SimpleVirtualGraphLiteralNode.Equals(VDS.RDF.Storage.Virtualisation.SimpleVirtualGraphLiteralNode)">
            <summary>
            Determines whether this Node is equal to another virtual Graph Literal node
            </summary>
            <param name="other">Other Graph Literal Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.SimpleVirtualGraphLiteralNode.CompareTo(VDS.RDF.Storage.Virtualisation.SimpleVirtualGraphLiteralNode)">
            <summary>
            Compares this Node to another virtual Graph Literal node
            </summary>
            <param name="other">Other Graph Literal Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.SimpleVirtualGraphLiteralNode.CopyNode(VDS.RDF.IGraph)">
            <summary>
            Copies the Node to another Graph including the materialised value if present
            </summary>
            <param name="target">Target Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.SimpleVirtualGraphLiteralNode.CompareVirtualId(System.Int32)">
            <summary>
            Method to be implemented in derived classes to provide comparison of VirtualId values
            </summary>
            <param name="other">The other virtual ID value to be compared with this node's virtual ID value.</param>
            <returns>The comparison result.</returns>
        </member>
        <member name="T:VDS.RDF.Storage.Virtualisation.SimpleVirtualLiteralNode">
            <summary>
            Simple implementation of a Virtual Literal Node where the virtual IDs are integers
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.Virtualisation.BaseVirtualLiteralNode`2">
            <summary>
            Abstract Base implementation of a Virtual Literal Node
            </summary>
            <typeparam name="TNodeID">Node ID Type</typeparam>
            <typeparam name="TGraphID">Graph ID Type</typeparam>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualLiteralNode`2.#ctor(VDS.RDF.IGraph,`0,VDS.RDF.Storage.Virtualisation.IVirtualRdfProvider{`0,`1})">
            <summary>
            Creates a new Virtual Literal Node
            </summary>
            <param name="g">Graph the Node belongs to</param>
            <param name="id">Virtual ID</param>
            <param name="provider">Virtual RDF Provider</param>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualLiteralNode`2.#ctor(VDS.RDF.IGraph,`0,VDS.RDF.Storage.Virtualisation.IVirtualRdfProvider{`0,`1},VDS.RDF.ILiteralNode)">
            <summary>
            Creates a new Virtual Literal Node
            </summary>
            <param name="g">Graph the Node belongs to</param>
            <param name="id">Virtual ID</param>
            <param name="provider">Virtual RDF Provider</param>
            <param name="value">Materialised Value</param>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualLiteralNode`2.OnMaterialise">
            <summary>
            Takes post materialisation actions
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualLiteralNode`2.CompareTo(VDS.RDF.ILiteralNode)">
            <summary>
            Compares this Node to another Literal Node
            </summary>
            <param name="other">Other Literal Node</param>
            <returns></returns>
            <remarks>
            Unless Virtual Equality (equality based on the Virtual RDF Provider and Virtual ID) can be determined or the Nodes are of different types then the Nodes value will have to be materialised in order to perform comparison.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualLiteralNode`2.Equals(VDS.RDF.ILiteralNode)">
            <summary>
            Checks this Node for equality against another Literal Node
            </summary>
            <param name="other">Other Literal Node</param>
            <returns></returns>
            <remarks>
            Unless Virtual Equality (equality based on the Virtual RDF Provider and Virtual ID) can be determined or the Nodes are of different types then the Nodes value will have to be materialised in order to perform the equality check.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualLiteralNode`2.Equals(VDS.RDF.Storage.Virtualisation.BaseVirtualLiteralNode{`0,`1})">
            <summary>
            Checks this Node for equality against another Literal Node
            </summary>
            <param name="other">Other Literal Node</param>
            <returns></returns>
            <remarks>
            Unless Virtual Equality (equality based on the Virtual RDF Provider and Virtual ID) can be determined or the Nodes are of different types then the Nodes value will have to be materialised in order to perform the equality check.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualLiteralNode`2.CompareTo(VDS.RDF.Storage.Virtualisation.BaseVirtualLiteralNode{`0,`1})">
            <summary>
            Compares this Node to another Literal Node
            </summary>
            <param name="other">Other Literal Node</param>
            <returns></returns>
            <remarks>
            Unless Virtual Equality (equality based on the Virtual RDF Provider and Virtual ID) can be determined or the Nodes are of different types then the Nodes value will have to be materialised in order to perform comparison.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualLiteralNode`2.EnsureStrongValue">
            <summary>
            Ensures that a strong value has been determined for this node
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualLiteralNode`2.AsString">
            <summary>
            Gets the value as a string
            </summary>
            <returns></returns>
            <remarks>
            Forces a materialisation of the value
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualLiteralNode`2.AsInteger">
            <summary>
            Gets the value as an integer
            </summary>
            <returns></returns>
            <remarks>
            Forces a materialisation of the value
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualLiteralNode`2.AsDecimal">
            <summary>
            Gets the value as a decimal
            </summary>
            <returns></returns>
            <remarks>
            Forces a materialisation of the value
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualLiteralNode`2.AsFloat">
            <summary>
            Gets the value as a float
            </summary>
            <returns></returns>
            <remarks>
            Forces a materialisation of the value
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualLiteralNode`2.AsDouble">
            <summary>
            Gets the value as a double
            </summary>
            <returns></returns>
            <remarks>
            Forces a materialisation of the value
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualLiteralNode`2.AsBoolean">
            <summary>
            Gets the value as a boolean
            </summary>
            <returns></returns>
            <remarks>
            Forces a materialisation of the value
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualLiteralNode`2.AsDateTime">
            <summary>
            Gets the value as a date time
            </summary>
            <returns></returns>
            <remarks>
            Forces a materialisation of the value
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualLiteralNode`2.AsDateTimeOffset">
            <summary>
            Gets the value as a date time
            </summary>
            <returns></returns>
            <remarks>
            Forces a materialisation of the value
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualLiteralNode`2.AsTimeSpan">
            <summary>
            Gets the value as a time span
            </summary>
            <returns></returns>
            <remarks>
            Forces a materialisation of the value
            </remarks>
        </member>
        <member name="P:VDS.RDF.Storage.Virtualisation.BaseVirtualLiteralNode`2.Value">
            <summary>
            Gets the lexical value of the Literal
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Virtualisation.BaseVirtualLiteralNode`2.Language">
            <summary>
            Gets the language specifier (if any) of the Literal
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Virtualisation.BaseVirtualLiteralNode`2.DataType">
            <summary>
            Gets the Datatype (if any) of the Literal
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Virtualisation.BaseVirtualLiteralNode`2.EffectiveType">
            <summary>
            Gets the URI of the datatype this valued node represents as a String
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Virtualisation.BaseVirtualLiteralNode`2.NumericType">
            <summary>
            Gets the numeric type of the node
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.SimpleVirtualLiteralNode.#ctor(VDS.RDF.IGraph,System.Int32,VDS.RDF.Storage.Virtualisation.IVirtualRdfProvider{System.Int32,System.Int32})">
            <summary>
            Creates a new Virtual Literal Node
            </summary>
            <param name="g">Graph the Node belongs to</param>
            <param name="id">Virtual ID</param>
            <param name="provider">Virtual RDF Provider</param>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.SimpleVirtualLiteralNode.#ctor(VDS.RDF.IGraph,System.Int32,VDS.RDF.Storage.Virtualisation.IVirtualRdfProvider{System.Int32,System.Int32},VDS.RDF.ILiteralNode)">
            <summary>
            Creates a new Virtual Literal Node
            </summary>
            <param name="g">Graph the Node belongs to</param>
            <param name="id">Virtual ID</param>
            <param name="provider">Virtual RDF Provider</param>
            <param name="value">Materialised Value</param>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.SimpleVirtualLiteralNode.Equals(VDS.RDF.Storage.Virtualisation.SimpleVirtualLiteralNode)">
            <summary>
            Determines whether this Node is equal to another virtual Literal node
            </summary>
            <param name="other">Other Literal Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.SimpleVirtualLiteralNode.CompareTo(VDS.RDF.Storage.Virtualisation.SimpleVirtualLiteralNode)">
            <summary>
            Compares this Node to another virtual Literal node
            </summary>
            <param name="other">Other Literal Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.SimpleVirtualLiteralNode.CopyNode(VDS.RDF.IGraph)">
            <summary>
            Copies the Node to another Graph including the materialised value if present
            </summary>
            <param name="target">Target Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.SimpleVirtualLiteralNode.CompareVirtualId(System.Int32)">
            <summary>
            Method to be implemented in derived classes to provide comparison of VirtualId values
            </summary>
            <param name="other">The other virtual ID value to be compared with this node's virtual ID value.</param>
            <returns>The comparison result.</returns>
        </member>
        <member name="T:VDS.RDF.Storage.Virtualisation.SimpleVirtualUriNode">
            <summary>
            Simple implementation of a Virtual URI Node where the virtual IDs are integers
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.Virtualisation.BaseVirtualUriNode`2">
            <summary>
            Abstract Base implementation of a Virtual URI Node
            </summary>
            <typeparam name="TNodeID">Node ID Type</typeparam>
            <typeparam name="TGraphID">Graph ID Type</typeparam>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualUriNode`2.#ctor(VDS.RDF.IGraph,`0,VDS.RDF.Storage.Virtualisation.IVirtualRdfProvider{`0,`1})">
            <summary>
            Creates a new Virtual URI Node
            </summary>
            <param name="g">Graph the Node belongs to</param>
            <param name="id">Virtual ID</param>
            <param name="provider">Virtual RDF Provider</param>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualUriNode`2.#ctor(VDS.RDF.IGraph,`0,VDS.RDF.Storage.Virtualisation.IVirtualRdfProvider{`0,`1},VDS.RDF.IUriNode)">
            <summary>
            Creates a new Virtual URI Node
            </summary>
            <param name="g">Graph the Node belongs to</param>
            <param name="id">Virtual ID</param>
            <param name="provider">Virtual RDF Provider</param>
            <param name="value">Materialised Value</param>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualUriNode`2.OnMaterialise">
            <summary>
            Takes post materialisation actions
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualUriNode`2.CompareTo(VDS.RDF.IUriNode)">
            <summary>
            Compares this Node to another URI Node
            </summary>
            <param name="other">Other URI Node</param>
            <returns></returns>
            <remarks>
            Unless Virtual Equality (equality based on the Virtual RDF Provider and Virtual ID) can be determined or the Nodes are of different types then the Nodes value will have to be materialised in order to perform comparison.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualUriNode`2.Equals(VDS.RDF.IUriNode)">
            <summary>
            Checks this Node for equality against another URI Node
            </summary>
            <param name="other">Other URI Node</param>
            <returns></returns>
            <remarks>
            Unless Virtual Equality (equality based on the Virtual RDF Provider and Virtual ID) can be determined or the Nodes are of different types then the Nodes value will have to be materialised in order to perform the equality check.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualUriNode`2.Equals(VDS.RDF.Storage.Virtualisation.BaseVirtualUriNode{`0,`1})">
            <summary>
            Checks this Node for equality against another URI Node
            </summary>
            <param name="other">Other URI Node</param>
            <returns></returns>
            <remarks>
            Unless Virtual Equality (equality based on the Virtual RDF Provider and Virtual ID) can be determined or the Nodes are of different types then the Nodes value will have to be materialised in order to perform the equality check.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualUriNode`2.CompareTo(VDS.RDF.Storage.Virtualisation.BaseVirtualUriNode{`0,`1})">
            <summary>
            Compares this Node to another URI Node
            </summary>
            <param name="other">Other URI Node</param>
            <returns></returns>
            <remarks>
            Unless Virtual Equality (equality based on the Virtual RDF Provider and Virtual ID) can be determined or the Nodes are of different types then the Nodes value will have to be materialised in order to perform comparison.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualUriNode`2.AsString">
            <summary>
            Gets the string value of the node
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualUriNode`2.AsInteger">
            <summary>
            Throws an error as URI nodes cannot be cast to numerics
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualUriNode`2.AsDecimal">
            <summary>
            Throws an error as URI nodes cannot be cast to numerics
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualUriNode`2.AsFloat">
            <summary>
            Throws an error as URI nodes cannot be cast to numerics
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualUriNode`2.AsDouble">
            <summary>
            Throws an error as URI nodes cannot be cast to numerics
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualUriNode`2.AsBoolean">
            <summary>
            Throws an error as URI nodes cannot be cast to a boolean
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualUriNode`2.AsDateTime">
            <summary>
            Throws an error as URI nodes cannot be cast to a date time
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualUriNode`2.AsDateTimeOffset">
            <summary>
            Throws an error as URI nodes cannot be cast to a date time
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualUriNode`2.AsTimeSpan">
            <summary>
            Throws an error as URIs cannot be cast to a time span
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Storage.Virtualisation.BaseVirtualUriNode`2.Uri">
            <summary>
            Gets the URI
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Virtualisation.BaseVirtualUriNode`2.EffectiveType">
            <summary>
            Gets the URI of the datatype this valued node represents as a String
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Virtualisation.BaseVirtualUriNode`2.NumericType">
            <summary>
            Gets the numeric type of the expression
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.SimpleVirtualUriNode.#ctor(VDS.RDF.IGraph,System.Int32,VDS.RDF.Storage.Virtualisation.IVirtualRdfProvider{System.Int32,System.Int32})">
            <summary>
            Creates a new Virtual URI Node
            </summary>
            <param name="g">Graph the Node belongs to</param>
            <param name="id">Virtual ID</param>
            <param name="provider">Virtual RDF Provider</param>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.SimpleVirtualUriNode.#ctor(VDS.RDF.IGraph,System.Int32,VDS.RDF.Storage.Virtualisation.IVirtualRdfProvider{System.Int32,System.Int32},VDS.RDF.IUriNode)">
            <summary>
            Creates a new Virtual URI Node
            </summary>
            <param name="g">Graph the Node belongs to</param>
            <param name="id">Virtual ID</param>
            <param name="provider">Virtual RDF Provider</param>
            <param name="value">Materialised Value</param>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.SimpleVirtualUriNode.Equals(VDS.RDF.Storage.Virtualisation.SimpleVirtualUriNode)">
            <summary>
            Determines whether this Node is equal to another virtual URI node
            </summary>
            <param name="other">Other URI Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.SimpleVirtualUriNode.CompareTo(VDS.RDF.Storage.Virtualisation.SimpleVirtualUriNode)">
            <summary>
            Compares this Node to another virtual URI node
            </summary>
            <param name="other">Other URI Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.SimpleVirtualUriNode.CopyNode(VDS.RDF.IGraph)">
            <summary>
            Copies the Node to another Graph including the materialised value if present
            </summary>
            <param name="target">Target Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.SimpleVirtualUriNode.CompareVirtualId(System.Int32)">
            <summary>
            Method to be implemented in derived classes to provide comparison of VirtualId values
            </summary>
            <param name="other">The other virtual ID value to be compared with this node's virtual ID value.</param>
            <returns>The comparison result.</returns>
        </member>
        <member name="T:VDS.RDF.Storage.Virtualisation.SimpleVirtualVariableNode">
            <summary>
            Simple implementation of a Virtual URI Node where the virtual IDs are integers
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.Virtualisation.BaseVirtualVariableNode`2">
            <summary>
            Abstract Base implementation of a Virtual Variable Node
            </summary>
            <typeparam name="TNodeID">Node ID Type</typeparam>
            <typeparam name="TGraphID">Graph ID Type</typeparam>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualVariableNode`2.#ctor(VDS.RDF.IGraph,`0,VDS.RDF.Storage.Virtualisation.IVirtualRdfProvider{`0,`1})">
            <summary>
            Creates a new Virtual Variable Node
            </summary>
            <param name="g">Graph the Node belongs to</param>
            <param name="id">Virtual ID</param>
            <param name="provider">Virtual RDF Provider</param>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualVariableNode`2.#ctor(VDS.RDF.IGraph,`0,VDS.RDF.Storage.Virtualisation.IVirtualRdfProvider{`0,`1},VDS.RDF.IVariableNode)">
            <summary>
            Creates a new Virtual Variable Node
            </summary>
            <param name="g">Graph the Node belongs to</param>
            <param name="id">Virtual ID</param>
            <param name="provider">Virtual RDF Provider</param>
            <param name="value">Materialised Value</param>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualVariableNode`2.OnMaterialise">
            <summary>
            Takes post materialisation actions
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualVariableNode`2.CompareTo(VDS.RDF.IVariableNode)">
            <summary>
            Compares this Node to another Variable Node
            </summary>
            <param name="other">Other Variable Node</param>
            <returns></returns>
            <remarks>
            Unless Virtual Equality (equality based on the Virtual RDF Provider and Virtual ID) can be determined or the Nodes are of different types then the Nodes value will have to be materialised in order to perform comparison.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualVariableNode`2.Equals(VDS.RDF.IVariableNode)">
            <summary>
            Checks this Node for equality against another Variable Node
            </summary>
            <param name="other">Other Variable Node</param>
            <returns></returns>
            <remarks>
            Unless Virtual Equality (equality based on the Virtual RDF Provider and Virtual ID) can be determined or the Nodes are of different types then the Nodes value will have to be materialised in order to perform the equality check.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualVariableNode`2.Equals(VDS.RDF.Storage.Virtualisation.BaseVirtualVariableNode{`0,`1})">
            <summary>
            Checks this Node for equality against another Variable Node
            </summary>
            <param name="other">Other Variable Node</param>
            <returns></returns>
            <remarks>
            Unless Virtual Equality (equality based on the Virtual RDF Provider and Virtual ID) can be determined or the Nodes are of different types then the Nodes value will have to be materialised in order to perform the equality check.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualVariableNode`2.CompareTo(VDS.RDF.Storage.Virtualisation.BaseVirtualVariableNode{`0,`1})">
            <summary>
            Compares this Node to another Variable Node
            </summary>
            <param name="other">Other Variable Node</param>
            <returns></returns>
            <remarks>
            Unless Virtual Equality (equality based on the Virtual RDF Provider and Virtual ID) can be determined or the Nodes are of different types then the Nodes value will have to be materialised in order to perform comparison.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualVariableNode`2.AsString">
            <summary>
            Throws an error as variables nodes cannot be cast to types
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualVariableNode`2.AsInteger">
            <summary>
            Throws an error as variables nodes cannot be cast to types
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualVariableNode`2.AsDecimal">
            <summary>
            Throws an error as variables nodes cannot be cast to types
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualVariableNode`2.AsFloat">
            <summary>
            Throws an error as variables nodes cannot be cast to types
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualVariableNode`2.AsDouble">
            <summary>
            Throws an error as variables nodes cannot be cast to types
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualVariableNode`2.AsBoolean">
            <summary>
            Throws an error as variables nodes cannot be cast to types
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualVariableNode`2.AsDateTime">
            <summary>
            Throws an error as variables nodes cannot be cast to types
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualVariableNode`2.AsDateTimeOffset">
            <summary>
            Throws an error as variables nodes cannot be cast to types
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.BaseVirtualVariableNode`2.AsTimeSpan">
            <summary>
            Throws an error as variables cannot be cast to a time span
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Storage.Virtualisation.BaseVirtualVariableNode`2.VariableName">
            <summary>
            Gets the Variable Name
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Virtualisation.BaseVirtualVariableNode`2.EffectiveType">
            <summary>
            Gets the URI of the datatype this valued node represents as a String
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.Virtualisation.BaseVirtualVariableNode`2.NumericType">
            <summary>
            Gets the numeric type of the node
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.SimpleVirtualVariableNode.#ctor(VDS.RDF.IGraph,System.Int32,VDS.RDF.Storage.Virtualisation.IVirtualRdfProvider{System.Int32,System.Int32})">
            <summary>
            Creates a new Virtual Variable Node
            </summary>
            <param name="g">Graph the Node belongs to</param>
            <param name="id">Virtual ID</param>
            <param name="provider">Virtual RDF Provider</param>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.SimpleVirtualVariableNode.#ctor(VDS.RDF.IGraph,System.Int32,VDS.RDF.Storage.Virtualisation.IVirtualRdfProvider{System.Int32,System.Int32},VDS.RDF.IVariableNode)">
            <summary>
            Creates a new Virtual Variable Node
            </summary>
            <param name="g">Graph the Node belongs to</param>
            <param name="id">Virtual ID</param>
            <param name="provider">Virtual RDF Provider</param>
            <param name="value">Materialised Value</param>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.SimpleVirtualVariableNode.Equals(VDS.RDF.Storage.Virtualisation.SimpleVirtualVariableNode)">
            <summary>
            Determines whether this Node is equal to another virtual variable node
            </summary>
            <param name="other">Other Variable Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.SimpleVirtualVariableNode.CompareTo(VDS.RDF.Storage.Virtualisation.SimpleVirtualVariableNode)">
            <summary>
            Compares this Node to another virtual Variable node
            </summary>
            <param name="other">Other Variable Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.SimpleVirtualVariableNode.CopyNode(VDS.RDF.IGraph)">
            <summary>
            Copies the Node to another Graph including the materialised value if present
            </summary>
            <param name="target">Target Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.SimpleVirtualVariableNode.CompareVirtualId(System.Int32)">
            <summary>
            Method to be implemented in derived classes to provide comparison of VirtualId values
            </summary>
            <param name="other">The other virtual ID value to be compared with this node's virtual ID value.</param>
            <returns>The comparison result.</returns>
        </member>
        <member name="T:VDS.RDF.Storage.Virtualisation.VirtualNodeCache`2">
            <summary>
            A Cache that maps from Virtual IDs to Materialised Values
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.VirtualNodeCache`2.#ctor(System.Func{`0,`1})">
            <summary>
            Creates a new Virtual ID cache
            </summary>
            <param name="keyGenerator">Function that maps Node IDs to dictionary keys</param>
        </member>
        <member name="P:VDS.RDF.Storage.Virtualisation.VirtualNodeCache`2.Item(`0)">
            <summary>
            Gets/Sets the materialised value for a particular Virtual ID
            </summary>
            <param name="id">Virtual ID</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Storage.Virtualisation.SimpleVirtualNodeCache`1">
            <summary>
            A Cache that maps from Virtual IDs to Materialised Values where the IDs map directly to dictionary keys
            </summary>
            <typeparam name="TNodeID">Node ID Type</typeparam>
        </member>
        <member name="M:VDS.RDF.Storage.Virtualisation.SimpleVirtualNodeCache`1.#ctor">
            <summary>
            Creates a new Simple Virtual Node Cache
            </summary>
        </member>
        <member name="T:VDS.RDF.Update.Commands.AddCommand">
            <summary>
            Represents the SPARQL Update ADD Command
            </summary>
        </member>
        <member name="T:VDS.RDF.Update.Commands.BaseTransferCommand">
            <summary>
            Abstract Base Class for SPARQL Update Commands which move data between Graphs
            </summary>
        </member>
        <member name="T:VDS.RDF.Update.SparqlUpdateCommand">
            <summary>
            Base Class of SPARQL Update Commands
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.SparqlUpdateCommand.#ctor(VDS.RDF.Update.SparqlUpdateCommandType)">
            <summary>
            Creates a new SPARQL Update Command
            </summary>
            <param name="type">Command Type</param>
        </member>
        <member name="M:VDS.RDF.Update.SparqlUpdateCommand.AffectsGraph(System.Uri)">
            <summary>
            Gets whether the Command will potentially affect the given Graph
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
            <remarks>
            A return value of <strong>true</strong> does not guarantee that the Graph will be affected.  Some Commands (e.g. DROP ALL) affect all Graphs in the Dataset but the command itself doesn't know whether a Graph with the given URI is actually present in the dataset to which it is applied
            </remarks>
        </member>
        <member name="M:VDS.RDF.Update.SparqlUpdateCommand.Optimise(VDS.RDF.Query.Optimisation.IQueryOptimiser)">
            <summary>
            Optimises the Command
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.SparqlUpdateCommand.Evaluate(VDS.RDF.Update.SparqlUpdateEvaluationContext)">
            <summary>
            Evaluates the Command in the given Context
            </summary>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Update.SparqlUpdateCommand.Process(VDS.RDF.Update.ISparqlUpdateProcessor)">
            <summary>
            Processes the Command Set using the given Update Processor
            </summary>
            <param name="processor">Update Processor</param>
        </member>
        <member name="M:VDS.RDF.Update.SparqlUpdateCommand.ToString">
            <summary>
            Gets the String representation of the Command
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Update.SparqlUpdateCommand.CommandType">
            <summary>
            Gets the Type of this Command
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.SparqlUpdateCommand.AffectsSingleGraph">
            <summary>
            Gets whether the Command will only affect a single Graph
            </summary>
        </member>
        <member name="F:VDS.RDF.Update.Commands.BaseTransferCommand._sourceUri">
            <summary>
            Source Graph URI
            </summary>
        </member>
        <member name="F:VDS.RDF.Update.Commands.BaseTransferCommand._destUri">
            <summary>
            Destination Graph URI
            </summary>
        </member>
        <member name="F:VDS.RDF.Update.Commands.BaseTransferCommand._silent">
            <summary>
            Whether errors should be suppressed
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.Commands.BaseTransferCommand.#ctor(VDS.RDF.Update.SparqlUpdateCommandType,System.Uri,System.Uri,System.Boolean)">
            <summary>
            Creates a new Transfer Command
            </summary>
            <param name="type">Command Type</param>
            <param name="sourceUri">Source Graph URI</param>
            <param name="destUri">Destination Graph URI</param>
            <param name="silent">Whether errors should be suppressed</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.BaseTransferCommand.#ctor(VDS.RDF.Update.SparqlUpdateCommandType,System.Uri,System.Uri)">
            <summary>
            Creates a new Transfer Command
            </summary>
            <param name="type">Command Type</param>
            <param name="sourceUri">Source Graph URI</param>
            <param name="destUri">Destination Graph URI</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.BaseTransferCommand.AffectsGraph(System.Uri)">
            <summary>
            Gets whether the Command affects a given Graph
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Update.Commands.BaseTransferCommand.ToString">
            <summary>
            Gets the String representation of the Command
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Update.Commands.BaseTransferCommand.SourceUri">
            <summary>
            URI of the Source Graph
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.Commands.BaseTransferCommand.DestinationUri">
            <summary>
            URI of the Destination Graph
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.Commands.BaseTransferCommand.Silent">
            <summary>
            Whether errors during evaluation should be suppressed
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.Commands.BaseTransferCommand.AffectsSingleGraph">
            <summary>
            Gets whether the Command affects a Single Graph
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.Commands.AddCommand.#ctor(System.Uri,System.Uri,System.Boolean)">
            <summary>
            Creates a Command which merges the data from the Source Graph into the Destination Graph
            </summary>
            <param name="sourceUri">Source Graph URI</param>
            <param name="destUri">Destination Graph URI</param>
            <param name="silent">Whether errors should be suppressed</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.AddCommand.#ctor(System.Uri,System.Uri)">
            <summary>
            Creates a Command which merges the data from the Source Graph into the Destination Graph
            </summary>
            <param name="sourceUri">Source Graph URI</param>
            <param name="destUri">Destination Graph URI</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.AddCommand.Evaluate(VDS.RDF.Update.SparqlUpdateEvaluationContext)">
            <summary>
            Evaluates the Command in the given Context
            </summary>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.AddCommand.Process(VDS.RDF.Update.ISparqlUpdateProcessor)">
            <summary>
            Processes the Command using the given Update Processor
            </summary>
            <param name="processor">SPARQL Update Processor</param>
        </member>
        <member name="T:VDS.RDF.Update.Commands.BaseModificationCommand">
            <summary>
            Abstract Base class for classes that represent SPARQL Update INSERT, DELETE and INSERT/DELETE commands
            </summary>
        </member>
        <member name="F:VDS.RDF.Update.Commands.BaseModificationCommand._graphUri">
            <summary>
            URI from the WITH statement
            </summary>
        </member>
        <member name="F:VDS.RDF.Update.Commands.BaseModificationCommand._usingUris">
            <summary>
            URIs for the USING clauses
            </summary>
        </member>
        <member name="F:VDS.RDF.Update.Commands.BaseModificationCommand._usingNamedUris">
            <summary>
            URIS for the USING NAMED clauses
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.Commands.BaseModificationCommand.#ctor(VDS.RDF.Update.SparqlUpdateCommandType)">
            <summary>
            Creates a new Base Modification Command
            </summary>
            <param name="type">Update Command Type</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.BaseModificationCommand.AddUsingUri(System.Uri)">
            <summary>
            Adds a new USING URI
            </summary>
            <param name="u">URI</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.BaseModificationCommand.AddUsingNamedUri(System.Uri)">
            <summary>
            Adds a new USING NAMED URI
            </summary>
            <param name="u">URI</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.BaseModificationCommand.IsValidDeletePattern(VDS.RDF.Query.Patterns.GraphPattern,System.Boolean)">
            <summary>
            Determines whether a Graph Pattern is valid for use in an DELETE pattern
            </summary>
            <param name="p">Graph Pattern</param>
            <param name="top">Is this the top level pattern?</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Update.Commands.BaseModificationCommand.UsingUris">
            <summary>
            Gets the URIs specified in USING clauses
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.Commands.BaseModificationCommand.UsingNamedUris">
            <summary>
            Gets the URIs specified in USING NAMED clauses
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.Commands.BaseModificationCommand.GraphUri">
            <summary>
            Gets the URI of the Graph specified in the WITH clause
            </summary>
        </member>
        <member name="T:VDS.RDF.Update.Commands.ClearMode">
            <summary>
            Mode by which to clear Graphs
            </summary>
        </member>
        <member name="F:VDS.RDF.Update.Commands.ClearMode.Graph">
            <summary>
            Clears a specific Graph of Triples
            </summary>
        </member>
        <member name="F:VDS.RDF.Update.Commands.ClearMode.Named">
            <summary>
            Clears all Named Graphs of Triples
            </summary>
        </member>
        <member name="F:VDS.RDF.Update.Commands.ClearMode.Default">
            <summary>
            Clears the Default Graph of Triples
            </summary>
        </member>
        <member name="F:VDS.RDF.Update.Commands.ClearMode.All">
            <summary>
            Clears all Graphs of Triples
            </summary>
        </member>
        <member name="T:VDS.RDF.Update.Commands.ClearCommand">
            <summary>
            Represents the SPARQL Update CLEAR command
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.Commands.ClearCommand.#ctor(System.Uri,VDS.RDF.Update.Commands.ClearMode,System.Boolean)">
            <summary>
            Creates a Command which clears the given Graph or Graphs depending on the Clear Mode specified
            </summary>
            <param name="graphUri">Graph URI</param>
            <param name="mode">Clear Mode</param>
            <param name="silent">Whether errors should be suppressed</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.ClearCommand.#ctor(System.Uri)">
            <summary>
            Creates a Command which clears the given Graph
            </summary>
            <param name="graphUri">URI of the Graph to clear</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.ClearCommand.#ctor">
            <summary>
            Creates a Command which clears the Default Graph (if any)
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.Commands.ClearCommand.#ctor(VDS.RDF.Update.Commands.ClearMode,System.Boolean)">
            <summary>
            Creates a Command which performs the specified type of clear
            </summary>
            <param name="mode">Clear Mode</param>
            <param name="silent">Whether errors should be suppressed</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.ClearCommand.#ctor(VDS.RDF.Update.Commands.ClearMode)">
            <summary>
            Creates a Command which performs the specified type of clear
            </summary>
            <param name="mode">Clear Mode</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.ClearCommand.AffectsGraph(System.Uri)">
            <summary>
            Gets whether this Command affects the given Graph
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Update.Commands.ClearCommand.Evaluate(VDS.RDF.Update.SparqlUpdateEvaluationContext)">
            <summary>
            Evaluates the Command in the given Context
            </summary>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.ClearCommand.Process(VDS.RDF.Update.ISparqlUpdateProcessor)">
            <summary>
            Processes the Command using the given Update Processor
            </summary>
            <param name="processor">SPARQL Update Processor</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.ClearCommand.ToString">
            <summary>
            Gets the String representation of the Command
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Update.Commands.ClearCommand.AffectsSingleGraph">
            <summary>
            Gets whether this Command affects a Single Graph
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.Commands.ClearCommand.TargetUri">
            <summary>
            Gets the URI of the Graph to be cleared (or null if the default graph should be cleared)
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.Commands.ClearCommand.Silent">
            <summary>
            Gets whether errors should be suppressed
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.Commands.ClearCommand.Mode">
            <summary>
            Gets the Mode by which Graphs are to be cleared
            </summary>
        </member>
        <member name="T:VDS.RDF.Update.Commands.CopyCommand">
            <summary>
            Represents the SPARQL Update COPY Command
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.Commands.CopyCommand.#ctor(System.Uri,System.Uri,System.Boolean)">
            <summary>
            Creates a Command which Copies the contents of one Graph to another overwriting the destination Graph
            </summary>
            <param name="sourceUri">Source Graph URI</param>
            <param name="destUri">Destination Graph URI</param>
            <param name="silent">Whether errors should be suppressed</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.CopyCommand.#ctor(System.Uri,System.Uri)">
            <summary>
            Creates a Command which Copies the contents of one Graph to another overwriting the destination Graph
            </summary>
            <param name="sourceUri">Source Graph URI</param>
            <param name="destUri">Destination Graph URI</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.CopyCommand.Evaluate(VDS.RDF.Update.SparqlUpdateEvaluationContext)">
            <summary>
            Evaluates the Command in the given Context
            </summary>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.CopyCommand.Process(VDS.RDF.Update.ISparqlUpdateProcessor)">
            <summary>
            Processes the Command using the given Update Processor
            </summary>
            <param name="processor">SPARQL Update Processor</param>
        </member>
        <member name="T:VDS.RDF.Update.Commands.CreateCommand">
            <summary>
            Represents the SPARQL Update CREATE command
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.Commands.CreateCommand.#ctor(System.Uri,System.Boolean)">
            <summary>
            Creates a new CREATE command
            </summary>
            <param name="graphUri">URI of the Graph to create</param>
            <param name="silent">Whether the create should be done silenty</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.CreateCommand.#ctor(System.Uri)">
            <summary>
            Creates a new CREATE command
            </summary>
            <param name="graphUri">URI of the Graph to create</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.CreateCommand.AffectsGraph(System.Uri)">
            <summary>
            Gets whether the Command affects a given Graph
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Update.Commands.CreateCommand.Evaluate(VDS.RDF.Update.SparqlUpdateEvaluationContext)">
            <summary>
            Evaluates the Command in the given Context
            </summary>
            <param name="context">Update Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.CreateCommand.Process(VDS.RDF.Update.ISparqlUpdateProcessor)">
            <summary>
            Processes the Command using the given Update Processor
            </summary>
            <param name="processor">SPARQL Update Processor</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.CreateCommand.ToString">
            <summary>
            Gets the String representation of the Command
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Update.Commands.CreateCommand.AffectsSingleGraph">
            <summary>
            Gets whether the Command affects a Single Graph
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.Commands.CreateCommand.TargetUri">
            <summary>
            Gets the URI of the Graph to be created
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.Commands.CreateCommand.Silent">
            <summary>
            Gets whether the Create should be done silently
            </summary>
        </member>
        <member name="T:VDS.RDF.Update.Commands.DeleteCommand">
            <summary>
            Represents the SPARQL Update DELETE command
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.Commands.DeleteCommand.#ctor(VDS.RDF.Query.Patterns.GraphPattern,VDS.RDF.Query.Patterns.GraphPattern,System.Uri)">
            <summary>
            Creates a new DELETE command
            </summary>
            <param name="deletions">Pattern to construct Triples to delete</param>
            <param name="where">Pattern to select data which is then used in evaluating the deletions pattern</param>
            <param name="graphUri">URI of the affected Graph</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.DeleteCommand.#ctor(VDS.RDF.Query.Patterns.GraphPattern,VDS.RDF.Query.Patterns.GraphPattern)">
            <summary>
            Creates a new DELETE command which operates on the Default Graph
            </summary>
            <param name="deletions">Pattern to construct Triples to delete</param>
            <param name="where">Pattern to select data which is then used in evaluating the deletions pattern</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.DeleteCommand.#ctor(VDS.RDF.Query.Patterns.GraphPattern,System.Uri)">
            <summary>
            Creates a new DELETE command 
            </summary>
            <param name="where">Pattern to construct Triples to delete</param>
            <param name="graphUri">URI of the affected Graph</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.DeleteCommand.#ctor(VDS.RDF.Query.Patterns.GraphPattern)">
            <summary>
            Createa a new DELETE command which operates on the Default Graph
            </summary>
            <param name="where">Pattern to construct Triples to delete</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.DeleteCommand.AffectsGraph(System.Uri)">
            <summary>
            Gets whether the Command affects a given Graph
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Update.Commands.DeleteCommand.Optimise(VDS.RDF.Query.Optimisation.IQueryOptimiser)">
            <summary>
            Optimises the Commands WHERE pattern
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.Commands.DeleteCommand.Evaluate(VDS.RDF.Update.SparqlUpdateEvaluationContext)">
            <summary>
            Evaluates the Command in the given Context
            </summary>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.DeleteCommand.Process(VDS.RDF.Update.ISparqlUpdateProcessor)">
            <summary>
            Processes the Command using the given Update Processor
            </summary>
            <param name="processor">SPARQL Update Processor</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.DeleteCommand.ToString">
            <summary>
            Gets the String representation of the Command
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Update.Commands.DeleteCommand.AffectsSingleGraph">
            <summary>
            Gets whether the Command affects a single Graph
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.Commands.DeleteCommand.TargetUri">
            <summary>
            Gets the URI of the Graph the deletions are made from
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.Commands.DeleteCommand.DeletePattern">
            <summary>
            Gets the pattern used for Deletions
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.Commands.DeleteCommand.WherePattern">
            <summary>
            Gets the pattern used for the WHERE clause
            </summary>
        </member>
        <member name="T:VDS.RDF.Update.Commands.DeleteDataCommand">
            <summary>
            Represents a SPARQL Update DELETE DATA command
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.Commands.DeleteDataCommand.#ctor(VDS.RDF.Query.Patterns.GraphPattern)">
            <summary>
            Creates a new DELETE DATA command
            </summary>
            <param name="pattern">Pattern composed of concrete Triples to delete</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.DeleteDataCommand.IsValidDataPattern(VDS.RDF.Query.Patterns.GraphPattern,System.Boolean)">
            <summary>
            Determines whether a Graph Pattern is valid for use in an DELETE DATA command
            </summary>
            <param name="p">Graph Pattern</param>
            <param name="top">Is this the top level pattern?</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Update.Commands.DeleteDataCommand.AffectsGraph(System.Uri)">
            <summary>
            Gets whether the Command affects a given Graph
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Update.Commands.DeleteDataCommand.Evaluate(VDS.RDF.Update.SparqlUpdateEvaluationContext)">
            <summary>
            Evaluates the Command in the given Context
            </summary>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.DeleteDataCommand.Process(VDS.RDF.Update.ISparqlUpdateProcessor)">
            <summary>
            Processes the Command using the given Update Processor
            </summary>
            <param name="processor">SPARQL Update Processor</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.DeleteDataCommand.ToString">
            <summary>
            Gets the String representation of the Command
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Update.Commands.DeleteDataCommand.DataPattern">
            <summary>
            Gets the Data Pattern containing Triples to delete
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.Commands.DeleteDataCommand.AffectsSingleGraph">
            <summary>
            Gets whether the Command affects a single Graph
            </summary>
        </member>
        <member name="T:VDS.RDF.Update.Commands.DropCommand">
            <summary>
            Represents a SPARQL Update DROP command
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.Commands.DropCommand.#ctor(System.Uri,VDS.RDF.Update.Commands.ClearMode,System.Boolean)">
            <summary>
            Creates a new DROP command
            </summary>
            <param name="graphUri">URI ofthe Graph to DROP</param>
            <param name="mode">DROP Mode to use</param>
            <param name="silent">Whether the DROP should be done silently</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.DropCommand.#ctor(System.Uri,VDS.RDF.Update.Commands.ClearMode)">
            <summary>
            Creates a new DROP command
            </summary>
            <param name="graphUri">URI of the Graph to DROP</param>
            <param name="mode">DROP Mode to use</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.DropCommand.#ctor(System.Uri)">
            <summary>
            Creates a new DROP command
            </summary>
            <param name="graphUri">URI of the Graph to DROP</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.DropCommand.#ctor">
            <summary>
            Creates a new DROP command which drops the Default Graph
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.Commands.DropCommand.#ctor(VDS.RDF.Update.Commands.ClearMode)">
            <summary>
            Creates a new DROP command which performs a specific clear mode drop operation
            </summary>
            <param name="mode">Clear Mode</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.DropCommand.#ctor(VDS.RDF.Update.Commands.ClearMode,System.Boolean)">
            <summary>
            Creates a new DROP command which performs a specific clear mode drop operation
            </summary>
            <param name="mode">Clear Mode</param>
            <param name="silent">Whether errors should be suppressed</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.DropCommand.AffectsGraph(System.Uri)">
            <summary>
            Gets whether the Command affects a given Graph
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Update.Commands.DropCommand.Evaluate(VDS.RDF.Update.SparqlUpdateEvaluationContext)">
            <summary>
            Evaluates the Command in the given Context
            </summary>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.DropCommand.Process(VDS.RDF.Update.ISparqlUpdateProcessor)">
            <summary>
            Processes the Command using the given Update Processor
            </summary>
            <param name="processor">SPARQL Update Processor</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.DropCommand.ToString">
            <summary>
            Gets the String representation of the command
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Update.Commands.DropCommand.AffectsSingleGraph">
            <summary>
            Gets whether the Command affects a single Graph
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.Commands.DropCommand.TargetUri">
            <summary>
            Gets the URI of the Graph to be dropped
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.Commands.DropCommand.Silent">
            <summary>
            Gets whether the Drop should be done silently
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.Commands.DropCommand.Mode">
            <summary>
            Gets the type of DROP operation to perform
            </summary>
        </member>
        <member name="T:VDS.RDF.Update.Commands.InsertCommand">
            <summary>
            Represents a SPARQL Update INSERT command
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.Commands.InsertCommand.#ctor(VDS.RDF.Query.Patterns.GraphPattern,VDS.RDF.Query.Patterns.GraphPattern,System.Uri)">
            <summary>
            Creates a new INSERT command
            </summary>
            <param name="insertions">Pattern to construct Triples to insert</param>
            <param name="where">Pattern to select data which is then used in evaluating the insertions</param>
            <param name="graphUri">URI of the affected Graph</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.InsertCommand.#ctor(VDS.RDF.Query.Patterns.GraphPattern,VDS.RDF.Query.Patterns.GraphPattern)">
            <summary>
            Creates a new INSERT command which operates on the Default Graph
            </summary>
            <param name="insertions">Pattern to construct Triples to insert</param>
            <param name="where">Pattern to select data which is then used in evaluating the insertions</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.InsertCommand.AffectsGraph(System.Uri)">
            <summary>
            Gets whether the Command affects a given Graph
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Update.Commands.InsertCommand.Optimise(VDS.RDF.Query.Optimisation.IQueryOptimiser)">
            <summary>
            Optimises the Commands WHERE pattern
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.Commands.InsertCommand.Evaluate(VDS.RDF.Update.SparqlUpdateEvaluationContext)">
            <summary>
            Evaluates the Command in the given Context
            </summary>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.InsertCommand.Process(VDS.RDF.Update.ISparqlUpdateProcessor)">
            <summary>
            Processes the Command using the given Update Processor
            </summary>
            <param name="processor">SPARQL Update Processor</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.InsertCommand.ToString">
            <summary>
            Gets the String representation of the Command
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Update.Commands.InsertCommand.AffectsSingleGraph">
            <summary>
            Gets whether the Command affects a single Graph
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.Commands.InsertCommand.TargetUri">
            <summary>
            Gets the URI of the Graph the insertions are made to
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.Commands.InsertCommand.InsertPattern">
            <summary>
            Gets the pattern used for insertions
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.Commands.InsertCommand.WherePattern">
            <summary>
            Gets the pattern used for the WHERE clause
            </summary>
        </member>
        <member name="T:VDS.RDF.Update.Commands.InsertDataCommand">
            <summary>
            Represents the SPARQL Update INSERT DATA command
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.Commands.InsertDataCommand.#ctor(VDS.RDF.Query.Patterns.GraphPattern)">
            <summary>
            Creates a new INSERT DATA command
            </summary>
            <param name="pattern">Pattern containing concrete Triples to insert</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.InsertDataCommand.IsValidDataPattern(VDS.RDF.Query.Patterns.GraphPattern,System.Boolean)">
            <summary>
            Determines whether a Graph Pattern is valid for use in an INSERT DATA command
            </summary>
            <param name="p">Graph Pattern</param>
            <param name="top">Is this the top level pattern?</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Update.Commands.InsertDataCommand.AffectsGraph(System.Uri)">
            <summary>
            Gets whether the Command affects a given Graph
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Update.Commands.InsertDataCommand.Evaluate(VDS.RDF.Update.SparqlUpdateEvaluationContext)">
            <summary>
            Evaluates the Command in the given Context
            </summary>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.InsertDataCommand.Process(VDS.RDF.Update.ISparqlUpdateProcessor)">
            <summary>
            Processes the Command using the given Update Processor
            </summary>
            <param name="processor">SPARQL Update Processor</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.InsertDataCommand.ToString">
            <summary>
            Gets the String representation of the Command
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Update.Commands.InsertDataCommand.DataPattern">
            <summary>
            Gets the Data Pattern containing Triples to insert
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.Commands.InsertDataCommand.AffectsSingleGraph">
            <summary>
            Gets whether the Command affects a single Graph
            </summary>
        </member>
        <member name="T:VDS.RDF.Update.Commands.LoadCommand">
            <summary>
            Represents the SPARQL Update LOAD command
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.Commands.LoadCommand.#ctor(System.Uri,System.Uri,System.Boolean)">
            <summary>
            Creates a new LOAD command
            </summary>
            <param name="sourceUri">Source URI to load data from</param>
            <param name="graphUri">Target URI for the Graph to store data in</param>
            <param name="silent">Whether errors loading should be suppressed</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.LoadCommand.#ctor(System.Uri,System.Boolean)">
            <summary>
            Creates a new LOAD command
            </summary>
            <param name="sourceUri">Source URI to load data from</param>
            <param name="silent">Whether errors loading should be suppressed</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.LoadCommand.#ctor(System.Uri,System.Uri)">
            <summary>
            Creates a new LOAD command
            </summary>
            <param name="sourceUri">Source URI to load data from</param>
            <param name="targetUri">Target URI for the Graph to store data in</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.LoadCommand.#ctor(System.Uri)">
            <summary>
            Creates a new LOAD command which operates on the Default Graph
            </summary>
            <param name="sourceUri">Source URI to load data from</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.LoadCommand.AffectsGraph(System.Uri)">
            <summary>
            Gets whether the Command affects a given Graph
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Update.Commands.LoadCommand.Evaluate(VDS.RDF.Update.SparqlUpdateEvaluationContext)">
            <summary>
            Evaluates the Command in the given Context
            </summary>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.LoadCommand.Process(VDS.RDF.Update.ISparqlUpdateProcessor)">
            <summary>
            Processes the Command using the given Update Processor
            </summary>
            <param name="processor">SPARQL Update Processor</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.LoadCommand.ToString">
            <summary>
            Gets the String representation of the Command
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Update.Commands.LoadCommand.AffectsSingleGraph">
            <summary>
            Gets whether the Command affects a specific Graph
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.Commands.LoadCommand.SourceUri">
            <summary>
            Gets the URI that data is loaded from
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.Commands.LoadCommand.TargetUri">
            <summary>
            Gets the URI of the Graph to load data into
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.Commands.LoadCommand.Silent">
            <summary>
            Gets whether errors loading the data are suppressed
            </summary>
        </member>
        <member name="T:VDS.RDF.Update.Commands.ModifyCommand">
            <summary>
            Represents the SPARQL Update INSERT/DELETE command
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.Commands.ModifyCommand.#ctor(VDS.RDF.Query.Patterns.GraphPattern,VDS.RDF.Query.Patterns.GraphPattern,VDS.RDF.Query.Patterns.GraphPattern,System.Uri)">
            <summary>
            Creates a new INSERT/DELETE command
            </summary>
            <param name="deletions">Pattern to construct Triples to delete</param>
            <param name="insertions">Pattern to construct Triples to insert</param>
            <param name="where">Pattern to select data which is then used in evaluating the insertions and deletions</param>
            <param name="graphUri">URI of the affected Graph</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.ModifyCommand.#ctor(VDS.RDF.Query.Patterns.GraphPattern,VDS.RDF.Query.Patterns.GraphPattern,VDS.RDF.Query.Patterns.GraphPattern)">
            <summary>
            Creates a new INSERT/DELETE command which operates on the Default Graph
            </summary>
            <param name="deletions">Pattern to construct Triples to delete</param>
            <param name="insertions">Pattern to construct Triples to insert</param>
            <param name="where">Pattern to select data which is then used in evaluating the insertions and deletions</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.ModifyCommand.AffectsGraph(System.Uri)">
            <summary>
            Gets whether the Command affects a given Graph
            </summary>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Update.Commands.ModifyCommand.Optimise(VDS.RDF.Query.Optimisation.IQueryOptimiser)">
            <summary>
            Optimises the Commands WHERE pattern
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.Commands.ModifyCommand.Evaluate(VDS.RDF.Update.SparqlUpdateEvaluationContext)">
            <summary>
            Evaluates the Command in the given Context
            </summary>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.ModifyCommand.Process(VDS.RDF.Update.ISparqlUpdateProcessor)">
            <summary>
            Processes the Command using the given Update Processor
            </summary>
            <param name="processor">SPARQL Update Processor</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.ModifyCommand.ToString">
            <summary>
            Gets the String representation of the Command
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Update.Commands.ModifyCommand.AffectsSingleGraph">
            <summary>
            Gets whether the Command affects a Single Graph
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.Commands.ModifyCommand.TargetUri">
            <summary>
            Gets the URI of the Graph the insertions are made to
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.Commands.ModifyCommand.DeletePattern">
            <summary>
            Gets the pattern used for deletions
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.Commands.ModifyCommand.InsertPattern">
            <summary>
            Gets the pattern used for insertions
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.Commands.ModifyCommand.WherePattern">
            <summary>
            Gets the pattern used for the WHERE clause
            </summary>
        </member>
        <member name="T:VDS.RDF.Update.Commands.MoveCommand">
            <summary>
            Represents a SPARQL Update MOVE Command
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.Commands.MoveCommand.#ctor(System.Uri,System.Uri,System.Boolean)">
            <summary>
            Creates a Command which Moves data from one Graph to another overwriting the destination Graph and deleting the source Graph
            </summary>
            <param name="sourceUri">Source Graph URI</param>
            <param name="destUri">Destination Graph URI</param>
            <param name="silent">Whether errors should be suppressed</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.MoveCommand.#ctor(System.Uri,System.Uri)">
            <summary>
            Creates a Command which Moves data from one Graph to another overwriting the destination Graph and deleting the source Graph
            </summary>
            <param name="sourceUri">Source Graph URI</param>
            <param name="destUri">Destination Graph URI</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.MoveCommand.Evaluate(VDS.RDF.Update.SparqlUpdateEvaluationContext)">
            <summary>
            Evaluates the Command in the given Context
            </summary>
            <param name="context">Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Update.Commands.MoveCommand.Process(VDS.RDF.Update.ISparqlUpdateProcessor)">
            <summary>
            Processes the Command using the given Update Processor
            </summary>
            <param name="processor">SPARQL Update Processor</param>
        </member>
        <member name="T:VDS.RDF.Update.ExplainUpdateProcessor">
            <summary>
            An Update Processor that extends the Leviathan Engine to include explanations of the query portions of the Updates
            </summary>
        </member>
        <member name="T:VDS.RDF.Update.LeviathanUpdateProcessor">
            <summary>
            Default SPARQL Update Processor provided by the library's Leviathan SPARQL Engine
            </summary>
            <remarks>
            <para>
            The Leviathan Update Processor simply invokes the <see cref="M:VDS.RDF.Update.SparqlUpdateCommand.Evaluate(VDS.RDF.Update.SparqlUpdateEvaluationContext)">Evaluate</see> method of the SPARQL Commands it is asked to process.  Derived implementations may override the relevant virtual protected methods to substitute their own evaluation of an update for our default standards compliant implementations.
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Update.ISparqlUpdateProcessor">
            <summary>
            Interface for SPARQL Update Processors
            </summary>
            <remarks>
            <para>
            A SPARQL Update Processor is a class that knows how apply SPARQL Update Commands to some data source to which the processor has access
            </para>
            <para>
            The point of this interface is to allow for end users to implement custom update processors or to extend and modify the behaviour of the default Leviathan engine as required.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Update.ISparqlUpdateProcessor.ProcessAddCommand(VDS.RDF.Update.Commands.AddCommand)">
            <summary>
            Processes an ADD command
            </summary>
            <param name="cmd">Add Command</param>
        </member>
        <member name="M:VDS.RDF.Update.ISparqlUpdateProcessor.ProcessClearCommand(VDS.RDF.Update.Commands.ClearCommand)">
            <summary>
            Processes a CLEAR command
            </summary>
            <param name="cmd">Clear Command</param>
        </member>
        <member name="M:VDS.RDF.Update.ISparqlUpdateProcessor.ProcessCopyCommand(VDS.RDF.Update.Commands.CopyCommand)">
            <summary>
            Processes a COPY command
            </summary>
            <param name="cmd">Copy Command</param>
        </member>
        <member name="M:VDS.RDF.Update.ISparqlUpdateProcessor.ProcessCreateCommand(VDS.RDF.Update.Commands.CreateCommand)">
            <summary>
            Processes a CREATE command
            </summary>
            <param name="cmd">Create Command</param>
        </member>
        <member name="M:VDS.RDF.Update.ISparqlUpdateProcessor.ProcessCommand(VDS.RDF.Update.SparqlUpdateCommand)">
            <summary>
            Processes a command
            </summary>
            <param name="cmd">Command</param>
        </member>
        <member name="M:VDS.RDF.Update.ISparqlUpdateProcessor.ProcessCommandSet(VDS.RDF.Update.SparqlUpdateCommandSet)">
            <summary>
            Processes a command set
            </summary>
            <param name="commands">Command Set</param>
        </member>
        <member name="M:VDS.RDF.Update.ISparqlUpdateProcessor.ProcessDeleteCommand(VDS.RDF.Update.Commands.DeleteCommand)">
            <summary>
            Processes a DELETE command
            </summary>
            <param name="cmd">Delete Command</param>
        </member>
        <member name="M:VDS.RDF.Update.ISparqlUpdateProcessor.ProcessDeleteDataCommand(VDS.RDF.Update.Commands.DeleteDataCommand)">
            <summary>
            Processes a DELETE DATA command
            </summary>
            <param name="cmd">DELETE Data Command</param>
        </member>
        <member name="M:VDS.RDF.Update.ISparqlUpdateProcessor.ProcessDropCommand(VDS.RDF.Update.Commands.DropCommand)">
            <summary>
            Processes a DROP command
            </summary>
            <param name="cmd">Drop Command</param>
        </member>
        <member name="M:VDS.RDF.Update.ISparqlUpdateProcessor.ProcessInsertCommand(VDS.RDF.Update.Commands.InsertCommand)">
            <summary>
            Processes an INSERT command
            </summary>
            <param name="cmd">Insert Command</param>
        </member>
        <member name="M:VDS.RDF.Update.ISparqlUpdateProcessor.ProcessInsertDataCommand(VDS.RDF.Update.Commands.InsertDataCommand)">
            <summary>
            Processes an INSERT DATA command
            </summary>
            <param name="cmd">Insert Data Command</param>
        </member>
        <member name="M:VDS.RDF.Update.ISparqlUpdateProcessor.ProcessLoadCommand(VDS.RDF.Update.Commands.LoadCommand)">
            <summary>
            Processes a LOAD command
            </summary>
            <param name="cmd">Load Command</param>
        </member>
        <member name="M:VDS.RDF.Update.ISparqlUpdateProcessor.ProcessModifyCommand(VDS.RDF.Update.Commands.ModifyCommand)">
            <summary>
            Processes an INSERT/DELETE command
            </summary>
            <param name="cmd">Insert/Delete Command</param>
        </member>
        <member name="M:VDS.RDF.Update.ISparqlUpdateProcessor.ProcessMoveCommand(VDS.RDF.Update.Commands.MoveCommand)">
            <summary>
            Processes a MOVE command
            </summary>
            <param name="cmd">Move Command</param>
        </member>
        <member name="M:VDS.RDF.Update.ISparqlUpdateProcessor.Discard">
            <summary>
            Causes any outstanding changes to be discarded
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.ISparqlUpdateProcessor.Flush">
            <summary>
            Causes any outstanding changes to be flushed to the underlying storage
            </summary>
        </member>
        <member name="F:VDS.RDF.Update.LeviathanUpdateProcessor._dataset">
            <summary>
            Dataset over which updates are applied
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.LeviathanUpdateProcessor.#ctor(VDS.RDF.IInMemoryQueryableStore)">
            <summary>
            Creates a new Leviathan Update Processor
            </summary>
            <param name="store">Triple Store</param>
        </member>
        <member name="M:VDS.RDF.Update.LeviathanUpdateProcessor.#ctor(VDS.RDF.Query.Datasets.ISparqlDataset)">
            <summary>
            Creates a new Leviathan Update Processor
            </summary>
            <param name="data">SPARQL Dataset</param>
        </member>
        <member name="M:VDS.RDF.Update.LeviathanUpdateProcessor.Flush">
            <summary>
            Flushes any outstanding changes to the underlying dataset
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.LeviathanUpdateProcessor.Discard">
            <summary>
            Discards and outstanding changes from the underlying dataset
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.LeviathanUpdateProcessor.GetContext(VDS.RDF.Update.SparqlUpdateCommandSet)">
            <summary>
            Creates a new Evaluation Context
            </summary>
            <param name="cmds">Update Commands</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Update.LeviathanUpdateProcessor.GetContext">
            <summary>
            Creates a new Evaluation Context
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Update.LeviathanUpdateProcessor.GetQueryProcessor">
            <summary>
            Gets the Query Processor to be used
            </summary>
            <returns></returns>
            <remarks>
            By default <strong>null</strong> is returned which indicates that the default query processing behaviour is used, to use a specific processor extend this class and override this method.  If you do so you will have access to the dataset in use so generally you will want to use a query processor that accepts a <see cref="T:VDS.RDF.Query.Datasets.ISparqlDataset">ISparqlDataset</see> instance
            </remarks>
        </member>
        <member name="M:VDS.RDF.Update.LeviathanUpdateProcessor.ProcessAddCommand(VDS.RDF.Update.Commands.AddCommand)">
            <summary>
            Processes an ADD command
            </summary>
            <param name="cmd">Add Command</param>
        </member>
        <member name="M:VDS.RDF.Update.LeviathanUpdateProcessor.ProcessAddCommandInternal(VDS.RDF.Update.Commands.AddCommand,VDS.RDF.Update.SparqlUpdateEvaluationContext)">
            <summary>
            Processes an ADD command
            </summary>
            <param name="cmd">Add Command</param>
            <param name="context">SPARQL Update Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Update.LeviathanUpdateProcessor.ProcessClearCommand(VDS.RDF.Update.Commands.ClearCommand)">
            <summary>
            Processes a CLEAR command
            </summary>
            <param name="cmd">Clear Command</param>
        </member>
        <member name="M:VDS.RDF.Update.LeviathanUpdateProcessor.ProcessClearCommandInternal(VDS.RDF.Update.Commands.ClearCommand,VDS.RDF.Update.SparqlUpdateEvaluationContext)">
            <summary>
            Processes a CLEAR command
            </summary>
            <param name="cmd">Clear Command</param>
            <param name="context">SPARQL Update Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Update.LeviathanUpdateProcessor.ProcessCopyCommand(VDS.RDF.Update.Commands.CopyCommand)">
            <summary>
            Processes a COPY command
            </summary>
            <param name="cmd">Copy Command</param>
        </member>
        <member name="M:VDS.RDF.Update.LeviathanUpdateProcessor.ProcessCopyCommandInternal(VDS.RDF.Update.Commands.CopyCommand,VDS.RDF.Update.SparqlUpdateEvaluationContext)">
            <summary>
            Processes a COPY command
            </summary>
            <param name="cmd">Copy Command</param>
            <param name="context">SPARQL Update Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Update.LeviathanUpdateProcessor.ProcessCreateCommand(VDS.RDF.Update.Commands.CreateCommand)">
            <summary>
            Processes a CREATE command
            </summary>
            <param name="cmd">Create Command</param>
        </member>
        <member name="M:VDS.RDF.Update.LeviathanUpdateProcessor.ProcessCreateCommandInternal(VDS.RDF.Update.Commands.CreateCommand,VDS.RDF.Update.SparqlUpdateEvaluationContext)">
            <summary>
            Processes a CREATE command
            </summary>
            <param name="cmd">Create Command</param>
            <param name="context">SPARQL Update Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Update.LeviathanUpdateProcessor.ProcessCommand(VDS.RDF.Update.SparqlUpdateCommand)">
            <summary>
            Processes a command
            </summary>
            <param name="cmd">Command</param>
        </member>
        <member name="M:VDS.RDF.Update.LeviathanUpdateProcessor.ProcessCommandInternal(VDS.RDF.Update.SparqlUpdateCommand,VDS.RDF.Update.SparqlUpdateEvaluationContext)">
            <summary>
            Processes a command
            </summary>
            <param name="cmd">Command</param>
            <param name="context">SPARQL Update Evaluation Context</param>
            <remarks>
            Invokes the type specific method for the command type
            </remarks>
        </member>
        <member name="M:VDS.RDF.Update.LeviathanUpdateProcessor.ProcessCommandSet(VDS.RDF.Update.SparqlUpdateCommandSet)">
            <summary>
            Processes a command set
            </summary>
            <param name="commands">Command Set</param>
            <remarks>
            Invokes <see cref="M:VDS.RDF.Update.LeviathanUpdateProcessor.ProcessCommand(VDS.RDF.Update.SparqlUpdateCommand)">ProcessCommand()</see> on each command in turn
            </remarks>
        </member>
        <member name="M:VDS.RDF.Update.LeviathanUpdateProcessor.ProcessDeleteCommand(VDS.RDF.Update.Commands.DeleteCommand)">
            <summary>
            Processes a DELETE command
            </summary>
            <param name="cmd">Delete Command</param>
        </member>
        <member name="M:VDS.RDF.Update.LeviathanUpdateProcessor.ProcessDeleteCommandInternal(VDS.RDF.Update.Commands.DeleteCommand,VDS.RDF.Update.SparqlUpdateEvaluationContext)">
            <summary>
            Processes a DELETE command
            </summary>
            <param name="cmd">Delete Command</param>
            <param name="context">SPARQL Update Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Update.LeviathanUpdateProcessor.ProcessDeleteDataCommand(VDS.RDF.Update.Commands.DeleteDataCommand)">
            <summary>
            Processes a DELETE DATA command
            </summary>
            <param name="cmd">DELETE Data Command</param>
        </member>
        <member name="M:VDS.RDF.Update.LeviathanUpdateProcessor.ProcessDeleteDataCommandInternal(VDS.RDF.Update.Commands.DeleteDataCommand,VDS.RDF.Update.SparqlUpdateEvaluationContext)">
            <summary>
            Processes a DELETE DATA command
            </summary>
            <param name="cmd">Delete Data Command</param>
            <param name="context">SPARQL Update Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Update.LeviathanUpdateProcessor.ProcessDropCommand(VDS.RDF.Update.Commands.DropCommand)">
            <summary>
            Processes a DROP command
            </summary>
            <param name="cmd">Drop Command</param>
        </member>
        <member name="M:VDS.RDF.Update.LeviathanUpdateProcessor.ProcessDropCommandInternal(VDS.RDF.Update.Commands.DropCommand,VDS.RDF.Update.SparqlUpdateEvaluationContext)">
            <summary>
            Processes a DROP command
            </summary>
            <param name="cmd">Drop Command</param>
            <param name="context">SPARQL Update Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Update.LeviathanUpdateProcessor.ProcessInsertCommand(VDS.RDF.Update.Commands.InsertCommand)">
            <summary>
            Processes an INSERT command
            </summary>
            <param name="cmd">Insert Command</param>
        </member>
        <member name="M:VDS.RDF.Update.LeviathanUpdateProcessor.ProcessInsertCommandInternal(VDS.RDF.Update.Commands.InsertCommand,VDS.RDF.Update.SparqlUpdateEvaluationContext)">
            <summary>
            Processes an INSERT command
            </summary>
            <param name="cmd">Insert Command</param>
            <param name="context">SPARQL Update Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Update.LeviathanUpdateProcessor.ProcessInsertDataCommand(VDS.RDF.Update.Commands.InsertDataCommand)">
            <summary>
            Processes an INSERT DATA command
            </summary>
            <param name="cmd">Insert Data Command</param>
        </member>
        <member name="M:VDS.RDF.Update.LeviathanUpdateProcessor.ProcessInsertDataCommandInternal(VDS.RDF.Update.Commands.InsertDataCommand,VDS.RDF.Update.SparqlUpdateEvaluationContext)">
            <summary>
            Processes an INSERT DATA command
            </summary>
            <param name="cmd">Insert Data Command</param>
            <param name="context">SPARQL Update Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Update.LeviathanUpdateProcessor.ProcessLoadCommand(VDS.RDF.Update.Commands.LoadCommand)">
            <summary>
            Processes a LOAD command
            </summary>
            <param name="cmd">Load Command</param>
        </member>
        <member name="M:VDS.RDF.Update.LeviathanUpdateProcessor.ProcessLoadCommandInternal(VDS.RDF.Update.Commands.LoadCommand,VDS.RDF.Update.SparqlUpdateEvaluationContext)">
            <summary>
            Processes a LOAD command
            </summary>
            <param name="cmd">Load Command</param>
            <param name="context">SPARQL Update Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Update.LeviathanUpdateProcessor.ProcessModifyCommand(VDS.RDF.Update.Commands.ModifyCommand)">
            <summary>
            Processes an INSERT/DELETE command
            </summary>
            <param name="cmd">Insert/Delete Command</param>
        </member>
        <member name="M:VDS.RDF.Update.LeviathanUpdateProcessor.ProcessModifyCommandInternal(VDS.RDF.Update.Commands.ModifyCommand,VDS.RDF.Update.SparqlUpdateEvaluationContext)">
            <summary>
            Processes an INSERT/DELETE command
            </summary>
            <param name="cmd">Insert/Delete Command</param>
            <param name="context">SPARQL Update Evaluation Context</param>
        </member>
        <member name="M:VDS.RDF.Update.LeviathanUpdateProcessor.ProcessMoveCommand(VDS.RDF.Update.Commands.MoveCommand)">
            <summary>
            Processes a MOVE command
            </summary>
            <param name="cmd">Move Command</param>
        </member>
        <member name="M:VDS.RDF.Update.LeviathanUpdateProcessor.ProcessMoveCommandInternal(VDS.RDF.Update.Commands.MoveCommand,VDS.RDF.Update.SparqlUpdateEvaluationContext)">
            <summary>
            Processes a MOVE command
            </summary>
            <param name="cmd">Move Command</param>
            <param name="context">SPARQL Update Evaluation Context</param>
        </member>
        <member name="P:VDS.RDF.Update.LeviathanUpdateProcessor.AutoCommit">
            <summary>
            Gets/Sets whether Updates are automatically committed
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.ExplainUpdateProcessor.#ctor(VDS.RDF.Query.Datasets.ISparqlDataset)">
            <summary>
            Creates a new Explain Update Processor
            </summary>
            <param name="data">Dataset</param>
        </member>
        <member name="M:VDS.RDF.Update.ExplainUpdateProcessor.#ctor(VDS.RDF.Query.Datasets.ISparqlDataset,VDS.RDF.Query.ExplanationLevel)">
            <summary>
            Creates a new Explain Update Processor
            </summary>
            <param name="data">Dataset</param>
            <param name="level">Explanation Level</param>
        </member>
        <member name="M:VDS.RDF.Update.ExplainUpdateProcessor.#ctor(VDS.RDF.IInMemoryQueryableStore,VDS.RDF.Query.ExplanationLevel)">
            <summary>
            Creates a new Explain Update Processor
            </summary>
            <param name="store">Triple Store</param>
            <param name="level">Explanation Level</param>
        </member>
        <member name="M:VDS.RDF.Update.ExplainUpdateProcessor.#ctor(VDS.RDF.IInMemoryQueryableStore)">
            <summary>
            Creates a new Explain Update Processor
            </summary>
            <param name="store">Triple Store</param>
        </member>
        <member name="M:VDS.RDF.Update.ExplainUpdateProcessor.GetQueryProcessor">
            <summary>
            Gets the Query Processor to be used
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Update.GenericUpdateProcessor">
            <summary>
            SPARQL Update Processor which processes commands against a generic underlying store represented by an <see cref="T:VDS.RDF.Storage.IStorageProvider">IStorageProvider</see> implementation
            </summary>
            <remarks>
            <para>
            If the provided manager also implements the <see cref="T:VDS.RDF.Storage.IUpdateableStorage">IUpdateableStorage</see> interface then the managers native SPARQL Update implementation will be used for the non-type specific calls i.e. <see cref="M:VDS.RDF.Update.GenericUpdateProcessor.ProcessCommand(VDS.RDF.Update.SparqlUpdateCommand)">ProcessCommand()</see> and <see cref="M:VDS.RDF.Update.GenericUpdateProcessor.ProcessCommandSet(VDS.RDF.Update.SparqlUpdateCommandSet)">ProcessCommandSet()</see>.  At all other times the SPARQL Update commands will be processed by approximating their behaviour through calls to <see cref="M:VDS.RDF.Storage.IStorageProvider.SaveGraph(VDS.RDF.IGraph)">SaveGraph()</see>, <see cref="!:IStorageProvider.LoadGraph(Uri)">LoadGraph()</see> and <see cref="M:VDS.RDF.Storage.IStorageProvider.UpdateGraph(System.Uri,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple})">UpdateGraph()</see> in addition to local in-memory manipulation of the data.  Some commands such as INSERT and DELETE can only be processed when the manager is also a <see cref="T:VDS.RDF.Storage.IQueryableStorage">IQueryableStorage</see> since they rely on making a query and performing actions based on the results of that query.
            </para>
            <para>
            The performance of this processor is somewhat dependent on the underlying <see cref="T:VDS.RDF.Storage.IStorageProvider">IStorageProvider</see>.  If the underlying manager supports triple level updates as indicated by the <see cref="P:VDS.RDF.Storage.IStorageCapabilities.UpdateSupported">UpdateSupported</see> property then operations can be performed quite efficiently, if this is not the case then any operation which modifies a Graph will need to load the existing Graph from the store, make the modifications locally in-memory and then save the resulting Graph back to the Store
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Update.GenericUpdateProcessor.#ctor(VDS.RDF.Storage.IStorageProvider)">
            <summary>
            Creates a new Generic Update Processor
            </summary>
            <param name="manager">Generic IO Manager</param>
        </member>
        <member name="M:VDS.RDF.Update.GenericUpdateProcessor.Discard">
            <summary>
            Discards any outstanding changes
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.GenericUpdateProcessor.Flush">
            <summary>
            Flushes any outstanding changes to the underlying store
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.GenericUpdateProcessor.ProcessAddCommand(VDS.RDF.Update.Commands.AddCommand)">
            <summary>
            Processes an ADD command
            </summary>
            <param name="cmd">Add Command</param>
        </member>
        <member name="M:VDS.RDF.Update.GenericUpdateProcessor.ProcessClearCommand(VDS.RDF.Update.Commands.ClearCommand)">
            <summary>
            Processes a CLEAR command
            </summary>
            <param name="cmd">Clear Command</param>
            <remarks>
            Implemented by replacing the Graph with an empty Graph
            </remarks>
        </member>
        <member name="M:VDS.RDF.Update.GenericUpdateProcessor.ProcessCopyCommand(VDS.RDF.Update.Commands.CopyCommand)">
            <summary>
            Processes a COPY command
            </summary>
            <param name="cmd">Copy Command</param>
        </member>
        <member name="M:VDS.RDF.Update.GenericUpdateProcessor.ProcessCreateCommand(VDS.RDF.Update.Commands.CreateCommand)">
            <summary>
            Processes a CREATE command
            </summary>
            <param name="cmd">Create Command</param>
            <remarks>
            <para>
            Implemented by adding an empty Graph to the Store
            </para>
            <para>
            <strong>Warning:</strong> As the <see cref="T:VDS.RDF.Storage.IStorageProvider">IStorageProvider</see> interface does not allow checking whether a Graph exists processing CREATE commands can result in overwriting existing Graphs
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Update.GenericUpdateProcessor.ProcessCommand(VDS.RDF.Update.SparqlUpdateCommand)">
            <summary>
            Processes a command
            </summary>
            <param name="cmd">Command</param>
            <remarks>
            <para>
            If the provided manager also implements the <see cref="T:VDS.RDF.Storage.IUpdateableStorage">IUpdateableStorage</see> interface then the managers native SPARQL Update implementation will be used.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Update.GenericUpdateProcessor.ProcessCommandSet(VDS.RDF.Update.SparqlUpdateCommandSet)">
            <summary>
            Processes a command set
            </summary>
            <param name="commands">Command Set</param>
            <remarks>
            <para>
            If the provided manager also implements the <see cref="T:VDS.RDF.Storage.IUpdateableStorage">IUpdateableStorage</see> interface then the managers native SPARQL Update implementation will be used.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Update.GenericUpdateProcessor.ProcessDeleteCommand(VDS.RDF.Update.Commands.DeleteCommand)">
            <summary>
            Processes a DELETE command
            </summary>
            <param name="cmd">Delete Command</param>
            <remarks>
            <para>
            <strong>Note:</strong> The underlying manager must implement the <see cref="T:VDS.RDF.Storage.IQueryableStorage">IQueryableStorage</see> interface in order for DELETE commands to be processed
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Update.GenericUpdateProcessor.ProcessDeleteDataCommand(VDS.RDF.Update.Commands.DeleteDataCommand)">
            <summary>
            Processes a DELETE DATA command
            </summary>
            <param name="cmd">DELETE Data Command</param>
        </member>
        <member name="M:VDS.RDF.Update.GenericUpdateProcessor.ProcessDropCommand(VDS.RDF.Update.Commands.DropCommand)">
            <summary>
            Processes a DROP command
            </summary>
            <param name="cmd">Drop Command</param>
        </member>
        <member name="M:VDS.RDF.Update.GenericUpdateProcessor.ProcessInsertCommand(VDS.RDF.Update.Commands.InsertCommand)">
            <summary>
            Processes an INSERT command
            </summary>
            <param name="cmd">Insert Command</param>
            <remarks>
            <para>
            <strong>Note:</strong> The underlying manager must implement the <see cref="T:VDS.RDF.Storage.IQueryableStorage">IQueryableStorage</see> interface in order for INSERT commands to be processed
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Update.GenericUpdateProcessor.ProcessInsertDataCommand(VDS.RDF.Update.Commands.InsertDataCommand)">
            <summary>
            Processes an INSERT DATA command
            </summary>
            <param name="cmd">Insert Data Command</param>
        </member>
        <member name="M:VDS.RDF.Update.GenericUpdateProcessor.ProcessLoadCommand(VDS.RDF.Update.Commands.LoadCommand)">
            <summary>
            Processes a LOAD command
            </summary>
            <param name="cmd">Load Command</param>
        </member>
        <member name="M:VDS.RDF.Update.GenericUpdateProcessor.ProcessModifyCommand(VDS.RDF.Update.Commands.ModifyCommand)">
            <summary>
            Processes an INSERT/DELETE command
            </summary>
            <param name="cmd">Insert/Delete Command</param>
        </member>
        <member name="M:VDS.RDF.Update.GenericUpdateProcessor.ProcessMoveCommand(VDS.RDF.Update.Commands.MoveCommand)">
            <summary>
            Processes a MOVE command
            </summary>
            <param name="cmd">Move Command</param>
        </member>
        <member name="M:VDS.RDF.Update.GenericUpdateProcessor.IsValidDataPattern(VDS.RDF.Query.Patterns.GraphPattern,System.Boolean)">
            <summary>
            Determines whether a Graph Pattern is valid for use in an INSERT/DELETE DATA command
            </summary>
            <param name="p">Graph Pattern</param>
            <param name="top">Is this the top level pattern?</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Update.SimpleUpdateProcessor">
            <summary>
            SPARQL Update Processor which processes updates by handing them off to the <see cref="M:VDS.RDF.IUpdateableTripleStore.ExecuteUpdate(System.String)">ExecuteUpdate()</see> method of an <see cref="T:VDS.RDF.IUpdateableTripleStore">IUpdateableTripleStore</see>
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.SimpleUpdateProcessor.#ctor(VDS.RDF.IUpdateableTripleStore)">
            <summary>
            Creates a new Simple Update Processor
            </summary>
            <param name="store">Updateable Triple Store</param>
        </member>
        <member name="M:VDS.RDF.Update.SimpleUpdateProcessor.Discard">
            <summary>
            Discards any outstanding changes
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.SimpleUpdateProcessor.Flush">
            <summary>
            Flushes any outstanding changes to the underlying store
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.SimpleUpdateProcessor.ProcessAddCommand(VDS.RDF.Update.Commands.AddCommand)">
            <summary>
            Processes an ADD command
            </summary>
            <param name="cmd">Add Command</param>
        </member>
        <member name="M:VDS.RDF.Update.SimpleUpdateProcessor.ProcessClearCommand(VDS.RDF.Update.Commands.ClearCommand)">
            <summary>
            Processes a CLEAR command
            </summary>
            <param name="cmd">Clear Command</param>
        </member>
        <member name="M:VDS.RDF.Update.SimpleUpdateProcessor.ProcessCopyCommand(VDS.RDF.Update.Commands.CopyCommand)">
            <summary>
            Processes a COPY command
            </summary>
            <param name="cmd">Copy Command</param>
        </member>
        <member name="M:VDS.RDF.Update.SimpleUpdateProcessor.ProcessCreateCommand(VDS.RDF.Update.Commands.CreateCommand)">
            <summary>
            Processes a CREATE command
            </summary>
            <param name="cmd">Create Command</param>
        </member>
        <member name="M:VDS.RDF.Update.SimpleUpdateProcessor.ProcessCommand(VDS.RDF.Update.SparqlUpdateCommand)">
            <summary>
            Processes a command
            </summary>
            <param name="cmd">Command</param>
        </member>
        <member name="M:VDS.RDF.Update.SimpleUpdateProcessor.ProcessCommandSet(VDS.RDF.Update.SparqlUpdateCommandSet)">
            <summary>
            Processes a command set
            </summary>
            <param name="commands">Command Set</param>
        </member>
        <member name="M:VDS.RDF.Update.SimpleUpdateProcessor.ProcessDeleteCommand(VDS.RDF.Update.Commands.DeleteCommand)">
            <summary>
            Processes a DELETE command
            </summary>
            <param name="cmd">Delete Command</param>
        </member>
        <member name="M:VDS.RDF.Update.SimpleUpdateProcessor.ProcessDeleteDataCommand(VDS.RDF.Update.Commands.DeleteDataCommand)">
            <summary>
            Processes a DELETE DATA command
            </summary>
            <param name="cmd">DELETE Data Command</param>
        </member>
        <member name="M:VDS.RDF.Update.SimpleUpdateProcessor.ProcessDropCommand(VDS.RDF.Update.Commands.DropCommand)">
            <summary>
            Processes a DROP command
            </summary>
            <param name="cmd">Drop Command</param>
        </member>
        <member name="M:VDS.RDF.Update.SimpleUpdateProcessor.ProcessInsertCommand(VDS.RDF.Update.Commands.InsertCommand)">
            <summary>
            Processes an INSERT command
            </summary>
            <param name="cmd">Insert Command</param>
        </member>
        <member name="M:VDS.RDF.Update.SimpleUpdateProcessor.ProcessInsertDataCommand(VDS.RDF.Update.Commands.InsertDataCommand)">
            <summary>
            Processes an INSERT DATA command
            </summary>
            <param name="cmd">Insert Data Command</param>
        </member>
        <member name="M:VDS.RDF.Update.SimpleUpdateProcessor.ProcessLoadCommand(VDS.RDF.Update.Commands.LoadCommand)">
            <summary>
            Processes a LOAD command
            </summary>
            <param name="cmd">Load Command</param>
        </member>
        <member name="M:VDS.RDF.Update.SimpleUpdateProcessor.ProcessModifyCommand(VDS.RDF.Update.Commands.ModifyCommand)">
            <summary>
            Processes an INSERT/DELETE command
            </summary>
            <param name="cmd">Insert/Delete Command</param>
        </member>
        <member name="M:VDS.RDF.Update.SimpleUpdateProcessor.ProcessMoveCommand(VDS.RDF.Update.Commands.MoveCommand)">
            <summary>
            Processes a MOVE command
            </summary>
            <param name="cmd">Move Command</param>
        </member>
        <member name="T:VDS.RDF.Update.SparqlRemoteUpdateEndpoint">
            <summary>
            A Class for connecting to a remote SPARQL Update endpoint and executing Updates against it
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.SparqlRemoteUpdateEndpoint.#ctor(System.Uri)">
            <summary>
            Creates a new SPARQL Update Endpoint for the given URI
            </summary>
            <param name="endpointUri">Endpoint URI</param>
        </member>
        <member name="M:VDS.RDF.Update.SparqlRemoteUpdateEndpoint.#ctor(System.String)">
            <summary>
            Creates a new SPARQL Update Endpoint for the given URI
            </summary>
            <param name="endpointUri">Endpoint URI</param>
        </member>
        <member name="M:VDS.RDF.Update.SparqlRemoteUpdateEndpoint.Update(System.String,VDS.RDF.UpdateCallback,System.Object)">
            <summary>
            Makes an update request asynchronously to the remote endpoint
            </summary>
            <param name="sparqlUpdate">SPARQL Update</param>
            <param name="callback">Callback to invoke when the update completes</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Update.SparqlRemoteUpdateEndpoint.SerializeConfiguration(VDS.RDF.Configuration.ConfigurationSerializationContext)">
            <summary>
            Serializes configuration for the endpoint
            </summary>
            <param name="context">Serialization Context</param>
        </member>
        <member name="P:VDS.RDF.Update.SparqlRemoteUpdateEndpoint.HttpMode">
            <summary>
            Gets/Sets the HTTP Method used for requests
            </summary>
            <remarks>
            The SPARQL 1.1 Protocol specification mandates that Update requests may only be POSTed, attempting to alter the HTTP Mode to anything other than POST will result in a <see cref="T:VDS.RDF.Update.SparqlUpdateException">SparqlUpdateException</see>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Update.SparqlUpdateCommandType">
            <summary>
            Possible SPARQL Update Command Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Update.SparqlUpdateCommandType.InsertData">
            <summary>
            Command inserts data
            </summary>
        </member>
        <member name="F:VDS.RDF.Update.SparqlUpdateCommandType.DeleteData">
            <summary>
            Command deletes data
            </summary>
        </member>
        <member name="F:VDS.RDF.Update.SparqlUpdateCommandType.Insert">
            <summary>
            Command inserts data and may be based upon a template
            </summary>
        </member>
        <member name="F:VDS.RDF.Update.SparqlUpdateCommandType.Delete">
            <summary>
            Command deletes data and may be based upon a template
            </summary>
        </member>
        <member name="F:VDS.RDF.Update.SparqlUpdateCommandType.Modify">
            <summary>
            Command modifies data
            </summary>
        </member>
        <member name="F:VDS.RDF.Update.SparqlUpdateCommandType.Load">
            <summary>
            Command loads a graph into the Store
            </summary>
        </member>
        <member name="F:VDS.RDF.Update.SparqlUpdateCommandType.Clear">
            <summary>
            Command clears a graph in the Store
            </summary>
        </member>
        <member name="F:VDS.RDF.Update.SparqlUpdateCommandType.Create">
            <summary>
            Command creates a Graph in the Store
            </summary>
        </member>
        <member name="F:VDS.RDF.Update.SparqlUpdateCommandType.Drop">
            <summary>
            Command removes a Graph from the Store
            </summary>
        </member>
        <member name="F:VDS.RDF.Update.SparqlUpdateCommandType.Add">
            <summary>
            Command which merges the data from one Graph into another
            </summary>
        </member>
        <member name="F:VDS.RDF.Update.SparqlUpdateCommandType.Copy">
            <summary>
            Command which copies the data from one Graph into another overwriting the destination Graph
            </summary>
        </member>
        <member name="F:VDS.RDF.Update.SparqlUpdateCommandType.Move">
            <summary>
            Command which moves data from one Graph to another overwriting the destination Graph and deleting the Source Graph
            </summary>
        </member>
        <member name="F:VDS.RDF.Update.SparqlUpdateCommandType.Unknown">
            <summary>
            Unknown
            </summary>
        </member>
        <member name="T:VDS.RDF.Update.SparqlUpdateCommandSet">
            <summary>
            Represents a sequence of SPARQL Update Commands to be executed on a Dataset
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.SparqlUpdateCommandSet.#ctor">
            <summary>
            Creates a new empty Command Set
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.SparqlUpdateCommandSet.#ctor(VDS.RDF.Update.SparqlUpdateCommand)">
            <summary>
            Creates a new Command Set containing the given Command
            </summary>
            <param name="command">Command</param>
        </member>
        <member name="M:VDS.RDF.Update.SparqlUpdateCommandSet.#ctor(System.Collections.Generic.IEnumerable{VDS.RDF.Update.SparqlUpdateCommand})">
            <summary>
            Creates a new Command Set with the given Commands
            </summary>
            <param name="commands">Commands</param>
        </member>
        <member name="M:VDS.RDF.Update.SparqlUpdateCommandSet.AddCommand(VDS.RDF.Update.SparqlUpdateCommand)">
            <summary>
            Adds a new Command to the end of the sequence of Commands
            </summary>
            <param name="command">Command to add</param>
        </member>
        <member name="M:VDS.RDF.Update.SparqlUpdateCommandSet.Optimise(VDS.RDF.Query.Optimisation.IQueryOptimiser)">
            <summary>
            Optimises the Commands in the Command Set
            </summary>
            <param name="optimiser">Optimiser to use</param>
        </member>
        <member name="M:VDS.RDF.Update.SparqlUpdateCommandSet.Optimise">
            <summary>
            Optimises the Commands in the Command Set
            </summary>
            <remarks>Uses the globally registered query optimiser from <see cref="P:VDS.RDF.Query.Optimisation.SparqlOptimiser.QueryOptimiser">SparqlOptimiser.QueryOptimiser</see></remarks>
        </member>
        <member name="M:VDS.RDF.Update.SparqlUpdateCommandSet.Process(VDS.RDF.Update.ISparqlUpdateProcessor)">
            <summary>
            Processes the Command Set using the given Update Processor
            </summary>
            <param name="processor">Update Processor</param>
        </member>
        <member name="M:VDS.RDF.Update.SparqlUpdateCommandSet.ToString">
            <summary>
            Gets the String representation of the Command Set
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Update.SparqlUpdateCommandSet.Item(System.Int32)">
            <summary>
            Gets the Command at the given index
            </summary>
            <param name="index">Index</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Update.SparqlUpdateCommandSet.CommandCount">
            <summary>
            Gets the number of Commands in the set
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.SparqlUpdateCommandSet.Commands">
            <summary>
            Gets the enumeration of Commands in the set
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.SparqlUpdateCommandSet.BaseUri">
            <summary>
            Gets/Sets the Base URI for the Command Set
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.SparqlUpdateCommandSet.NamespaceMap">
            <summary>
            Gets the Namespace Map for the Command Set
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.SparqlUpdateCommandSet.Timeout">
            <summary>
            Gets/Sets the Timeout in milliseconds for the execution of the Updates
            </summary>
            <remarks>Default is no timeout</remarks>
        </member>
        <member name="P:VDS.RDF.Update.SparqlUpdateCommandSet.UpdateExecutionTime">
            <summary>
            Gets/Sets the Time the updates took to execute
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown if you try to inspect the execution time before/during the execution of updates</exception>
        </member>
        <member name="P:VDS.RDF.Update.SparqlUpdateCommandSet.AlgebraOptimisers">
            <summary>
            Gets/Sets the Algebra Optimisers to be applied to portions of updates that require queries to be made
            </summary>
        </member>
        <member name="T:VDS.RDF.Update.SparqlUpdateEvaluationContext">
            <summary>
            Evaluation Context for SPARQL Updates evaluated by the libraries Leviathan SPARQL Engine
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.SparqlUpdateEvaluationContext.#ctor(VDS.RDF.Update.SparqlUpdateCommandSet,VDS.RDF.Query.Datasets.ISparqlDataset,VDS.RDF.Query.ISparqlQueryAlgebraProcessor{VDS.RDF.Query.Algebra.BaseMultiset,VDS.RDF.Query.SparqlEvaluationContext})">
            <summary>
            Creates a new SPARQL Update Evaluation Context
            </summary>
            <param name="commands">Command Set</param>
            <param name="data">SPARQL Dataset</param>
            <param name="processor">Query Processor for WHERE clauses</param>
        </member>
        <member name="M:VDS.RDF.Update.SparqlUpdateEvaluationContext.#ctor(VDS.RDF.Update.SparqlUpdateCommandSet,VDS.RDF.Query.Datasets.ISparqlDataset)">
            <summary>
            Creates a new SPARQL Update Evaluation Context
            </summary>
            <param name="commands">Command Set</param>
            <param name="data">SPARQL Dataset</param>
        </member>
        <member name="M:VDS.RDF.Update.SparqlUpdateEvaluationContext.#ctor(VDS.RDF.Query.Datasets.ISparqlDataset,VDS.RDF.Query.ISparqlQueryAlgebraProcessor{VDS.RDF.Query.Algebra.BaseMultiset,VDS.RDF.Query.SparqlEvaluationContext})">
            <summary>
            Creates a new SPARQL Update Evaluation Context
            </summary>
            <param name="data">SPARQL Dataset</param>
            <param name="processor">Query Processor for WHERE clauses</param>
        </member>
        <member name="M:VDS.RDF.Update.SparqlUpdateEvaluationContext.#ctor(VDS.RDF.Query.Datasets.ISparqlDataset)">
            <summary>
            Creates a new SPARQL Update Evaluation Context
            </summary>
            <param name="data">SPARQL Dataset</param>
        </member>
        <member name="M:VDS.RDF.Update.SparqlUpdateEvaluationContext.CheckTimeout">
            <summary>
            Checks whether Execution should Time out
            </summary>
            <exception cref="T:VDS.RDF.Update.SparqlUpdateTimeoutException">Thrown if the Update has exceeded the Execution Timeout</exception>
        </member>
        <member name="M:VDS.RDF.Update.SparqlUpdateEvaluationContext.StartExecution">
            <summary>
            Starts the Execution Timer
            </summary>
        </member>
        <member name="M:VDS.RDF.Update.SparqlUpdateEvaluationContext.EndExecution">
            <summary>
            Ends the Execution Timer
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.SparqlUpdateEvaluationContext.Commands">
            <summary>
            Gets the Command Set (if any) that this context pertains to
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.SparqlUpdateEvaluationContext.Data">
            <summary>
            Dataset upon which the Updates are applied
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.SparqlUpdateEvaluationContext.QueryProcessor">
            <summary>
            Gets the Query Processor used to process the WHERE clauses of DELETE or INSERT commands
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.SparqlUpdateEvaluationContext.UpdateTime">
            <summary>
            Retrieves the Time in milliseconds the update took to evaluate
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.SparqlUpdateEvaluationContext.UpdateTimeTicks">
            <summary>
            Retrieves the Time in ticks the updates took to evaluate
            </summary>
        </member>
        <member name="P:VDS.RDF.Update.SparqlUpdateEvaluationContext.RemainingTimeout">
            <summary>
            Gets the Remaining Timeout i.e. the Timeout taking into account time already elapsed
            </summary>
            <remarks>
            If there is no timeout then this is always zero, if there is a timeout this is always >= 1 since any operation that wants to respect the timeout must have a non-zero timeout to actually timeout properly.
            </remarks>
        </member>
        <member name="P:VDS.RDF.Update.SparqlUpdateEvaluationContext.UpdateTimeout">
            <summary>
            Gets the Update Timeout used for the Command Set
            </summary>
            <remarks>
            <para>
            This is taken either from the <see cref="P:VDS.RDF.Update.SparqlUpdateCommandSet.Timeout">Timeout</see> property of the <see cref="T:VDS.RDF.Update.SparqlUpdateCommandSet">SparqlUpdateCommandSet</see> to which this evaluation context pertains or from the global option <see cref="P:VDS.RDF.Options.UpdateExecutionTimeout">Options.UpdateExecutionTimeout</see>.  To set the Timeout to be used set whichever of those is appropriate prior to evaluating the updates.  If there is a Command Set present then it's timeout takes precedence unless it is set to zero (no timeout) in which case the global timeout setting is applied.  You cannot set the Update Timeout to be higher than the global timeout unless the global timeout is set to zero (i.e. no global timeout)
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Update.SparqlUpdateSpecsHelper">
            <summary>
            Static Helper class for providing constants, helper functions etc regarding the SPARQL Update specification
            </summary>
        </member>
        <member name="T:VDS.RDF.Configuration.ConfigurationLoader">
            <summary>
            The Configuration Loader is responsible for the loading of Configuration information and objects based upon information encoded in a Graph but more generally may be used for the loading of any type of object whose configuration has been loaded in a Graph and for which a relevant <see cref="T:VDS.RDF.Configuration.IObjectFactory">IObjectFactory</see> is available.
            </summary>
            <remarks>
            <para></para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Configuration.IConfigurationLoader">
            <summary>
            The Configuration Loader is responsible for the loading of Configuration information 
            and objects based upon information encoded in a Graph but more generally may be used 
            for the loading of any type of object whose configuration has been loaded in a Graph 
            and for which a relevant <see cref="T:VDS.RDF.Configuration.IObjectFactory">IObjectFactory</see> is available.
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.IConfigurationLoader.LoadObject``1(System.Uri)">
            <summary>
            Loads the Object identified by the given URI as an object of the given type based on information from the Configuration Graph
            </summary>
            <remarks>
            See remarks under <see cref="M:VDS.RDF.Configuration.ConfigurationLoader.LoadObject(VDS.RDF.IGraph,VDS.RDF.INode)"/> 
            </remarks>
        </member>
        <member name="M:VDS.RDF.Configuration.IConfigurationLoader.LoadObject``1(System.String)">
            <summary>
            Loads the Object identified by the given blank node identifier as an object of the given type based on information from the Configuration Graph
            </summary>
            <remarks>
            See remarks under <see cref="M:VDS.RDF.Configuration.ConfigurationLoader.LoadObject(VDS.RDF.IGraph,VDS.RDF.INode)"/> 
            </remarks>
        </member>
        <member name="M:VDS.RDF.Configuration.IConfigurationLoader.LoadObject(System.String)">
            <summary>
            Loads the Object identified by the given blank node identifier as an <see cref="T:System.Object"/>
            </summary>
            <remarks>
            See remarks under <see cref="M:VDS.RDF.Configuration.ConfigurationLoader.LoadObject(VDS.RDF.IGraph,VDS.RDF.INode)"/> 
            </remarks>
        </member>
        <member name="M:VDS.RDF.Configuration.IConfigurationLoader.LoadObject(System.Uri)">
            <summary>
            Loads the Object identified by the given URI as an <see cref="T:System.Object"/>
            </summary>
            <remarks>
            See remarks under <see cref="M:VDS.RDF.Configuration.ConfigurationLoader.LoadObject(VDS.RDF.IGraph,VDS.RDF.INode)"/> 
            </remarks>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ConfigurationNamespace">
            <summary>
            Configuration Namespace URI
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.UriSchemeAppSettings">
            <summary>
            Constants for URI Schemes with special meaning within the Configuration API
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.UriSchemeConfigureOptions">
            <summary>
            Constants for URI Schemes with special meaning within the Configuration API
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyType">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyImports">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyConfigure">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyEnabled">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyUser">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyPassword">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyCredentials">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyUseCredentialsForProxy">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyServer">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyPort">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyDatabase">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyCatalog">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyStore">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyQueryPath">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyUpdatePath">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyReadOnly">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyEnableUpdates">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyAsync">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyLoadMode">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyEncryptConnection">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertySkipParsing">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyStorageProvider">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyQueryProcessor">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyUpdateProcessor">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyProtocolProcessor">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyUsingDataset">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyUsingStore">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyUsingGraph">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyUsingTripleCollection">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyUsingGraphCollection">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyFromFile">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyFromEmbedded">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyFromUri">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyFromString">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyFromDataset">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyFromStore">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyFromGraph">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyWithUri">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyAssignUri">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyEndpoint">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyEndpointUri">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyQueryEndpointUri">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyUpdateEndpointUri">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyQueryEndpoint">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyUpdateEndpoint">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyDefaultGraphUri">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyNamedGraphUri">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyUnionDefaultGraph">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyProxy">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyReasoner">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyOwlReasoner">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyUserGroup">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyMember">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyRequiresAuthentication">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyPermissionModel">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyAllow">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyDeny">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyAction">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyEnableCors">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertySyntax">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyTimeout">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyPartialResults">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyShowErrors">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyHaltOnError">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyShowQueryForm">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyShowUpdateForm">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyDefaultQueryFile">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyDefaultUpdateFile">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyIntroFile">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyStylesheet">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyCacheDuration">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyCacheSliding">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyExpressionFactory">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyFunctionFactory">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyDescribeAlgorithm">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyServiceDescription">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyQueryOptimiser">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyAlgebraOptimiser">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyCompressionLevel">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyPrettyPrinting">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyHighSpeedWriting">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyDtdWriting">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyAttributeWriting">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyMultiThreadedWriting">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.PropertyImportNamespacesFrom">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ClassObjectFactory">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ClassTripleStore">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ClassGraphCollection">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ClassGraph">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ClassTripleCollection">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ClassStorageServer">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ClassStorageProvider">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ClassHttpHandler">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ClassSparqlEndpoint">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ClassSparqlQueryEndpoint">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ClassSparqlUpdateEndpoint">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ClassSparqlQueryProcessor">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ClassSparqlUpdateProcessor">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ClassSparqlHttpProtocolProcessor">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ClassSparqlExpressionFactory">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ClassSparqlPropertyFunctionFactory">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ClassSparqlDataset">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ClassQueryOptimiser">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ClassAlgebraOptimiser">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ClassSparqlOperator">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ClassReasoner">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ClassOwlReasoner">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ClassProxy">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ClassUserGroup">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ClassUser">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ClassPermission">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ClassRdfParser">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ClassDatasetParser">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ClassSparqlResultsParser">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ClassRdfWriter">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ClassDatasetWriter">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.ClassSparqlResultsWriter">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.DefaultTypeTripleStore">
            <summary>
            QName Constants for Default Types for some configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.DefaultTypeGraphCollection">
            <summary>
            QName Constants for Default Types for some configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.DefaultTypeGraph">
            <summary>
            QName Constants for Default Types for some configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.DefaultTypeTripleCollection">
            <summary>
            QName Constants for Default Types for some configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.DefaultTypeSparqlQueryProcessor">
            <summary>
            QName Constants for Default Types for some configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.DefaultTypeSparqlUpdateProcessor">
            <summary>
            QName Constants for Default Types for some configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.DefaultTypeSparqlHttpProtocolProcessor">
            <summary>
            QName Constants for Default Types for some configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader.DefaultTypeUserGroup">
            <summary>
            QName Constants for Default Types for some configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader._cache">
            <summary>
            Cache for loaded objects
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader._factories">
            <summary>
            Set of built-in object factories that are automatically registered and used
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationLoader._resolver">
            <summary>
            Path resolver
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.LoadEmbeddedConfiguration(System.String)">
            <summary>
            Loads a Configuration Graph and applies auto-configuration
            </summary>
            <param name="resource">Embedded Resource to load</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.LoadEmbeddedConfiguration(System.String,System.Boolean)">
            <summary>
            Loads a Configuration Graph and applies auto-configuration if desired
            </summary>
            <param name="resource">Embedded Resource to load</param>
            <param name="autoConfigure">Whether to apply auto-configuration</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.LoadCommon(VDS.RDF.IGraph,VDS.RDF.INode,System.Boolean)">
            <summary>
            Common loader for Configuration Graphs, handles the resolution of dnr:imports and applies the auto-configuration if selected
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="source">Source the graph originated from</param>
            <param name="autoConfigure">Whether to apply auto-configuration</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.LoadCommon(VDS.RDF.IGraph,System.Collections.Generic.IEnumerable{VDS.RDF.INode},System.Boolean)">
            <summary>
            Common loader for Configuration Graphs, handles the resolution of dnr:imports and applies the auto-configuration if selected
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="sources">Sources the graph originated from</param>
            <param name="autoConfigure">Whether to apply auto-configuration</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.AutoConfigure(VDS.RDF.IGraph)">
            <summary>
            Given a Configuration Graph applies all available auto-configuration based on the contents of the graph
            </summary>
            <param name="g">Configuration Graph</param>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.AutoConfigureObjectFactories(VDS.RDF.IGraph)">
            <summary>
            Given a Configuration Graph will detect and configure Object Factories defined in the configuration
            </summary>
            <param name="g">Configuration Graph</param>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.AutoConfigureStaticOptions(VDS.RDF.IGraph)">
            <summary>
            Given a Configuration Graph will detect and configure static options that are specified using the dnr:configure property with special &lt;dotnetrdf-configure:Class/Property&gt; subject URIs
            </summary>
            <param name="g">Configuration Graph</param>
            <remarks>
            <para>
            An example of using this mechanism to configure a static option is as follows:
            </para>
            <pre>
            &lt;dotnetrdf-configure:VDS.RDF.Options#UsePLinqEvaluation&gt; dnr:configure false .
            </pre>
            <para>
            Class and property names must be fully qualified, to specify static options outside of dotNetRDF itself you can add an additional path segment with the assembly name after the initial configure keyword.  If the class/property does not exist or the value of the literal cannot be appropriately converted to the type of the property then an exception will be thrown.  If there is a problem setting the property (e.g. it does not have a public setter) then an exception will be thrown.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.AutoConfigureReadersAndWriters(VDS.RDF.IGraph)">
            <summary>
            Given a Configuration Graph will detect Readers and Writers for RDF and SPARQL syntaxes and register them with <see cref="T:VDS.RDF.MimeTypesHelper">MimeTypesHelper</see>.  This will cause the library defaults to be overridden where appropriate.
            </summary>
            <param name="g">Configuration Graph</param>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.AutoConfigureSparqlOperators(VDS.RDF.IGraph)">
            <summary>
            Given a Configuration Graph will detect and configure SPARQL Operators
            </summary>
            <param name="g">Configuration Graph</param>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.CheckCircularReference(VDS.RDF.INode,VDS.RDF.INode,System.String)">
            <summary>
            Checks for circular references and throws an error if there is one
            </summary>
            <param name="a">Object you are attempting to load</param>
            <param name="b">Object being referenced</param>
            <param name="property">QName for the property that makes the reference</param>
            <remarks>
            <para>
            If the Object you are trying to load and the Object you need to load are equal then this is a circular reference and an error is thrown
            </para>
            <para>
            The <see cref="T:VDS.RDF.Configuration.ConfigurationLoader">ConfigurationLoader</see> is not currently capable of detecting more subtle circular references
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.CreateConfigurationNode(VDS.RDF.IGraph,System.String)">
            <summary>
            Creates a URI Node that refers to some Configuration property/type
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="qname">QName of the property/type</param>
            <returns></returns>
            <remarks>
            <para>
            The QName provides should be of the form <strong>dnr:qname</strong> - the <strong>dnr</strong> prefix will be automatically be considered to be to the Configuration Namespace which is defined by the <see cref="F:VDS.RDF.Configuration.ConfigurationLoader.ConfigurationNamespace">ConfigurationNamespace</see> constant.
            </para>
            <para>
            This function uses caching to ensure that URI Nodes aren't needlessly recreated in order to save memory.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.ClearCache">
            <summary>
            Clears the Object Loader cache (this is not recommended)
            </summary>
            <remarks>
            <para>
            This method should only be invoked in cases where you have attempted to load an object and some error occurred which was external to dotNetRDF e.g. network connectivity problem and 
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.GetConfigurationData(VDS.RDF.IGraph,VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets all the values given for a property of a given Object in the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="property">Property Node</param>
            <returns>
            Enumeration of values given for the property for the Object
            </returns>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.GetConfigurationArray(VDS.RDF.IGraph,VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets all the literal values given for a property of a given Object in the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="property">Property Node</param>
            <returns></returns>
            <remarks>
            <para>
            Only returns the value part of Literal Nodes which are given as values for the property i.e. ignores all non-Literals and discards any language/data type from Literals
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.GetConfigurationNode(VDS.RDF.IGraph,VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets the first value given for a property of a given Object in the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="property">Property Node</param>
            <returns>
            First value given for the property of the Object
            </returns>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.GetConfigurationNode(VDS.RDF.IGraph,VDS.RDF.INode,System.Collections.Generic.IEnumerable{VDS.RDF.INode})">
            <summary>
            Gets the first value given for the first found property of a given Object in the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="properties">Properties</param>
            <returns>
            First value given for the first property of the Object which is matched
            </returns>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.GetConfigurationString(VDS.RDF.IGraph,VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets the String value or null of the first instance of a property for a given Object in the Configuration Graph where the value for the property is a Literal Node
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="property">Property Node</param>
            <returns>
            <para>
            String value of the first instance of the property or a null if no values or not a literal value
            </para>
            <para>
            If you want the String value regardless of Node type then use the <see cref="M:VDS.RDF.Configuration.ConfigurationLoader.GetConfigurationValue(VDS.RDF.IGraph,VDS.RDF.INode,VDS.RDF.INode)">GetConfigurationValue</see> function instead
            </para>
            </returns>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.GetConfigurationString(VDS.RDF.IGraph,VDS.RDF.INode,System.Collections.Generic.IEnumerable{VDS.RDF.INode})">
            <summary>
            Gets the String value or null of the first instance of the first property for a given Object in the Configuration Graph where the value for the property is a Literal Node
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="properties">Property Nodes</param>
            <returns>
            <para>
            String value of the first instance of the first property or a null if no values or not a literal value
            </para>
            <para>
            If you want the String value regardless of Node type then use the <see cref="M:VDS.RDF.Configuration.ConfigurationLoader.GetConfigurationValue(VDS.RDF.IGraph,VDS.RDF.INode,System.Collections.Generic.IEnumerable{VDS.RDF.INode})">GetConfigurationValue</see> function instead
            </para>
            </returns>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.GetConfigurationValue(VDS.RDF.IGraph,VDS.RDF.INode,VDS.RDF.INode)">
            <summary>
            Gets the String value or null of the first instance of a property for a given Object in the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="property">Property Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.GetConfigurationValue(VDS.RDF.IGraph,VDS.RDF.INode,System.Collections.Generic.IEnumerable{VDS.RDF.INode})">
            <summary>
            Gets the String value or null of the first instance of the first property for a given Object in the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="properties">Property Nodes</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.GetConfigurationBoolean(VDS.RDF.IGraph,VDS.RDF.INode,VDS.RDF.INode,System.Boolean)">
            <summary>
            Gets the Boolean value or a given default of the first instance of a property for a given Object in the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="property">Property Node</param>
            <param name="defValue">Default Value to return if there is no valid boolean value</param>
            <returns>
            If there is a valid boolean value for the property then that is returned, in any other case the given <paramref name="defValue">Default Value</paramref> is returned
            </returns>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.GetConfigurationBoolean(VDS.RDF.IGraph,VDS.RDF.INode,System.Collections.Generic.IEnumerable{VDS.RDF.INode},System.Boolean)">
            <summary>
            Gets the Boolean value or a given default of the first instance of the first property for a given Object in the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="properties">Property Nodes</param>
            <param name="defValue">Default Value to return if there is no valid boolean value</param>
            <returns>
            If there is a valid boolean value for any property then that is returned, in any other case the given <paramref name="defValue">Default Value</paramref> is returned
            </returns>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.GetConfigurationInt64(VDS.RDF.IGraph,VDS.RDF.INode,VDS.RDF.INode,System.Int64)">
            <summary>
            Gets the 64 bit Integer value or a given default of the first instance of a property for a given Object in the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="property">Property Node</param>
            <param name="defValue">Default Value to return if there is no valid boolean value</param>
            <returns>
            If there is a valid integer value for the property then that is returned, in any other case the given <paramref name="defValue">Default Value</paramref> is returned
            </returns>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.GetConfigurationInt64(VDS.RDF.IGraph,VDS.RDF.INode,System.Collections.Generic.IEnumerable{VDS.RDF.INode},System.Int64)">
            <summary>
            Gets the 64 bit Integer value or a given default of the first instance of the first property for a given Object in the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="properties">Property Nodes</param>
            <param name="defValue">Default Value to return if there is no valid boolean value</param>
            <returns>
            If there is a valid integer value for any property then that is returned, in any other case the given <paramref name="defValue">Default Value</paramref> is returned
            </returns>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.GetConfigurationInt32(VDS.RDF.IGraph,VDS.RDF.INode,VDS.RDF.INode,System.Int32)">
            <summary>
            Gets the 64 bit Integer value or a given default of the first instance of a property for a given Object in the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="property">Property Node</param>
            <param name="defValue">Default Value to return if there is no valid boolean value</param>
            <returns>
            If there is a valid integer value for the property then that is returned, in any other case the given <paramref name="defValue">Default Value</paramref> is returned
            </returns>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.GetConfigurationInt32(VDS.RDF.IGraph,VDS.RDF.INode,System.Collections.Generic.IEnumerable{VDS.RDF.INode},System.Int32)">
            <summary>
            Gets the 64 bit Integer value or a given default of the first instance of the first property for a given Object in the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="properties">Property Nodes</param>
            <param name="defValue">Default Value to return if there is no valid boolean value</param>
            <returns>
            If there is a valid integer value for any property then that is returned, in any other case the given <paramref name="defValue">Default Value</paramref> is returned
            </returns>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.GetUsernameAndPassword(VDS.RDF.IGraph,VDS.RDF.INode,System.Boolean,System.String@,System.String@)">
            <summary>
            Gets the Username and Password specified for a given Object
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="allowCredentials">Whether settings may be specified using the dnr:credentials property</param>
            <param name="user">Username</param>
            <param name="pwd">Password</param>
            <remarks>
            Username and/or Password will be null if there is no value specified for the relevant properties
            </remarks>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.IsCached(VDS.RDF.IGraph,VDS.RDF.INode)">
            <summary>
            Gets whether the given Object has already been loaded and cached
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <returns></returns>
            <remarks>
            If this returns true then loading that object again should be essentially instantaneous as it will come from the cache
            </remarks>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.LoadObject(VDS.RDF.IGraph,VDS.RDF.INode,System.Type)">
            <summary>
            Loads the Object identified by the given Node as an object of the given type based on information from the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="targetType">Target Type</param>
            <returns></returns>
            <remarks>
            <para>
            Callers of this method should be careful to check that the Object returned is of a usable type to them.  The Target Type parameter does not guarantee that the return value is of that type it is only used to determine which registered instances of <see cref="T:VDS.RDF.Configuration.IObjectFactory">IObjectFactory</see> are potentially capable of creating the desired Object
            </para>
            <para>
            Callers should also take care that any Objects returned from this method are disposed of when the caller no longer has a use for them as otherwise the reference kept in the cache here will cause the Object to remain in-memory consuming resources
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.LoadObject(VDS.RDF.IGraph,VDS.RDF.INode)">
            <summary>
            Loads the Object identified by the given Node based on information from the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <returns></returns>
            <remarks>
            <para>
            Use this overload when you have a Node which identifies an Object and you don't know what the type of that Object is.  This function looks up the <strong>dnr:type</strong> property for the given Object and then calls the other version of this function providing it with the relevant type information.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.GetDefaultType(VDS.RDF.IGraph,VDS.RDF.INode)">
            <summary>
            Attempts to find the Default Type to load an Object as when no explicit dnr:type property has been declared but an rdf:type property has been declared giving a valid Configuration Class
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <returns></returns>
            <remarks>
            <para>
            <strong>Note:</strong> Only some configuration classes have corresponding default types, in general it is recommended that Configuration Graphs should always use the dnr:type property to explicitly state the intended type of an Object
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.GetDefaultType(System.String)">
            <summary>
            Attempts to return the Default Type to load an Object as when there is no dnr:type property but there is a rdf:type property
            </summary>
            <param name="typeUri">Type URI declared by the rdf:type property</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.ResolveAppSetting(VDS.RDF.IGraph,VDS.RDF.INode)">
            <summary>
            Attempts to resolve special &lt;appsettings&gt; URIs into actual values
            </summary>
            <param name="g"></param>
            <param name="n"></param>
            <returns></returns>
            <remarks>
            <para>
            These special URIs have the form &lt;appsetting:Key&gt; where <strong>Key</strong> is the key for an appSetting in your applications configuration file.  When used these URIs are resolved at load time into the actual values from your configuration file.  This allows you to avoid spreading configuration data over multiple files since you can specify things like connection settings in the Application Config file and then simply reference them in the dotNetRDF configuration file.
            </para>
            <para>
            <strong>Warning: </strong> This feature is not supported in the Silverlight build 
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.#ctor(VDS.RDF.IGraph)">
            <summary>
            Creates a new instance of <see cref="T:VDS.RDF.Configuration.ConfigurationLoader"/>, which
            loads an existing configuration graph and applies auto-configuration
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.#ctor(VDS.RDF.IGraph,System.Boolean)">
            <summary>
            Creates a new instance of <see cref="T:VDS.RDF.Configuration.ConfigurationLoader"/>, which
            loads an existing configuration graph and optionally applies auto-configuration
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.LoadObject``1(System.String)">
            <summary>
            Loads the Object identified by the given blank node identifier as an object of the given type based on information from the Configuration Graph
            </summary>
            <remarks>
            See remarks under <see cref="M:VDS.RDF.Configuration.ConfigurationLoader.LoadObject(VDS.RDF.IGraph,VDS.RDF.INode)"/> 
            </remarks>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.LoadObject``1(System.Uri)">
            <summary>
            Loads the Object identified by the given URI as an object of the given type based on information from the Configuration Graph
            </summary>
            <remarks>
            See remarks under <see cref="M:VDS.RDF.Configuration.ConfigurationLoader.LoadObject(VDS.RDF.IGraph,VDS.RDF.INode)"/> 
            </remarks>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.LoadObject(System.String)">
            <summary>
            Loads the Object identified by the given blank node identifier as an <see cref="T:System.Object"/>
            </summary>
            <remarks>
            See remarks under <see cref="M:VDS.RDF.Configuration.ConfigurationLoader.LoadObject(VDS.RDF.IGraph,VDS.RDF.INode)"/> 
            </remarks>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.LoadObject(System.Uri)">
            <summary>
            Loads the Object identified by the given URI as an <see cref="T:System.Object"/>
            </summary>
            <remarks>
            See remarks under <see cref="M:VDS.RDF.Configuration.ConfigurationLoader.LoadObject(VDS.RDF.IGraph,VDS.RDF.INode)"/> 
            </remarks>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.AddObjectFactory(VDS.RDF.Configuration.IObjectFactory)">
            <summary>
            Registers an Object Factory with the Configuration Loader
            </summary>
            <param name="factory">Object Factory</param>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationLoader.ResolvePath(System.String)">
            <summary>
            Resolves a Path using the in-use path-resolver
            </summary>
            <param name="path">Path to resolve</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Configuration.ConfigurationLoader.PathResolver">
            <summary>
            Gets/Sets the in-use Path Resolver
            </summary>
        </member>
        <member name="T:VDS.RDF.Configuration.UnloadableObject">
            <summary>
            Marker class used in the <see cref="T:VDS.RDF.Configuration.ConfigurationLoader">ConfigurationLoader</see> Object cache to mark objects which are unloadable due to some errors to stop the loader repeatedly trying to load an Object whose configuration is invalid, incomplete or otherwise erroneous.
            </summary>
        </member>
        <member name="T:VDS.RDF.Configuration.IPathResolver">
            <summary>
            Inteface for Objects which can resolve paths specified for Configuration properties
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.IPathResolver.ResolvePath(System.String)">
            <summary>
            Resolves a Path
            </summary>
            <param name="path">Path</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Configuration.StorageFactory">
            <summary>
            Factory class for producing <see cref="T:VDS.RDF.Storage.IStorageProvider">IStorageProvider</see> and <see cref="T:VDS.RDF.Storage.Management.IStorageServer"/> instances from Configuration Graphs
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.StorageFactory.TryLoadObject(VDS.RDF.IGraph,VDS.RDF.INode,System.Type,System.Object@)">
            <summary>
            Tries to load a Generic IO Manager based on information from the Configuration Graph
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="targetType">Target Type</param>
            <param name="obj">Output Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Configuration.StorageFactory.CanLoadObject(System.Type)">
            <summary>
            Gets whether this Factory can load objects of the given Type
            </summary>
            <param name="t">Type</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Writing.Contexts.IStoreWriterContext">
            <summary>
            Interface for Store Writer Contexts
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.IStoreWriterContext.Store">
            <summary>
            Gets the Store being written
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.Contexts.BaseStoreWriterContext">
            <summary>
            Base Class for Store Writer Context Objects
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.Contexts.BaseStoreWriterContext._prettyPrint">
            <summary>
            Pretty Print Mode setting
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.Contexts.BaseStoreWriterContext._hiSpeedAllowed">
            <summary>
            High Speed Mode setting
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.BaseStoreWriterContext.#ctor(VDS.RDF.ITripleStore,System.IO.TextWriter)">
            <summary>
            Creates a new Base Store Writer Context with default settings
            </summary>
            <param name="store">Store to write</param>
            <param name="output">TextWriter being written to</param>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.BaseStoreWriterContext.#ctor(VDS.RDF.ITripleStore,System.IO.TextWriter,System.Boolean,System.Boolean)">
            <summary>
            Creates a new Base Store Writer Context with custom settings
            </summary>
            <param name="store">Store to write</param>
            <param name="output">TextWriter being written to</param>
            <param name="prettyPrint">Pretty Print Mode</param>
            <param name="hiSpeedAllowed">High Speed Mode</param>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.BaseStoreWriterContext.FormatUri(System.String)">
            <summary>
            Formats a URI as a String for full Output
            </summary>
            <param name="u">URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.BaseStoreWriterContext.FormatUri(System.Uri)">
            <summary>
            Formats a URI as a String for full Output
            </summary>
            <param name="u">URI</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.BaseStoreWriterContext.PrettyPrint">
            <summary>
            Gets/Sets the Pretty Printing Mode used
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.BaseStoreWriterContext.HighSpeedModePermitted">
            <summary>
            Gets/Sets the High Speed Mode used
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.BaseStoreWriterContext.Store">
            <summary>
            Gets the Store being written
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.BaseStoreWriterContext.Output">
            <summary>
            Gets the TextWriter being written to
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.Contexts.IWriterContext">
            <summary>
            Interface for Writer Contexts
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.IWriterContext.Graph">
            <summary>
            Gets the Graph being written
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.IWriterContext.Output">
            <summary>
            Gets the TextWriter being written to
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.IWriterContext.PrettyPrint">
            <summary>
            Gets/Sets the Pretty Printing Mode used
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.IWriterContext.HighSpeedModePermitted">
            <summary>
            Gets/Sets the High Speed Mode used
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.IWriterContext.CompressionLevel">
            <summary>
            Gets/Sets the Compression Level used
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.IWriterContext.NodeFormatter">
            <summary>
            Gets/Sets the Node Formatter used
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.IWriterContext.UriFormatter">
            <summary>
            Gets/Sets the URI Formatter used
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.Contexts.ICollectionCompressingWriterContext">
            <summary>
            Interface for Writer Contexts which store collection compression data
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.ICollectionCompressingWriterContext.Collections">
            <summary>
            Gets the mapping from Blank Nodes to Collections
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.ICollectionCompressingWriterContext.TriplesDone">
            <summary>
            Gets the Triples that should be excluded from standard output as they are part of collections
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.Contexts.BaseWriterContext">
            <summary>
            Base Class for Writer Context Objects
            </summary>
            <remarks>
            This is not an abstract class since some writers will require only this information or possibly less
            </remarks>
        </member>
        <member name="F:VDS.RDF.Writing.Contexts.BaseWriterContext._compressionLevel">
            <summary>
            Compression Level to be used
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.Contexts.BaseWriterContext._prettyPrint">
            <summary>
            Pretty Printing Mode setting
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.Contexts.BaseWriterContext._hiSpeedAllowed">
            <summary>
            High Speed Mode setting
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.Contexts.BaseWriterContext._g">
            <summary>
            Graph being written
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.Contexts.BaseWriterContext._output">
            <summary>
            TextWriter being written to
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.Contexts.BaseWriterContext._qnameMapper">
            <summary>
            QName Output Mapper
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.Contexts.BaseWriterContext._formatter">
            <summary>
            Node Formatter
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.Contexts.BaseWriterContext._uriFormatter">
            <summary>
            URI Formatter
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.BaseWriterContext.#ctor(VDS.RDF.IGraph,System.IO.TextWriter)">
            <summary>
            Creates a new Base Writer Context with default settings
            </summary>
            <param name="g">Graph being written</param>
            <param name="output">TextWriter being written to</param>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.BaseWriterContext.#ctor(VDS.RDF.IGraph,System.IO.TextWriter,System.Int32)">
            <summary>
            Creates a new Base Writer Context with custom settings
            </summary>
            <param name="g">Graph being written</param>
            <param name="output">TextWriter being written to</param>
            <param name="compressionLevel">Compression Level</param>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.BaseWriterContext.#ctor(VDS.RDF.IGraph,System.IO.TextWriter,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Creates a new Base Writer Context with custom settings
            </summary>
            <param name="g">Graph being written</param>
            <param name="output">TextWriter being written to</param>
            <param name="compressionLevel">Compression Level</param>
            <param name="prettyPrint">Pretty Print Mode</param>
            <param name="hiSpeedAllowed">High Speed Mode</param>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.BaseWriterContext.Graph">
            <summary>
            Gets the Graph being written
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.BaseWriterContext.Output">
            <summary>
            Gets the TextWriter being written to
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.BaseWriterContext.QNameMapper">
            <summary>
            Gets the QName Output Mapper in use
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.BaseWriterContext.CompressionLevel">
            <summary>
            Gets/Sets the Compression Level used
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.BaseWriterContext.PrettyPrint">
            <summary>
            Gets/Sets the Pretty Printing Mode used
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.BaseWriterContext.HighSpeedModePermitted">
            <summary>
            Gets/Sets the High Speed Mode used
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.BaseWriterContext.NodeFormatter">
            <summary>
            Gets/Sets the Node Formatter in use
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.BaseWriterContext.UriFormatter">
            <summary>
            Gets/Sets the URI Formatter in use
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.BindingGroup">
            <summary>
            Represents an Group of Bindings which is used when executing Queries with GROUP BY clauses
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.BindingGroup.#ctor">
            <summary>
            Creates a new Binding Group
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.BindingGroup.#ctor(VDS.RDF.Query.BindingGroup)">
            <summary>
            Creates a new Binding Group which is a sub-group of the given Parent Group
            </summary>
            <param name="parent">Parent Group</param>
        </member>
        <member name="M:VDS.RDF.Query.BindingGroup.#ctor(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Creates a new Binding Group from the specified IDs
            </summary>
            <param name="ids">IDs</param>
        </member>
        <member name="M:VDS.RDF.Query.BindingGroup.Add(System.Int32)">
            <summary>
            Adds a Binding ID to the Group
            </summary>
            <param name="id">ID</param>
        </member>
        <member name="M:VDS.RDF.Query.BindingGroup.GetEnumerator">
            <summary>
            Gets the Enumerator for the Binding IDs in the Group
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.BindingGroup.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets the Enumerator for the Binding IDs in the Group
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.BindingGroup.AddAssignment(System.String,VDS.RDF.INode)">
            <summary>
            Adds a Variable Assignment to the Group
            </summary>
            <param name="variable">Variable</param>
            <param name="value">Value</param>
        </member>
        <member name="M:VDS.RDF.Query.BindingGroup.ToString">
            <summary>
            Gets a String summarising the group
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.BindingGroup.BindingIDs">
            <summary>
            Gets the Binding IDs in the Group
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.BindingGroup.Assignments">
            <summary>
            Gets the Variable Assignments for the Group
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Inference.StaticRdfsReasoner">
            <summary>
            An Inference Engine which uses RDFS reasoning
            </summary>
            <remarks>
            <para>
            Does basic RDFS inferencing using the schema taken from the Graph(s) which are provided in calls to the reasoners <see cref="M:VDS.RDF.Query.Inference.StaticRdfsReasoner.Initialise(VDS.RDF.IGraph)">Initialise()</see> method.
            </para>
            <para>
            Types of inference performed are as follows:
            </para>
            <ul>
                <li>Class hierarchy reasoning - asserts additional types triples for anything that is typed as the subclass of a class.</li>
                <li>Property hierarchy reasoning - asserts additional property triples for anything where the predicate is a subproperty of a defined property</li>
                <li>Domain &amp; Range reasoning - asserts additional type triples based on the domains and ranges of properties</li>
            </ul>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Inference.StaticRdfsReasoner.#ctor">
            <summary>
            Creates a new instance of the Static RdfsReasoner
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Inference.StaticRdfsReasoner.Apply(VDS.RDF.IGraph)">
            <summary>
            Applies inference to the given Graph and outputs the inferred information to that Graph
            </summary>
            <param name="g">Graph</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.StaticRdfsReasoner.Apply(VDS.RDF.IGraph,VDS.RDF.IGraph)">
            <summary>
            Applies inference to the Input Graph and outputs the inferred information to the Output Graph
            </summary>
            <param name="input">Graph to apply inference to</param>
            <param name="output">Graph inferred information is output to</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.StaticRdfsReasoner.Initialise(VDS.RDF.IGraph)">
            <summary>
            Imports any Class heirarchy information from the given Graph into the Reasoners Knowledge Base in order to initialise the Reasoner
            </summary>
            <param name="g">Graph to import from</param>
            <remarks>
            Looks for Triples defining things to be classes and those defining that something is a subClass of something
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Inference.StaticRdfsReasoner.InferClasses(VDS.RDF.Triple,VDS.RDF.IGraph,VDS.RDF.IGraph,System.Collections.Generic.List{VDS.RDF.Triple})">
            <summary>
            Helper method which applies Class hierarchy inferencing
            </summary>
            <param name="t">Triple defining the type for something</param>
            <param name="input">Input Graph</param>
            <param name="output">Output Graph</param>
            <param name="inferences">List of Inferences</param>
        </member>
        <member name="T:VDS.RDF.Query.Inference.RdfsReasoner">
            <summary>
            An Inference Engine which uses RDFS reasoning
            </summary>
            <remarks>
            Does basic RDFS inferencing as detailed in the remarks for the <see cref="T:VDS.RDF.Query.Inference.StaticRdfsReasoner">StaticRdfsReasoner</see> except every Graph that inference is applied to has the potential to alter the schema which is in use.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Inference.RdfsReasoner.Apply(VDS.RDF.IGraph,VDS.RDF.IGraph)">
            <summary>
            Applies inference to the Input Graph and outputs the inferred information to the Output Graph
            </summary>
            <param name="input">Graph to apply inference to</param>
            <param name="output">Graph inferred information is output to</param>
        </member>
        <member name="T:VDS.RDF.Query.Inference.StaticSkosReasoner">
            <summary>
            An Inference Engine that uses SKOS Concept Hierarchies
            </summary>
            <remarks>
            <para>
            Infers additional values for properties based on SKOS Concept Hierarcies.  If there is a Triple whose value is a Concept from the hierarchy then new versions of that Triple will be inferred where the object becomes each concept higher in the hierarchy.
            </para>
            </remarks>
        </member>
        <member name="F:VDS.RDF.Query.Inference.StaticSkosReasoner.SKOSNamespace">
            <summary>
            Namespace for SKOS
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Inference.StaticSkosReasoner.#ctor">
            <summary>
            Creates a new instance of the SKOS Reasoner
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Inference.StaticSkosReasoner.Apply(VDS.RDF.IGraph)">
            <summary>
            Applies inference to the given Graph and outputs the inferred information to that Graph
            </summary>
            <param name="g">Graph</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.StaticSkosReasoner.Apply(VDS.RDF.IGraph,VDS.RDF.IGraph)">
            <summary>
            Applies inference to the Input Graph and outputs the inferred information to the Output Graph
            </summary>
            <param name="input">Graph to apply inference to</param>
            <param name="output">Graph inferred information is output to</param>
        </member>
        <member name="M:VDS.RDF.Query.Inference.StaticSkosReasoner.Initialise(VDS.RDF.IGraph)">
            <summary>
            Imports any Concept heirarchy information from the given Graph into the Reasoners Knowledge Base in order to initialise the Reasoner
            </summary>
            <param name="g">Graph to import from</param>
            <remarks>
            Looks for Triples defining SKOS concepts and relating them to narrower and broader concepts
            </remarks>
        </member>
        <member name="T:VDS.RDF.Query.Inference.SkosReasoner">
            <summary>
            An Inference Engine that uses SKOS Concept Hierarchies
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Inference.SkosReasoner.Apply(VDS.RDF.IGraph,VDS.RDF.IGraph)">
            <summary>
            Applies inference to the Input Graph and outputs the inferred information to the Output Graph
            </summary>
            <param name="input">Graph to apply inference to</param>
            <param name="output">Graph inferred information is output to</param>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.SparqlNumericType">
            <summary>
            Numeric Types for Sparql Numeric Expressions
            </summary>
            <remarks>All Numeric expressions in Sparql are typed as Integer/Decimal/Double</remarks>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.SparqlNumericType.NaN">
            <summary>
            Not a Number
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.SparqlNumericType.Integer">
            <summary>
            An Integer
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.SparqlNumericType.Decimal">
            <summary>
            A Decimal
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.SparqlNumericType.Float">
            <summary>
            A Single precision Floating Point
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.SparqlNumericType.Double">
            <summary>
            A Double precision Floating Point
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.SparqlExpressionType">
            <summary>
            SPARQL Expression Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.SparqlExpressionType.Primary">
            <summary>
            The Expression is a Primary Expression which is a leaf in the expression tree
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.SparqlExpressionType.UnaryOperator">
            <summary>
            The Expression is a Unary Operator which has a single argument
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.SparqlExpressionType.BinaryOperator">
            <summary>
            The Expression is a Binary Operator which has two arguments
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.SparqlExpressionType.Function">
            <summary>
            The Expression is a Function which has zero/more arguments
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.SparqlExpressionType.Aggregate">
            <summary>
            The Expression is an Aggregate Function which has one/more arguments
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.SparqlExpressionType.SetOperator">
            <summary>
            The Expression is a Set Operator where the first argument forms the LHS and all remaining arguments form a set on the RHS
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Expressions.SparqlExpressionType.GraphOperator">
            <summary>
            The Expression is a Unary Operator that applies to a Graph Pattern
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Grouping.ISparqlGroupBy">
            <summary>
            Interface for Classes that represent SPARQL GROUP BY clauses
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Grouping.ISparqlGroupBy.Apply(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Applies the Grouping to a Result Binder
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Grouping.ISparqlGroupBy.Apply(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.List{VDS.RDF.Query.BindingGroup})">
            <summary>
            Applies the Grouping to a Result Binder subdividing the Groups from the previous Group By clause into further Groups
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="groups">Groups</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Grouping.ISparqlGroupBy.Child">
            <summary>
            Gets/Sets the child GROUP BY Clause
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Grouping.ISparqlGroupBy.Variables">
            <summary>
            Gets the Variables used in the GROUP BY
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Grouping.ISparqlGroupBy.ProjectableVariables">
            <summary>
            Gets the Projectable Variables used in the GROUP BY i.e. Variables that are grouped upon and Assigned Variables
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Grouping.ISparqlGroupBy.Expression">
            <summary>
            Gets the Expression used to GROUP BY
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Grouping.ISparqlGroupBy.AssignVariable">
            <summary>
            Gets/Sets the Variable the value of the GROUP BY expression should be bound to (may be null if not bound to anything)
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Grouping.BaseGroupBy">
            <summary>
            Abstract Base Class for classes representing Sparql GROUP BY clauses
            </summary>
        </member>
        <member name="F:VDS.RDF.Query.Grouping.BaseGroupBy._child">
            <summary>
            Child Grouping
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Grouping.BaseGroupBy.Apply(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Applies the Grouping to the Binder
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Grouping.BaseGroupBy.Apply(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.List{VDS.RDF.Query.BindingGroup})">
            <summary>
            Applies the Grouping to the Binder subdividing Groups from a previous Grouping
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="groups">Groups to subdivide</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Grouping.BaseGroupBy.Child">
            <summary>
            Gets/Sets the Child GROUP BY Clause
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Grouping.BaseGroupBy.Variables">
            <summary>
            Gets the Variables involved in this Group By
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Grouping.BaseGroupBy.ProjectableVariables">
            <summary>
            Gets the Projectable Variables used in the GROUP BY i.e. Variables that are grouped upon and Assigned Variables
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Grouping.BaseGroupBy.Expression">
            <summary>
            Gets the Expression used to GROUP BY
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Grouping.BaseGroupBy.AssignVariable">
            <summary>
            Gets/Sets the Variable that the grouped upon value should be assigned to
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Grouping.GroupByVariable">
            <summary>
            Represents a Grouping on a given Variable
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Grouping.GroupByVariable.#ctor(System.String)">
            <summary>
            Creates a new Group By which groups by a given Variable
            </summary>
            <param name="name">Variable Name</param>
        </member>
        <member name="M:VDS.RDF.Query.Grouping.GroupByVariable.#ctor(System.String,System.String)">
            <summary>
            Creates a new Group By which groups by a given Variable and assigns to another variable
            </summary>
            <param name="name">Variable Name</param>
            <param name="assignVariable">Assign Variable</param>
        </member>
        <member name="M:VDS.RDF.Query.Grouping.GroupByVariable.Apply(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Applies a Grouping on a given Variable to the Binder
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Grouping.GroupByVariable.Apply(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.List{VDS.RDF.Query.BindingGroup})">
            <summary>
            Applies a Grouping on a given Variable to the Binder Groups from a previous Grouping
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="groups">Binder Group to subgroup</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Grouping.GroupByVariable.ToString">
            <summary>
            Gets the String representation of the GROUP BY
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Grouping.GroupByVariable.Variables">
            <summary>
            Gets the Variables used in the GROUP BY
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Grouping.GroupByVariable.ProjectableVariables">
            <summary>
            Gets the Projectable Variables used in the GROUP BY i.e. Variables that are grouped upon and Assigned Variables
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Grouping.GroupByVariable.Expression">
            <summary>
            Gets the Variable Expression Term used by this GROUP BY
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Grouping.GroupByExpression">
            <summary>
            Represents a Grouping on a given Expression
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Grouping.GroupByExpression.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a new Group By which groups by a given Expression
            </summary>
            <param name="expr">Expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Grouping.GroupByExpression.Apply(VDS.RDF.Query.SparqlEvaluationContext)">
            <summary>
            Applies a Grouping on a given Expression to the Binder
            </summary>
            <param name="context">Evaluation Context</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Grouping.GroupByExpression.Apply(VDS.RDF.Query.SparqlEvaluationContext,System.Collections.Generic.List{VDS.RDF.Query.BindingGroup})">
            <summary>
            Applies a Grouping on a given Variable to the Binder Groups from a previous Grouping
            </summary>
            <param name="context">Evaluation Context</param>
            <param name="groups">Binder Group to subgroup</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Grouping.GroupByExpression.ToString">
            <summary>
            Gets the String representation of the GROUP BY
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Query.Grouping.GroupByExpression.Variables">
            <summary>
            Gets the Fixed Variables used in the Grouping
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Grouping.GroupByExpression.ProjectableVariables">
            <summary>
            Gets the Projectable Variables used in the GROUP BY i.e. Variables that are grouped upon and Assigned Variables
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Grouping.GroupByExpression.Expression">
            <summary>
            Gets the Expression used to GROUP BY
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.AllegroGraphConnector">
            <summary>
            Class for connecting to an AllegroGraph Store
            </summary>
            <remarks>
            <para>
            Connection to AllegroGraph is based on their new HTTP Protocol which is an extension of the <a href="http://www.openrdf.org/doc/sesame2/system/ch08.html">Sesame 2.0 HTTP Protocol</a>.  The specification for the AllegroGraph protocol can be found <a href="http://www.franz.com/agraph/support/documentation/current/new-http-server.html">here</a>
            </para>
            <para>
            If you wish to use a Store which is part of the Root Catalog on an AllegroGraph 4.x and higher server you can either use the constructor overloads that omit the <strong>catalogID</strong> parameter or pass in null as the value for that parameter
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Storage.BaseSesameHttpProtocolConnector">
            <summary>
            Abstract Base Class for connecting to any Store that supports the Sesame 2.0 HTTP Communication protocol
            </summary>
            <remarks>
            <para>
            See <a href="http://www.openrdf.org/doc/sesame2/system/ch08.html">here</a> for the protocol specification, this base class supports Version 5 of the protocol which does not include SPARQL Update support
            </para>
            </remarks>
        </member>
        <member name="F:VDS.RDF.Storage.BaseSesameHttpProtocolConnector._baseUri">
            <summary>
            Base Uri for the Store
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.BaseSesameHttpProtocolConnector._store">
            <summary>
            Store ID
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.BaseSesameHttpProtocolConnector._username">
            <summary>
            Username for accessing the Store
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.BaseSesameHttpProtocolConnector._pwd">
            <summary>
            Password for accessing the Store
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.BaseSesameHttpProtocolConnector._hasCredentials">
            <summary>
            Whether the User has provided credentials for accessing the Store using authentication
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.BaseSesameHttpProtocolConnector._repositoriesPrefix">
            <summary>
            Repositories Prefix
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.BaseSesameHttpProtocolConnector._queryPath">
            <summary>
            Query Path Prefix
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.BaseSesameHttpProtocolConnector._updatePath">
            <summary>
            Update Path Prefix
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.BaseSesameHttpProtocolConnector._fullContextEncoding">
            <summary>
            Whether to do full encoding of contexts
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.BaseSesameHttpProtocolConnector._postAllQueries">
            <summary>
            Whether queries should always be posted
            </summary>
        </member>
        <member name="F:VDS.RDF.Storage.BaseSesameHttpProtocolConnector._server">
            <summary>
            Server the store is hosted on
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.BaseSesameHttpProtocolConnector.#ctor(System.String,System.String)">
            <summary>
            Creates a new connection to a Sesame HTTP Protocol supporting Store
            </summary>
            <param name="baseUri">Base Uri of the Store</param>
            <param name="storeID">Store ID</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseSesameHttpProtocolConnector.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Creates a new connection to a Sesame HTTP Protocol supporting Store
            </summary>
            <param name="baseUri">Base Uri of the Store</param>
            <param name="storeID">Store ID</param>
            <param name="username">Username to use for requests that require authentication</param>
            <param name="password">Password to use for requests that require authentication</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseSesameHttpProtocolConnector.EscapeQuery(System.String)">
            <summary>
            Escapes a Query to avoid a character encoding issue when communicating a query to Sesame
            </summary>
            <param name="query">Query</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.BaseSesameHttpProtocolConnector.SaveGraph(VDS.RDF.IGraph,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Saves a Graph to the Store asynchronously
            </summary>
            <param name="g">Graph to save</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseSesameHttpProtocolConnector.LoadGraph(VDS.RDF.IRdfHandler,System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Loads a Graph from the Store asynchronously
            </summary>
            <param name="handler">Handler to load with</param>
            <param name="graphUri">URI of the Graph to load</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseSesameHttpProtocolConnector.UpdateGraph(System.String,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple},VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Updates a Graph in the Store asychronously
            </summary>
            <param name="graphUri">URI of the Graph to update</param>
            <param name="additions">Triples to be added</param>
            <param name="removals">Triples to be removed</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseSesameHttpProtocolConnector.DeleteGraph(System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Deletes a Graph from the Store
            </summary>
            <param name="graphUri">URI of the Graph to delete</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseSesameHttpProtocolConnector.Query(System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Makes a SPARQL Query against the underlying store
            </summary>
            <param name="sparqlQuery">SPARQL Query</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
            <returns><see cref="T:VDS.RDF.Query.SparqlResultSet">SparqlResultSet</see> or a <see cref="T:VDS.RDF.Graph">Graph</see> depending on the Sparql Query</returns>
        </member>
        <member name="M:VDS.RDF.Storage.BaseSesameHttpProtocolConnector.Query(VDS.RDF.IRdfHandler,VDS.RDF.ISparqlResultsHandler,System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Makes a SPARQL Query against the underlying store processing the resulting Graph/Result Set with a handler of your choice
            </summary>
            <param name="rdfHandler">RDF Handler</param>
            <param name="resultsHandler">SPARQL Results Handler</param>
            <param name="sparqlQuery">SPARQL Query</param>
            <param name="callback">Callbakc</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.BaseSesameHttpProtocolConnector.CreateRequest(System.String,System.String,System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Helper method for creating HTTP Requests to the Store
            </summary>
            <param name="servicePath">Path to the Service requested</param>
            <param name="accept">Acceptable Content Types</param>
            <param name="method">HTTP Method</param>
            <param name="queryParams">Querystring Parameters</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.BaseSesameHttpProtocolConnector.Dispose">
            <summary>
            Disposes of the Connector
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.BaseSesameHttpProtocolConnector.ToString">
            <summary>
            Gets a String which gives details of the Connection
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.BaseSesameHttpProtocolConnector.SerializeConfiguration(VDS.RDF.Configuration.ConfigurationSerializationContext)">
            <summary>
            Serializes the connection's configuration
            </summary>
            <param name="context">Configuration Serialization Context</param>
        </member>
        <member name="P:VDS.RDF.Storage.BaseSesameHttpProtocolConnector.BaseUri">
            <summary>
            Gets the Base URI to the repository
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.BaseSesameHttpProtocolConnector.RepositoryName">
            <summary>
            Gets the Repository Name that is in use
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.BaseSesameHttpProtocolConnector.IOBehaviour">
            <summary>
            Gets the Save Behaviour of Stores that use the Sesame HTTP Protocol
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.BaseSesameHttpProtocolConnector.UpdateSupported">
            <summary>
            Returns that Updates are supported on Sesame HTTP Protocol supporting Stores
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.BaseSesameHttpProtocolConnector.DeleteSupported">
            <summary>
            Returns that deleting graphs from the Sesame store is supported
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.BaseSesameHttpProtocolConnector.ListGraphsSupported">
            <summary>
            Returns that listing Graphs is supported
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.BaseSesameHttpProtocolConnector.IsReady">
            <summary>
            Returns that the Connection is ready
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.BaseSesameHttpProtocolConnector.IsReadOnly">
            <summary>
            Returns that the Connection is not read-only
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.BaseSesameHttpProtocolConnector.AsyncParentServer">
            <summary>
            Gets the parent server
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.AllegroGraphConnector.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new Connection to an AllegroGraph store
            </summary>
            <param name="baseUri">Base URI for the Store</param>
            <param name="catalogID">Catalog ID</param>
            <param name="storeID">Store ID</param>
        </member>
        <member name="M:VDS.RDF.Storage.AllegroGraphConnector.#ctor(System.String,System.String)">
            <summary>
            Creates a new Connection to an AllegroGraph store in the Root Catalog (AllegroGraph 4.x and higher)
            </summary>
            <param name="baseUri">Base Uri for the Store</param>
            <param name="storeID">Store ID</param>
        </member>
        <member name="M:VDS.RDF.Storage.AllegroGraphConnector.#ctor(System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Creates a new Connection to an AllegroGraph store
            </summary>
            <param name="baseUri">Base Uri for the Store</param>
            <param name="catalogID">Catalog ID</param>
            <param name="storeID">Store ID</param>
            <param name="username">Username for connecting to the Store</param>
            <param name="password">Password for connecting to the Store</param>
        </member>
        <member name="M:VDS.RDF.Storage.AllegroGraphConnector.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Creates a new Connection to an AllegroGraph store in the Root Catalog (AllegroGraph 4.x and higher)
            </summary>
            <param name="baseUri">Base Uri for the Store</param>
            <param name="storeID">Store ID</param>
            <param name="username">Username for connecting to the Store</param>
            <param name="password">Password for connecting to the Store</param>
        </member>
        <member name="M:VDS.RDF.Storage.AllegroGraphConnector.Update(System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Makes a SPARQL Update request to the Allegro Graph server
            </summary>
            <param name="sparqlUpdate">SPARQL Update</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.AllegroGraphConnector.EscapeQuery(System.String)">
            <summary>
            Does nothing as AllegroGraph does not require the same query escaping that Sesame does
            </summary>
            <param name="query">Query to escape</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.AllegroGraphConnector.CreateRequest(System.String,System.String,System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Helper method for creating HTTP Requests to the Store
            </summary>
            <param name="servicePath">Path to the Service requested</param>
            <param name="accept">Acceptable Content Types</param>
            <param name="method">HTTP Method</param>
            <param name="queryParams">Querystring Parameters</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.AllegroGraphConnector.ToString">
            <summary>
            Gets a String which gives details of the Connection
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.AllegroGraphConnector.SerializeConfiguration(VDS.RDF.Configuration.ConfigurationSerializationContext)">
            <summary>
            Serializes the connection's configuration
            </summary>
            <param name="context">Configuration Serialization Context</param>
        </member>
        <member name="P:VDS.RDF.Storage.AllegroGraphConnector.Catalog">
            <summary>
            Gets the Catalog under which the repository you are connected to is located
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.FourStoreConnector">
            <summary>
            Class for connecting to 4store
            </summary>
            <remarks>
            <para>
            Depending on the version of <a href="http://librdf.org/rasqal/">RASQAL</a> used for your 4store instance and the options it was built with some kinds of queries may not suceed or return unexpected results.
            </para>
            <para>
            Prior to the 1.x releases 4store did not permit the saving of unamed Graphs to the Store or Triple level updates.  There was a branch of 4store that supports Triple level updates and you could tell the connector if your 4store instance supports this when you instantiate it.  From the 0.4.0 release of the library onwards this support was enabled by default since the 1.x builds of 4store have this feature integrated into them by default.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.FourStoreConnector.#ctor(System.String)">
            <summary>
            Creates a new 4store connector which manages access to the services provided by a 4store server
            </summary>
            <param name="baseUri">Base Uri of the 4store</param>
            <remarks>
            <strong>Note:</strong> As of the 0.4.0 release 4store support defaults to Triple Level updates enabled as all recent 4store releases have supported this.  You can still optionally disable this with the two argument version of the constructor
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.FourStoreConnector.#ctor(System.String,System.Boolean)">
            <summary>
            Creates a new 4store connector which manages access to the services provided by a 4store server
            </summary>
            <param name="baseUri">Base Uri of the 4store</param>
            <param name="enableUpdateSupport">Indicates to the connector that you are using a 4store instance that supports Triple level updates</param>
            <remarks>
            If you enable Update support but are using a 4store instance that does not support Triple level updates then you will almost certainly experience errors while using the connector.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Storage.FourStoreConnector.SaveGraph(VDS.RDF.IGraph,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Saves a Graph to the Store asynchronously
            </summary>
            <param name="g">Graph to save</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.FourStoreConnector.LoadGraph(VDS.RDF.IRdfHandler,System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Loads a Graph from the Store asynchronously
            </summary>
            <param name="handler">Handler to load with</param>
            <param name="graphUri">URI of the Graph to load</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.FourStoreConnector.UpdateGraph(System.String,System.Collections.Generic.IEnumerable{VDS.RDF.Triple},System.Collections.Generic.IEnumerable{VDS.RDF.Triple},VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Updates a Graph in the Store asychronously
            </summary>
            <param name="graphUri">URI of the Graph to update</param>
            <param name="additions">Triples to be added</param>
            <param name="removals">Triples to be removed</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.FourStoreConnector.DeleteGraph(System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Deletes a Graph from the Store
            </summary>
            <param name="graphUri">URI of the Graph to delete</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.FourStoreConnector.Update(System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Updates the store asynchronously
            </summary>
            <param name="sparqlUpdates">SPARQL Update</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.FourStoreConnector.Query(System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Queries the store asynchronously
            </summary>
            <param name="sparqlQuery">SPARQL Query</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.FourStoreConnector.Query(VDS.RDF.IRdfHandler,VDS.RDF.ISparqlResultsHandler,System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Queries the store asynchronously
            </summary>
            <param name="sparqlQuery">SPARQL Query</param>
            <param name="rdfHandler">RDF Handler</param>
            <param name="resultsHandler">Results Handler</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.FourStoreConnector.Dispose">
            <summary>
            Disposes of a 4store connection
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.FourStoreConnector.ToString">
            <summary>
            Gets a String which gives details of the Connection
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.FourStoreConnector.SerializeConfiguration(VDS.RDF.Configuration.ConfigurationSerializationContext)">
            <summary>
            Serializes the connection's configuration
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:VDS.RDF.Storage.FourStoreConnector.UpdateSupported">
            <summary>
            Returns whether this connector has been instantiated with update support or not
            </summary>
            <remarks>
            If this property returns true it does not guarantee that the 4store instance actually supports updates it simply indicates that the user has enabled updates on the connector.  If Updates are enabled and the 4store server being connected to does not support updates then errors will occur.
            </remarks>
        </member>
        <member name="P:VDS.RDF.Storage.FourStoreConnector.IsReady">
            <summary>
            Returns that the Connection is ready
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.FourStoreConnector.IsReadOnly">
            <summary>
            Returns that the Connection is not read-only
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.FourStoreConnector.IOBehaviour">
            <summary>
            Gets the IO Behaviour of 4store
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.FourStoreConnector.DeleteSupported">
            <summary>
            Returns that deleting Graph is supported
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.FourStoreConnector.ListGraphsSupported">
            <summary>
            Returns that Listing Graphs is supported
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.BatchTriple">
            <summary>
            Structure for representing Triples that are waiting to be Batch written to the Database
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.BatchTriple.#ctor(VDS.RDF.Triple,System.String)">
            <summary>
            Creates a new Batch Triple
            </summary>
            <param name="t">Triple</param>
            <param name="graphID">Graph ID to store Triple for</param>
        </member>
        <member name="M:VDS.RDF.Storage.BatchTriple.Equals(System.Object)">
            <summary>
            Equality for Batch Triples
            </summary>
            <param name="obj">Object to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Storage.BatchTriple.GetHashCode">
            <summary>
            Hash Code for Batch Triples
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Storage.BatchTriple.Triple">
            <summary>
            Triple
            </summary>
        </member>
        <member name="P:VDS.RDF.Storage.BatchTriple.GraphID">
            <summary>
            Graph ID
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.SesameHttpProtocolConnector">
            <summary>
            Connector for connecting to a Store that supports the Sesame 2.0 HTTP Communication protocol
            </summary>
            <remarks>
            Acts as a synonym for whatever the latest version of the Sesame HTTP Protocol that is supported by dotNetRDF might be.  Currently this is Version 6 which includes SPARQL Update support (Sesame 2.4+ required)
            </remarks>
        </member>
        <member name="T:VDS.RDF.Storage.SesameHttpProtocolVersion6Connector">
            <summary>
            Connector for connecting to a Store that supports the Sesame 2.0 HTTP Communication Protocol version 6 (i.e. includes SPARQL Update support)
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.SesameHttpProtocolVersion5Connector">
            <summary>
            Connector for connecting to a Store that supports the Sesame 2.0 HTTP Communication Protocol version 5 (i.e. no SPARQL Update support)
            </summary>
        </member>
        <member name="M:VDS.RDF.Storage.SesameHttpProtocolVersion5Connector.#ctor(System.String,System.String)">
            <summary>
            Creates a new connection to a Sesame HTTP Protocol supporting Store
            </summary>
            <param name="baseUri">Base Uri of the Store</param>
            <param name="storeID">Store ID</param>
        </member>
        <member name="M:VDS.RDF.Storage.SesameHttpProtocolVersion5Connector.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Creates a new connection to a Sesame HTTP Protocol supporting Store
            </summary>
            <param name="baseUri">Base Uri of the Store</param>
            <param name="storeID">Store ID</param>
            <param name="username">Username to use for requests that require authentication</param>
            <param name="password">Password to use for requests that require authentication</param>
        </member>
        <member name="M:VDS.RDF.Storage.SesameHttpProtocolVersion6Connector.#ctor(System.String,System.String)">
            <summary>
            Creates a new connection to a Sesame HTTP Protocol supporting Store
            </summary>
            <param name="baseUri">Base Uri of the Store</param>
            <param name="storeID">Store ID</param>
        </member>
        <member name="M:VDS.RDF.Storage.SesameHttpProtocolVersion6Connector.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Creates a new connection to a Sesame HTTP Protocol supporting Store
            </summary>
            <param name="baseUri">Base Uri of the Store</param>
            <param name="storeID">Store ID</param>
            <param name="username">Username to use for requests that require authentication</param>
            <param name="password">Password to use for requests that require authentication</param>
        </member>
        <member name="M:VDS.RDF.Storage.SesameHttpProtocolVersion6Connector.Update(System.String,VDS.RDF.Storage.AsyncStorageCallback,System.Object)">
            <summary>
            Makes a SPARQL Update request to the Sesame server
            </summary>
            <param name="sparqlUpdate">SPARQL Update</param>
            <param name="callback">Callback</param>
            <param name="state">State to pass to the callback</param>
        </member>
        <member name="M:VDS.RDF.Storage.SesameHttpProtocolConnector.#ctor(System.String,System.String)">
            <summary>
            Creates a new connection to a Sesame HTTP Protocol supporting Store
            </summary>
            <param name="baseUri">Base Uri of the Store</param>
            <param name="storeID">Store ID</param>
        </member>
        <member name="M:VDS.RDF.Storage.SesameHttpProtocolConnector.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Creates a new connection to a Sesame HTTP Protocol supporting Store
            </summary>
            <param name="baseUri">Base Uri of the Store</param>
            <param name="storeID">Store ID</param>
            <param name="username">Username to use for requests that require authentication</param>
            <param name="password">Password to use for requests that require authentication</param>
        </member>
        <member name="T:VDS.RDF.Writing.Contexts.HtmlWriterContext">
            <summary>
            Writer Context for XHTML+RDFa Writers
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.HtmlWriterContext.#ctor(VDS.RDF.IGraph,System.IO.TextWriter)">
            <summary>
            Creates a new HTML Writer Context
            </summary>
            <param name="g">Graph</param>
            <param name="writer">Text Writer</param>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.HtmlWriterContext.HtmlWriter">
            <summary>
            HTML Writer to use
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.Contexts.NTriplesWriterContext">
            <summary>
            Writer Context for NTriples Writers
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.NTriplesWriterContext.#ctor(VDS.RDF.IGraph,System.IO.TextWriter,VDS.RDF.Parsing.NTriplesSyntax)">
            <summary>
            Creates a new NTriples Writer Context with default settings
            </summary>
            <param name="g">Graph to write</param>
            <param name="output">TextWriter to write to</param>
            <param name="syntax">NTriples Syntax mode</param>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.NTriplesWriterContext.#ctor(VDS.RDF.IGraph,System.IO.TextWriter,VDS.RDF.Parsing.NTriplesSyntax,System.Boolean,System.Boolean)">
            <summary>
            Creates a new NTriples Writer Context with custom settings
            </summary>
            <param name="g">Graph to write</param>
            <param name="output">TextWriter to write to</param>
            <param name="syntax">NTriples Syntax mode</param>
            <param name="prettyPrint">Pretty Print Mode</param>
            <param name="hiSpeed">High Speed Mode</param>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.NTriplesWriterContext.Syntax">
            <summary>
            Gets the NTriples syntax mode
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.Contexts.RdfXmlWriterContext">
            <summary>
            Writer Context for RDF/XML Writers
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.Contexts.RdfXmlWriterContext._prettyPrint">
            <summary>
            Pretty Printing Mode setting
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.Contexts.RdfXmlWriterContext._g">
            <summary>
            Graph being written
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.Contexts.RdfXmlWriterContext._output">
            <summary>
            TextWriter being written to
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.Contexts.RdfXmlWriterContext._writer">
            <summary>
            XmlWriter being written to
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.Contexts.RdfXmlWriterContext._nsmapper">
            <summary>
            Nested Namespace Mapper
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.RdfXmlWriterContext.#ctor(VDS.RDF.IGraph,System.IO.TextWriter)">
            <summary>
            Creates a new RDF/XML Writer Context
            </summary>
            <param name="g">Graph</param>
            <param name="output">Output destination</param>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.RdfXmlWriterContext.GetSettings">
            <summary>
            Generates the required settings for the <see cref="T:System.Xml.XmlWriter">XmlWriter</see>
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.RdfXmlWriterContext.Graph">
            <summary>
            Gets the Graph being written
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.RdfXmlWriterContext.Output">
            <summary>
            Gets the TextWriter being written to
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.RdfXmlWriterContext.Writer">
            <summary>
            Gets the XML Writer in use
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.RdfXmlWriterContext.PrettyPrint">
            <summary>
            Gets/Sets the Pretty Printing Mode used
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.RdfXmlWriterContext.NodeFormatter">
            <summary>
            Gets/Sets the Node Formatter
            </summary>
            <remarks>
            Node Formatters are not used for RDF/XML output
            </remarks>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.RdfXmlWriterContext.UriFormatter">
            <summary>
            Gets/Sets the URI Formatter
            </summary>
            <remarks>
            URI Formatters are not used for RDF/XML output
            </remarks>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.RdfXmlWriterContext.NamespaceMap">
            <summary>
            Gets the Namespace Map in use
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.RdfXmlWriterContext.BlankNodeMapper">
            <summary>
            Gets the Blank Node map in use
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.RdfXmlWriterContext.HighSpeedModePermitted">
            <summary>
            Gets/Sets whether High Speed Mode is permitted
            </summary>
            <remarks>
            Not currently supported
            </remarks>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.RdfXmlWriterContext.CompressionLevel">
            <summary>
            Gets/Sets the Compression Level used
            </summary>
            <remarks>
            Not currently supported
            </remarks>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.RdfXmlWriterContext.NextNamespaceID">
            <summary>
            Gets/Sets the next ID to use for issuing Temporary Namespaces
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.RdfXmlWriterContext.UseDtd">
            <summary>
            Gets/Sets whether a DTD is used
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.RdfXmlWriterContext.UseAttributes">
            <summary>
            Gets/Sets whether attributes are used to encode the predicates and objects of triples with simple literal properties
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.RdfXmlWriterContext.Collections">
            <summary>
            Represents the mapping from Blank Nodes to Collections
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.RdfXmlWriterContext.TriplesDone">
            <summary>
            Stores the Triples that should be excluded from standard output as they are part of collections
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.Contexts.ThreadedStoreWriterContext">
            <summary>
            Writer Context for Store Writers which do multi-threaded writing
            </summary>
            <remarks>
            Provides a queue for queuing the URIs of Graphs from the Store that need writing and a thread safe way of retrieving the next Uri to be written from the Queue
            </remarks>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.ThreadedStoreWriterContext.#ctor(VDS.RDF.ITripleStore,System.IO.TextWriter)">
            <summary>
            Creates a new Threaded Store Writer Context with default settings
            </summary>
            <param name="store">Store to be written</param>
            <param name="output">TextWriter to write to</param>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.ThreadedStoreWriterContext.#ctor(VDS.RDF.ITripleStore,System.IO.TextWriter,System.Boolean,System.Boolean)">
            <summary>
            Creates a new Threaded Store Writer Context with custom settings
            </summary>
            <param name="store">Store to be written</param>
            <param name="output">TextWriter to write to</param>
            <param name="prettyPrint">Pretty Print Mode</param>
            <param name="hiSpeedAllowed">High Speed Mode</param>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.ThreadedStoreWriterContext.Add(System.Uri)">
            <summary>
            Adds a Uri to the list of URIs for Graphs that are waiting to be written
            </summary>
            <param name="u"></param>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.ThreadedStoreWriterContext.TryGetNextUri(System.Uri@)">
            <summary>
            Gets the next Uri for a Graph that is waiting to be written
            </summary>
            <returns>Uri of next Graph to be written</returns>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.ThreadedStoreWriterContext.NamespaceMap">
            <summary>
            Gets the NamespaceMap used for reducing URIs to QNames since there may only be one shared map written to the output
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.ThreadedStoreWriterContext.QNameMapper">
            <summary>
            Gets the QName Mapper
            </summary>
            <remarks>
            Must be manually initialised by the user
            </remarks>
        </member>
        <member name="T:VDS.RDF.Writing.Contexts.TriGWriterContext">
            <summary>
            Writer Context for TriG
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.TriGWriterContext.#ctor(VDS.RDF.ITripleStore,System.IO.TextWriter,System.Boolean,System.Boolean,System.Int32,System.Boolean)">
            <summary>
            Creates a new TriG Writer context
            </summary>
            <param name="store">Triple Store to save</param>
            <param name="output">TextWriter to output to</param>
            <param name="prettyPrint">Whether to use pretty printing</param>
            <param name="hiSpeedAllowed">Whether high speed mode is permitted</param>
            <param name="compressionLevel">Compression Level to use</param>
            <param name="n3compatability">Whether to enable N3 compatability mode</param>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.TriGWriterContext.CompressionLevel">
            <summary>
            Gets/Sets the Compression Level
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.TriGWriterContext.N3CompatabilityMode">
            <summary>
            Gets/Sets N3 Compatability Mode
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.Contexts.TurtleWriterContext">
            <summary>
            Writer Context for Turtle Writers
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.TurtleWriterContext.#ctor(VDS.RDF.IGraph,System.IO.TextWriter,VDS.RDF.Parsing.TurtleSyntax)">
            <summary>
            Creates a new Turtle Writer Context with default settings
            </summary>
            <param name="g">Graph to write</param>
            <param name="output">TextWriter to write to</param>
            <param name="syntax">Turtle Syntax</param>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.TurtleWriterContext.#ctor(VDS.RDF.IGraph,System.IO.TextWriter)">
            <summary>
            Creates a new Turtle Writer Context with default settings
            </summary>
            <param name="g">Graph to write</param>
            <param name="output">TextWriter to write to</param>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.TurtleWriterContext.#ctor(VDS.RDF.IGraph,System.IO.TextWriter,System.Boolean,System.Boolean,VDS.RDF.Parsing.TurtleSyntax)">
            <summary>
            Creates a new Turtle Writer Context with custom settings
            </summary>
            <param name="g">Graph to write</param>
            <param name="output">TextWriter to write to</param>
            <param name="prettyPrint">Pretty Print Mode</param>
            <param name="hiSpeed">High Speed Mode</param>
            <param name="syntax">Turtle Syntax</param>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.TurtleWriterContext.#ctor(VDS.RDF.IGraph,System.IO.TextWriter,System.Boolean,System.Boolean)">
            <summary>
            Creates a new Turtle Writer Context with custom settings
            </summary>
            <param name="g">Graph to write</param>
            <param name="output">TextWriter to write to</param>
            <param name="prettyPrint">Pretty Print Mode</param>
            <param name="hiSpeed">High Speed Mode</param>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.TurtleWriterContext.#ctor(VDS.RDF.IGraph,System.IO.TextWriter,System.Int32,System.Boolean,System.Boolean,VDS.RDF.Parsing.TurtleSyntax)">
            <summary>
            Creates a new Turtle Writer Context with custom settings
            </summary>
            <param name="g">Graph to write</param>
            <param name="output">TextWriter to write to</param>
            <param name="compressionLevel">Compression Level to use</param>
            <param name="prettyPrint">Pretty Print Mode</param>
            <param name="hiSpeed">High Speed Mode</param>
            <param name="syntax">Turtle Syntax</param>
        </member>
        <member name="T:VDS.RDF.Writing.Contexts.CompressingTurtleWriterContext">
            <summary>
            Writer Context for Compressing Turtle Writers
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.CompressingTurtleWriterContext.#ctor(VDS.RDF.IGraph,System.IO.TextWriter)">
            <summary>
            Creates a new Turtle Writer Context with default settings
            </summary>
            <param name="g">Graph to write</param>
            <param name="output">TextWriter to write to</param>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.CompressingTurtleWriterContext.#ctor(VDS.RDF.IGraph,System.IO.TextWriter,VDS.RDF.Parsing.TurtleSyntax)">
            <summary>
            Creates a new Turtle Writer Context with default settings
            </summary>
            <param name="g">Graph to write</param>
            <param name="output">TextWriter to write to</param>
            <param name="syntax">Turtle Syntax</param>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.CompressingTurtleWriterContext.#ctor(VDS.RDF.IGraph,System.IO.TextWriter,System.Boolean,System.Boolean)">
            <summary>
            Creates a new Turtle Writer Context with custom settings
            </summary>
            <param name="g">Graph to write</param>
            <param name="output">TextWriter to write to</param>
            <param name="prettyPrint">Pretty Print Mode</param>
            <param name="hiSpeed">High Speed Mode</param>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.CompressingTurtleWriterContext.#ctor(VDS.RDF.IGraph,System.IO.TextWriter,System.Boolean,System.Boolean,VDS.RDF.Parsing.TurtleSyntax)">
            <summary>
            Creates a new Turtle Writer Context with custom settings
            </summary>
            <param name="g">Graph to write</param>
            <param name="output">TextWriter to write to</param>
            <param name="prettyPrint">Pretty Print Mode</param>
            <param name="hiSpeed">High Speed Mode</param>
            <param name="syntax">Turtle Syntax</param>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.CompressingTurtleWriterContext.#ctor(VDS.RDF.IGraph,System.IO.TextWriter,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Creates a new Turtle Writer Context with custom settings
            </summary>
            <param name="g">Graph to write</param>
            <param name="output">TextWriter to write to</param>
            <param name="compressionLevel">Compression Level to use</param>
            <param name="prettyPrint">Pretty Print Mode</param>
            <param name="hiSpeed">High Speed Mode</param>
        </member>
        <member name="M:VDS.RDF.Writing.Contexts.CompressingTurtleWriterContext.#ctor(VDS.RDF.IGraph,System.IO.TextWriter,System.Int32,System.Boolean,System.Boolean,VDS.RDF.Parsing.TurtleSyntax)">
            <summary>
            Creates a new Turtle Writer Context with custom settings
            </summary>
            <param name="g">Graph to write</param>
            <param name="output">TextWriter to write to</param>
            <param name="compressionLevel">Compression Level to use</param>
            <param name="prettyPrint">Pretty Print Mode</param>
            <param name="hiSpeed">High Speed Mode</param>
            <param name="syntax">Turtle Syntax</param>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.CompressingTurtleWriterContext.Collections">
            <summary>
            Represents the mapping from Blank Nodes to Collections
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Contexts.CompressingTurtleWriterContext.TriplesDone">
            <summary>
            Stores the Triples that should be excluded from standard output as they are part of collections
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.Formatting.IGraphFormatter">
            <summary>
            Interface for formatters designed to format entire RDF Graphs
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.Formatting.ITripleFormatter">
            <summary>
            Interface for Triple Formatters
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.ITripleFormatter.Format(VDS.RDF.Triple)">
            <summary>
            Formats a Triple as a String
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.IGraphFormatter.FormatGraphHeader(VDS.RDF.IGraph)">
            <summary>
            Generates the header section for the Graph
            </summary>
            <param name="g">Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.IGraphFormatter.FormatGraphHeader(VDS.RDF.INamespaceMapper)">
            <summary>
            Generates the header section for the Graph
            </summary>
            <param name="namespaces">Namespaces</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.IGraphFormatter.FormatGraphHeader">
            <summary>
            Generates a generic header section
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.IGraphFormatter.FormatGraphFooter">
            <summary>
            Generates the footer section
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Writing.Formatting.IResultSetFormatter">
            <summary>
            Interface for formatters designed to format entire SPARQL Result Sets
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.Formatting.IResultFormatter">
            <summary>
            Interface for Formatters which Format SPARQL Results
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.IResultFormatter.Format(VDS.RDF.Query.SparqlResult)">
            <summary>
            Formats a SPARQL Result as a String
            </summary>
            <param name="result">SPARQL Result</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.IResultFormatter.FormatBooleanResult(System.Boolean)">
            <summary>
            Formats a Boolean Result as a String
            </summary>
            <param name="result">Boolean Result</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.IResultSetFormatter.FormatResultSetHeader(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Generates a header section using the given variables
            </summary>
            <param name="variables">Variables</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.IResultSetFormatter.FormatResultSetHeader">
            <summary>
            Generates a header section assuming no variables
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.IResultSetFormatter.FormatResultSetFooter">
            <summary>
            Generates a footer section
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Writing.Formatting.RdfXmlFormatter">
            <summary>
            A formatter which formats triples for RDF/XML output
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.RdfXmlFormatter.FormatGraphHeader(VDS.RDF.IGraph)">
            <summary>
            Formats a Graph Header by creating an <strong>&lt;rdf:RDF&gt;</strong> element and adding namespace definitions
            </summary>
            <param name="g">Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.RdfXmlFormatter.FormatGraphHeader(VDS.RDF.INamespaceMapper)">
            <summary>
            Formats a Graph Header by creating an <strong>&lt;rdf:RDF&gt;</strong> element and adding namespace definitions
            </summary>
            <param name="namespaces">Namespaces</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.RdfXmlFormatter.FormatGraphHeader">
            <summary>
            Formats a Graph Header by creating an <strong>&lt;rdf:RDF&gt;</strong> element
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.RdfXmlFormatter.FormatGraphFooter">
            <summary>
            Formats a Graph Footer by closing the <strong>&lt;rdf:RDF&gt;</strong> element
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.RdfXmlFormatter.Format(VDS.RDF.Triple)">
            <summary>
            Formats a Triple as a <strong>&lt;rdf:Description&gt;</strong> element
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.RdfXmlFormatter.ToString">
            <summary>
            Gets the String description of this formatter
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Writing.Formatting.SparqlXmlFormatter">
            <summary>
            A Result Format that formats using the official SPARQL XML Results format
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.SparqlXmlFormatter.FormatResultSetHeader(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Formats the Header for a SPARQL Result Set
            </summary>
            <param name="variables">Variables</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.SparqlXmlFormatter.FormatResultSetHeader">
            <summary>
            Formats the Header for a SPARQL Result Set
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.SparqlXmlFormatter.FormatResultSetFooter">
            <summary>
            Formats the Footer for a SPARQL Result Set
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.SparqlXmlFormatter.Format(VDS.RDF.Query.SparqlResult)">
            <summary>
            Formats a SPARQL Result
            </summary>
            <param name="result">SPARQL Result</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.SparqlXmlFormatter.FormatBooleanResult(System.Boolean)">
            <summary>
            Formats a Boolean Result
            </summary>
            <param name="result">Boolean Result</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.SparqlXmlFormatter.ToString">
            <summary>
            Gets the string representation of the formatter
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Writing.PrettyRdfXmlWriter">
            <summary>
            Class for generating RDF/XML Concrete Syntax
            </summary>
            <remarks>
            <para>
            This is a fast writer based on the fast writing technique used in the other non-RDF/XML Writers.
            </para>
            <para>
            <strong>Note:</strong> If the Graph to be serialized makes heavy use of collections it may result in a StackOverflowException.  To address this set the <see cref="P:VDS.RDF.Writing.RdfXmlWriter.CompressionLevel">CompressionLevel</see> property to &lt; 5
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Writing.PrettyRdfXmlWriter.#ctor">
            <summary>
            Creates a new RDF/XML Writer
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.PrettyRdfXmlWriter.#ctor(System.Int32)">
            <summary>
            Creates a new RDF/XML Writer
            </summary>
            <param name="compressionLevel">Compression Level</param>
        </member>
        <member name="M:VDS.RDF.Writing.PrettyRdfXmlWriter.#ctor(System.Int32,System.Boolean)">
            <summary>
            Creates a new RDF/XML Writer
            </summary>
            <param name="compressionLevel">Compression Level</param>
            <param name="useDtd">Whether to use DTDs to further compress output</param>
        </member>
        <member name="M:VDS.RDF.Writing.PrettyRdfXmlWriter.#ctor(System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Creates a new RDF/XML Writer
            </summary>
            <param name="compressionLevel">Compression Level</param>
            <param name="useDtd">Whether to use DTDs to further compress output</param>
            <param name="useAttributes">Whether to use attributes to encode triples with simple literal objects where possible</param>
        </member>
        <member name="M:VDS.RDF.Writing.PrettyRdfXmlWriter.Save(VDS.RDF.IGraph,System.IO.TextWriter)">
            <summary>
            Saves a Graph to an arbitrary output stream
            </summary>
            <param name="g">Graph to save</param>
            <param name="output">Stream to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.PrettyRdfXmlWriter.GenerateOutput(VDS.RDF.IGraph,System.IO.TextWriter)">
            <summary>
            Internal method which generates the RDF/Json Output for a Graph
            </summary>
            <param name="g">Graph to save</param>
            <param name="output">Stream to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.PrettyRdfXmlWriter.RaiseWarning(System.String)">
            <summary>
            Internal Helper method for raising the Warning event
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="M:VDS.RDF.Writing.PrettyRdfXmlWriter.ToString">
            <summary>
            Gets the String representation of the writer which is a description of the syntax it produces
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Writing.PrettyRdfXmlWriter.PrettyPrintMode">
            <summary>
            Gets/Sets Pretty Print Mode for the Writer
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.PrettyRdfXmlWriter.CompressionLevel">
            <summary>
            Gets/Sets the Compression Level in use
            </summary>
            <remarks>
            <para>
            Compression Level defaults to <see cref="F:VDS.RDF.Writing.WriterCompressionLevel.High">High</see> - if Compression Level is set to below <see cref="F:VDS.RDF.Writing.WriterCompressionLevel.More">More</see> i.e. &lt; 5 then Collections will not be compressed into more compact syntax
            </para>
            </remarks>
        </member>
        <member name="P:VDS.RDF.Writing.PrettyRdfXmlWriter.UseDtd">
            <summary>
            Gets/Sets whether DTDs are used in the output
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.PrettyRdfXmlWriter.UseAttributes">
            <summary>
            Gets/Sets whether triples which have a literal object will be expressed as attributes rather than elements where possible (defaults to true)
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.PrettyRdfXmlWriter.DefaultNamespaces">
            <summary>
            Gets/Sets the Default Namespaces that are always available
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.PrettyRdfXmlWriter.TripleFormatterType">
            <summary>
            Gets the type of the Triple Formatter used by the writer
            </summary>
        </member>
        <member name="E:VDS.RDF.Writing.PrettyRdfXmlWriter.Warning">
            <summary>
            Event which is raised when there is a non-fatal issue with the RDF being output
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.Formatting.BaseFormatter">
            <summary>
            Abstract Base Class for Formatters
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.Formatting.INodeFormatter">
            <summary>
            Interface for classes which can format Nodes into Strings
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.INodeFormatter.Format(VDS.RDF.INode)">
            <summary>
            Formats a Node as a String
            </summary>
            <param name="n">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.INodeFormatter.Format(VDS.RDF.INode,System.Nullable{VDS.RDF.Writing.TripleSegment})">
            <summary>
            Formats a Node as a String for a specific segment of a Triple
            </summary>
            <param name="n">Node</param>
            <param name="segment">Segment</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Writing.Formatting.IUriFormatter">
            <summary>
            Interface for URI Formatters
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.IUriFormatter.FormatUri(System.Uri)">
            <summary>
            Formats a URI as a String
            </summary>
            <param name="u">URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.IUriFormatter.FormatUri(System.String)">
            <summary>
            Formats a URI as a String
            </summary>
            <param name="u">URI</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Writing.Formatting.ICharFormatter">
            <summary>
            Interface for Character Formatters
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.ICharFormatter.FormatChar(System.Char)">
            <summary>
            Formats a Character as a String
            </summary>
            <param name="c">Character</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.ICharFormatter.FormatChar(System.Char[])">
            <summary>
            Formats a sequence of characters as a String
            </summary>
            <param name="cs">Characters</param>
            <returns>String</returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.BaseFormatter.#ctor(System.String)">
            <summary>
            Creates a new Formatter
            </summary>
            <param name="formatName">Format Name</param>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.BaseFormatter.Format(VDS.RDF.INode,System.Nullable{VDS.RDF.Writing.TripleSegment})">
            <summary>
            Formats a Node as a String
            </summary>
            <param name="n">Node</param>
            <param name="segment">Triple Segment</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.BaseFormatter.Format(VDS.RDF.INode)">
            <summary>
            Formats a Node as a String
            </summary>
            <param name="n">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.BaseFormatter.Format(VDS.RDF.Triple)">
            <summary>
            Formats a Triple as a String
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.BaseFormatter.FormatUriNode(VDS.RDF.IUriNode,System.Nullable{VDS.RDF.Writing.TripleSegment})">
            <summary>
            Formats a URI Node as a String for the given Format
            </summary>
            <param name="u">URI Node</param>
            <param name="segment">Triple Segment</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.BaseFormatter.FormatUri(System.String)">
            <summary>
            Formats a URI as a String for full Output
            </summary>
            <param name="u">URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.BaseFormatter.FormatUri(System.Uri)">
            <summary>
            Formats a URI as a String for full Output
            </summary>
            <param name="u">URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.BaseFormatter.FormatLiteralNode(VDS.RDF.ILiteralNode,System.Nullable{VDS.RDF.Writing.TripleSegment})">
            <summary>
            Formats a Literal Node as a String for the given Format
            </summary>
            <param name="l">Literal Node</param>
            <param name="segment">Triple Segment</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.BaseFormatter.FormatBlankNode(VDS.RDF.IBlankNode,System.Nullable{VDS.RDF.Writing.TripleSegment})">
            <summary>
            Formats a Blank Node as a String for the given Format
            </summary>
            <param name="b">Blank Node</param>
            <param name="segment">Triple Segment</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.BaseFormatter.FormatVariableNode(VDS.RDF.IVariableNode,System.Nullable{VDS.RDF.Writing.TripleSegment})">
            <summary>
            Formats a Variable Node as a String for the given Format
            </summary>
            <param name="v">Variable Name</param>
            <param name="segment">Triple Segment</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.BaseFormatter.FormatGraphLiteralNode(VDS.RDF.IGraphLiteralNode,System.Nullable{VDS.RDF.Writing.TripleSegment})">
            <summary>
            Formats a Graph Literal Node as a String for the given Format
            </summary>
            <param name="glit">Graph Literal</param>
            <param name="segment">Triple Segment</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.BaseFormatter.FormatChar(System.Char)">
            <summary>
            Formats a Character for the given Format
            </summary>
            <param name="c">Character</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.BaseFormatter.FormatChar(System.Char[])">
            <summary>
            Formats a sequence of characters as a String
            </summary>
            <param name="cs">Characters</param>
            <returns>String</returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.BaseFormatter.Format(VDS.RDF.Query.SparqlResult)">
            <summary>
            Formats a SPARQL Result for the given format
            </summary>
            <param name="result">SPARQL Result</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.BaseFormatter.FormatBooleanResult(System.Boolean)">
            <summary>
            Formats a SPARQL Boolean Result for the given format
            </summary>
            <param name="result">Boolean Result</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.BaseFormatter.Escape(System.String,System.Collections.Generic.List{System.String[]})">
            <summary>
            Applies escapes to the given value
            </summary>
            <param name="value">Value</param>
            <param name="escapes">Escapes</param>
            <returns>Escaped string</returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.BaseFormatter.ToString">
            <summary>
            Gets the Name of the Format this Format uses
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Writing.Formatting.BaseFormatter.FormatName">
            <summary>
            Gets the Format Name
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.Formatting.CsvFormatter">
            <summary>
            Formatter for generating CSV
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.CsvFormatter.#ctor">
            <summary>
            Creates a new CSV Formatter
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.CsvFormatter.FormatUriNode(VDS.RDF.IUriNode,System.Nullable{VDS.RDF.Writing.TripleSegment})">
            <summary>
            Formats URIs for CSV output
            </summary>
            <param name="u">URI</param>
            <param name="segment">Triple Segment</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.CsvFormatter.FormatLiteralNode(VDS.RDF.ILiteralNode,System.Nullable{VDS.RDF.Writing.TripleSegment})">
            <summary>
            Formats Literals for CSV output
            </summary>
            <param name="l">Literal</param>
            <param name="segment">Triple Segment</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Writing.Formatting.DeliminatedLineFormatter">
            <summary>
            Abstract Base Class for formatters where things are formatted as lines of plain text deliminated by specific characters
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.DeliminatedLineFormatter.#ctor(System.String,System.Char,System.Char,System.Nullable{System.Char},System.Nullable{System.Char},System.Nullable{System.Char},System.Nullable{System.Char},System.Nullable{System.Char},System.Boolean)">
            <summary>
            Creates a new Deliminated Line Formatter
            </summary>
            <param name="formatName">Format Name</param>
            <param name="deliminator">Item Deliminator Character</param>
            <param name="escape">Escape Character</param>
            <param name="uriStartChar">Character to start URIs (may be null)</param>
            <param name="uriEndChar">Character to end URIs (may be null)</param>
            <param name="literalWrapperChar">Character to wrap Literals in (may be null)</param>
            <param name="longLiteralWrapperChar">Character to wrap Long Literals in (may be null)</param>
            <param name="lineEndChar">Character to add at end of line (may be null)</param>
            <param name="fullLiteralOutput">Whether Literals are output with Language/Datatype information</param>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.DeliminatedLineFormatter.Format(VDS.RDF.Triple)">
            <summary>
            Formats a Triple
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.DeliminatedLineFormatter.FormatUriNode(VDS.RDF.IUriNode,System.Nullable{VDS.RDF.Writing.TripleSegment})">
            <summary>
            Formats a URI Node
            </summary>
            <param name="u">URI Node</param>
            <param name="segment">Triple Segment</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.DeliminatedLineFormatter.FormatLiteralNode(VDS.RDF.ILiteralNode,System.Nullable{VDS.RDF.Writing.TripleSegment})">
            <summary>
            Formats a Literal Node
            </summary>
            <param name="lit">Literal Node</param>
            <param name="segment">Triple Segment</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.DeliminatedLineFormatter.FormatUri(System.String)">
            <summary>
            Formats URIs
            </summary>
            <param name="u"></param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Writing.Formatting.HtmlFormatter">
            <summary>
            Formatter for formatting as HTML
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.HtmlFormatter.FormatUri(System.Uri)">
            <summary>
            Formats URIs using HTML encoding
            </summary>
            <param name="u">URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.HtmlFormatter.FormatUri(System.String)">
            <summary>
            Formats URIs using HTML encoding
            </summary>
            <param name="u">URI</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Writing.Formatting.INamespaceFormatter">
            <summary>
            Interface for Formatters which can format Namespace Information
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.INamespaceFormatter.FormatNamespace(System.String,System.Uri)">
            <summary>
            Formats Namespace Information as a String
            </summary>
            <param name="prefix">Namespae Prefix</param>
            <param name="namespaceUri">Namespace URI</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Writing.Formatting.IBaseUriFormatter">
            <summary>
            Interface for Formatters which can format Base URI Information
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.IBaseUriFormatter.FormatBaseUri(System.Uri)">
            <summary>
            Formats Base URI Information as a String
            </summary>
            <param name="u">Base URI</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Writing.Formatting.IQueryFormatter">
            <summary>
            Interface for classes which can format SPARQL Queries into Strings
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.IQueryFormatter.Format(VDS.RDF.Query.SparqlQuery)">
            <summary>
            Formats a SPARQL Query into a String
            </summary>
            <param name="query">SPARQL Query</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.IQueryFormatter.Format(VDS.RDF.Query.Patterns.GraphPattern)">
            <summary>
            Formats a Graph Pattern into a String
            </summary>
            <param name="gp">Graph Pattern</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.IQueryFormatter.Format(VDS.RDF.Query.Patterns.ITriplePattern)">
            <summary>
            Formats a Triple Pattern into a String
            </summary>
            <param name="tp">Triple Pattern</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.IQueryFormatter.Format(VDS.RDF.Query.Patterns.PatternItem,System.Nullable{VDS.RDF.Writing.TripleSegment})">
            <summary>
            Formats a Triple Pattern item into a String
            </summary>
            <param name="item">Pattern Item</param>
            <param name="segment">Segment of the Triple Pattern in which the Item appears</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Writing.Formatting.UncompressedNotation3Formatter">
            <summary>
            Formatter for formatting as Notation 3 without any compression
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.Formatting.UncompressedTurtleFormatter">
            <summary>
            Formatter which formats Turtle without any compression
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.Formatting.NTriplesFormatter">
            <summary>
            Formatter for formatting as NTriples
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.Formatting.NTriplesFormatter._litEscapes">
            <summary>
            Set of characters which must be escaped in Literals
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.NTriplesFormatter.#ctor(VDS.RDF.Parsing.NTriplesSyntax,System.String)">
            <summary>
            Creates a new NTriples formatter
            </summary>
            <param name="syntax">NTriples syntax to output</param>
            <param name="formatName">Format Name</param>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.NTriplesFormatter.#ctor(VDS.RDF.Parsing.NTriplesSyntax)">
            <summary>
            Creates a new NTriples Formatter
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.NTriplesFormatter.#ctor">
            <summary>
            Creates a new NTriples Formatter
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.NTriplesFormatter.#ctor(System.String)">
            <summary>
            Creates a new NTriples Formatter
            </summary>
            <param name="formatName">Format Name</param>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.NTriplesFormatter.FormatUriNode(VDS.RDF.IUriNode,System.Nullable{VDS.RDF.Writing.TripleSegment})">
            <summary>
            Formats a URI Node
            </summary>
            <param name="u">URI Node</param>
            <param name="segment">Triple Segment</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.NTriplesFormatter.FormatLiteralNode(VDS.RDF.ILiteralNode,System.Nullable{VDS.RDF.Writing.TripleSegment})">
            <summary>
            Formats a Literal Node
            </summary>
            <param name="l">Literal Node</param>
            <param name="segment">Triple Segment</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.NTriplesFormatter.FormatChar(System.Char)">
            <summary>
            Formats a Character
            </summary>
            <param name="c">Character</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.NTriplesFormatter.FormatChar(System.Char[])">
            <summary>
            Formats a sequence of characters as a String
            </summary>
            <param name="cs">Characters</param>
            <returns>String</returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.NTriplesFormatter.FormatBlankNode(VDS.RDF.IBlankNode,System.Nullable{VDS.RDF.Writing.TripleSegment})">
            <summary>
            Formats a Blank Node
            </summary>
            <param name="b">Blank Node</param>
            <param name="segment">Triple Segment</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.NTriplesFormatter.FormatUri(System.String)">
            <summary>
            Formats a URI
            </summary>
            <param name="u">URI</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Writing.Formatting.NTriplesFormatter.Syntax">
            <summary>
            Gets the NTriples syntax being used
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.UncompressedTurtleFormatter.#ctor">
            <summary>
            Creates a new Uncompressed Turtle Formatter
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.UncompressedTurtleFormatter.#ctor(System.String)">
            <summary>
            Creates a new Uncompressed Formatter
            </summary>
            <param name="formatName">Format Name</param>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.UncompressedTurtleFormatter.FormatChar(System.Char)">
            <summary>
            Formats characters
            </summary>
            <param name="c">Character</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.UncompressedTurtleFormatter.FormatChar(System.Char[])">
            <summary>
            Formats a sequence of characters as a String
            </summary>
            <param name="cs">Characters</param>
            <returns>String</returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.UncompressedNotation3Formatter.#ctor">
            <summary>
            Creates a new Uncompressed Notation 3 Formatter
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.UncompressedNotation3Formatter.FormatVariableNode(VDS.RDF.IVariableNode,System.Nullable{VDS.RDF.Writing.TripleSegment})">
            <summary>
            Formats a Variable Node for Notation 3
            </summary>
            <param name="v">Variable</param>
            <param name="segment">Triple Segment</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.UncompressedNotation3Formatter.FormatGraphLiteralNode(VDS.RDF.IGraphLiteralNode,System.Nullable{VDS.RDF.Writing.TripleSegment})">
            <summary>
            Formats a Graph Literal Node for Notation 3
            </summary>
            <param name="glit">Graph Literal</param>
            <param name="segment">Triple Segment</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Writing.Formatting.Notation3Formatter">
            <summary>
            Formatter for formatting as Notation 3
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.Formatting.TurtleFormatter">
            <summary>
            Formatter which formats Turtle with QName compression
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.Formatting.QNameFormatter">
            <summary>
            Abstract Base Class for Formatters that can compress URIs to QNames
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.Formatting.QNameFormatter._qnameMapper">
            <summary>
            QName Map used for compressing URIs to QNames
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.QNameFormatter.#ctor(System.String,VDS.RDF.QNameOutputMapper)">
            <summary>
            Creates a new QName Formatter
            </summary>
            <param name="formatName">Format Name</param>
            <param name="qnameMapper">QName Map</param>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.QNameFormatter.#ctor(System.String,VDS.RDF.QNameOutputMapper,System.Boolean)">
            <summary>
            Creates a new QName Formatter
            </summary>
            <param name="formatName">Format Name</param>
            <param name="qnameMapper">QName Map</param>
            <param name="allowAKeyword">Whether the 'a' keyword can be used for the RDF type predicate</param>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.QNameFormatter.IsValidQName(System.String)">
            <summary>
            Determines whether a QName is valid
            </summary>
            <param name="value">Value</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.QNameFormatter.FormatUriNode(VDS.RDF.IUriNode,System.Nullable{VDS.RDF.Writing.TripleSegment})">
            <summary>
            Formats a URI Node using QName compression if possible
            </summary>
            <param name="u">URI</param>
            <param name="segment">Triple Segment</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.QNameFormatter.FormatLiteralNode(VDS.RDF.ILiteralNode,System.Nullable{VDS.RDF.Writing.TripleSegment})">
            <summary>
            Formats a Literal Node using QName compression for the datatype if possible
            </summary>
            <param name="l">Literal Node</param>
            <param name="segment">Triple Segment</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.QNameFormatter.FormatNamespace(System.String,System.Uri)">
            <summary>
            Formats a Namespace as a String
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="namespaceUri">Namespace URI</param>
            <returns></returns>
        </member>
        <member name="F:VDS.RDF.Writing.Formatting.TurtleFormatter._longLitMustEscape">
            <summary>
            Set of characters that must be escaped for Long Literals
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.Formatting.TurtleFormatter._litMustEscape">
            <summary>
            Set of characters that must be escaped for Literals
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.TurtleFormatter.#ctor">
            <summary>
            Creates a new Turtle Formatter
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.TurtleFormatter.#ctor(VDS.RDF.QNameOutputMapper)">
            <summary>
            Creates a new Turtle Formatter that uses the given QName mapper
            </summary>
            <param name="qnameMapper">QName Mapper</param>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.TurtleFormatter.#ctor(VDS.RDF.IGraph)">
            <summary>
            Creates a new Turtle Formatter for the given Graph
            </summary>
            <param name="g">Graph</param>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.TurtleFormatter.#ctor(VDS.RDF.INamespaceMapper)">
            <summary>
            Creates a new Turtle Formatter for the given Namespace Map
            </summary>
            <param name="nsmap">Namespace Map</param>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.TurtleFormatter.#ctor(System.String)">
            <summary>
            Creates a new Turtle Formatter
            </summary>
            <param name="formatName">Format Name</param>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.TurtleFormatter.#ctor(System.String,VDS.RDF.IGraph)">
            <summary>
            Creates a new Turtle Formatter
            </summary>
            <param name="formatName">Format Name</param>
            <param name="g">Graph</param>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.TurtleFormatter.#ctor(System.String,VDS.RDF.INamespaceMapper)">
            <summary>
            Creates a new Turtle Formatter
            </summary>
            <param name="formatName">Format Name</param>
            <param name="nsmap">Namespace Map</param>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.TurtleFormatter.#ctor(System.String,VDS.RDF.QNameOutputMapper)">
            <summary>
            Creates a new Turtle Formatter
            </summary>
            <param name="formatName">Format Name</param>
            <param name="qnameMapper">QName Map</param>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.TurtleFormatter.FormatLiteralNode(VDS.RDF.ILiteralNode,System.Nullable{VDS.RDF.Writing.TripleSegment})">
            <summary>
            Formats a Literal Node as a String
            </summary>
            <param name="l">Literal Node</param>
            <param name="segment">Triple Segment</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.TurtleFormatter.FormatBlankNode(VDS.RDF.IBlankNode,System.Nullable{VDS.RDF.Writing.TripleSegment})">
            <summary>
            Formats a Blank Node as a String
            </summary>
            <param name="b">Blank Node</param>
            <param name="segment">Triple Segment</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.TurtleFormatter.FormatNamespace(System.String,System.Uri)">
            <summary>
            Formats a Namespace Decalaration as a @prefix declaration
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="namespaceUri">Namespace URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.TurtleFormatter.FormatBaseUri(System.Uri)">
            <summary>
            Formats a Base URI declaration as a @base declaration
            </summary>
            <param name="u">Base URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.Notation3Formatter.#ctor">
            <summary>
            Creates a new Notation 3 Formatter
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.Notation3Formatter.#ctor(VDS.RDF.IGraph)">
            <summary>
            Creates a new Notation 3 Formatter using the given Graph
            </summary>
            <param name="g">Graph</param>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.Notation3Formatter.#ctor(VDS.RDF.INamespaceMapper)">
            <summary>
            Creates a new Notation 3 Formatter using the given Namespace Map
            </summary>
            <param name="nsmap">Namespace Map</param>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.Notation3Formatter.FormatVariableNode(VDS.RDF.IVariableNode,System.Nullable{VDS.RDF.Writing.TripleSegment})">
            <summary>
            Formats a Variable Node for Notation 3
            </summary>
            <param name="v">Variable</param>
            <param name="segment">Triple Segment</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.Notation3Formatter.FormatGraphLiteralNode(VDS.RDF.IGraphLiteralNode,System.Nullable{VDS.RDF.Writing.TripleSegment})">
            <summary>
            Formats a Graph Literal Node for Notation 3
            </summary>
            <param name="glit">Graph Literal</param>
            <param name="segment">Triple Segment</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Writing.Formatting.NQuadsFormatter">
            <summary>
            Formatter which formats Triples as NQuads adding an additional URI at the end of the Triple if there is a Graph URI associated with the Triple
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.NQuadsFormatter.#ctor">
            <summary>
            Creates a new NQuads Formatter
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.NQuadsFormatter.#ctor(VDS.RDF.Parsing.NQuadsSyntax)">
            <summary>
            Creates a new NQuads formatter
            </summary>
            <param name="syntax">NQuads syntax to output</param>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.NQuadsFormatter.#ctor(VDS.RDF.Parsing.NQuadsSyntax,System.String)">
            <summary>
            Creates a new NQuads formatter
            </summary>
            <param name="syntax">NQuads syntax to output</param>
            <param name="formatName">Format Name</param>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.NQuadsFormatter.Format(VDS.RDF.Triple)">
            <summary>
            Formats a Triple as a String
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Writing.Formatting.NQuads11Formatter">
            <summary>
            Formatter which formats Triples as NQuads according to the RDF 1.1 NQuads specification
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.NQuads11Formatter.#ctor">
            <summary>
            Creates a new formatter
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.Formatting.NTriples11Formatter">
            <summary>
            Formatter for formatting as NTriples according to the RDF 1.1 specification
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.NTriples11Formatter.#ctor">
            <summary>
            Creaates a new formatter
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.Formatting.SparqlFormatter">
            <summary>
            Formatter for formatting Nodes for use in SPARQL and for formatting SPARQL Queries
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.SparqlFormatter.#ctor">
            <summary>
            Creates a new SPARQL Formatter
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.SparqlFormatter.#ctor(VDS.RDF.IGraph)">
            <summary>
            Creates a new SPARQL Formatter using the given Graph
            </summary>
            <param name="g">Graph</param>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.SparqlFormatter.#ctor(VDS.RDF.INamespaceMapper)">
            <summary>
            Creates a new SPARQL Formatter using the given Namespace Map
            </summary>
            <param name="nsmap">Namespace Map</param>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.SparqlFormatter.IsValidQName(System.String)">
            <summary>
            Determines whether a QName is valid
            </summary>
            <param name="value">Value</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.SparqlFormatter.FormatVariableNode(VDS.RDF.IVariableNode,System.Nullable{VDS.RDF.Writing.TripleSegment})">
            <summary>
            Formats a Variable Node in SPARQL Syntax
            </summary>
            <param name="v">Variable Node</param>
            <param name="segment">Triple Segment</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.SparqlFormatter.FormatNamespace(System.String,System.Uri)">
            <summary>
            Formats a Namespace Declaration
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="namespaceUri">Namespace URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.SparqlFormatter.FormatBaseUri(System.Uri)">
            <summary>
            Formats a Base URI Declaration
            </summary>
            <param name="u">Base URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.SparqlFormatter.Format(VDS.RDF.Query.SparqlQuery)">
            <summary>
            Formats a Query in nicely formatted SPARQL syntax
            </summary>
            <param name="query">SPARQL Query</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.SparqlFormatter.Format(VDS.RDF.Query.Patterns.GraphPattern)">
            <summary>
            Formats a Graph Pattern in nicely formatted SPARQL syntax
            </summary>
            <param name="gp">Graph Pattern</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.SparqlFormatter.Format(VDS.RDF.Query.Patterns.ITriplePattern)">
            <summary>
            Formats a Triple Pattern in nicely formatted SPARQL syntax
            </summary>
            <param name="tp">Triple Pattern</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.SparqlFormatter.Format(VDS.RDF.Query.Patterns.PatternItem,System.Nullable{VDS.RDF.Writing.TripleSegment})">
            <summary>
            Formats a Pattern Item in nicely formatted SPARQL syntax
            </summary>
            <param name="item">Pattern Item</param>
            <param name="segment">Triple Pattern Segment</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.SparqlFormatter.FormatVariablesList(System.Collections.Generic.IEnumerable{VDS.RDF.Query.SparqlVariable})">
            <summary>
            Formats the Variable List for a SPARQL Query
            </summary>
            <param name="vars">Variables</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.SparqlFormatter.FormatDescribeVariablesList(VDS.RDF.Query.SparqlQuery)">
            <summary>
            Formats the Variable/QName/URI for a SPARQL DESCRIBE Query
            </summary>
            <param name="q">SPARQL Query</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.SparqlFormatter.FormatExpression(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Formats a SPARQL Expression
            </summary>
            <param name="expr">SPARQL Expression</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.SparqlFormatter.FormatAggregate(VDS.RDF.Query.Aggregates.ISparqlAggregate)">
            <summary>
            Formats a SPARQL Aggregate
            </summary>
            <param name="agg">SPARQL Aggregate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.SparqlFormatter.FormatPath(VDS.RDF.Query.Paths.ISparqlPath)">
            <summary>
            Formats a SPARQL Property Path
            </summary>
            <param name="path">SPARQL Property Path</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.SparqlFormatter.FormatGroupBy(VDS.RDF.Query.Grouping.ISparqlGroupBy)">
            <summary>
            Formats a SPARQL GROUP BY Clause
            </summary>
            <param name="groupBy">GROUP BY Clause</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.SparqlFormatter.FormatOrderBy(VDS.RDF.Query.Ordering.ISparqlOrderBy)">
            <summary>
            Formats a SPARQL ORDER BY Clause
            </summary>
            <param name="orderBy">ORDER BY Clause</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.SparqlFormatter.FormatInlineData(VDS.RDF.Query.Patterns.BindingsPattern)">
            <summary>
            Formats the Inline Data portion of a Query
            </summary>
            <param name="data">Inline Data</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.SparqlFormatter.Format(VDS.RDF.Query.SparqlResult)">
            <summary>
            Formats a SPARQL Result using this Formatter to format the Node values for each Variable
            </summary>
            <param name="result">SPARQL Result</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.SparqlFormatter.FormatBooleanResult(System.Boolean)">
            <summary>
            Formats a Boolean Result
            </summary>
            <param name="result">Boolean Result</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Writing.Formatting.TsvFormatter">
            <summary>
            Formatter for formatting as TSV
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.TsvFormatter.#ctor">
            <summary>
            Creates a new TSV Formatter
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.Formatting.TurtleW3CFormatter">
            <summary>
            Formatter which formats Turtle with QName compression using the newer W3C syntax which permits a wider range of valid QNames
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.TurtleW3CFormatter.#ctor">
            <summary>
            Creates a new Turtle Formatter
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.TurtleW3CFormatter.#ctor(VDS.RDF.QNameOutputMapper)">
            <summary>
            Creates a new Turtle Formatter that uses the given QName mapper
            </summary>
            <param name="qnameMapper">QName Mapper</param>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.TurtleW3CFormatter.#ctor(VDS.RDF.IGraph)">
            <summary>
            Creates a new Turtle Formatter for the given Graph
            </summary>
            <param name="g">Graph</param>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.TurtleW3CFormatter.#ctor(VDS.RDF.INamespaceMapper)">
            <summary>
            Creates a new Turtle Formatter for the given Namespace Map
            </summary>
            <param name="nsmap">Namespace Map</param>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.TurtleW3CFormatter.#ctor(System.String)">
            <summary>
            Creates a new Turtle Formatter
            </summary>
            <param name="formatName">Format Name</param>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.TurtleW3CFormatter.#ctor(System.String,VDS.RDF.IGraph)">
            <summary>
            Creates a new Turtle Formatter
            </summary>
            <param name="formatName">Format Name</param>
            <param name="g">Graph</param>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.TurtleW3CFormatter.#ctor(System.String,VDS.RDF.INamespaceMapper)">
            <summary>
            Creates a new Turtle Formatter
            </summary>
            <param name="formatName">Format Name</param>
            <param name="nsmap">Namespace Map</param>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.TurtleW3CFormatter.#ctor(System.String,VDS.RDF.QNameOutputMapper)">
            <summary>
            Creates a new Turtle Formatter
            </summary>
            <param name="formatName">Format Name</param>
            <param name="qnameMapper">QName Map</param>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.TurtleW3CFormatter.IsValidQName(System.String)">
            <summary>
            Gets whether a QName is valid in Turtle as specified by the W3C
            </summary>
            <param name="value">QName</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Writing.HtmlSchemaWriter">
            <summary>
            HTML Schema Writer is a HTML Writer which writes a human readable description of a Schema/Ontology
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlSchemaWriter.Save(VDS.RDF.IGraph,System.IO.TextWriter)">
            <summary>
            Saves the Result Set to the given Stream as an XHTML Table with embedded RDFa
            </summary>
            <param name="g">Graph to save</param>
            <param name="output">Stream to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlSchemaWriter.GenerateOutput(VDS.RDF.Writing.Contexts.HtmlWriterContext)">
            <summary>
            Internal method which generates the HTML Output for the Graph
            </summary>
            <param name="context">Writer Context</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlSchemaWriter.RaiseWarning(System.String)">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.Writing.HtmlSchemaWriter.Warning">Warning</see> event
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlSchemaWriter.ToString">
            <summary>
            Gets the String representation of the writer which is a description of the syntax it produces
            </summary>
            <returns></returns>
        </member>
        <member name="E:VDS.RDF.Writing.HtmlSchemaWriter.Warning">
            <summary>
            Event which is raised if there is a non-fatal error with the RDF being output
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.RdfXmlWriter">
            <summary>
            Class for generating RDF/XML Concrete Syntax
            </summary>
            <remarks>
            <para>
            This is a fast writer based on the fast writing technique used in the other non-RDF/XML Writers.
            </para>
            <para>
            <strong>Note:</strong> If the Graph to be serialized makes heavy use of collections it may result in a StackOverflowException.  To address this set the <see cref="P:VDS.RDF.Writing.RdfXmlWriter.CompressionLevel">CompressionLevel</see> property to &lt; 5
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Writing.RdfXmlWriter.#ctor">
            <summary>
            Creates a new RDF/XML Writer
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.RdfXmlWriter.#ctor(System.Int32)">
            <summary>
            Creates a new RDF/XML Writer
            </summary>
            <param name="compressionLevel">Compression Level</param>
        </member>
        <member name="M:VDS.RDF.Writing.RdfXmlWriter.#ctor(System.Int32,System.Boolean)">
            <summary>
            Creates a new RDF/XML Writer
            </summary>
            <param name="compressionLevel">Compression Level</param>
            <param name="useDtd">Whether to use DTDs to further compress output</param>
        </member>
        <member name="M:VDS.RDF.Writing.RdfXmlWriter.Save(VDS.RDF.IGraph,System.IO.TextWriter)">
            <summary>
            Saves a Graph to an arbitrary output stream
            </summary>
            <param name="g">Graph to save</param>
            <param name="output">Stream to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.RdfXmlWriter.GenerateOutput(VDS.RDF.IGraph,System.IO.TextWriter)">
            <summary>
            Internal method which generates the RDF/Json Output for a Graph
            </summary>
            <param name="g">Graph to save</param>
            <param name="output">Stream to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.RdfXmlWriter.RaiseWarning(System.String)">
            <summary>
            Internal Helper method for raising the Warning event
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="M:VDS.RDF.Writing.RdfXmlWriter.ToString">
            <summary>
            Gets the String representation of the writer which is a description of the syntax it produces
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Writing.RdfXmlWriter.PrettyPrintMode">
            <summary>
            Gets/Sets Pretty Print Mode for the Writer
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.RdfXmlWriter.CompressionLevel">
            <summary>
            Gets/Sets the Compression Level in use
            </summary>
            <remarks>
            <para>
            Compression Level defaults to <see cref="F:VDS.RDF.Writing.WriterCompressionLevel.High">High</see> - if Compression Level is set to below <see cref="F:VDS.RDF.Writing.WriterCompressionLevel.More">More</see> i.e. &lt; 5 then Collections will not be compressed into more compact syntax
            </para>
            </remarks>
        </member>
        <member name="P:VDS.RDF.Writing.RdfXmlWriter.UseDtd">
            <summary>
            Gets/Sets whether DTDs are used in the output
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.RdfXmlWriter.DefaultNamespaces">
            <summary>
            Gets/Sets the Default Namespaces that are always available
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.RdfXmlWriter.TripleFormatterType">
            <summary>
            Gets the type of the Triple Formatter used by this writer
            </summary>
        </member>
        <member name="E:VDS.RDF.Writing.RdfXmlWriter.Warning">
            <summary>
            Event which is raised when there is a non-fatal issue with the RDF being output
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.HtmlWriter">
            <summary>
            Class for saving RDF Graphs to a XHTML Table format with the actual Triples embedded as RDFa
            </summary>
            <remarks>
            <para>
            Since not all Triples can be embedded into XHTML those Triples will not have RDFa generated for them but all Triples will be shown in a human readable format.  Triples that can be serialized are roughly equivalent to anything that can be serialized in Turtle i.e. URI/BNode subject, URI predicates and URI/BNode/Literal object.
            </para>
            <para>
            If you encode Triples which have values datatyped as XML Literals with this writer then round-trip Graph equality is not guaranteed as the RDFa parser will add appropriate Namespace declarations to elements as required by the specification
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlWriter.Save(VDS.RDF.IGraph,System.IO.TextWriter)">
            <summary>
            Saves the Result Set to the given Stream as an XHTML Table with embedded RDFa
            </summary>
            <param name="g">Graph to save</param>
            <param name="output">Stream to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlWriter.GenerateOutput(VDS.RDF.Writing.Contexts.HtmlWriterContext)">
            <summary>
            Internal method which generates the HTML Output for the Graph
            </summary>
            <param name="context">Writer Context</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlWriter.GenerateNodeOutput(VDS.RDF.Writing.Contexts.HtmlWriterContext,VDS.RDF.INode)">
            <summary>
            Generates Output for a given Node
            </summary>
            <param name="context">Writer Context</param>
            <param name="n">Node</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlWriter.GenerateNodeOutput(VDS.RDF.Writing.Contexts.HtmlWriterContext,VDS.RDF.INode,VDS.RDF.Triple)">
            <summary>
            Generates Output for a given Node
            </summary>
            <param name="context">Writer Context</param>
            <param name="n">Node</param>
            <param name="t">Triple being written</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlWriter.RaiseWarning(System.String)">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.Writing.HtmlWriter.Warning">Warning</see> event
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="M:VDS.RDF.Writing.HtmlWriter.ToString">
            <summary>
            Gets the String representation of the writer which is a description of the syntax it produces
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Writing.HtmlWriter.DefaultNamespaces">
            <summary>
            Gets/Sets the Default Namespaces to use for writers
            </summary>
        </member>
        <member name="E:VDS.RDF.Writing.HtmlWriter.Warning">
            <summary>
            Event which is raised if there is a non-fatal error with the RDF being output
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.CsvWriter">
            <summary>
            Class for generating CSV output from RDF Graphs
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.CsvWriter.Save(VDS.RDF.IGraph,System.IO.TextWriter)">
            <summary>
            Saves a Graph to CSV format
            </summary>
            <param name="g">Graph</param>
            <param name="output">Writer to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.CsvWriter.GenerateNodeOutput(System.IO.TextWriter,VDS.RDF.INode,VDS.RDF.Writing.TripleSegment)">
            <summary>
            Generates Node Output for the given Node
            </summary>
            <param name="output">Text Writer</param>
            <param name="n">Node</param>
            <param name="segment">Triple Segment</param>
        </member>
        <member name="M:VDS.RDF.Writing.CsvWriter.ToString">
            <summary>
            Gets the String representation of the writer which is a description of the syntax it produces
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Writing.CsvWriter.TripleFormatterType">
            <summary>
            Gets the type of the Triple Formatter used by the writer
            </summary>
        </member>
        <member name="E:VDS.RDF.Writing.CsvWriter.Warning">
            <summary>
            Event which is raised if the Writer detects a non-fatal error while outputting CSV
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.CsvStoreWriter">
            <summary>
            Class for generating CSV output from RDF Datasets
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.CsvStoreWriter.Save(VDS.RDF.ITripleStore,System.IO.TextWriter)">
            <summary>
            Saves a Triple Store to CSV Format
            </summary>
            <param name="store">Triple Store to save</param>
            <param name="writer">Writer to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.CsvStoreWriter.SaveGraphs(VDS.RDF.Writing.Contexts.ThreadedStoreWriterContext)">
            <summary>
            Thread Worker method which writes Graphs to the output
            </summary>
            <param name="globalContext">Context for writing the Store</param>
        </member>
        <member name="M:VDS.RDF.Writing.CsvStoreWriter.GenerateGraphOutput(VDS.RDF.Writing.Contexts.ThreadedStoreWriterContext,VDS.RDF.Writing.Contexts.BaseWriterContext)">
            <summary>
            Generates the Output for a Graph as a String in CSV syntax
            </summary>
            <param name="globalContext">Context for writing the Store</param>
            <param name="context">Context for writing the Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.CsvStoreWriter.GenerateNodeOutput(VDS.RDF.Writing.Contexts.BaseWriterContext,VDS.RDF.INode,VDS.RDF.Writing.TripleSegment)">
            <summary>
            Generates Output for the given Node
            </summary>
            <param name="context">Writer Context</param>
            <param name="n">Node</param>
            <param name="segment">Triple Segment</param>
        </member>
        <member name="M:VDS.RDF.Writing.CsvStoreWriter.ToString">
            <summary>
            Gets the String representation of the writer which is a description of the syntax it produces
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Writing.CsvStoreWriter.TripleFormatterType">
            <summary>
            Gets the type of the Triple Formatter used by the writer
            </summary>
        </member>
        <member name="E:VDS.RDF.Writing.CsvStoreWriter.Warning">
            <summary>
            Event which is raised when a non-fatal error occurs while outputting CSV
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.CsvStoreWriter.SaveGraphsDeletegate">
            <summary>
            Delegate for the SaveGraphs method
            </summary>
            <param name="globalContext">Context for writing the Store</param>
        </member>
        <member name="T:VDS.RDF.Writing.Notation3Writer">
            <summary>
            Class for generating Notation 3 Concrete RDF Syntax which provides varying levels of Syntax Compression
            </summary>
            <threadsafety instance="true">Designed to be Thread Safe - should be able to call the Save() method from multiple threads on different Graphs without issue</threadsafety>
        </member>
        <member name="M:VDS.RDF.Writing.Notation3Writer.#ctor">
            <summary>
            Creates a new Notation 3 Writer which uses the Default Compression Level
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Notation3Writer.#ctor(System.Int32)">
            <summary>
            Creates a new Notation 3 Writer which uses the given Compression Level
            </summary>
            <param name="compressionLevel">Desired Compression Level</param>
            <remarks>See Remarks for this classes <see cref="P:VDS.RDF.Writing.Notation3Writer.CompressionLevel">CompressionLevel</see> property to see what effect different compression levels have</remarks>
        </member>
        <member name="M:VDS.RDF.Writing.Notation3Writer.Save(VDS.RDF.IGraph,System.IO.TextWriter)">
            <summary>
            Saves a Graph to the given Stream using Notation 3 Syntax
            </summary>
            <param name="g">Graph to save</param>
            <param name="output">Stream to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.Notation3Writer.GenerateOutput(VDS.RDF.Writing.Contexts.CompressingTurtleWriterContext)">
            <summary>
            Generates the Notation 3 Syntax for the Graph
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Notation3Writer.GenerateTripleOutput(VDS.RDF.Writing.Contexts.CompressingTurtleWriterContext,VDS.RDF.Triple)">
            <summary>
            Generates Output for Triples as a single "s p o." Triple
            </summary>
            <param name="context">Writer Context</param>
            <param name="t">Triple to output</param>
            <returns></returns>
            <remarks>Used only in High Speed Write Mode</remarks>
        </member>
        <member name="M:VDS.RDF.Writing.Notation3Writer.GenerateNodeOutput(VDS.RDF.Writing.Contexts.CompressingTurtleWriterContext,VDS.RDF.INode,VDS.RDF.Writing.TripleSegment,System.Int32)">
            <summary>
            Generates Output for Nodes in Notation 3 syntax
            </summary>
            <param name="context">Writer Context</param>
            <param name="n">Node to generate output for</param>
            <param name="segment">Segment of the Triple being output</param>
            <param name="indent">Indent to use for pretty printing</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Notation3Writer.GenerateCollectionOutput(VDS.RDF.Writing.Contexts.CompressingTurtleWriterContext,VDS.RDF.Writing.OutputRdfCollection,System.Int32)">
            <summary>
            Internal Helper method which converts a Collection into Notation 3 Syntax
            </summary>
            <param name="context">Writer Context</param>
            <param name="c">Collection to convert</param>
            <param name="indent">Indent to use for pretty printing</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Notation3Writer.RaiseWarning(System.String)">
            <summary>
            Helper method for generating Parser Warning Events
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="M:VDS.RDF.Writing.Notation3Writer.ToString">
            <summary>
            Gets the String representation of the writer which is a description of the syntax it produces
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Writing.Notation3Writer.PrettyPrintMode">
            <summary>
            Gets/Sets whether Pretty Printing is used
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Notation3Writer.HighSpeedModePermitted">
            <summary>
            Gets/Sets whether High Speed Write Mode should be allowed
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Notation3Writer.CompressionLevel">
            <summary>
            Gets/Sets the Compression Level to be used
            </summary>
            <remarks>
            <para>
            If the Compression Level is set to <see cref="F:VDS.RDF.Writing.WriterCompressionLevel.None">None</see> then High Speed mode will always be used regardless of the input Graph and the <see cref="P:VDS.RDF.Writing.Notation3Writer.HighSpeedModePermitted">HighSpeedMorePermitted</see> property.
            </para>
            <para>
            If the Compression Level is set to <see cref="F:VDS.RDF.Writing.WriterCompressionLevel.Minimal">Minimal</see> or above then full Predicate Object lists will be used for Triples.
            </para>
            <para>
            If the Compression Level is set to <see cref="F:VDS.RDF.Writing.WriterCompressionLevel.More">More</see> or above then Blank Node Collections and Collection syntax will be used if the Graph contains Triples that can be compressed in that way.</para>
            </remarks>
        </member>
        <member name="P:VDS.RDF.Writing.Notation3Writer.DefaultNamespaces">
            <summary>
            Gets/Sets the Default Namespaces that are always available
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.Notation3Writer.TripleFormatterType">
            <summary>
            Gets the type of the Triple Formatter used by this writer
            </summary>
        </member>
        <member name="E:VDS.RDF.Writing.Notation3Writer.Warning">
            <summary>
            Event which is raised when there is a non-fatal issue with the Graph being written
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.NQuadsWriter">
            <summary>
            Class for serializing a Triple Store in the NQuads (NTriples plus context) syntax
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.NQuadsWriter.#ctor">
            <summary>
            Creates a new writer
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.NQuadsWriter.#ctor(VDS.RDF.Parsing.NQuadsSyntax)">
            <summary>
            Creates a new writer
            </summary>
            <param name="syntax">NQuads Syntax mode to use</param>
        </member>
        <member name="M:VDS.RDF.Writing.NQuadsWriter.Save(VDS.RDF.ITripleStore,System.IO.TextWriter)">
            <summary>
            Saves a Store in NQuads format
            </summary>
            <param name="store">Store to save</param>
            <param name="writer">Writer to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.NQuadsWriter.TripleToNQuads(VDS.RDF.Writing.Contexts.NTriplesWriterContext,VDS.RDF.Triple,System.Uri)">
            <summary>
            Converts a Triple into relevant NQuads Syntax
            </summary>
            <param name="context">Writer Context</param>
            <param name="t">Triple to convert</param>
            <param name="graphUri">Graph URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.NQuadsWriter.NodeToNTriples(VDS.RDF.Writing.Contexts.NTriplesWriterContext,VDS.RDF.INode,VDS.RDF.Writing.TripleSegment)">
            <summary>
            Converts a Node into relevant NTriples Syntax
            </summary>
            <param name="n">Node to convert</param>
            <param name="context">Writer Context</param>
            <param name="segment">Triple Segment being written</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.NQuadsWriter.SaveGraphs(VDS.RDF.Writing.Contexts.ThreadedStoreWriterContext)">
            <summary>
            Thread Worker method which writes Graphs to the output
            </summary>
            <param name="globalContext">Context for writing the Store</param>
        </member>
        <member name="M:VDS.RDF.Writing.NQuadsWriter.RaiseWarning(System.String)">
            <summary>
            Internal Helper method which raises the Warning event only if there is an Event Handler registered
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="M:VDS.RDF.Writing.NQuadsWriter.ToString">
            <summary>
            Gets the String representation of the writer which is a description of the syntax it produces
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Writing.NQuadsWriter.PrettyPrintMode">
            <summary>
            Controls whether Pretty Printing is used
            </summary>
            <remarks>
            For NQuads this simply means that Graphs in the output are separated with Whitespace and comments used before each Graph
            </remarks>
        </member>
        <member name="P:VDS.RDF.Writing.NQuadsWriter.UseMultiThreadedWriting">
            <summary>
            Gets/Sets whether Multi-Threaded Writing
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.NQuadsWriter.TripleFormatterType">
            <summary>
            Gets the type of the Triple Formatter used by this writer
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.NQuadsWriter.Syntax">
            <summary>
            Gets/Sets the NQuads syntax mode
            </summary>
        </member>
        <member name="E:VDS.RDF.Writing.NQuadsWriter.Warning">
            <summary>
            Event which is raised when there is an issue with the Graphs being serialized that doesn't prevent serialization but the user should be aware of
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.NQuadsWriter.SaveGraphsDelegate">
            <summary>
            Delegate for the SaveGraphs method
            </summary>
            <param name="globalContext">Context for writing the Store</param>
        </member>
        <member name="T:VDS.RDF.Writing.RdfJsonWriter">
            <summary>
            Class for generating RDF/Json Concrete Syntax
            </summary>
            <remarks>
            <p>
            Uses the Json.Net library by <a href="http://james.newtonking.com">James Newton-King</a> to output RDF/Json according to the specification located on the <a href="http://n2.talis.com/wiki/RDF_JSON_Specification">Talis n2 Wiki</a>
            </p>
            </remarks>
            <threadsafety instance="true">Designed to be Thread Safe - should be able to call the Save() method from multiple threads on different Graphs without issue</threadsafety>
        </member>
        <member name="M:VDS.RDF.Writing.RdfJsonWriter.Save(VDS.RDF.IGraph,System.IO.TextWriter)">
            <summary>
            Saves a Graph to an arbitrary output stream
            </summary>
            <param name="g">Graph to save</param>
            <param name="output">Stream to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.RdfJsonWriter.GenerateOutput(VDS.RDF.IGraph,System.IO.TextWriter)">
            <summary>
            Internal method which generates the RDF/Json Output for a Graph
            </summary>
            <param name="g">Graph to save</param>
            <param name="output">Stream to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.RdfJsonWriter.RaiseWarning(System.String)">
            <summary>
            Internal Helper method for raising the Warning event
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="M:VDS.RDF.Writing.RdfJsonWriter.ToString">
            <summary>
            Gets the String representation of the writer which is a description of the syntax it produces
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Writing.RdfJsonWriter.PrettyPrintMode">
            <summary>
            Gets/Sets Pretty Print Mode for the Writer
            </summary>
        </member>
        <member name="E:VDS.RDF.Writing.RdfJsonWriter.Warning">
            <summary>
            Event which is raised when there is a non-fatal issue with the RDF being output
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.SparqlCsvWriter">
            <summary>
            Class for saving SPARQL Result Sets to CSV format (not a standardised format)
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.SparqlCsvWriter.Save(VDS.RDF.Query.SparqlResultSet,System.IO.TextWriter)">
            <summary>
            Saves a SPARQL Result Set to CSV format
            </summary>
            <param name="results">Result Set</param>
            <param name="output">Writer to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.SparqlCsvWriter.RaiseWarning(System.String)">
            <summary>
            Helper Method which raises the Warning event when a non-fatal issue with the SPARQL Results being written is detected
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="M:VDS.RDF.Writing.SparqlCsvWriter.ToString">
            <summary>
            Gets the String representation of the writer which is a description of the syntax it produces
            </summary>
            <returns></returns>
        </member>
        <member name="E:VDS.RDF.Writing.SparqlCsvWriter.Warning">
            <summary>
            Event raised when a non-fatal issue with the SPARQL Results being written is detected
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.SparqlRdfWriter">
            <summary>
            Class for saving SPARQL Result Sets in the RDF serialization in the RDF format of your choice (default Turtle)
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.SparqlRdfWriter.#ctor">
            <summary>
            Creates a new SPARQL RDF Writer which will save Result Sets in the RDF serialization using Turtle syntax
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.SparqlRdfWriter.#ctor(VDS.RDF.IRdfWriter)">
            <summary>
            Creates a new SPARQL RDF Writer which will save Result Sets in the RDF serialization in your chosen RDF Syntax
            </summary>
            <param name="writer">RDF Writer to use</param>
        </member>
        <member name="M:VDS.RDF.Writing.SparqlRdfWriter.Save(VDS.RDF.Query.SparqlResultSet,System.IO.TextWriter)">
            <summary>
            Saves the SPARQL Result Set to the given Stream
            </summary>
            <param name="results">Result Set to save</param>
            <param name="output">Stream to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.SparqlRdfWriter.GenerateOutput(VDS.RDF.Query.SparqlResultSet)">
            <summary>
            Method which generates the RDF Graph of a SPARQL Result Set
            </summary>
            <param name="results">Result Set</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.SparqlRdfWriter.RaiseWarning(System.String)">
            <summary>
            Helper Method which raises the Warning event when a non-fatal issue with the SPARQL Results being written is detected
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="M:VDS.RDF.Writing.SparqlRdfWriter.ToString">
            <summary>
            Gets the String representation of the writer which is a description of the syntax it produces
            </summary>
            <returns></returns>
        </member>
        <member name="E:VDS.RDF.Writing.SparqlRdfWriter.Warning">
            <summary>
            Event raised when a non-fatal issue with the SPARQL Results being written is detected
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.SparqlTsvWriter">
            <summary>
            Class for saving SPARQL Result Sets to TSV format (not a standardised format)
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.SparqlTsvWriter.Save(VDS.RDF.Query.SparqlResultSet,System.IO.TextWriter)">
            <summary>
            Saves a SPARQL Result Set to TSV format
            </summary>
            <param name="results">Result Set</param>
            <param name="output">Writer to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.SparqlTsvWriter.RaiseWarning(System.String)">
            <summary>
            Helper Method which raises the Warning event when a non-fatal issue with the SPARQL Results being written is detected
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="M:VDS.RDF.Writing.SparqlTsvWriter.ToString">
            <summary>
            Gets the String representation of the writer which is a description of the syntax it produces
            </summary>
            <returns></returns>
        </member>
        <member name="E:VDS.RDF.Writing.SparqlTsvWriter.Warning">
            <summary>
            Event raised when a non-fatal issue with the SPARQL Results being written is detected
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.TriXWriter">
            <summary>
            Class for serialzing Triple Stores in the TriX format
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.TriXWriter.Save(VDS.RDF.ITripleStore,System.IO.TextWriter)">
            <summary>
            Saves a Store in TriX format
            </summary>
            <param name="store">Store to save</param>
            <param name="output">Writer to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.TriXWriter.RaiseWarning(System.String)">
            <summary>
            Internal Helper method which raises the Warning event only if there is an Event Handler registered
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="M:VDS.RDF.Writing.TriXWriter.ToString">
            <summary>
            Gets the String representation of the writer which is a description of the syntax it produces
            </summary>
            <returns></returns>
        </member>
        <member name="E:VDS.RDF.Writing.TriXWriter.Warning">
            <summary>
            Event which is raised when there is an issue with the Graphs being serialized that doesn't prevent serialization but the user should be aware of
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.TsvWriter">
            <summary>
            Class for generating TSV files from RDF Graphs
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.TsvWriter.Save(VDS.RDF.IGraph,System.IO.TextWriter)">
            <summary>
            Saves a Graph to TSV format
            </summary>
            <param name="g">Graph</param>
            <param name="output">Writer to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.TsvWriter.ToString">
            <summary>
            Gets the String representation of the writer which is a description of the syntax it produces
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Writing.TsvWriter.TripleFormatterType">
            <summary>
            Gets the type of the Triple Formatter used by this writer
            </summary>
        </member>
        <member name="E:VDS.RDF.Writing.TsvWriter.Warning">
            <summary>
            Event which is raised if the Writer detects a non-fatal error with the RDF being output
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.TsvStoreWriter">
            <summary>
            Class for generating TSV output from RDF Datasets
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.TsvStoreWriter.Save(VDS.RDF.ITripleStore,System.IO.TextWriter)">
            <summary>
            Saves a Triple Store to TSV format
            </summary>
            <param name="store">Triple Store to save</param>
            <param name="writer">Writer to save to</param>
        </member>
        <member name="M:VDS.RDF.Writing.TsvStoreWriter.SaveGraphs(VDS.RDF.Writing.Contexts.ThreadedStoreWriterContext)">
            <summary>
            Thread Worker method which writes Graphs to the output
            </summary>
            <param name="globalContext">Context for writing the Store</param>
        </member>
        <member name="M:VDS.RDF.Writing.TsvStoreWriter.GenerateGraphOutput(VDS.RDF.Writing.Contexts.ThreadedStoreWriterContext,VDS.RDF.Writing.Contexts.BaseWriterContext)">
            <summary>
            Generates the Output for a Graph as a String in TSV syntax
            </summary>
            <param name="globalContext">Context for writing the Store</param>
            <param name="context">Context for writing the Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.TsvStoreWriter.GenerateNodeOutput(VDS.RDF.Writing.Contexts.BaseWriterContext,VDS.RDF.INode,VDS.RDF.Writing.TripleSegment)">
            <summary>
            Generates Output for the given Node
            </summary>
            <param name="context">Writer Context</param>
            <param name="n">Node</param>
            <param name="segment">Triple Context</param>
        </member>
        <member name="M:VDS.RDF.Writing.TsvStoreWriter.ToString">
            <summary>
            Gets the String representation of the writer which is a description of the syntax it produces
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Writing.TsvStoreWriter.TripleFormatterType">
            <summary>
            Gets the type of the Triple Formatter used by this writer
            </summary>
        </member>
        <member name="E:VDS.RDF.Writing.TsvStoreWriter.Warning">
            <summary>
            Event which is raised if the Writer detects a non-fatal error with the RDF being output
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.TsvStoreWriter.SaveGraphsDelegate">
            <summary>
            Delegate for the SaveGraphs method
            </summary>
            <param name="globalContext">Context for writing the Store</param>
        </member>
        <member name="T:VDS.RDF.Writing.TurtleWriter">
            <summary>
            Class for generating RDF in Turtle Syntax
            </summary>
            <remarks>
            Similar in speed to the <see cref="T:VDS.RDF.Writing.CompressingTurtleWriter">CompressingTurtleWriter</see> but doesn't use the full Blank Node and Collection syntax compressions
            </remarks>
            <threadsafety instance="true">Designed to be Thread Safe - should be able to call the Save() method from multiple threads on different Graphs without issue</threadsafety>
        </member>
        <member name="M:VDS.RDF.Writing.TurtleWriter.#ctor">
            <summary>
            Creates a new Turtle Writer
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.TurtleWriter.#ctor(VDS.RDF.Parsing.TurtleSyntax)">
            <summary>
            Creates a new Turtle Writer
            </summary>
            <param name="syntax">Turtle Syntax</param>
        </member>
        <member name="M:VDS.RDF.Writing.TurtleWriter.Save(VDS.RDF.IGraph,System.IO.TextWriter)">
            <summary>
            Saves a Graph using an arbitrary <see cref="T:System.IO.TextWriter">TextWriter</see>
            </summary>
            <param name="g">Graph to save</param>
            <param name="output">Writer to save using</param>
        </member>
        <member name="M:VDS.RDF.Writing.TurtleWriter.GenerateOutput(VDS.RDF.Writing.Contexts.TurtleWriterContext)">
            <summary>
            Generates the Output for a Graph
            </summary>
            <param name="context">Context for writing the Graph</param>
        </member>
        <member name="M:VDS.RDF.Writing.TurtleWriter.GenerateNodeOutput(VDS.RDF.Writing.Contexts.TurtleWriterContext,VDS.RDF.INode,VDS.RDF.Writing.TripleSegment)">
            <summary>
            Generates the Output for a Node in Turtle Syntax
            </summary>
            <param name="context">Context for writing the Graph</param>
            <param name="n">Node to generate Output for</param>
            <param name="segment">Segment of the Triple being written</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.TurtleWriter.RaiseWarning(System.String)">
            <summary>
            Helper method for raising the <see cref="E:VDS.RDF.Writing.TurtleWriter.Warning">Warning</see> event
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="M:VDS.RDF.Writing.TurtleWriter.ToString">
            <summary>
            Gets the String representation of the writer which is a description of the syntax it produces
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Writing.TurtleWriter.PrettyPrintMode">
            <summary>
            Gets/Sets whether Pretty Printing is used
            </summary>
        </member>
        <member name="P:VDS.RDF.Writing.TurtleWriter.HighSpeedModePermitted">
            <summary>
            Gets/Sets whether the Writer is allowed to use High Speed write mode
            </summary>
            <remarks>High Speed Write Mode is engaged when the Writer determines that the contents of the Graph are not well suited to Turtle syntax compressions.  Usually the writer compresses triples into groups by Subject using Predicate-Object lists to output the Triples relating to each Subject.  If the number of distinct Subjects is greater than 75% of the Triples in the Graph then High Speed write mode will be used, in High Speed mode all Triples are written fully and no grouping of any sort is done.</remarks>
        </member>
        <member name="P:VDS.RDF.Writing.TurtleWriter.TripleFormatterType">
            <summary>
            Gets the type of the Triple Formatter used by this writer
            </summary>
        </member>
        <member name="E:VDS.RDF.Writing.TurtleWriter.Warning">
            <summary>
            Event which is raised when a non-fatal issue with the Graph being serialized is encountered
            </summary>
        </member>
        <member name="T:VDS.RDF.WindowsPhoneCompatibility">
            <summary>
            Extension methods for the Windows Phone builds to avoid having to do lots of #if WINDOWS_PHONE blocks
            </summary>
        </member>
        <member name="M:VDS.RDF.WindowsPhoneCompatibility.Any``2(System.Collections.Generic.IDictionary{``0,``1},System.Func{System.Collections.Generic.KeyValuePair{``0,``1},System.Boolean})">
            <summary>
            Determines whether any key value pairs meet the given criteria
            </summary>
            <typeparam name="TKey">Key Type</typeparam>
            <typeparam name="TValue">Value Type</typeparam>
            <param name="source">Dictionary to operator over</param>
            <param name="predicate">Criteria</param>
            <returns>True if any key value pair fulfils the criteria, false otherwise</returns>
        </member>
        <member name="M:VDS.RDF.WindowsPhoneCompatibility.RemoveWhere``1(VDS.RDF.HashSet{``0},System.Func{``0,System.Boolean})">
            <summary>
            Removes all elements that match a given criteria
            </summary>
            <typeparam name="T">Element Type</typeparam>
            <param name="source">Hash Set</param>
            <param name="predicate">Criteria</param>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.SetDistinctnessComparer">
            <summary>
            Comparer for checking whether sets are distinct, check may either be using the entire set or by using only a subset of variables
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.SetDistinctnessComparer.#ctor">
            <summary>
            Creates a new comparer that compares across all variables
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.SetDistinctnessComparer.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a new comparer that compare only on the specific variables
            </summary>
            <param name="variables">Variables</param>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.SetDistinctnessComparer.Equals(VDS.RDF.Query.Algebra.ISet,VDS.RDF.Query.Algebra.ISet)">
            <summary>
            Determines whether the given sets are equal
            </summary>
            <param name="x">First Set</param>
            <param name="y">Second Set</param>
            <returns>True if sets are equal, false otherwise</returns>
        </member>
        <member name="M:VDS.RDF.Query.Algebra.SetDistinctnessComparer.GetHashCode(VDS.RDF.Query.Algebra.ISet)">
            <summary>
            Gets the hash code for a set
            </summary>
            <param name="obj">Set</param>
            <returns>Hash Code</returns>
        </member>
        <member name="T:VDS.RDF.Query.Builder.IAssignmentVariableNamePart`1">
            <summary>
            Exposes method for assigning a name to an expression variable
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.IAssignmentVariableNamePart`1.As(System.String)">
            <summary>
            Set the expression's variable name
            </summary>
            <returns>the parent query or graph pattern builder</returns>
        </member>
        <member name="T:VDS.RDF.Query.Builder.IDescribeBuilder">
            <summary>
            Provides methods for creating DESCRIBE queries
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.IQueryWithVariablesBuilder.GetQueryBuilder">
            <summary>
            Creates a <see cref="T:VDS.RDF.Query.Builder.QueryBuilder"/>
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.IDescribeBuilder.And(System.String[])">
            <summary>
            Adds additional <paramref name="variables"/> to DESCRIBE
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.IDescribeBuilder.And(System.Uri[])">
            <summary>
            Adds additional <paramref name="uris"/> to DESCRIBE
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.DescribeBuilder.And(System.String[])">
            <summary>
            Adds additional <paramref name="variables"/> to DESCRIBE
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.DescribeBuilder.And(System.Uri[])">
            <summary>
            Adds additional <paramref name="uris"/> to DESCRIBE
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Builder.IDescribeGraphPatternBuilder">
            <summary>
            Interface for creating DESCRIBE queries
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.IDescribeGraphPatternBuilder.Where(VDS.RDF.Query.Patterns.ITriplePattern[])">
            <summary>
            Adds triple patterns to the SPARQL query or graph pattern
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.IDescribeGraphPatternBuilder.Where(System.Action{VDS.RDF.Query.Builder.ITriplePatternBuilder})">
            <summary>
            Adds triple patterns to the SPARQL query or graph pattern
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Builder.ExpressionBuilderRdfTermsFunctionsExtensions">
            <summary>
            Provides methods for creating SPARQL functions, which operate on RDF Terms
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderRdfTermsFunctionsExtensions.IsIRI(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.SparqlExpression)">
            <summary>
            Creates a call to the isIRI function with an expression parameter
            </summary>
            <param name="eb"> </param>
            <param name="term">any SPARQL expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderRdfTermsFunctionsExtensions.IsIRI(VDS.RDF.Query.Builder.ExpressionBuilder,System.String)">
            <summary>
            Creates a call to the isIRI function with a variable parameter
            </summary>
            <param name="eb"> </param>
            <param name="variableName">name of variable to check</param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderRdfTermsFunctionsExtensions.IsBlank(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.SparqlExpression)">
            <summary>
            Creates a call to the isBlank function with an expression parameter
            </summary>
            <param name="eb"> </param>
            <param name="term">any SPARQL expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderRdfTermsFunctionsExtensions.IsBlank(VDS.RDF.Query.Builder.ExpressionBuilder,System.String)">
            <summary>
            Creates a call to the isBlank function with a variable parameter
            </summary>
            <param name="eb"> </param>
            <param name="variableName">name of variable to check</param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderRdfTermsFunctionsExtensions.IsLiteral(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.SparqlExpression)">
            <summary>
            Creates a call to the isLiteral function with an expression parameter
            </summary>
            <param name="eb"> </param>
            <param name="term">any SPARQL expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderRdfTermsFunctionsExtensions.IsLiteral(VDS.RDF.Query.Builder.ExpressionBuilder,System.String)">
            <summary>
            Creates a call to the isLiteral function with a variable parameter
            </summary>
            <param name="eb"> </param>
            <param name="variableName">name of variable to check</param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderRdfTermsFunctionsExtensions.IsNumeric(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.SparqlExpression)">
            <summary>
            Creates a call to the isNumeric function with an expression parameter
            </summary>
            <param name="eb"> </param>
            <param name="term">any SPARQL expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderRdfTermsFunctionsExtensions.IsNumeric(VDS.RDF.Query.Builder.ExpressionBuilder,System.String)">
            <summary>
            Creates a call to the isNumeric function with a variable parameter
            </summary>
            <param name="eb"> </param>
            <param name="variableName">name of variable to check</param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderRdfTermsFunctionsExtensions.Str(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.VariableExpression)">
            <summary>
            Creates a call to the STR function with a variable parameter
            </summary>
            <param name="eb"> </param>
            <param name="variable">a SPARQL variable</param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderRdfTermsFunctionsExtensions.Str(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.LiteralExpression)">
            <summary>
            Creates a call to the STR function with a literal expression parameter
            </summary>
            <param name="eb"> </param>
            <param name="literal">a SPARQL literal expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderRdfTermsFunctionsExtensions.Str(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.IriExpression)">
            <summary>
            Creates a call to the STR function with an variable parameter
            </summary>
            <param name="eb"> </param>
            <param name="iriTerm">an RDF IRI term</param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderRdfTermsFunctionsExtensions.Lang(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.VariableExpression)">
            <summary>
            Creates a call to the LANG function with a variable parameter
            </summary>
            <param name="eb"> </param>
            <param name="variable">a SPARQL variable</param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderRdfTermsFunctionsExtensions.Lang(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.LiteralExpression)">
            <summary>
            Creates a call to the LANG function with a literal expression parameter
            </summary>
            <param name="eb"> </param>
            <param name="literal">a SPARQL literal expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderRdfTermsFunctionsExtensions.Datatype(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.VariableExpression)">
            <summary>
            Creates a call to the DATATYPE function with a variable parameter
            </summary>
            <param name="eb"> </param>
            <param name="variable">a SPARQL variable</param>
            <remarks>depending on <see cref="P:VDS.RDF.Query.Builder.ExpressionBuilder.SparqlVersion"/> will use a different flavour of datatype function</remarks>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderRdfTermsFunctionsExtensions.Datatype(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.LiteralExpression)">
            <summary>
            Creates a call to the DATATYPE function with a literal expression parameter
            </summary>
            <param name="eb"> </param>
            <param name="literal">a SPARQL literal expression</param>
            <remarks>depending on <see cref="P:VDS.RDF.Query.Builder.ExpressionBuilder.SparqlVersion"/> will use a different flavour of datatype function</remarks>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderRdfTermsFunctionsExtensions.BNode(VDS.RDF.Query.Builder.ExpressionBuilder)">
            <summary>
            Creates a parameterless call to the BNODE function
            </summary>
            <param name="eb"> </param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderRdfTermsFunctionsExtensions.BNode(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.LiteralExpression)">
            <summary>
            Creates a call to the BNODE function with a simple literal parameter
            </summary>
            <param name="eb"> </param>
            <param name="simpleLiteral">a SPARQL simple literal</param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderRdfTermsFunctionsExtensions.BNode(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.TypedLiteralExpression{System.String})">
            <summary>
            Creates a call to the BNODE function with a string literal parameter
            </summary>
            <param name="eb"> </param>
            <param name="stringLiteral">a SPARQL string literal</param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderRdfTermsFunctionsExtensions.StrDt(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.LiteralExpression,VDS.RDF.Query.Builder.Expressions.IriExpression)">
            <summary>
            Creates a call to the STRDT function with a simple literal and a IRI expression parameters
            </summary>
            <param name="eb"> </param>
            <param name="lexicalForm">a SPARQL simple literal</param>
            <param name="datatypeIri">datatype IRI</param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderRdfTermsFunctionsExtensions.StrDt(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.LiteralExpression,System.Uri)">
            <summary>
            Creates a call to the STRDT function with a simple literal and a <see cref="T:System.Uri"/> parameters
            </summary>
            <param name="eb"> </param>
            <param name="lexicalForm">a SPARQL simple literal</param>
            <param name="datatypeIri">datatype IRI</param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderRdfTermsFunctionsExtensions.StrDt(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.LiteralExpression,VDS.RDF.Query.Builder.Expressions.VariableExpression)">
            <summary>
            Creates a call to the STRDT function with a simple literal and a variable parameters
            </summary>
            <param name="eb"> </param>
            <param name="lexicalForm">a SPARQL simple literal</param>
            <param name="datatypeIri">datatype IRI</param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderRdfTermsFunctionsExtensions.StrDt(VDS.RDF.Query.Builder.ExpressionBuilder,System.String,VDS.RDF.Query.Builder.Expressions.IriExpression)">
            <summary>
            Creates a call to the STRDT function with a simple literal and a IRI expression parameters
            </summary>
            <param name="eb"> </param>
            <param name="lexicalForm">a literal</param>
            <param name="datatypeIri">datatype IRI</param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderRdfTermsFunctionsExtensions.StrDt(VDS.RDF.Query.Builder.ExpressionBuilder,System.String,VDS.RDF.Query.Builder.Expressions.VariableExpression)">
            <summary>
            Creates a call to the STRDT function with a simple literal and a IRI expression parameters
            </summary>
            <param name="eb"> </param>
            <param name="lexicalForm">a literal</param>
            <param name="datatypeIri">datatype IRI</param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderRdfTermsFunctionsExtensions.StrDt(VDS.RDF.Query.Builder.ExpressionBuilder,System.String,System.Uri)">
            <summary>
            Creates a call to the STRDT function with a simple literal and a <see cref="T:System.Uri"/> parameters
            </summary>
            <param name="eb"> </param>
            <param name="lexicalForm">a literal</param>
            <param name="datatypeIri">datatype IRI</param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderRdfTermsFunctionsExtensions.StrDt(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.VariableExpression,System.Uri)">
            <summary>
            Creates a call to the STRDT function with a variable and a <see cref="T:System.Uri"/> parameters
            </summary>
            <param name="eb"> </param>
            <param name="lexicalForm">a literal</param>
            <param name="datatypeIri">datatype IRI</param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderRdfTermsFunctionsExtensions.StrDt(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.VariableExpression,VDS.RDF.Query.Builder.Expressions.VariableExpression)">
            <summary>
            Creates a call to the STRDT function with a variable and a <see cref="T:System.Uri"/> parameters
            </summary>
            <param name="eb"> </param>
            <param name="lexicalForm">a literal</param>
            <param name="datatypeIri">datatype IRI</param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderRdfTermsFunctionsExtensions.StrDt(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.VariableExpression,VDS.RDF.Query.Builder.Expressions.IriExpression)">
            <summary>
            Creates a call to the STRDT function with a variable and a IRI expression parameters
            </summary>
            <param name="eb"> </param>
            <param name="lexicalForm">a literal</param>
            <param name="datatypeIri">datatype IRI</param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderRdfTermsFunctionsExtensions.UUID(VDS.RDF.Query.Builder.ExpressionBuilder)">
            <summary>
            Creates a call to the UUID function
            </summary>
            <param name="eb"> </param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderRdfTermsFunctionsExtensions.StrUUID(VDS.RDF.Query.Builder.ExpressionBuilder)">
            <summary>
            Creates a call to the StrUUID function
            </summary>
            <param name="eb"> </param>
        </member>
        <member name="T:VDS.RDF.Query.Builder.Expressions.BlankNodeExpression">
            <summary>
            Represents a blank node RDF term expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Builder.Expressions.RdfTermExpression">
            <summary>
            Represents a RDF term expression (IRI, literal or blank node)
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Builder.Expressions.SparqlExpression">
            <summary>
            Represents a SPARQL expression (variable, function, operator or term)
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.Expressions.SparqlExpression.In(VDS.RDF.Query.Builder.Expressions.SparqlExpression[])">
            <summary>
            Creates a call to the IN function
            </summary>
            <param name="expressions">the list of SPARQL expressions</param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.Expressions.SparqlExpression.Gt(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a greater than operator usage
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.Expressions.SparqlExpression.Lt(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a less than operator usage
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.Expressions.SparqlExpression.Ge(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a greater than or equal operator usage
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.Expressions.SparqlExpression.Le(VDS.RDF.Query.Expressions.ISparqlExpression,VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Creates a less than or equal operator usage
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Builder.Expressions.SparqlExpression.Expression">
            <summary>
            The undelrying expression
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.Expressions.RdfTermExpression.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Wraps the <paramref name="expression"/> as an RDF term expression
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.Expressions.BlankNodeExpression.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Wraps the <paramref name="expression"/> as a blank node expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Builder.Expressions.BooleanExpression">
            <summary>
            Represents a logical expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Builder.Expressions.TypedLiteralExpression`1">
            <summary>
            Represents a typed literal
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Builder.Expressions.LiteralExpression">
            <summary>
            Represents a literal expression
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.Expressions.LiteralExpression.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Wraps the <paramref name="expression"/> as a literal expression
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.Expressions.TypedLiteralExpression`1.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Wraps the <paramref name="expression"/> as a typed literal expression
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.Expressions.BooleanExpression.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Wraps the <paramref name="expression"/> as a boolean expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Builder.ExpressionBuilder">
            <summary>
            Provides methods for building SPARQL expressions
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilder.Variable(System.String)">
            <summary>
            Creates a SPARQL variable
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilder.Constant(System.String)">
            <summary>
            Creates a string constant 
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilder.Constant(System.Int32)">
            <summary>
            Creates a numeric constant 
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilder.Constant(System.Decimal)">
            <summary>
            Creates a numeric constant 
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilder.Constant(System.Single)">
            <summary>
            Creates a numeric constant 
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilder.Constant(System.Double)">
            <summary>
            Creates a numeric constant 
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilder.Constant(System.Boolean)">
            <summary>
            Creates a boolean constant 
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilder.Constant(System.Byte)">
            <summary>
            Creates a numeric constant 
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilder.Constant(System.SByte)">
            <summary>
            Creates a numeric constant 
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilder.Constant(System.Int16)">
            <summary>
            Creates a numeric constant 
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilder.Constant(System.DateTime)">
            <summary>
            Creates a datetime constant 
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilder.Constant(System.Uri)">
            <summary>
            Creates an IRI constant 
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilder.Cast(VDS.RDF.Query.Builder.Expressions.SparqlExpression)">
            <summary>
            Builds a SPARQL constructor function call
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Builder.ExpressionBuilder.SparqlVersion">
            <summary>
            SPARQL syntax verions to use when creating expressions
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Builder.ExpressionBuilderFunctionalFormsExtensions">
            <summary>
            Provides methods for creating SPARQL functional forms
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderFunctionalFormsExtensions.Bound(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.VariableExpression)">
            <summary>
            Creates a call to the BOUND function with a variable parameter
            </summary>
            <param name="eb"></param>
            <param name="var">a SPARQL variable</param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderFunctionalFormsExtensions.Bound(VDS.RDF.Query.Builder.ExpressionBuilder,System.String)">
            <summary>
            Creates a call to the BOUND function with a variable parameter
            </summary>
            <param name="eb"></param>
            <param name="var">a SPARQL variable name</param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderFunctionalFormsExtensions.If(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.BooleanExpression)">
            <summary>
            Creates a call to the IF function with an expression for the first parameter
            </summary>
            <param name="eb"></param>
            <param name="ifExpression">conditional clause expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderFunctionalFormsExtensions.If(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.VariableExpression)">
            <summary>
            Creates a call to the IF function with a variable for the first parameter
            </summary>
            <param name="eb"></param>
            <param name="ifExpression">conditional clause variable expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderFunctionalFormsExtensions.Coalesce(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.SparqlExpression[])">
            <summary>
            Creates a call of the COALESCE function with a variable number of expression parameters
            </summary>
            <param name="eb"></param>
            <param name="expressions">SPARQL expressions</param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderFunctionalFormsExtensions.Exists(VDS.RDF.Query.Builder.ExpressionBuilder,System.Action{VDS.RDF.Query.Builder.IGraphPatternBuilder})">
            <summary>
            Creates a call of the EXISTS function
            </summary>
            <param name="eb"></param>
            <param name="buildExistsPattern">a function, which will create the graph pattern parameter</param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderFunctionalFormsExtensions.SameTerm(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.SparqlExpression,VDS.RDF.Query.Builder.Expressions.SparqlExpression)">
            <summary>
            Creates a call of the SAMETERM function with two expression parameters
            </summary>
            <param name="eb"></param>
            <param name="left">a SPARQL expression</param>
            <param name="right">a SPARQL expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderFunctionalFormsExtensions.SameTerm(VDS.RDF.Query.Builder.ExpressionBuilder,System.String,VDS.RDF.Query.Builder.Expressions.SparqlExpression)">
            <summary>
            Creates a call of the SAMETERM function with variable and expression parameters
            </summary>
            <param name="eb"></param>
            <param name="left">a variable name</param>
            <param name="right">a SPARQL expression</param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderFunctionalFormsExtensions.SameTerm(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.SparqlExpression,System.String)">
            <summary>
            Creates a call of the SAMETERM function with expression and variable parameters
            </summary>
            <param name="eb"></param>
            <param name="left">a SPARQL expression</param>
            <param name="right">a variable name</param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderFunctionalFormsExtensions.SameTerm(VDS.RDF.Query.Builder.ExpressionBuilder,System.String,System.String)">
            <summary>
            Creates a call of the SAMETERM function with two variable parameters
            </summary>
            <param name="eb"></param>
            <param name="left">a variable name</param>
            <param name="right">a variable name</param>
        </member>
        <member name="T:VDS.RDF.Query.Builder.IfThenPart">
            <summary>
            Provides methods to supply the "then" expression for the IF function call
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.IfThenPart.Then(VDS.RDF.Query.Builder.Expressions.SparqlExpression)">
            <summary>
            Sets the second parameter of the IF function call
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Builder.IfElsePart">
            <summary>
            Provides methods to supply the "else" expression for the IF function call
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.IfElsePart.Else(VDS.RDF.Query.Builder.Expressions.SparqlExpression)">
            <summary>
            Sets the third parameter of the IF function call
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Builder.ExpressionBuilderStringExtensions">
            <summary>
            Provides methods for creating SPARQL functions, which operate on strings
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderStringExtensions.Regex(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.VariableExpression,System.String)">
            <summary>
            Creates a call to the REGEX function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderStringExtensions.Regex(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.VariableExpression,VDS.RDF.Query.Builder.Expressions.VariableExpression)">
            <summary>
            Creates a call to the REGEX function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderStringExtensions.Regex(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.LiteralExpression,System.String)">
            <summary>
            Creates a call to the REGEX function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderStringExtensions.Regex(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.LiteralExpression,VDS.RDF.Query.Builder.Expressions.LiteralExpression)">
            <summary>
            Creates a call to the REGEX function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderStringExtensions.Regex(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.LiteralExpression,VDS.RDF.Query.Builder.Expressions.VariableExpression)">
            <summary>
            Creates a call to the REGEX function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderStringExtensions.Regex(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.SparqlExpression,System.String,System.String)">
            <summary>
            Creates a call to the REGEX function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderStringExtensions.Regex(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.VariableExpression,VDS.RDF.Query.Builder.Expressions.VariableExpression,System.String)">
            <summary>
            Creates a call to the REGEX function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderStringExtensions.Regex(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.LiteralExpression,System.String,System.String)">
            <summary>
            Creates a call to the REGEX function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderStringExtensions.Regex(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.LiteralExpression,VDS.RDF.Query.Builder.Expressions.LiteralExpression,System.String)">
            <summary>
            Creates a call to the REGEX function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderStringExtensions.Regex(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.LiteralExpression,VDS.RDF.Query.Builder.Expressions.VariableExpression,System.String)">
            <summary>
            Creates a call to the REGEX function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderStringExtensions.StrLen(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.VariableExpression)">
            <summary>
            Creates a call to the STRLEN function with a variable parameter
            </summary>
            <param name="eb"> </param>
            <param name="str">a SPARQL variable</param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderStringExtensions.StrLen(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.TypedLiteralExpression{System.String})">
            <summary>
            Creates a call to the STRLEN function with a string literal parameter
            </summary>
            <param name="eb"> </param>
            <param name="str">a string literal parameter</param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderStringExtensions.Substr(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.TypedLiteralExpression{System.String},VDS.RDF.Query.Builder.Expressions.NumericExpression{System.Int32})">
            <summary>
            Creates a call to the SUBSTR function with a string literal and variable parameters
            </summary>
            <param name="eb"> </param>
            <param name="str">a string literal parameter</param>
            <param name="startingLoc">1-based start index</param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderStringExtensions.Substr(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.TypedLiteralExpression{System.String},VDS.RDF.Query.Builder.Expressions.VariableExpression)">
            <summary>
            Creates a call to the SUBSTR function with a string literal and interger expression parameters
            </summary>
            <param name="eb"> </param>
            <param name="str">a string literal parameter</param>
            <param name="startingLoc">a SPARQL variable</param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderStringExtensions.Substr(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.TypedLiteralExpression{System.String},System.Int32)">
            <summary>
            Creates a call to the SUBSTR function with a string literal and interger parameters
            </summary>
            <param name="eb"> </param>
            <param name="str">a string literal parameter</param>
            <param name="startingLoc">1-based start index</param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderStringExtensions.Substr(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.VariableExpression,VDS.RDF.Query.Builder.Expressions.NumericExpression{System.Int32})">
            <summary>
            Creates a call to the SUBSTR function with a variable and interger expression parameters
            </summary>
            <param name="eb"> </param>
            <param name="str">a SPARQL variable</param>
            <param name="startingLoc">1-based start index</param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderStringExtensions.Substr(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.VariableExpression,System.Int32)">
            <summary>
            Creates a call to the SUBSTR function with a variable and interger parameters
            </summary>
            <param name="eb"> </param>
            <param name="str">a SPARQL variable</param>
            <param name="startingLoc">1-based start index</param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderStringExtensions.Substr(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.VariableExpression,VDS.RDF.Query.Builder.Expressions.VariableExpression)">
            <summary>
            Creates a call to the SUBSTR function with two variable parameters
            </summary>
            <param name="eb"> </param>
            <param name="str">a SPARQL variable</param>
            <param name="startingLoc">a SPARQL variable</param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderStringExtensions.Substr(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.TypedLiteralExpression{System.String},VDS.RDF.Query.Builder.Expressions.NumericExpression{System.Int32},System.Int32)">
            <summary>
            Creates a call to the SUBSTR function with a string literal and variable parameters
            </summary>
            <param name="eb"> </param>
            <param name="str">a string literal parameter</param>
            <param name="startingLoc">1-based start index</param>
            <param name="length">substring length </param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderStringExtensions.Substr(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.TypedLiteralExpression{System.String},VDS.RDF.Query.Builder.Expressions.VariableExpression,System.Int32)">
            <summary>
            Creates a call to the SUBSTR function with a string literal and interger expression parameters
            </summary>
            <param name="eb"> </param>
            <param name="str">a string literal parameter</param>
            <param name="startingLoc">a SPARQL variable</param>
            <param name="length">substring length </param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderStringExtensions.Substr(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.TypedLiteralExpression{System.String},System.Int32,System.Int32)">
            <summary>
            Creates a call to the SUBSTR function with a string literal and interger parameters
            </summary>
            <param name="eb"> </param>
            <param name="str">a string literal parameter</param>
            <param name="startingLoc">1-based start index</param>
            <param name="length">substring length </param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderStringExtensions.Substr(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.VariableExpression,VDS.RDF.Query.Builder.Expressions.NumericExpression{System.Int32},System.Int32)">
            <summary>
            Creates a call to the SUBSTR function with a variable and interger expression parameters
            </summary>
            <param name="eb"> </param>
            <param name="str">a SPARQL variable</param>
            <param name="startingLoc">1-based start index</param>
            <param name="length">substring length </param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderStringExtensions.Substr(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.VariableExpression,System.Int32,System.Int32)">
            <summary>
            Creates a call to the SUBSTR function with a variable and interger parameters
            </summary>
            <param name="eb"> </param>
            <param name="str">a SPARQL variable</param>
            <param name="startingLoc">1-based start index</param>
            <param name="length">substring length </param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderStringExtensions.Substr(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.VariableExpression,VDS.RDF.Query.Builder.Expressions.VariableExpression,System.Int32)">
            <summary>
            Creates a call to the SUBSTR function with two variable parameters
            </summary>
            <param name="eb"> </param>
            <param name="str">a SPARQL variable</param>
            <param name="startingLoc">a SPARQL variable</param>
            <param name="length">substring length </param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderStringExtensions.Substr(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.TypedLiteralExpression{System.String},VDS.RDF.Query.Builder.Expressions.NumericExpression{System.Int32},VDS.RDF.Query.Builder.Expressions.NumericExpression{System.Int32})">
            <summary>
            Creates a call to the SUBSTR function with a string literal and two integer expressions parameters
            </summary>
            <param name="eb"> </param>
            <param name="str">a string literal parameter</param>
            <param name="startingLoc">1-based start index</param>
            <param name="length">substring length </param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderStringExtensions.Substr(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.TypedLiteralExpression{System.String},VDS.RDF.Query.Builder.Expressions.VariableExpression,VDS.RDF.Query.Builder.Expressions.NumericExpression{System.Int32})">
            <summary>
            Creates a call to the SUBSTR function with a string literal, variable and interger expression parameters
            </summary>
            <param name="eb"> </param>
            <param name="str">a string literal parameter</param>
            <param name="startingLoc">a SPARQL variable</param>
            <param name="length">substring length </param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderStringExtensions.Substr(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.TypedLiteralExpression{System.String},System.Int32,VDS.RDF.Query.Builder.Expressions.NumericExpression{System.Int32})">
            <summary>
            Creates a call to the SUBSTR function with a string literal, interger and integer expression parameters
            </summary>
            <param name="eb"> </param>
            <param name="str">a string literal parameter</param>
            <param name="startingLoc">1-based start index</param>
            <param name="length">substring length </param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderStringExtensions.Substr(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.VariableExpression,VDS.RDF.Query.Builder.Expressions.NumericExpression{System.Int32},VDS.RDF.Query.Builder.Expressions.NumericExpression{System.Int32})">
            <summary>
            Creates a call to the SUBSTR function with a variable, interger expression and integer expression parameters
            </summary>
            <param name="eb"> </param>
            <param name="str">a SPARQL variable</param>
            <param name="startingLoc">1-based start index</param>
            <param name="length">substring length </param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderStringExtensions.Substr(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.VariableExpression,System.Int32,VDS.RDF.Query.Builder.Expressions.NumericExpression{System.Int32})">
            <summary>
            Creates a call to the SUBSTR function with a variable, interger and a numeric expression parameters
            </summary>
            <param name="eb"> </param>
            <param name="str">a SPARQL variable</param>
            <param name="startingLoc">1-based start index</param>
            <param name="length">substring length </param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderStringExtensions.Substr(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.VariableExpression,VDS.RDF.Query.Builder.Expressions.VariableExpression,VDS.RDF.Query.Builder.Expressions.NumericExpression{System.Int32})">
            <summary>
            Creates a call to the SUBSTR function with two variable parameters
            </summary>
            <param name="eb"> </param>
            <param name="str">a SPARQL variable</param>
            <param name="startingLoc">a SPARQL variable</param>
            <param name="length">substring length </param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderStringExtensions.Substr(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.TypedLiteralExpression{System.String},VDS.RDF.Query.Builder.Expressions.NumericExpression{System.Int32},VDS.RDF.Query.Builder.Expressions.VariableExpression)">
            <summary>
            Creates a call to the SUBSTR function with a string literal, interger expression and a numeric expression parameters
            </summary>
            <param name="eb"> </param>
            <param name="str">a string literal parameter</param>
            <param name="startingLoc">1-based start index</param>
            <param name="length">substring length </param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderStringExtensions.Substr(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.TypedLiteralExpression{System.String},VDS.RDF.Query.Builder.Expressions.VariableExpression,VDS.RDF.Query.Builder.Expressions.VariableExpression)">
            <summary>
            Creates a call to the SUBSTR function with a string literal, interger expression and a variable parameters
            </summary>
            <param name="eb"> </param>
            <param name="str">a string literal parameter</param>
            <param name="startingLoc">a SPARQL variable</param>
            <param name="length">substring length </param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderStringExtensions.Substr(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.TypedLiteralExpression{System.String},System.Int32,VDS.RDF.Query.Builder.Expressions.VariableExpression)">
            <summary>
            Creates a call to the SUBSTR function with a string literal, interger and a variable parameters
            </summary>
            <param name="eb"> </param>
            <param name="str">a string literal parameter</param>
            <param name="startingLoc">1-based start index</param>
            <param name="length">substring length </param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderStringExtensions.Substr(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.VariableExpression,VDS.RDF.Query.Builder.Expressions.NumericExpression{System.Int32},VDS.RDF.Query.Builder.Expressions.VariableExpression)">
            <summary>
            Creates a call to the SUBSTR function with a variable, interger expression and a variable parameters
            </summary>
            <param name="eb"> </param>
            <param name="str">a SPARQL variable</param>
            <param name="startingLoc">1-based start index</param>
            <param name="length">substring length </param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderStringExtensions.Substr(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.VariableExpression,System.Int32,VDS.RDF.Query.Builder.Expressions.VariableExpression)">
            <summary>
            Creates a call to the SUBSTR function with a variable, interger and a variable parameters
            </summary>
            <param name="eb"> </param>
            <param name="str">a SPARQL variable</param>
            <param name="startingLoc">1-based start index</param>
            <param name="length">substring length </param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderStringExtensions.Substr(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.VariableExpression,VDS.RDF.Query.Builder.Expressions.VariableExpression,VDS.RDF.Query.Builder.Expressions.VariableExpression)">
            <summary>
            Creates a call to the SUBSTR function with three variable parameters
            </summary>
            <param name="eb"> </param>
            <param name="str">a SPARQL variable</param>
            <param name="startingLoc">a SPARQL variable</param>
            <param name="length">substring length </param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderStringExtensions.LangMatches(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.LiteralExpression,System.String)">
            <summary>
            Creates a call to the LANGMATCHES function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderStringExtensions.LangMatches(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.VariableExpression,System.String)">
            <summary>
            Creates a call to the LANGMATCHES function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderStringExtensions.LangMatches(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.LiteralExpression,VDS.RDF.Query.Builder.Expressions.LiteralExpression)">
            <summary>
            Creates a call to the LANGMATCHES function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderStringExtensions.LangMatches(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.VariableExpression,VDS.RDF.Query.Builder.Expressions.LiteralExpression)">
            <summary>
            Creates a call to the LANGMATCHES function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderStringExtensions.LangMatches(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.LiteralExpression,VDS.RDF.Query.Builder.Expressions.VariableExpression)">
            <summary>
            Creates a call to the LANGMATCHES function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ExpressionBuilderStringExtensions.LangMatches(VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.VariableExpression,VDS.RDF.Query.Builder.Expressions.VariableExpression)">
            <summary>
            Creates a call to the LANGMATCHES function
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.Expressions.LiteralExpressionExtensions.ToConstantTerm``1(``0)">
            <summary>
            Creates a typed literal term
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.Expressions.LiteralExpressionExtensions.ToSimpleLiteral(System.String)">
            <summary>
            Creates an untyped literal term (simple literal)
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Builder.Expressions.NumericExpression`1">
            <summary>
            Represents a numeric expression of known type
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.Expressions.NumericExpression`1.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Wraps the <paramref name="expression"/> as a typed numeric expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Builder.Expressions.NumericExpression">
            <summary>
            Represents a numeric expression of undefined type
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.Expressions.NumericExpression.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Wraps the <paramref name="expression"/> as a numeric expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Builder.Expressions.VariableExpression">
            <summary>
            Represents an expression, which evaluates to a variable
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Builder.Expressions.VariableExpression.Expression">
            <summary>
            Gets the <see cref="T:VDS.RDF.Query.Expressions.Primary.VariableTerm"/> represented by this variable expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Builder.Expressions.IriExpression">
            <summary>
            Represents a IRI expression
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.Expressions.IriExpression.#ctor(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Wraps the <paramref name="expression"/> as an IRI expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Builder.IGraphPatternBuilder">
            <summary>
            Provides methods for building graph patterns
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.IGraphPatternBuilder.Union(System.Action{VDS.RDF.Query.Builder.IGraphPatternBuilder})">
            <summary>
            Creates a UNION of the current graph pattern and a new one
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.IGraphPatternBuilder.Where(VDS.RDF.Query.Patterns.ITriplePattern[])">
            <summary>
            Adds triple patterns to the SPARQL query or graph pattern
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.IGraphPatternBuilder.Where(System.Action{VDS.RDF.Query.Builder.ITriplePatternBuilder})">
            <summary>
            Adds triple patterns to the SPARQL query or graph pattern
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.IGraphPatternBuilder.Optional(System.Action{VDS.RDF.Query.Builder.IGraphPatternBuilder})">
            <summary>
            Adds an OPTIONAL graph pattern to the SPARQL query or graph pattern
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.IGraphPatternBuilder.Filter(System.Func{VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.BooleanExpression})">
            <summary>
            Adds a FILTER to the SPARQL query or graph pattern
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.IGraphPatternBuilder.Filter(VDS.RDF.Query.Expressions.ISparqlExpression)">
            <summary>
            Adds a FILTER expression to the SPARQL query or graph pattern
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.IGraphPatternBuilder.Minus(System.Action{VDS.RDF.Query.Builder.IGraphPatternBuilder})">
            <summary>
            Adds a MINUS graph pattern to the SPARQL query or graph pattern
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.IGraphPatternBuilder.Graph(System.Uri,System.Action{VDS.RDF.Query.Builder.IGraphPatternBuilder})">
            <summary>
            Adds a GRAPH graph pattern to the graph pattern
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.IGraphPatternBuilder.Graph(System.String,System.Action{VDS.RDF.Query.Builder.IGraphPatternBuilder})">
            <summary>
            Adds a GRAPH graph pattern to the graph pattern
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.IGraphPatternBuilder.Service(System.Uri,System.Action{VDS.RDF.Query.Builder.IGraphPatternBuilder})">
            <summary>
            Adds a SERVICE graph pattern to the graph pattern
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.IGraphPatternBuilder.Bind(System.Func{VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.SparqlExpression})">
            <summary>
            Adds a BIND variable assignment to the graph pattern
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.IGraphPatternBuilder.Child(System.Action{VDS.RDF.Query.Builder.IGraphPatternBuilder})">
            <summary>
            Addsa "normal" child graph pattern
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.GraphPatternBuilder.#ctor">
            <summary>
            Creates a builder of a normal graph patterns
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.GraphPatternBuilder.#ctor(VDS.RDF.Query.Builder.GraphPatternType)">
            <summary>
            Creates a builder of a graph pattern
            </summary>
            <param name="graphPatternType">MINUS, GRAPH, SERVICE etc.</param>
        </member>
        <member name="T:VDS.RDF.Query.Builder.ISelectBuilder">
            <summary>
            Interface for creating SELECT queries
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ISelectBuilder.And(VDS.RDF.Query.SparqlVariable[])">
            <summary>
            Adds additional SELECT return <paramref name="variables"/>
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ISelectBuilder.And(System.String[])">
            <summary>
            Adds additional SELECT return <paramref name="variables"/>
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ISelectBuilder.And(System.Func{VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.SparqlExpression})">
            <summary>
            Adds additional SELECT expression
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ISelectBuilder.Distinct">
            <summary>
            Applies the DISTINCT modifier if the Query is a SELECT, otherwise leaves query unchanged (since results from any other query are DISTINCT by default)
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Builder.ITriplePatternBuilder">
            <summary>
            Provides methods for building triple patterns
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ITriplePatternBuilder.Subject(System.String)">
            <summary>
            Sets a variable as <see cref="P:VDS.RDF.Query.Patterns.IMatchTriplePattern.Subject"/>
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ITriplePatternBuilder.Subject``1(System.String)">
            <summary>
            Depending on the generic parameter type, sets a literal, a QName or a blank node as <see cref="P:VDS.RDF.Query.Patterns.IMatchTriplePattern.Subject"/>
            </summary>
            <param name="subject">Either a variable name, a literal, a QName or a blank node identifier</param>
            <remarks>A relevant prefix/base URI must be added to <see cref="!:ICommonQueryBuilder.Prefixes"/> to accept a QName</remarks>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ITriplePatternBuilder.Subject(VDS.RDF.INode)">
            <summary>
            Depending on the <paramref name="subjectNode"/>'s type, sets a literal, a QName or a blank node as <see cref="P:VDS.RDF.Query.Patterns.IMatchTriplePattern.Subject"/>
            </summary>
            <remarks>A relevant prefix/base URI must be added to <see cref="!:ICommonQueryBuilder.Prefixes"/> to accept a QName</remarks>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ITriplePatternBuilder.Subject(System.Uri)">
            <summary>
            Sets a <see cref="T:System.Uri"/> as <see cref="P:VDS.RDF.Query.Patterns.IMatchTriplePattern.Subject"/>
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.ITriplePatternBuilder.Subject(VDS.RDF.Query.Patterns.PatternItem)">
            <summary>
            Sets a <see cref="T:VDS.RDF.Query.Patterns.PatternItem"/> as <see cref="P:VDS.RDF.Query.Patterns.IMatchTriplePattern.Subject"/>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Builder.PatternItemFactory">
            <summary>
            Class responsible for creating <see cref="T:VDS.RDF.Query.Patterns.PatternItem"/>s
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.QueryBuilderExtensions.BuildQuery(VDS.RDF.Query.Builder.IDescribeBuilder)">
            <summary>
            Builds a simple DESCRIBE query without the WHERE part
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.SelectBuilder.And(VDS.RDF.Query.SparqlVariable[])">
            <summary>
            Adds additional SELECT <paramref name="variables"/>
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.SelectBuilder.And(System.Func{VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.SparqlExpression})">
            <summary>
            Adds additional SELECT expression
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.SelectBuilder.And(System.String[])">
            <summary>
            Adds additional SELECT <paramref name="variables"/>
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.SelectBuilder.Distinct">
            <summary>
            Applies the DISTINCT modifier if the Query is a SELECT, otherwise leaves query unchanged (since results from any other query are DISTINCT by default)
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Builder.SparqlCastBuilder">
            <summary>
            Provides methods for casting expressions to XPath types
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.SparqlCastBuilder.AsInteger">
            <summary>
            Creates a cast to xsd:integer
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.SparqlCastBuilder.AsDouble">
            <summary>
            Creates a cast to xsd:double
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.SparqlCastBuilder.AsDecimal">
            <summary>
            Creates a cast to xsd:decimal
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.SparqlCastBuilder.AsDateTime">
            <summary>
            Creates a cast to xsd:dateTime
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.SparqlCastBuilder.AsFloat">
            <summary>
            Creates a cast to xsd:float
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.SparqlCastBuilder.AsBoolean">
            <summary>
            Creates a cast to xsd:boolean
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.SparqlCastBuilder.AsString">
            <summary>
            Creates a cast to xsd:string
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Builder.TriplePatternObjectPart">
            <summary>
            Class responsible for setting the object part of triple patterns
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.TriplePatternObjectPart.Object(System.String)">
            <summary>
            Sets a SPARQL variable as <see cref="P:VDS.RDF.Query.Patterns.IMatchTriplePattern.Object"/>
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.TriplePatternObjectPart.Object``1(System.String)">
            <summary>
            Depending on the generic parameter type, sets a literal, a QName or a blank node as <see cref="P:VDS.RDF.Query.Patterns.IMatchTriplePattern.Object"/>
            </summary>
            <param name="object">Either a variable name, a literal, a QName or a blank node identifier</param>
            <remarks>A relevant prefix/base URI must be added to <see cref="P:VDS.RDF.Query.Builder.IQueryBuilder.Prefixes"/> to accept a QName</remarks>
        </member>
        <member name="M:VDS.RDF.Query.Builder.TriplePatternObjectPart.Object(VDS.RDF.INode)">
            <summary>
            Depending on the <paramref name="objectNode"/>'s type, sets a literal, a QName or a blank node as <see cref="P:VDS.RDF.Query.Patterns.IMatchTriplePattern.Object"/>
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.TriplePatternObjectPart.Object(System.Uri)">
            <summary>
            Sets a <see cref="T:System.Uri"/> as <see cref="P:VDS.RDF.Query.Patterns.IMatchTriplePattern.Object"/>
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.TriplePatternObjectPart.ObjectLiteral(System.Object)">
            <summary>
            Sets a plain literal as <see cref="P:VDS.RDF.Query.Patterns.IMatchTriplePattern.Object"/>
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.TriplePatternObjectPart.ObjectLiteral(System.Object,System.String)">
            <summary>
            Sets a literal with language tag as <see cref="P:VDS.RDF.Query.Patterns.IMatchTriplePattern.Object"/>
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.TriplePatternObjectPart.ObjectLiteral(System.Object,System.Uri)">
            <summary>
            Sets a typed literal as <see cref="P:VDS.RDF.Query.Patterns.IMatchTriplePattern.Object"/>
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.TriplePatternObjectPart.Object(VDS.RDF.Query.Patterns.PatternItem)">
            <summary>
            Sets a <see cref="T:VDS.RDF.Query.Patterns.PatternItem"/> as <see cref="P:VDS.RDF.Query.Patterns.IMatchTriplePattern.Object"/>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Builder.TriplePatternPredicatePart">
            <summary>
            Class responsible for setting the predicate part of triple patterns
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.TriplePatternPredicatePart.Predicate(System.String)">
            <summary>
            Sets a SPARQL variable as <see cref="P:VDS.RDF.Query.Patterns.IMatchTriplePattern.Predicate"/>
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.TriplePatternPredicatePart.Predicate(VDS.RDF.Query.Patterns.PatternItem)">
            <summary>
            Sets a <see cref="T:VDS.RDF.Query.Patterns.PatternItem"/> as <see cref="P:VDS.RDF.Query.Patterns.IMatchTriplePattern.Predicate"/>
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.TriplePatternPredicatePart.PredicateUri(System.Uri)">
            <summary>
            Sets a <see cref="T:System.Uri"/> as <see cref="P:VDS.RDF.Query.Patterns.IMatchTriplePattern.Predicate"/>
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.TriplePatternPredicatePart.PredicateUri(System.String)">
            <summary>
            Sets a <see cref="T:System.Uri"/> as <see cref="P:VDS.RDF.Query.Patterns.IMatchTriplePattern.Predicate"/> using a QName
            </summary>
            <remarks>A relevant prefix/base URI must be added to <see cref="P:VDS.RDF.Query.Builder.IQueryBuilder.Prefixes"/></remarks>
        </member>
        <member name="M:VDS.RDF.Query.Builder.TriplePatternPredicatePart.PredicateUri(VDS.RDF.IUriNode)">
            <summary>
            Sets a <see cref="T:System.Uri"/> as <see cref="P:VDS.RDF.Query.Patterns.IMatchTriplePattern.Predicate"/> using a <see cref="T:VDS.RDF.IUriNode"/>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Builder.IQueryBuilder">
            <summary>
            Interface for building SPARQL queries 
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.IQueryBuilder.Distinct">
            <summary>
            Applies the DISTINCT modifier if the Query is a SELECT, otherwise leaves query unchanged (since results from any other query are DISTINCT by default)
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.IQueryBuilder.Limit(System.Int32)">
            <summary>
            Applies a LIMIT
            </summary>
            <param name="limit">Limit value. Pass negative to disable LIMIT</param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.IQueryBuilder.Offset(System.Int32)">
            <summary>
            Applies an OFFSET
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.IQueryBuilder.OrderBy(System.String)">
            <summary>
            Adds ascending ordering by a variable to the query
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.IQueryBuilder.OrderByDescending(System.String)">
            <summary>
            Adds descending ordering by a variable to the query
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.IQueryBuilder.OrderBy(System.Func{VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.SparqlExpression})">
            <summary>
            Adds ascending ordering by an expression to the query
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.IQueryBuilder.OrderByDescending(System.Func{VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.SparqlExpression})">
            <summary>
            Adds descending ordering by an expression to the query
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.IQueryBuilder.BuildQuery">
            <summary>
            Builds and returns a <see cref="T:VDS.RDF.Query.SparqlQuery"/>
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.IQueryBuilder.Bind(System.Func{VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.SparqlExpression})">
            <summary>
            Adds a BIND variable assignment to the root graph pattern
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Builder.IQueryBuilder.Prefixes">
            <summary>
            Gets the prefix manager, which allows adding prefixes to the query or graph pattern
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Optimisation.OrderByDistinctOptimiser">
            <summary>
            An optimizer that handles a special case for ORDER BY + DISTINCT combinations which can significantly improve performance by eliminating duplicates prior to sorting when the default SPARQL behaviour is to do a potentially costly sort over many duplicates and then eliminate distincts.
            </summary>
            <remarks>
            Only applies to queries which meet the following criteria:
            <ul>
            <li>Has an ORDER BY and a DISTNCT on the same level of the query</li>
            <li>Selects a fixed list of variables i.e. not a SELECT DISTINCT *</li>
            <li>All variables used in the ORDER BY expressions also occur in the project list</li>
            </ul>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.OrderByDistinctOptimiser.Optimise(VDS.RDF.Query.Algebra.ISparqlAlgebra)">
            <summary>
            Optimizes the given algebra
            </summary>
            <param name="algebra">Algebra</param>
            <returns>Optimized algebra</returns>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.OrderByDistinctOptimiser.IsApplicable(VDS.RDF.Query.SparqlQuery)">
            <summary>
            Returns true if the query is a SELECT DISTINCT or SELECT REDUCED and has an ORDER BY
            </summary>
            <param name="q">Query</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Query.Optimisation.OrderByDistinctOptimiser.IsApplicable(VDS.RDF.Update.SparqlUpdateCommandSet)">
            <summary>
            Returns that this is not applicable to updates
            </summary>
            <param name="cmds">Update commands</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Query.Builder.QueryBuilder">
            <summary>
            Provides methods for building queries with a fluent style API
            </summary>
            <remarks>
            <para>
            A <see cref="T:VDS.RDF.Query.SparqlQuery"/> is mutable by definition so calling any of the extension methods in this API will cause the existing query it is called on to be changed.  You can call <see cref="M:VDS.RDF.Query.SparqlQuery.Copy"/> on an existing query to create a new copy if you want to make different queries starting from the same base query
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Query.Builder.QueryBuilder.Ask">
            <summary>
            Creates a new ASK query
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.QueryBuilder.Construct(System.Action{VDS.RDF.Query.Builder.IDescribeGraphPatternBuilder})">
            <summary>
            Creates a new CONSTRUCT query
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.QueryBuilder.Construct">
            <summary>
            Creates a new CONSTRUCT WHERE query
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.QueryBuilder.SelectAll">
            <summary>
            Creates a new SELECT * query
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.QueryBuilder.Select(VDS.RDF.Query.SparqlVariable[])">
            <summary>
            Creates a new SELECT query which will return the given 
            <paramref name="variables"/>
            </summary>
            <param name="variables">query result variables</param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.QueryBuilder.Select(System.String[])">
            <summary>
            Creates a new SELECT query which will return the given 
            <paramref name="variables"/>
            </summary>
            <param name="variables">query result variables</param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.QueryBuilder.Select(System.Func{VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.SparqlExpression})">
            <summary>
            Creates a new SELECT query which will return an expression
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.QueryBuilder.Describe(System.Uri[])">
            <summary>
            Creates a new query, which will DESCRIBE the given <paramref name="uris"/>
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.QueryBuilder.Describe(System.String[])">
            <summary>
            Creates a new query, which will DESCRIBE the given <paramref name="variables"/>
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.QueryBuilder.Distinct">
            <summary>
            Applies the DISTINCT modifier if the Query is a SELECT, otherwise leaves query unchanged (since results from any other query are DISTINCT by default)
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.QueryBuilder.Limit(System.Int32)">
            <summary>
            Applies a LIMIT
            </summary>
            <param name="limit">Limit value. Pass negative to disable LIMIT</param>
        </member>
        <member name="M:VDS.RDF.Query.Builder.QueryBuilder.Offset(System.Int32)">
            <summary>
            Applies an OFFSET
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.QueryBuilder.OrderBy(System.String)">
            <summary>
            Adds ascending ordering by a variable to the query
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.QueryBuilder.OrderByDescending(System.String)">
            <summary>
            Adds descending ordering by a variable to the query
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.QueryBuilder.OrderBy(System.Func{VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.SparqlExpression})">
            <summary>
            Adds ascending ordering by an expression to the query
            </summary>
        </member>
        <member name="M:VDS.RDF.Query.Builder.QueryBuilder.OrderByDescending(System.Func{VDS.RDF.Query.Builder.ExpressionBuilder,VDS.RDF.Query.Builder.Expressions.SparqlExpression})">
            <summary>
            Adds descending ordering by an expression to the query
            </summary>
        </member>
        <member name="P:VDS.RDF.Query.Builder.QueryBuilder.Prefixes">
            <summary>
            Gets or sets the namespace mappings for the SPARQL query being built
            </summary>
        </member>
    </members>
</doc>
